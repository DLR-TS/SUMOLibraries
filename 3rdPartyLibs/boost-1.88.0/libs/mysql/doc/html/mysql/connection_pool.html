<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Connection pools</title>
<link rel="stylesheet" href="../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="Chapter 1. Boost.MySQL">
<link rel="up" href="../index.html" title="Chapter 1. Boost.MySQL">
<link rel="prev" href="multi_function.html" title="Multi-function operations">
<link rel="next" href="async.html" title="Going async">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="multi_function.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="async.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="mysql.connection_pool"></a><a class="link" href="connection_pool.html" title="Connection pools">Connection pools</a>
</h2></div></div></div>
<p>
      Connection pooling is a technique where several long-lived connections are
      re-used for independent logical operations. When compared to establishing individual
      connections, it has the following benefits:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          It provides better performance. Please consult <a class="link" href="connection_pool.html#mysql.connection_pool.benchmarks">our
          benchmarks</a> for more info.
        </li>
<li class="listitem">
          It simplifies connection management. The connection pool will establish
          sessions, perform retries and apply timeouts out of the box.
        </li>
</ul></div>
<p>
      This is how you can create a pool of connections:
    </p>
<pre class="programlisting"><span class="comment">// pool_params contains configuration for the pool.</span>
<span class="comment">// You must specify enough information to establish a connection,</span>
<span class="comment">// including the server address and credentials.</span>
<span class="comment">// You can configure a lot of other things, like pool limits</span>
<span class="identifier">mysql</span><span class="special">::</span><span class="identifier">pool_params</span> <span class="identifier">params</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">server_address</span><span class="special">.</span><span class="identifier">emplace_host_and_port</span><span class="special">(</span><span class="identifier">server_hostname</span><span class="special">);</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">username</span> <span class="special">=</span> <span class="identifier">mysql_username</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">password</span> <span class="special">=</span> <span class="identifier">mysql_password</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">database</span> <span class="special">=</span> <span class="string">"boost_mysql_examples"</span><span class="special">;</span>

<span class="comment">// The I/O context, required by all I/O operations</span>
<span class="identifier">asio</span><span class="special">::</span><span class="identifier">io_context</span> <span class="identifier">ctx</span><span class="special">;</span>

<span class="comment">// Construct a pool of connections. The context will be used internally</span>
<span class="comment">// to create the connections and other I/O objects</span>
<span class="identifier">mysql</span><span class="special">::</span><span class="identifier">connection_pool</span> <span class="identifier">pool</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">params</span><span class="special">));</span>

<span class="comment">// You need to call async_run on the pool before doing anything useful with it.</span>
<span class="comment">// async_run creates connections and keeps them healthy. It must be called</span>
<span class="comment">// only once per pool.</span>
<span class="comment">// The detached completion token means that we don't want to be notified when</span>
<span class="comment">// the operation ends. It's similar to a no-op callback.</span>
<span class="identifier">pool</span><span class="special">.</span><span class="identifier">async_run</span><span class="special">(</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">detached</span><span class="special">);</span>
</pre>
<p>
      <a class="link" href="ref/boost__mysql__connection_pool.html" title="connection_pool"><code class="literal">connection_pool</code></a>
      is an I/O object that manages connections. It can be constructed from an executor
      or execution context (like all I/O objects) and a <a class="link" href="ref/boost__mysql__pool_params.html" title="pool_params"><code class="literal">pool_params</code></a>
      object.
    </p>
<p>
      <a class="link" href="ref/boost__mysql__connection_pool/async_run.html" title="connection_pool::async_run"><code class="literal">connection_pool::async_run</code></a>
      must be called exactly once per pool. This function takes care of actually
      keeping connections healthy.
    </p>
<p>
      We're now ready to obtain connections using <a class="link" href="ref/boost__mysql__connection_pool/async_get_connection.html" title="connection_pool::async_get_connection"><code class="literal">connection_pool::async_get_connection</code></a>.
      We will use C++20 coroutines to make async code simpler:
    </p>
<pre class="programlisting"><span class="comment">// Use connection pools for functions that will be called</span>
<span class="comment">// repeatedly during the application lifetime.</span>
<span class="comment">// An HTTP server handler function is a good candidate.</span>
<span class="identifier">asio</span><span class="special">::</span><span class="identifier">awaitable</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">int64_t</span><span class="special">&gt;</span> <span class="identifier">get_num_employees</span><span class="special">(</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">connection_pool</span><span class="special">&amp;</span> <span class="identifier">pool</span><span class="special">)</span>
<span class="special">{</span>
    <span class="comment">// Get a fresh connection from the pool.</span>
    <span class="comment">// pooled_connection is a proxy to an any_connection object.</span>
    <span class="identifier">mysql</span><span class="special">::</span><span class="identifier">pooled_connection</span> <span class="identifier">conn</span> <span class="special">=</span> <span class="identifier">co_await</span> <span class="identifier">pool</span><span class="special">.</span><span class="identifier">async_get_connection</span><span class="special">();</span>

    <span class="comment">// Use pooled_connection::operator-&gt; to access the underlying any_connection.</span>
    <span class="comment">// Let's use the connection</span>
    <span class="identifier">mysql</span><span class="special">::</span><span class="identifier">results</span> <span class="identifier">result</span><span class="special">;</span>
    <span class="identifier">co_await</span> <span class="identifier">conn</span><span class="special">-&gt;</span><span class="identifier">async_execute</span><span class="special">(</span><span class="string">"SELECT COUNT(*) FROM employee"</span><span class="special">,</span> <span class="identifier">result</span><span class="special">);</span>
    <span class="identifier">co_return</span> <span class="identifier">result</span><span class="special">.</span><span class="identifier">rows</span><span class="special">().</span><span class="identifier">at</span><span class="special">(</span><span class="number">0</span><span class="special">).</span><span class="identifier">at</span><span class="special">(</span><span class="number">0</span><span class="special">).</span><span class="identifier">as_int64</span><span class="special">();</span>

    <span class="comment">// When conn is destroyed, the connection is returned to the pool</span>
<span class="special">}</span>
</pre>
<p>
      By default, <a class="link" href="ref/boost__mysql__connection_pool/async_run.html" title="connection_pool::async_run"><code class="literal">connection_pool::async_run</code></a>
      will run forever. When your application exits, you will want to stop it using
      <a class="link" href="ref/boost__mysql__connection_pool/cancel.html" title="connection_pool::cancel"><code class="literal">connection_pool::cancel</code></a>.
      This is typical in signal handlers, to guarantee a clean shutdown.
    </p>
<p>
      Note that pooling works only with <a class="link" href="ref/boost__mysql__any_connection.html" title="any_connection"><code class="literal">any_connection</code></a>.
    </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        <code class="computeroutput"><span class="identifier">connection_pool</span></code> exposes async
        functions only. This has to do with efficiency and oddities in Boost.Asio
        executor model. If you need to use it from sync code, please visit <a class="link" href="interfacing_sync_async.html" title="Interfacing sync and async code: using connection_pool in sync code">this section</a>.
      </p></td></tr>
</table></div>
<h4>
<a name="mysql.connection_pool.h0"></a>
      <span class="phrase"><a name="mysql.connection_pool.pool_size"></a></span><a class="link" href="connection_pool.html#mysql.connection_pool.pool_size">Pool
      size</a>
    </h4>
<p>
      Pools start with a fixed initial size, and will be dynamically resized up to
      an upper limit if required. You can configure these sizes using <a class="link" href="ref/boost__mysql__pool_params/initial_size.html" title="pool_params::initial_size"><code class="literal">pool_params::initial_size</code></a>
      and <a class="link" href="ref/boost__mysql__pool_params/max_size.html" title="pool_params::max_size"><code class="literal">pool_params::max_size</code></a>.
    </p>
<p>
      The resizing algorithm works like this:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          When the pool is created, <a class="link" href="ref/boost__mysql__pool_params/initial_size.html" title="pool_params::initial_size"><code class="literal">pool_params::initial_size</code></a>
          number of connections are created and connected (by default, <code class="computeroutput"><span class="identifier">initial_size</span></code> is 1).
        </li>
<li class="listitem">
          If a connection is requested, but all available connections are in use,
          a new one is created, until <code class="computeroutput"><span class="identifier">max_size</span></code>
          is reached.
        </li>
<li class="listitem">
          If a connection is requested, and there are <code class="computeroutput"><span class="identifier">max_size</span></code>
          connections in use, <a class="link" href="ref/boost__mysql__connection_pool/async_get_connection.html" title="connection_pool::async_get_connection"><code class="literal">connection_pool::async_get_connection</code></a>
          waits for a connection to become available.
        </li>
<li class="listitem">
          Once created, connections never get deallocated.
        </li>
</ul></div>
<p>
      By default, <a class="link" href="ref/boost__mysql__pool_params/max_size.html" title="pool_params::max_size"><code class="literal">pool_params::max_size</code></a>
      is 151, which is MySQL's default value for the <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_max_connections" target="_top"><code class="computeroutput"><span class="identifier">max_connections</span></code></a> system variable,
      controlling the maximum number of concurrent connections allowed by the server.
    </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        Before increasing <a class="link" href="ref/boost__mysql__pool_params/max_size.html" title="pool_params::max_size"><code class="literal">pool_params::max_size</code></a>,
        make sure to also increase the value of <code class="computeroutput"><span class="identifier">max_connections</span></code>
        in the server. Otherwise, your connections will be rejected by the connection
        limit.
      </p></td></tr>
</table></div>
<p>
      This is how you configure pool sizes:
    </p>
<pre class="programlisting"><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">pool_params</span> <span class="identifier">params</span><span class="special">;</span>

<span class="comment">// Set the usual params</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">server_address</span><span class="special">.</span><span class="identifier">emplace_host_and_port</span><span class="special">(</span><span class="identifier">server_hostname</span><span class="special">);</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">username</span> <span class="special">=</span> <span class="identifier">mysql_username</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">password</span> <span class="special">=</span> <span class="identifier">mysql_password</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">database</span> <span class="special">=</span> <span class="string">"boost_mysql_examples"</span><span class="special">;</span>

<span class="comment">// Create 10 connections at startup, and allow up to 1000 connections</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">initial_size</span> <span class="special">=</span> <span class="number">10</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">max_size</span> <span class="special">=</span> <span class="number">1000</span><span class="special">;</span>

<span class="identifier">mysql</span><span class="special">::</span><span class="identifier">connection_pool</span> <span class="identifier">pool</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">params</span><span class="special">));</span>
</pre>
<h4>
<a name="mysql.connection_pool.h1"></a>
      <span class="phrase"><a name="mysql.connection_pool.applying_a_timeout_to_async_get_"></a></span><a class="link" href="connection_pool.html#mysql.connection_pool.applying_a_timeout_to_async_get_">Applying a
      timeout to async_get_connection</a>
    </h4>
<p>
      By default, <a class="link" href="ref/boost__mysql__connection_pool/async_get_connection.html" title="connection_pool::async_get_connection"><code class="literal">connection_pool::async_get_connection</code></a>
      waits until a connection is available. This means that, if the server is unavailable,
      <code class="computeroutput"><span class="identifier">async_get_connection</span></code> may wait
      forever.
    </p>
<p>
      For this reason, you may consider setting a timeout to <code class="computeroutput"><span class="identifier">async_get_connection</span></code>.
      You can do this using <a href="../../../../../doc/html/boost_asio/reference/cancel_after.html" target="_top"><code class="literal">asio::cancel_after</code></a>,
      which uses Asio's per-operation cancellation mechanism:
    </p>
<pre class="programlisting"><span class="comment">// Get a connection from the pool, but don't wait more than 5 seconds</span>
<span class="keyword">auto</span> <span class="identifier">conn</span> <span class="special">=</span> <span class="identifier">co_await</span> <span class="identifier">pool</span><span class="special">.</span><span class="identifier">async_get_connection</span><span class="special">(</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">cancel_after</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">seconds</span><span class="special">(</span><span class="number">5</span><span class="special">)));</span>
</pre>
<p>
      You might consider setting the timeout at a higher level, instead. For instance,
      if you're handling an HTTP request, you can use <code class="computeroutput"><span class="identifier">cancel_after</span></code>
      to set a timeout to the entire request. The <a class="link" href="examples/http_server_cpp20.html" title="A REST API server that uses C++20 coroutines">connection
      pool example</a> takes this approach.
    </p>
<h4>
<a name="mysql.connection_pool.h2"></a>
      <span class="phrase"><a name="mysql.connection_pool.session_state"></a></span><a class="link" href="connection_pool.html#mysql.connection_pool.session_state">Session
      state</a>
    </h4>
<p>
      MySQL connections hold state. You change session state when you prepare statements,
      create temporary tables, start transactions, or set session variables. When
      using pooled connections, session state can be problematic: if not reset properly,
      state from a previous operation may affect subsequent ones.
    </p>
<p>
      After you return a connection to the pool, the equivalent of <a class="link" href="ref/boost__mysql__any_connection/async_reset_connection.html" title="any_connection::async_reset_connection"><code class="literal">any_connection::async_reset_connection</code></a>
      and <a class="link" href="ref/boost__mysql__any_connection/async_set_character_set.html" title="any_connection::async_set_character_set"><code class="literal">async_set_character_set</code></a>
      are used to wipe session state before the connection can be obtained again.
      This will deallocate prepared statements, rollback uncommitted transactions,
      clear variables and restore the connection's character set to <code class="computeroutput"><span class="identifier">utf8mb4</span></code>. In particular, you don't need to
      call <a class="link" href="ref/boost__mysql__any_connection/async_close_statement.html" title="any_connection::async_close_statement"><code class="literal">any_connection::async_close_statement</code></a>
      to deallocate statements.
    </p>
<p>
      Resetting a connection is cheap but entails a cost (a roundtrip to the server).
      If you've used a connection and you know that you didn't mutate session state,
      you can use <a class="link" href="ref/boost__mysql__pooled_connection/return_without_reset.html" title="pooled_connection::return_without_reset"><code class="literal">pooled_connection::return_without_reset</code></a>
      to skip resetting. For instance:
    </p>
<pre class="programlisting"><span class="comment">// Get a connection from the pool</span>
<span class="identifier">mysql</span><span class="special">::</span><span class="identifier">pooled_connection</span> <span class="identifier">conn</span> <span class="special">=</span> <span class="identifier">co_await</span> <span class="identifier">pool</span><span class="special">.</span><span class="identifier">async_get_connection</span><span class="special">();</span>

<span class="comment">// Use the connection in a way that doesn't mutate session state.</span>
<span class="comment">// We're not setting variables, preparing statements or starting transactions,</span>
<span class="comment">// so it's safe to skip reset</span>
<span class="identifier">mysql</span><span class="special">::</span><span class="identifier">results</span> <span class="identifier">result</span><span class="special">;</span>
<span class="identifier">co_await</span> <span class="identifier">conn</span><span class="special">-&gt;</span><span class="identifier">async_execute</span><span class="special">(</span><span class="string">"SELECT COUNT(*) FROM employee"</span><span class="special">,</span> <span class="identifier">result</span><span class="special">);</span>

<span class="comment">// Explicitly return the connection to the pool, skipping reset</span>
<span class="identifier">conn</span><span class="special">.</span><span class="identifier">return_without_reset</span><span class="special">();</span>
</pre>
<p>
      Connection reset happens in the background, after the connection has been returned,
      so it does not affect latency. If you're not sure if an operation affects state
      or not, assume it does.
    </p>
<h4>
<a name="mysql.connection_pool.h3"></a>
      <span class="phrase"><a name="mysql.connection_pool.character_set"></a></span><a class="link" href="connection_pool.html#mysql.connection_pool.character_set">Character
      set</a>
    </h4>
<p>
      Pooled connections always use <code class="computeroutput"><span class="identifier">utf8mb4</span></code>
      as its character set. When connections are reset, the equivalent of <a class="link" href="ref/boost__mysql__any_connection/async_set_character_set.html" title="any_connection::async_set_character_set"><code class="literal">any_connection::async_set_character_set</code></a>
      is used to restore the character set to <code class="computeroutput"><span class="identifier">utf8mb4</span></code>
      (recall that raw <a class="link" href="ref/boost__mysql__any_connection/async_reset_connection.html" title="any_connection::async_reset_connection"><code class="literal">async_reset_connection</code></a>
      will wipe character set data).
    </p>
<p>
      Pooled connections always know the character set they're using. This means
      that <a class="link" href="ref/boost__mysql__any_connection/format_opts.html" title="any_connection::format_opts"><code class="literal">any_connection::format_opts</code></a>
      and <a class="link" href="ref/boost__mysql__any_connection/current_character_set.html" title="any_connection::current_character_set"><code class="literal">current_character_set</code></a>
      always succeed.
    </p>
<p>
      We recommend to always stick to <code class="computeroutput"><span class="identifier">utf8mb4</span></code>.
      If you really need to use any other character set, use <a class="link" href="ref/boost__mysql__any_connection/async_set_character_set.html" title="any_connection::async_set_character_set"><code class="literal">async_set_character_set</code></a>
      on your connection after it's been retrieved from the pool.
    </p>
<h4>
<a name="mysql.connection_pool.h4"></a>
      <span class="phrase"><a name="mysql.connection_pool.connection_lifecycle"></a></span><a class="link" href="connection_pool.html#mysql.connection_pool.connection_lifecycle">Connection
      lifecycle</a>
    </h4>
<p>
      The behavior already explained can be summarized using a state model like the
      following:
    </p>
<p>
      <span class="inlinemediaobject"><object type="image/svg+xml" data="images/pooled_connection_lifecycle.svg" align="middle"></object></span>
    </p>
<p>
      In short:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          When a connection is created, it goes into the <code class="computeroutput"><span class="identifier">pending_connect</span></code>
          state.
        </li>
<li class="listitem">
          Connection establishment is attempted. If it succeeds, the connection becomes
          <code class="computeroutput"><span class="identifier">idle</span></code>. Otherwise, it stays
          <code class="computeroutput"><span class="identifier">pending_connect</span></code>, and another
          attempt will be performed after <a class="link" href="ref/boost__mysql__pool_params/retry_interval.html" title="pool_params::retry_interval"><code class="literal">pool_params::retry_interval</code></a>
          has elapsed.
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="identifier">idle</span></code> connections can be
          retrieved by <a class="link" href="ref/boost__mysql__connection_pool/async_get_connection.html" title="connection_pool::async_get_connection"><code class="literal">connection_pool::async_get_connection</code></a>,
          and they become <code class="computeroutput"><span class="identifier">in_use</span></code>.
        </li>
<li class="listitem">
          If a connection is returned by <a class="link" href="ref/boost__mysql__pooled_connection/return_without_reset.html" title="pooled_connection::return_without_reset"><code class="literal">pooled_connection::return_without_reset</code></a>,
          it becomes <code class="computeroutput"><span class="identifier">idle</span></code> again.
        </li>
<li class="listitem">
          If a connection is returned by <a class="link" href="ref/boost__mysql__pooled_connection.html" title="pooled_connection"><code class="literal">pooled_connection</code></a>'s
          destructor, it becomes <code class="computeroutput"><span class="identifier">pending_reset</span></code>.
        </li>
<li class="listitem">
          <a class="link" href="ref/boost__mysql__any_connection/async_reset_connection.html" title="any_connection::async_reset_connection"><code class="literal">any_connection::async_reset_connection</code></a>
          is applied to <code class="computeroutput"><span class="identifier">pending_reset</span></code>
          connections. On success, they become <code class="computeroutput"><span class="identifier">idle</span></code>
          again. Otherwise, they become <code class="computeroutput"><span class="identifier">pending_connect</span></code>
          and will be reconnected.
        </li>
<li class="listitem">
          If a connection stays <code class="computeroutput"><span class="identifier">idle</span></code>
          for <a class="link" href="ref/boost__mysql__pool_params/ping_interval.html" title="pool_params::ping_interval"><code class="literal">pool_params::ping_interval</code></a>,
          it becomes <code class="computeroutput"><span class="identifier">pending_ping</span></code>.
          At this point, the connection is probed. If it's alive, it will return
          to being <code class="computeroutput"><span class="identifier">idle</span></code>. Otherwise,
          it becomes <code class="computeroutput"><span class="identifier">pending_connect</span></code>
          to be reconnected. Pings can be disabled by setting <a class="link" href="ref/boost__mysql__pool_params/ping_interval.html" title="pool_params::ping_interval"><code class="literal">pool_params::ping_interval</code></a>
          to zero.
        </li>
</ul></div>
<h4>
<a name="mysql.connection_pool.h5"></a>
      <span class="phrase"><a name="mysql.connection_pool.thread_safe"></a></span><a class="link" href="connection_pool.html#mysql.connection_pool.thread_safe">Thread-safety</a>
    </h4>
<p>
      By default, <a class="link" href="ref/boost__mysql__connection_pool.html" title="connection_pool"><code class="literal">connection_pool</code></a>
      is <span class="bold"><strong>not thread-safe</strong></span>, but it can be easily made
      thread-safe by setting <a class="link" href="ref/boost__mysql__pool_params/thread_safe.html" title="pool_params::thread_safe"><code class="literal">pool_params::thread_safe</code></a>:
    </p>
<pre class="programlisting"><span class="comment">// The I/O context, required by all I/O operations.</span>
<span class="comment">// This is like an io_context, but with 5 threads running it.</span>
<span class="identifier">asio</span><span class="special">::</span><span class="identifier">thread_pool</span> <span class="identifier">ctx</span><span class="special">(</span><span class="number">5</span><span class="special">);</span>

<span class="comment">// The usual pool configuration params</span>
<span class="identifier">mysql</span><span class="special">::</span><span class="identifier">pool_params</span> <span class="identifier">params</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">server_address</span><span class="special">.</span><span class="identifier">emplace_host_and_port</span><span class="special">(</span><span class="identifier">server_hostname</span><span class="special">);</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">username</span> <span class="special">=</span> <span class="identifier">mysql_username</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">password</span> <span class="special">=</span> <span class="identifier">mysql_password</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">database</span> <span class="special">=</span> <span class="string">"boost_mysql_examples"</span><span class="special">;</span>
<span class="identifier">params</span><span class="special">.</span><span class="identifier">thread_safe</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>  <span class="comment">// enable thread safety</span>

<span class="comment">// Construct a thread-safe pool</span>
<span class="identifier">mysql</span><span class="special">::</span><span class="identifier">connection_pool</span> <span class="identifier">pool</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">params</span><span class="special">));</span>
<span class="identifier">pool</span><span class="special">.</span><span class="identifier">async_run</span><span class="special">(</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">detached</span><span class="special">);</span>

<span class="comment">// We can now pass a reference to pool to other threads,</span>
<span class="comment">// and call async_get_connection concurrently without problem.</span>
<span class="comment">// Individual connections are still not thread-safe.</span>
</pre>
<p>
      To correctly understand what is protected by <a class="link" href="ref/boost__mysql__pool_params/thread_safe.html" title="pool_params::thread_safe"><code class="literal">pool_params::thread_safe</code></a>
      and what is not, we need a grasp of how pools are implemented. Both <a class="link" href="ref/boost__mysql__connection_pool.html" title="connection_pool"><code class="literal">connection_pool</code></a>
      and individual <a class="link" href="ref/boost__mysql__pooled_connection.html" title="pooled_connection"><code class="literal">pooled_connection</code></a>'s
      hold pointers to a shared state object containing all data required by the
      pool:
    </p>
<p>
      <span class="inlinemediaobject"><object type="image/svg+xml" data="images/connection_pool_impl.svg" align="middle"></object></span>
    </p>
<p>
      Thread-safe connection pools internally create an <a href="../../../../../doc/html/boost_asio/reference/strand.html" target="_top"><code class="literal">asio::strand</code></a>
      that protects the connection pool's state. Operations like <a class="link" href="ref/boost__mysql__connection_pool/async_get_connection.html" title="connection_pool::async_get_connection"><code class="literal">async_get_connection</code></a>,
      <a class="link" href="ref/boost__mysql__connection_pool/async_run.html" title="connection_pool::async_run"><code class="literal">async_run</code></a>
      and <a class="link" href="ref/boost__mysql__pooled_connection.html" title="pooled_connection"><code class="literal">pooled_connection</code></a>'s
      destructor will run through the strand, and are safe to be run from any thread.
      Operations that mutate state handles (the internal <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span></code>),
      like <span class="bold"><strong>assignment operators, are not thread-safe</strong></span>.
    </p>
<p>
      Data outside the pool's state is not protected. In particular, <span class="bold"><strong><code class="computeroutput"><span class="identifier">asio</span><span class="special">::</span><span class="identifier">cancel_after</span></code>
      creates an internal timer that can cause inadvertent race conditions</strong></span>.
      For example:
    </p>
<pre class="programlisting"><span class="comment">// A function that handles a user session in a server</span>
<span class="identifier">asio</span><span class="special">::</span><span class="identifier">awaitable</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span> <span class="identifier">handle_session</span><span class="special">(</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">connection_pool</span><span class="special">&amp;</span> <span class="identifier">pool</span><span class="special">)</span>
<span class="special">{</span>
    <span class="comment">// CAUTION: asio::cancel_after creates a timer that is *not* part of the pool's state.</span>
    <span class="comment">// The timer is not protected by the pool's strand.</span>
    <span class="comment">// This coroutine must be run within a strand for this to be safe</span>
    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono_literals</span><span class="special">;</span>
    <span class="identifier">co_await</span> <span class="identifier">pool</span><span class="special">.</span><span class="identifier">async_get_connection</span><span class="special">(</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">cancel_after</span><span class="special">(</span><span class="number">30</span><span class="identifier">s</span><span class="special">));</span>

    <span class="comment">// Use the connection</span>
<span class="special">}</span>
</pre>
<p>
      This coroutine must be run within a strand:
    </p>
<pre class="programlisting"><span class="comment">// OK: the entire coroutine runs within a strand.</span>
<span class="comment">// In a typical server setup, each request usually gets its own strand,</span>
<span class="comment">// so it can run in parallel with other requests.</span>
<span class="identifier">asio</span><span class="special">::</span><span class="identifier">co_spawn</span><span class="special">(</span>
    <span class="identifier">asio</span><span class="special">::</span><span class="identifier">make_strand</span><span class="special">(</span><span class="identifier">ctx</span><span class="special">),</span>  <span class="comment">// If we removed this make_strand, we would have a race condition</span>
    <span class="special">[&amp;</span><span class="identifier">pool</span><span class="special">]</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">handle_session</span><span class="special">(</span><span class="identifier">pool</span><span class="special">);</span> <span class="special">},</span>
    <span class="identifier">asio</span><span class="special">::</span><span class="identifier">detached</span>
<span class="special">);</span>
</pre>
<p>
      If we don't use <code class="computeroutput"><span class="identifier">asio</span><span class="special">::</span><span class="identifier">make_shared</span></code>, we have the following race condition:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          The thread calling <code class="computeroutput"><span class="identifier">async_get_connection</span></code>
          sets up the timer required by <code class="computeroutput"><span class="identifier">asio</span><span class="special">::</span><span class="identifier">cancel_after</span></code>.
        </li>
<li class="listitem">
          In parallel, the thread running the execution context sees that there is
          a healthy connection and completes the <code class="computeroutput"><span class="identifier">async_get_connection</span></code>
          operation. As a result, the timer is cancelled. Thus, the timer is accessed
          concurrently from both threads without protection.
        </li>
</ul></div>
<p>
      If you're using callbacks, code gets slightly more convoluted. The above coroutine
      can be rewritten as:
    </p>
<pre class="programlisting"><span class="comment">// Holds per-session state</span>
<span class="keyword">class</span> <span class="identifier">session_handler</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">enable_shared_from_this</span><span class="special">&lt;</span><span class="identifier">session_handler</span><span class="special">&gt;</span>
<span class="special">{</span>
    <span class="comment">// The connection pool</span>
    <span class="identifier">mysql</span><span class="special">::</span><span class="identifier">connection_pool</span><span class="special">&amp;</span> <span class="identifier">pool_</span><span class="special">;</span>

    <span class="comment">// A strand object, unique to this session</span>
    <span class="identifier">asio</span><span class="special">::</span><span class="identifier">strand</span><span class="special">&lt;</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">any_io_executor</span><span class="special">&gt;</span> <span class="identifier">strand_</span><span class="special">;</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// pool.get_executor() points to the execution context that was used</span>
    <span class="comment">// to create the pool, and never to the pool's internal strand</span>
    <span class="identifier">session_handler</span><span class="special">(</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">connection_pool</span><span class="special">&amp;</span> <span class="identifier">pool</span><span class="special">)</span>
        <span class="special">:</span> <span class="identifier">pool_</span><span class="special">(</span><span class="identifier">pool</span><span class="special">),</span> <span class="identifier">strand_</span><span class="special">(</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">make_strand</span><span class="special">(</span><span class="identifier">pool</span><span class="special">.</span><span class="identifier">get_executor</span><span class="special">()))</span>
    <span class="special">{</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">start</span><span class="special">()</span>
    <span class="special">{</span>
        <span class="comment">// Enters the strand. The passed function will be executed through the strand.</span>
        <span class="comment">// If the initiation is run outside the strand, a race condition will occur.</span>
        <span class="identifier">asio</span><span class="special">::</span><span class="identifier">dispatch</span><span class="special">(</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">bind_executor</span><span class="special">(</span><span class="identifier">strand_</span><span class="special">,</span> <span class="special">[</span><span class="identifier">self</span> <span class="special">=</span> <span class="identifier">shared_from_this</span><span class="special">()]</span> <span class="special">{</span> <span class="identifier">self</span><span class="special">-&gt;</span><span class="identifier">get_connection</span><span class="special">();</span> <span class="special">}));</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">get_connection</span><span class="special">()</span>
    <span class="special">{</span>
        <span class="comment">// This function will run within the strand. Binding the passed callback to</span>
        <span class="comment">// the strand will make async_get_connection run it within the strand, too.</span>
        <span class="identifier">pool_</span><span class="special">.</span><span class="identifier">async_get_connection</span><span class="special">(</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">cancel_after</span><span class="special">(</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">seconds</span><span class="special">(</span><span class="number">30</span><span class="special">),</span>
            <span class="identifier">asio</span><span class="special">::</span><span class="identifier">bind_executor</span><span class="special">(</span>
                <span class="identifier">strand_</span><span class="special">,</span>
                <span class="special">[</span><span class="identifier">self</span> <span class="special">=</span> <span class="identifier">shared_from_this</span><span class="special">()](</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">,</span> <span class="identifier">mysql</span><span class="special">::</span><span class="identifier">pooled_connection</span><span class="special">)</span> <span class="special">{</span>
                    <span class="comment">// Use the connection as required</span>
                <span class="special">}</span>
            <span class="special">)</span>
        <span class="special">));</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">void</span> <span class="identifier">handle_session_v2</span><span class="special">(</span><span class="identifier">mysql</span><span class="special">::</span><span class="identifier">connection_pool</span><span class="special">&amp;</span> <span class="identifier">pool</span><span class="special">)</span>
<span class="special">{</span>
    <span class="comment">// Start the callback chain</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span><span class="identifier">session_handler</span><span class="special">&gt;(</span><span class="identifier">pool</span><span class="special">)-&gt;</span><span class="identifier">start</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
      Thread-safety is disabled by default because strands impose a performance penalty
      that is avoidable in single-threaded programs.
    </p>
<h4>
<a name="mysql.connection_pool.h6"></a>
      <span class="phrase"><a name="mysql.connection_pool.transport_types_and_tls"></a></span><a class="link" href="connection_pool.html#mysql.connection_pool.transport_types_and_tls">Transport
      types and TLS</a>
    </h4>
<p>
      You can use the same set of transports as when working with <a class="link" href="ref/boost__mysql__any_connection.html" title="any_connection"><code class="literal">any_connection</code></a>:
      plaintext TCP, TLS over TCP or UNIX sockets. You can configure them using
      <a class="link" href="ref/boost__mysql__pool_params/server_address.html" title="pool_params::server_address"><code class="literal">pool_params::server_address</code></a>
      and <a class="link" href="ref/boost__mysql__pool_params/ssl.html" title="pool_params::ssl"><code class="literal">pool_params::ssl</code></a>.
      By default, TLS over TCP will be used if the server supports it, falling back
      to plaintext TCP if it does not.
    </p>
<p>
      You can use <a class="link" href="ref/boost__mysql__pool_params/ssl_ctx.html" title="pool_params::ssl_ctx"><code class="literal">pool_params::ssl_ctx</code></a>
      to configure TLS options for connections created by the pool. If no context
      is provided, one will be created for you internally.
    </p>
<h4>
<a name="mysql.connection_pool.h7"></a>
      <span class="phrase"><a name="mysql.connection_pool.benchmarks"></a></span><a class="link" href="connection_pool.html#mysql.connection_pool.benchmarks">Benchmarks</a>
    </h4>
<p>
      A throughput benchmark has been conducted to assess the performance gain provided
      by <code class="computeroutput"><span class="identifier">connection_pool</span></code>. Benchmark
      code is under <code class="computeroutput"><span class="identifier">bench</span><span class="special">/</span><span class="identifier">connection_pool</span><span class="special">.</span><span class="identifier">cpp</span></code>. The test goes as follows:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          The test consists of N = 10000 logically independent sessions. In an application
          like a webserver, this would map to handling N HTTP requests.
        </li>
<li class="listitem">
          Every logical session prepares a <code class="computeroutput"><span class="identifier">SELECT</span></code>
          statement and executes it. The statement matches a single row by primary
          key and retrieves a single, short string field (a lightweight query).
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="identifier">num_parallel</span></code> = 100 async
          agents are run in parallel. This means that, at any given point in time,
          no more than 100 parallel connections to MySQL are made.
        </li>
<li class="listitem">
          The test measures the time elapsed between launching the first async agent
          and receiving the response for the last query (<code class="computeroutput"><span class="identifier">ellapsed_time</span></code>).
        </li>
<li class="listitem">
          The test is repeated 10 times for each different configuration, and results
          are averaged. This time is used to measure the throughput, in "connections/s"
          (as given by <code class="computeroutput"><span class="identifier">N</span><span class="special">/</span><span class="identifier">ellapsed_time</span></code>).
        </li>
<li class="listitem">
          Connection pool scenarios use <code class="computeroutput"><span class="identifier">pooled_connection</span><span class="special">::~</span><span class="identifier">pooled_connection</span></code>,
          which causes a connection reset to be issued. Raw connection scenarios
          use <a class="link" href="ref/boost__mysql__any_connection/async_connect.html" title="any_connection::async_connect"><code class="literal">any_connection::async_connect</code></a>
          and <a class="link" href="ref/boost__mysql__any_connection/async_close.html" title="any_connection::async_close"><code class="literal">any_connection::async_close</code></a>
          for every session. All tests are single-threaded.
        </li>
<li class="listitem">
          The server runs MySQL v8.0.33 in a Docker container, in the same machine
          as the benchmarks.
        </li>
<li class="listitem">
          Benchmarks have been compiled using clang-18 using CMake's Release build
          type and C++20. They've been run in a Ubuntu 22.04 machine with an 8 core
          i7-10510U and 32GB of RAM.
        </li>
</ul></div>
<p>
      <span class="inlinemediaobject"><object type="image/svg+xml" data="images/connection_pool_bench.svg"></object></span>
    </p>
<p>
      We can see that pooling significantly increases throughput. This is specially
      true when communication with the server is expensive (as is the case when using
      TLS over TCP). The performance gain is likely to increase over high-latency
      networks, and to decrease for heavyweight queries, since the connection establishment
      has less overall weight.
    </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../../../doc/src/images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
        When using TLS or running small and frequent queries, pooling can help you.
      </p></td></tr>
</table></div>
</div>
<div class="copyright-footer">Copyright © 2019-2024 Ruben Perez<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="multi_function.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="async.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
