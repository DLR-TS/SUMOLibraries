<?xml version="1.0" standalone="yes"?>
<library-reference><header id="doxygen.a00809" name="boost/test/data/config.hpp">
<para>common dataset macros </para><macro id="doxygen.a00809_1a8524e9dc1fe870a7e7ff3d9e6bff5027" name="BOOST_TEST_NO_RANDOM_DATASET_AVAILABLE"><purpose>Defined when the random dataset feature is not available. </purpose></macro>
<macro id="doxygen.a00809_1aaf7af97683c31abe28a164c8e5b57e2b" name="BOOST_TEST_NO_GRID_COMPOSITION_AVAILABLE"><purpose>Defined when grid composition of datasets is not available. </purpose></macro>
<macro id="doxygen.a00809_1a3ffbac269df751c982974a73f2d55363" name="BOOST_TEST_NO_ZIP_COMPOSITION_AVAILABLE"><purpose>Defined when zip composition of datasets is not available. </purpose></macro>
<macro id="doxygen.a00809_1a08ce098d5011bf35d60d2e602bf27c4d" name="BOOST_TEST_DS_ERROR" kind="functionlike"><macro-parameter name="msg"/><purpose>Defined when the initializer_list implementation is buggy, such as for VS2013. </purpose></macro>
<macro id="doxygen.a00809_1a9c8f378d9e4489926d954330352a84c3" name="BOOST_TEST_DS_ASSERT" kind="functionlike"><macro-parameter name="cond"/><macro-parameter name="msg"/></macro>
</header>
<header id="doxygen.a00776" name="boost/test/data/for_each_sample.hpp">
<para>Defines for_each_sample algorithm. </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="data">









<function id="doxygen.a00867_1a607b6e76935832b0eb06680f56bc17e9" name="invoke_action"><type>void</type><template>
          <template-type-parameter name="Action"/>
          <template-type-parameter name="T"/>
        </template><parameter name="action"><paramtype>Action const &amp;</paramtype></parameter><parameter name="arg"><paramtype>T &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>std::false_type</paramtype></parameter></function>
<function id="doxygen.a00867_1aa598ecd1058fdf71c5c2ba6d166fcb12" name="invoke_action_impl"><type>void</type><template>
          <template-type-parameter name="Action"/>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="I"><type>std::size_t ...</type></template-nontype-parameter>
        </template><parameter name="action"><paramtype>Action const &amp;</paramtype></parameter><parameter name="args"><paramtype>T &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>index_sequence&lt; I... &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.a00867_1a484dfeb8a85997066224b577f6c01c49" name="invoke_action"><type>void</type><template>
          <template-type-parameter name="Action"/>
          <template-type-parameter name="T"/>
        </template><parameter name="action"><paramtype>Action const &amp;</paramtype></parameter><parameter name="args"><paramtype>T &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>std::true_type</paramtype></parameter></function>
<function id="doxygen.a00867_1af53e3d3f38ddfe8d70a1954588107aed" name="for_each_sample"><type>std::enable_if&lt; <classname>monomorphic::is_dataset</classname>&lt; DataSet &gt;::value, void &gt;::type</type><template>
          <template-type-parameter name="DataSet"/>
          <template-type-parameter name="Action"/>
        </template><parameter name="samples"><paramtype>DataSet const &amp;</paramtype></parameter><parameter name="act"><paramtype>Action const &amp;</paramtype></parameter><parameter name="number_of_samples"><paramtype><classname>data::size_t</classname></paramtype><default>BOOST_TEST_DS_INFINITE_SIZE</default></parameter></function>
<function id="doxygen.a00867_1a556ddc3341b611f82a588b71a98502e7" name="for_each_sample"><type>std::enable_if&lt;!<classname>monomorphic::is_dataset</classname>&lt; DataSet &gt;::value, void &gt;::type</type><template>
          <template-type-parameter name="DataSet"/>
          <template-type-parameter name="Action"/>
        </template><parameter name="samples"><paramtype>DataSet &amp;&amp;</paramtype></parameter><parameter name="act"><paramtype>Action const &amp;</paramtype></parameter><parameter name="number_of_samples"><paramtype><classname>data::size_t</classname></paramtype><default>BOOST_TEST_DS_INFINITE_SIZE</default></parameter></function>


































</namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00788" name="boost/test/data/monomorphic/array.hpp">
<para>Defines monomorphic dataset based on C type arrays. </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="data">
<namespace name="monomorphic">
<class id="doxygen.a01128" name="array"><template>
      <template-type-parameter name="T"/>
    </template><purpose>Dataset view of a C array. </purpose><typedef id="doxygen.a01128_1acdfe80517a7f283452fd4e522d78ccfc" name="sample"><type>T</type></typedef>
<typedef id="doxygen.a01128_1a012e2b23ea236dabfc06ca1d7832b650" name="iterator"><type>T const *</type></typedef>
<data-member id="doxygen.a01128_1aff66626483c7ee93ed4edd0ac8d2e896" name="arity" specifiers="static"><type>const int</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a01128_1aac4ae7aca3d275ec1cef1ca5983aa388"><parameter name="arr_"><paramtype>T const *</paramtype></parameter><parameter name="size_"><paramtype>std::size_t</paramtype></parameter></constructor>
<method id="doxygen.a01128_1acd1e9006ddd738497ae0c2e4adf49de8" name="size" cv="const"><type><classname>data::size_t</classname></type></method>
<method id="doxygen.a01128_1aca07d056b602faa5e035fc51419e84b9" name="begin" cv="const"><type>iterator</type></method>
</method-group>
</class><struct-specialization id="doxygen.a01132" name="is_dataset"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>array&lt; T &gt;</template-arg></specialization><inherit access="public">mpl::true_</inherit><purpose>An array dataset is a dataset. </purpose></struct-specialization>








</namespace>



<function id="doxygen.a00867_1ae2a718aa3cba362df6f827dbad955120" name="make"><type><classname>monomorphic::array</classname>&lt; typename boost::remove_const&lt; T &gt;::type &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="size"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="a"><paramtype>T(&amp;)</paramtype></parameter></function>












































</namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00791" name="boost/test/data/monomorphic/collection.hpp">
<para>Defines monomorphic dataset based on forward iterable sequence. </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="data">
<namespace name="monomorphic">
<class id="doxygen.a01136" name="collection"><template>
      <template-type-parameter name="C"/>
    </template><purpose>Dataset from a forward iterable container (collection) </purpose><description><para>This dataset is applicable to any container implementing a forward iterator. Note that container with one element will be considered as singletons. This dataset is constructible with the <link linkend="doxygen.a00867_1a75bb4ac1edba62ef731993799fb1474f">boost::unit_test::data::make</link> function. </para></description><typedef id="doxygen.a01136_1a19ff524320dffc8e72404592e5e0fd09" name="sample"><type>col_type::value_type</type></typedef>
<typedef id="doxygen.a01136_1a43ae8df51ee17682a9f82e1b32714455" name="iterator"><type>col_type::const_iterator</type></typedef>
<data-member id="doxygen.a01136_1add6dcef71e45ae4b62f80a5f2f1b3130" name="arity" specifiers="static"><type>const int</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a01136_1a2ad3f4bfc1b653ef0203ecee611ff815" specifiers="explicit"><parameter name="col"><paramtype>C &amp;&amp;</paramtype></parameter><purpose>Constructor consumed a temporary collection or stores a reference. </purpose></constructor>
<constructor id="doxygen.a01136_1accee8de787e480abb79c28ede4864861"><parameter name="c"><paramtype><classname>collection</classname> &amp;&amp;</paramtype></parameter><purpose>Move constructor. </purpose></constructor>
<method id="doxygen.a01136_1a133f411da870f5fadcff6705585bd905" name="col" cv="const"><type>C const &amp;</type><purpose>Returns the underlying collection. </purpose></method>
<method id="doxygen.a01136_1a1f5fd41156e455a65912d87625daaaae" name="size" cv="const"><type><classname>data::size_t</classname></type><purpose>dataset interface </purpose></method>
<method id="doxygen.a01136_1a9880d7902a75dd14d784df843f01e957" name="begin" cv="const"><type>iterator</type></method>
</method-group>
</class><struct-specialization id="doxygen.a01140" name="is_dataset"><template>
      <template-type-parameter name="C"/>
    </template><specialization><template-arg>collection&lt; C &gt;</template-arg></specialization><inherit access="public">mpl::true_</inherit><purpose>A collection from a forward iterable container is a dataset. </purpose></struct-specialization>








</namespace>


<function id="doxygen.a00867_1a277c678dc50b005e327cc45112c2b811" name="make"><type>std::enable_if&lt; <classname>is_container_forward_iterable</classname>&lt; C &gt;::value, <classname>monomorphic::collection</classname>&lt; C &gt; &gt;::type</type><template>
          <template-type-parameter name="C"/>
        </template><parameter name="c"><paramtype>C &amp;&amp;</paramtype></parameter></function>













































</namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00782" name="boost/test/data/monomorphic/delayed.hpp">
<para>Defines a lazy/delayed dataset store. </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="data">
<namespace name="monomorphic">
<class id="doxygen.a01104" name="delayed_dataset"><template>
      <template-type-parameter name="dataset_t"/>
      <template-nontype-parameter name="Args"><type>class ...</type></template-nontype-parameter>
    </template><purpose>Delayed dataset. </purpose><description><para>This dataset holds another dataset that is instanciated on demand. It is constructed with the <computeroutput><link linkend="doxygen.a00867_1a63604e3f1500464edf77be5abf783615">data::make_delayed&lt;dataset_t&gt;</link></computeroutput>(arg1,....) instead of the <computeroutput><link linkend="doxygen.a00867_1a75bb4ac1edba62ef731993799fb1474f">data::make</link></computeroutput>. </para></description><typedef id="doxygen.a01104_1adeaa704ac6d3eccf13a4d06d15aa4658" name="iterator"><type>decltype(std::declval&lt; dataset_t &gt;().begin())</type></typedef>
<data-member id="doxygen.a01104_1a2e2b6ecc022cdb77eae1599d277980e6" name="arity" specifiers="static"><type>const int</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a01104_1acff432a41b7e27d108123fd6043e2aa2"><parameter name="args"><paramtype>Args...</paramtype></parameter></constructor>
<constructor id="doxygen.a01104_1a4dbc0646c6c5d8f638bbfd7d3e81f9be"><parameter name="b"><paramtype><classname>delayed_dataset</classname> &amp;&amp;</paramtype></parameter></constructor>
<method id="doxygen.a01104_1acf9de39555db41ffb4b6ebb7357426df" name="size" cv="const"><type><classname>boost::unit_test::data::size_t</classname></type></method>
<method id="doxygen.a01104_1ae39a1d1dd037105b4297dff60f582eb8" name="begin" cv="const"><type>iterator</type></method>
</method-group>
<method-group name="private member functions">
<method id="doxygen.a01104_1ab2f6dcf3b8f5880003f2d73cecc7cc7a" name="get" cv="const"><type>dataset_t &amp;</type></method>
<method id="doxygen.a01104_1a45320b5f75a25fe2a747fe4ce3533cfe" name="create" cv="const"><type>std::unique_ptr&lt; dataset_t &gt;</type><template>
          <template-nontype-parameter name="I"><type>std::size_t...</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>boost::unit_test::data::index_sequence&lt; I... &gt;</paramtype></parameter></method>
</method-group>
</class><struct-specialization id="doxygen.a01108" name="is_dataset"><template>
      <template-type-parameter name="dataset_t"/>
      <template-nontype-parameter name="Args"><type>class ...</type></template-nontype-parameter>
    </template><specialization><template-arg>delayed_dataset&lt; dataset_t</template-arg><template-arg>Args... &gt;</template-arg></specialization><inherit access="public">boost::mpl::true_</inherit><purpose>A lazy/delayed dataset is a dataset. </purpose></struct-specialization>








</namespace>








<function id="doxygen.a00867_1a63604e3f1500464edf77be5abf783615" name="make_delayed"><type>std::enable_if&lt; <classname>monomorphic::is_dataset</classname>&lt; dataset_t &gt;::value, <classname>monomorphic::delayed_dataset</classname>&lt; dataset_t, Args... &gt; &gt;::type</type><template>
          <template-type-parameter name="dataset_t"/>
          <template-nontype-parameter name="Args"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args...</paramtype></parameter><purpose>Delayed dataset instanciation. </purpose></function>







































</namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00770" name="boost/test/data/monomorphic/fwd.hpp">
<para>Forward declares monomorphic datasets interfaces. </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="data">
<namespace name="monomorphic">
<struct id="doxygen.a01072" name="has_dataset"><template>
      <template-type-parameter name="DataSet"/>
      <template-nontype-parameter name=""><type>class...</type></template-nontype-parameter>
    </template><inherit access="public">boost::unit_test::data::monomorphic::is_dataset&lt; DataSet &gt;</inherit><purpose>Helper to check if a list of types contains a dataset. </purpose></struct><struct-specialization id="doxygen.a01076" name="has_dataset"><template>
      <template-type-parameter name="DataSet0"/>
      <template-type-parameter name="DataSet1"/>
      <template-nontype-parameter name="DataSetTT"><type>class...</type></template-nontype-parameter>
    </template><specialization><template-arg>DataSet0</template-arg><template-arg>DataSet1</template-arg><template-arg>DataSetTT...</template-arg></specialization><inherit access="public">std::integral_constant&lt; bool, is_dataset&lt; DataSet0 &gt;::value||has_dataset&lt; DataSet1, DataSetTT... &gt;::value &gt;</inherit></struct-specialization><struct id="doxygen.a01056" name="is_dataset"><template>
      <template-type-parameter name="DataSet"/>
    </template><inherit access="public">mpl::false_</inherit><purpose>Helper metafunction indicating if the specified type is a dataset. </purpose></struct><struct-specialization id="doxygen.a01060" name="is_dataset"><template>
      <template-type-parameter name="DataSet"/>
    </template><specialization><template-arg>DataSet &amp;</template-arg></specialization><inherit access="public">boost::unit_test::data::monomorphic::is_dataset&lt; DataSet &gt;</inherit><purpose>A reference to a dataset is a dataset. </purpose></struct-specialization><struct-specialization id="doxygen.a01064" name="is_dataset"><template>
      <template-type-parameter name="DataSet"/>
    </template><specialization><template-arg>DataSet &amp;&amp;</template-arg></specialization><inherit access="public">boost::unit_test::data::monomorphic::is_dataset&lt; DataSet &gt;</inherit></struct-specialization><struct-specialization id="doxygen.a01068" name="is_dataset"><template>
      <template-type-parameter name="DataSet"/>
    </template><specialization><template-arg>DataSet const</template-arg></specialization><inherit access="public">boost::unit_test::data::monomorphic::is_dataset&lt; DataSet &gt;</inherit><purpose>A const dataset is a dataset. </purpose></struct-specialization>








</namespace>
<namespace name="result_of">
<struct id="doxygen.a01080" name="make"><template>
      <template-type-parameter name="DataSet"/>
    </template><purpose>Result of the make call. </purpose><typedef id="doxygen.a01080_1aad9683f021a3746a6fe19e7fe012df67" name="type"><type>decltype(data::make(declval&lt; DataSet &gt;()))</type></typedef>
</struct></namespace>
<function id="doxygen.a00867_1a75bb4ac1edba62ef731993799fb1474f" name="make"><type>std::enable_if&lt; <classname>monomorphic::is_dataset</classname>&lt; DataSet &gt;::value, DataSet &gt;::type</type><template>
          <template-type-parameter name="DataSet"/>
        </template><parameter name="ds"><paramtype>DataSet &amp;&amp;</paramtype></parameter><purpose>Creates a dataset from a value, a collection or an array. </purpose><description><para>This function has several overloads: <programlisting language="c++">// returns ds if ds is already a dataset
template &lt;typename DataSet&gt; DataSet <link linkend="doxygen.a00867_1a75bb4ac1edba62ef731993799fb1474f">make</link>(DataSet&amp;&amp; ds); 

// creates a singleton dataset, for non forward iterable and non dataset type T
// (a C string is not considered as a sequence).
template &lt;typename T&gt; <link linkend="doxygen.a01188">monomorphic::singleton&lt;T&gt;</link> <link linkend="doxygen.a00867_1a75bb4ac1edba62ef731993799fb1474f">make</link>(T&amp;&amp; v); 
<link linkend="doxygen.a01188">monomorphic::singleton&lt;char*&gt;</link> <link linkend="doxygen.a00867_1a75bb4ac1edba62ef731993799fb1474f">make</link>( char* str );
<link linkend="doxygen.a01188">monomorphic::singleton&lt;char const*&gt;</link> <link linkend="doxygen.a00867_1a75bb4ac1edba62ef731993799fb1474f">make</link>( char const* str );

// creates a collection dataset, for forward iterable and non dataset type C
template &lt;typename C&gt; <link linkend="doxygen.a01136">monomorphic::collection&lt;C&gt;</link> <link linkend="doxygen.a00867_1a75bb4ac1edba62ef731993799fb1474f">make</link>(C &amp;&amp; c);

// creates an array dataset
template&lt;typename T, std::size_t size&gt; <link linkend="doxygen.a01128">monomorphic::array&lt;T&gt;</link> <link linkend="doxygen.a00867_1a75bb4ac1edba62ef731993799fb1474f">make</link>( T (&amp;a)[size] );
</programlisting> </para></description></function>
<function id="doxygen.a00867_1a7ee9c851014de74d2559ad5cc85d8a49" name="make"><type>std::enable_if&lt;!<classname>is_container_forward_iterable</classname>&lt; T &gt;::value &amp;&amp;!<classname>monomorphic::is_dataset</classname>&lt; T &gt;::value &amp;&amp;!is_array&lt; typenameremove_reference&lt; T &gt;::type &gt;::value, <classname>monomorphic::singleton</classname>&lt; T &gt; &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="v"><paramtype>T &amp;&amp;</paramtype></parameter></function>














































</namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00794" name="boost/test/data/monomorphic/generate.hpp">
<para>Defines generic interface for monomorphic dataset based on generator. </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="data">
<namespace name="monomorphic">
<class id="doxygen.a01144" name="generated_by"><template>
      <template-type-parameter name="Generator"/>
    </template><purpose>Generators interface. </purpose><description><para>This class implements the dataset concept over a generator. Examples of generators are:<itemizedlist>
<listitem><para><link linkend="doxygen.a01228">xrange_t</link></para>
</listitem><listitem><para><link linkend="doxygen.a01220">random_t</link></para>
</listitem></itemizedlist>
</para><para>The generator concept is the following:<itemizedlist>
<listitem><para>the type of the generated samples is given by field <computeroutput>sample</computeroutput> </para>
</listitem><listitem><para>the member function <computeroutput>capacity</computeroutput> should return the size of the collection being generated (potentially infinite)</para>
</listitem><listitem><para>the member function <computeroutput>next</computeroutput> should change the state of the generator to the next generated value</para>
</listitem><listitem><para>the member function <computeroutput>reset</computeroutput> should put the state of the object in the same state as right after its instanciation </para>
</listitem></itemizedlist>
</para></description><struct id="doxygen.a01148" name="iterator"><method-group name="public member functions">
<constructor id="doxygen.a01148_1a0d3d93a1610f185b5bf9e61a35cf9399" specifiers="explicit"><parameter name="gen"><paramtype>Generator &amp;</paramtype></parameter></constructor>
<method id="doxygen.a01148_1a66f7f98de9d7f165bcc8cda7e1d0083e" name="operator*" cv="const"><type>sample const &amp;</type></method>
<method id="doxygen.a01148_1a2f735d498b4bc8bf1fb0b0830e75e250" name="operator++"><type>void</type></method>
</method-group>
</struct><typedef id="doxygen.a01144_1a94b084f13e5d34305de9d2f33963a15f" name="sample"><type>Generator::sample</type></typedef>
<typedef id="doxygen.a01144_1a613c4afc2cfc3ff6f728e3e191779382" name="generator_type"><type>Generator</type></typedef>
<data-member id="doxygen.a01144_1a897127e99dce98f5da6eeb12dace1b47" name="arity" specifiers="static"><type>const int</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a01144_1aa4b5c94085749de416106c9d6035a61e" specifiers="explicit"><parameter name="G"><paramtype>Generator &amp;&amp;</paramtype></parameter></constructor>
<constructor id="doxygen.a01144_1aac5b4422ab668aa6f6f0711cfceabb42"><parameter name="rhs"><paramtype><classname>generated_by</classname> &amp;&amp;</paramtype></parameter></constructor>
<method id="doxygen.a01144_1af592b09582b926d773732478f3cf7e0d" name="size" cv="const"><type><classname>data::size_t</classname></type><purpose>Size of the underlying dataset. </purpose></method>
<method id="doxygen.a01144_1a426c8bf8b601a3fc59908b4966e313d6" name="begin" cv="const"><type><classname>iterator</classname></type><purpose>Iterator on the beginning of the dataset. </purpose></method>
</method-group>
</class><struct-specialization id="doxygen.a01152" name="is_dataset"><template>
      <template-type-parameter name="Generator"/>
    </template><specialization><template-arg>generated_by&lt; Generator &gt;</template-arg></specialization><inherit access="public">boost::mpl::true_</inherit><purpose>A generated dataset is a dataset. </purpose></struct-specialization>








</namespace>
















































</namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00812" name="boost/test/data/monomorphic/generators.hpp">
<para>Defines specific generators. </para></header>
<header id="doxygen.a00815" name="boost/test/data/monomorphic/generators/keywords.hpp">
<para>Keywords used in generator interfaces. </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="data">
















































</namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00818" name="boost/test/data/monomorphic/generators/random.hpp">
<para>Random generator. </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="data">
<namespace name="monomorphic">
<class id="doxygen.a01220" name="random_t"><template>
      <template-type-parameter name="SampleType"><default>double</default></template-type-parameter>
      <template-type-parameter name="DistributionType"><default><emphasis>unspecified</emphasis></default></template-type-parameter>
      <template-type-parameter name="EngineType"><default>std::default_random_engine</default></template-type-parameter>
    </template><purpose>Generator for the random sequences. </purpose><description><para>This class implements the generator concept (see <link linkend="doxygen.a01144">boost::unit_test::data::monomorphic::generated_by</link>) for implementing a random number generator. </para></description><typedef id="doxygen.a01220_1a1459c22718027b93fb24d4ef8063faad" name="sample"><type>SampleType</type></typedef>
<typedef id="doxygen.a01220_1a4bae67913f6cf83682309477325c05c6" name="distr_type"><type>DistributionType</type></typedef>
<typedef id="doxygen.a01220_1a42d3191267f84cd404831d37dc79d82c" name="engine_type"><type>EngineType</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.a01220_1a69a4f5d04b859c744418b0f7b79952e5"/>
<constructor id="doxygen.a01220_1a430b815581262d456976bbe5a7b374be" specifiers="explicit"><parameter name="d"><paramtype>distr_type &amp;&amp;</paramtype></parameter></constructor>
<constructor id="doxygen.a01220_1adc7fb70607a6b259fcfaabd9f7102642"><parameter name="e"><paramtype>engine_type &amp;&amp;</paramtype></parameter><parameter name="d"><paramtype>distr_type &amp;&amp;</paramtype></parameter></constructor>
<method id="doxygen.a01220_1a1d377705d92114e3e30c3cce486378da" name="capacity" cv="const"><type><classname>data::size_t</classname></type></method>
<method id="doxygen.a01220_1a57af82fe9b16257a5cac31fbb83a82fa" name="next"><type>SampleType</type></method>
<method id="doxygen.a01220_1a0bbf72b669d133c11341e943efd37710" name="reset"><type>void</type></method>
<method id="doxygen.a01220_1ad69f06357c85ab1a21ca0075a63e99cd" name="seed"><type>void</type><template>
          <template-type-parameter name="SeedType"/>
        </template><parameter name="seed"><paramtype>SeedType &amp;&amp;</paramtype></parameter><purpose>Sets the seed of the pseudo-random number engine. </purpose></method>
</method-group>
</class>








</namespace>








































<function id="doxygen.a00867_1aa047482a660068cc9a1b90d4e5341d1f" name="random"><type><classname>monomorphic::generated_by</classname>&lt; <classname>monomorphic::random_t</classname>&lt;&gt; &gt;</type><purpose>Returns an infinite sequence of random numbers. </purpose><description><para>The following overloads are available: <programlisting language="c++">auto d = <link linkend="doxygen.a00867_1aa047482a660068cc9a1b90d4e5341d1f">random</link>();
auto d = <link linkend="doxygen.a00867_1aa047482a660068cc9a1b90d4e5341d1f">random</link>(begin, end);
auto d = <link linkend="doxygen.a00867_1aa047482a660068cc9a1b90d4e5341d1f">random</link>(params);
</programlisting></para><para><itemizedlist>
<listitem><para>The first overload uses the default distribution, which is uniform and which elements are <computeroutput>double</computeroutput> type (the values are in [0, 1) ).</para>
</listitem><listitem><para>The second overload generates numbers in the given interval. The distribution is uniform (in [begin, end) for real numbers, and in [begin, end] for integers). The type of the distribution is deduced from the type of the <computeroutput>begin</computeroutput> and <computeroutput>end</computeroutput> parameters.</para>
</listitem><listitem><para>The third overload generates numbers using the named parameter inside <computeroutput>params</computeroutput> , which are:<itemizedlist>
<listitem><para><computeroutput>distribution:</computeroutput> the distribution used. In this overload, since the type of the samples cannot be deduced, the samples are of type <computeroutput>double</computeroutput> and the distribution is uniform real in [0, 1).</para>
</listitem><listitem><para><computeroutput>seed:</computeroutput> the seed for generating the values</para>
</listitem><listitem><para><computeroutput>engine:</computeroutput> the random number generator engine</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para><para>The function returns an object that implements the dataset API. <note><para>This function is available only for C++11 capable compilers. </para>
</note>
</para></description></function>
<function id="doxygen.a00867_1add43cb0985f06eb7de595386f2cc477d" name="random"><type><classname>monomorphic::generated_by</classname>&lt; <classname>monomorphic::random_t</classname>&lt; SampleType &gt; &gt;</type><template>
          <template-type-parameter name="SampleType"/>
        </template><parameter name="begin"><paramtype>SampleType</paramtype></parameter><parameter name="end"><paramtype>SampleType</paramtype></parameter></function>
<function id="doxygen.a00867_1aa6ce5247cd471db2d00b3b93927a0a18" name="random"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Params"/>
        </template><parameter name="params"><paramtype>Params const &amp;</paramtype></parameter></function>





</namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00821" name="boost/test/data/monomorphic/generators/xrange.hpp">
<para>Defines range generator. </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="data">
<namespace name="monomorphic">
<class id="doxygen.a01228" name="xrange_t"><template>
      <template-type-parameter name="SampleType"/>
      <template-type-parameter name="StepType"><default>SampleType</default></template-type-parameter>
    </template><purpose>Generator for the range sequences. </purpose><description><para>This class implements the generator concept (see <link linkend="doxygen.a01144">boost::unit_test::data::monomorphic::generated_by</link>) for implementing a range like sequence of numbers. </para></description><typedef id="doxygen.a01228_1acb1bc0e4aa2a8fe6abb81f273ee36a2d" name="sample"><type>SampleType</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.a01228_1a189ed7ba27d670de4b5ffe777da37f6b"><parameter name="begin_"><paramtype>SampleType const &amp;</paramtype></parameter><parameter name="step_"><paramtype>StepType const &amp;</paramtype></parameter><parameter name="size_"><paramtype><classname>data::size_t</classname></paramtype></parameter></constructor>
<method id="doxygen.a01228_1adff4b22227d0ed8ea3217af51ca355a0" name="capacity" cv="const"><type><classname>data::size_t</classname></type></method>
<method id="doxygen.a01228_1abce4e0a43405c5a1b11b0e9d04533ced" name="next"><type>SampleType</type></method>
<method id="doxygen.a01228_1a4542656bb1cfeaca6f473122050078cb" name="reset"><type>void</type></method>
</method-group>
</class>








</namespace>











































<function id="doxygen.a00867_1ab271da61d6a5d7eb4d0ff601c6cbecb9" name="xrange"><type><classname>monomorphic::generated_by</classname>&lt; <classname>monomorphic::xrange_t</classname>&lt; SampleType &gt; &gt;</type><template>
          <template-type-parameter name="SampleType"/>
          <template-type-parameter name="Params"/>
        </template><parameter name="params"><paramtype>Params const &amp;</paramtype></parameter><purpose>Creates a range (sequence) dataset. </purpose><description><para>The following overloads are available: <programlisting language="c++">auto d = <link linkend="doxygen.a00867_1ab271da61d6a5d7eb4d0ff601c6cbecb9">xrange</link>();
auto d = <link linkend="doxygen.a00867_1ab271da61d6a5d7eb4d0ff601c6cbecb9">xrange</link>(end_val);
auto d = <link linkend="doxygen.a00867_1ab271da61d6a5d7eb4d0ff601c6cbecb9">xrange</link>(end_val, param);
auto d = <link linkend="doxygen.a00867_1ab271da61d6a5d7eb4d0ff601c6cbecb9">xrange</link>(begin_val, end_val);
auto d = <link linkend="doxygen.a00867_1ab271da61d6a5d7eb4d0ff601c6cbecb9">xrange</link>(begin_val, end_val, step_val);
auto d = <link linkend="doxygen.a00867_1ab271da61d6a5d7eb4d0ff601c6cbecb9">xrange</link>(param);
</programlisting></para><para><itemizedlist>
<listitem><para><computeroutput>begin_val</computeroutput> indicates the start of the sequence (default to 0).</para>
</listitem><listitem><para><computeroutput>end_val</computeroutput> is the end of the sequence. If ommited, the dataset has infinite size.<sbr/>
</para>
</listitem><listitem><para><computeroutput>step_val</computeroutput> is the step between two consecutive elements of the sequence, and defaults to 1.<sbr/>
</para>
</listitem><listitem><para><computeroutput>param</computeroutput> is the named parameters that describe the sequence. The following parameters are accepted:<itemizedlist>
<listitem><para><computeroutput>begin:</computeroutput> same meaning <computeroutput>begin_val</computeroutput> </para>
</listitem><listitem><para><computeroutput>end:</computeroutput> same meaning as <computeroutput>end_val</computeroutput> </para>
</listitem><listitem><para><computeroutput>step:</computeroutput> same meaning as <computeroutput>step_val</computeroutput> </para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para><para>The returned value is an object that implements the dataset API.</para><para><note><para>the step size cannot be null, and it should be positive if <computeroutput>begin_val</computeroutput> &lt; <computeroutput>end_val</computeroutput>, negative otherwise. </para>
</note>
</para></description></function>
<function id="doxygen.a00867_1ad3fab7acba608b9150d0d7c7cc0798d4" name="xrange"><type><classname>monomorphic::generated_by</classname>&lt; <classname>monomorphic::xrange_t</classname>&lt; SampleType &gt; &gt;</type><template>
          <template-type-parameter name="SampleType"/>
        </template><parameter name="end_val"><paramtype>SampleType const &amp;</paramtype></parameter></function>
<function id="doxygen.a00867_1a8c9ba0062ad2e8a56e5a53440ad26e18" name="xrange"><type>enable_if_c&lt; <classname>nfp::is_named_param_pack</classname>&lt; Params &gt;::value, <classname>monomorphic::generated_by</classname>&lt; <classname>monomorphic::xrange_t</classname>&lt; SampleType &gt; &gt; &gt;::type</type><template>
          <template-type-parameter name="SampleType"/>
          <template-type-parameter name="Params"/>
        </template><parameter name="end_val"><paramtype>SampleType const &amp;</paramtype></parameter><parameter name="params"><paramtype>Params const &amp;</paramtype></parameter></function>
<function id="doxygen.a00867_1a0080136d4e14454bb0103263e51e4d4b" name="xrange"><type><classname>monomorphic::generated_by</classname>&lt; <classname>monomorphic::xrange_t</classname>&lt; SampleType &gt; &gt;</type><template>
          <template-type-parameter name="SampleType"/>
        </template><parameter name="begin_val"><paramtype>SampleType const &amp;</paramtype></parameter><parameter name="end_val"><paramtype>SampleType const &amp;</paramtype></parameter></function>
<function id="doxygen.a00867_1af2d848663ac9e3314744757e83a392e2" name="xrange"><type><classname>monomorphic::generated_by</classname>&lt; <classname>monomorphic::xrange_t</classname>&lt; SampleType &gt; &gt;</type><template>
          <template-type-parameter name="SampleType"/>
          <template-type-parameter name="StepType"/>
        </template><parameter name="begin_val"><paramtype>SampleType const &amp;</paramtype></parameter><parameter name="end_val"><paramtype>SampleType const &amp;</paramtype></parameter><parameter name="step_val"><paramtype>StepType const &amp;</paramtype></parameter></function>
</namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00797" name="boost/test/data/monomorphic/grid.hpp">
<para>Defines monomorphic dataset n+m dimentional *. Samples in this dataset is grid of elements in DataSet1 and DataSet2. There will be total |DataSet1| * |DataSet2| samples. </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="data">
<namespace name="monomorphic">
<class id="doxygen.a01156" name="grid"><template>
      <template-type-parameter name="DataSet1"/>
      <template-type-parameter name="DataSet2"/>
    </template><purpose>Implements the dataset resulting from a cartesian product/grid operation on datasets. </purpose><description><para>The arity of the resulting dataset is the sum of the arity of its operands. </para></description><struct id="doxygen.a01160" name="iterator"><typedef id="doxygen.a01160_1ad3fa14d859c6e80c13f248647a3644e7" name="iterator_sample"><type>decltype( sample_merge(*std::declval&lt; dataset1_iter &gt;(), *std::declval&lt; dataset2_iter &gt;()))</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.a01160_1af6dc655a2a78e1324a6f3cd5c0c34b92" specifiers="explicit"><parameter name="iter1"><paramtype>dataset1_iter</paramtype></parameter><parameter name="ds2"><paramtype>DataSet2 const &amp;</paramtype></parameter></constructor>
<method id="doxygen.a01160_1a3941b3dd4de2b9b91953aa5be6e926ca" name="operator*" cv="const"><type>iterator_sample</type></method>
<method id="doxygen.a01160_1a96b45917e3e6bfa0890358ef2d0a9b0e" name="operator++"><type>void</type></method>
</method-group>
</struct><data-member id="doxygen.a01156_1a7d2f69cad07b3dbe5d177e64d1078356" name="arity" specifiers="static"><type>const int</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a01156_1af81866589e93b932f26c9238ed12472f"><parameter name="ds1"><paramtype>DataSet1 &amp;&amp;</paramtype></parameter><parameter name="ds2"><paramtype>DataSet2 &amp;&amp;</paramtype></parameter><purpose>Constructor. </purpose></constructor>
<constructor id="doxygen.a01156_1af45c72af48d4b2cb58d3c07fa414b26c"><parameter name="j"><paramtype><classname>grid</classname> &amp;&amp;</paramtype></parameter><purpose>Move constructor. </purpose></constructor>
<method id="doxygen.a01156_1a2456b3417c1268e9e3958bd66edd0af7" name="size" cv="const"><type><classname>data::size_t</classname></type></method>
<method id="doxygen.a01156_1af5428c01874bda64c71b5e87c973f931" name="begin" cv="const"><type><classname>iterator</classname></type></method>
</method-group>
</class><struct-specialization id="doxygen.a01164" name="is_dataset"><template>
      <template-type-parameter name="DataSet1"/>
      <template-type-parameter name="DataSet2"/>
    </template><specialization><template-arg>grid&lt; DataSet1</template-arg><template-arg>DataSet2 &gt;</template-arg></specialization><inherit access="public">boost::mpl::true_</inherit></struct-specialization><namespace name="result_of">
<struct id="doxygen.a01168" name="grid"><template>
      <template-type-parameter name="DS1Gen"/>
      <template-type-parameter name="DS2Gen"/>
    </template><purpose>Result type of the grid operation on dataset. </purpose><typedef id="doxygen.a01168_1a5a4ef41d5d391a2dc71aae500a2039da" name="type"><type><classname>monomorphic::grid</classname>&lt; typename DS1Gen::type, typename DS2Gen::type &gt;</type></typedef>
</struct></namespace>
<function id="doxygen.a00868_1a225bf43b94a043484a71e05035a7b34f" name="operator*"><type>boost::lazy_enable_if_c&lt; <classname>is_dataset</classname>&lt; DataSet1 &gt;::value &amp;&amp;<classname>is_dataset</classname>&lt; DataSet2 &gt;::value, <classname>result_of::grid</classname>&lt; mpl::identity&lt; DataSet1 &gt;, mpl::identity&lt; DataSet2 &gt; &gt; &gt;::type</type><template>
          <template-type-parameter name="DataSet1"/>
          <template-type-parameter name="DataSet2"/>
        </template><parameter name="ds1"><paramtype>DataSet1 &amp;&amp;</paramtype></parameter><parameter name="ds2"><paramtype>DataSet2 &amp;&amp;</paramtype></parameter><purpose>Grid operation. </purpose></function>
<function id="doxygen.a00868_1acaa76b67c49a15a961a89fedd94a7eb3" name="operator*"><type>boost::lazy_enable_if_c&lt; <classname>is_dataset</classname>&lt; DataSet1 &gt;::value &amp;&amp;!<classname>is_dataset</classname>&lt; DataSet2 &gt;::value, <classname>result_of::grid</classname>&lt; mpl::identity&lt; DataSet1 &gt;, <classname>data::result_of::make</classname>&lt; DataSet2 &gt; &gt; &gt;::type</type><template>
          <template-type-parameter name="DataSet1"/>
          <template-type-parameter name="DataSet2"/>
        </template><parameter name="ds1"><paramtype>DataSet1 &amp;&amp;</paramtype></parameter><parameter name="ds2"><paramtype>DataSet2 &amp;&amp;</paramtype></parameter></function>
<function id="doxygen.a00868_1a57c76b2f3c0f87c119d63e50fc85a19d" name="operator*"><type>boost::lazy_enable_if_c&lt;!<classname>is_dataset</classname>&lt; DataSet1 &gt;::value &amp;&amp;<classname>is_dataset</classname>&lt; DataSet2 &gt;::value, <classname>result_of::grid</classname>&lt; <classname>data::result_of::make</classname>&lt; DataSet1 &gt;, mpl::identity&lt; DataSet2 &gt; &gt; &gt;::type</type><template>
          <template-type-parameter name="DataSet1"/>
          <template-type-parameter name="DataSet2"/>
        </template><parameter name="ds1"><paramtype>DataSet1 &amp;&amp;</paramtype></parameter><parameter name="ds2"><paramtype>DataSet2 &amp;&amp;</paramtype></parameter></function>






</namespace>
















































</namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00785" name="boost/test/data/monomorphic/initializer_list.hpp">
<para>Defines monomorphic dataset based on C++11 initializer_list template. </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="data">
<namespace name="monomorphic">
<class id="doxygen.a01112" name="init_list"><template>
      <template-type-parameter name="T"/>
    </template><purpose>Dataset view from an initializer_list or variadic template arguments. </purpose><description><para>The data should be stored in the dataset, and since the elements are passed by an <computeroutput>std::initializer_list</computeroutput> , it implies a copy of the elements. </para></description><typedef id="doxygen.a01112_1a63f9b5545284be4d1ae60dbb8aba8996" name="iterator"><type>std::vector&lt; T &gt;::const_iterator</type></typedef>
<data-member id="doxygen.a01112_1acf3c84219814fce2ca7a64eaffc2ea88" name="arity" specifiers="static"><type>const int</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a01112_1a1b9df5ea090356954f89a603f4b4df96"><parameter name="il"><paramtype>std::initializer_list&lt; T &gt;</paramtype></parameter><purpose>Constructor copies content of initializer_list. </purpose></constructor>
<constructor id="doxygen.a01112_1a917365bec4bd89b0b5454ad0f06ca394"><template>
          <template-nontype-parameter name="Args"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><purpose>Variadic template initialization. </purpose></constructor>
<method id="doxygen.a01112_1acdee4837c17f2e95645b88813c9100e5" name="size" cv="const"><type><classname>data::size_t</classname></type><purpose>dataset interface </purpose></method>
<method id="doxygen.a01112_1a03bd33485d33dc0574b0ff8a4a1e631f" name="begin" cv="const"><type>iterator</type></method>
</method-group>
</class><class-specialization id="doxygen.a01116" name="init_list"><template>
    </template><specialization><template-arg>bool</template-arg></specialization><purpose>Specialization of <link linkend="doxygen.a01112">init_list</link> for type bool. </purpose><struct id="doxygen.a01120" name="non_proxy_iterator"><template>
    </template><data-member id="doxygen.a01120_1a26e088250d1c2b6b48e32781d6e547b5" name="iterator"><type>std::vector&lt; bool &gt;::const_iterator</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a01120_1ac68dc455cf3eb2678678f5736021558d"><parameter name="it"><paramtype>std::vector&lt; bool &gt;::const_iterator &amp;&amp;</paramtype></parameter></constructor>
<method id="doxygen.a01120_1afb4df54aa1ac135756e7531cc4db68fb" name="operator*" cv="const"><type>bool</type></method>
<method id="doxygen.a01120_1a240e08adcf031cbd10972e21db1c9712" name="operator++"><type><classname>non_proxy_iterator</classname> &amp;</type></method>
</method-group>
</struct><typedef id="doxygen.a01116_1a8ecf94314709057f44aabdf558627a90" name="sample"><type>bool</type></typedef>
<typedef id="doxygen.a01116_1aae73366e0b4ef5a0103484ebd2549b8a" name="iterator"><type><classname>non_proxy_iterator</classname></type></typedef>
<data-member id="doxygen.a01116_1ae23afd5469eb47fd3bd551e0fcfdcfdd" name="arity" specifiers="static"><type>const int</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a01116_1ae6fcb0975469de69f898cfff6793e65c"><parameter name="il"><paramtype>std::initializer_list&lt; bool &gt; &amp;&amp;</paramtype></parameter><purpose>Constructor copies content of initializer_list. </purpose></constructor>
<constructor id="doxygen.a01116_1a057b7ecdf3c3dc6972312791c4a1099c"><template>
          <template-nontype-parameter name="Args"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><purpose>Variadic template initialization. </purpose></constructor>
<method id="doxygen.a01116_1a6d1c3b80fd84a46a731381347bee9232" name="size" cv="const"><type><classname>data::size_t</classname></type><purpose>dataset interface </purpose></method>
<method id="doxygen.a01116_1ae77220f78d751aa9e4cd498b5666b39a" name="begin" cv="const"><type>iterator</type></method>
</method-group>
</class-specialization><struct-specialization id="doxygen.a01124" name="is_dataset"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>init_list&lt; T &gt;</template-arg></specialization><inherit access="public">boost::mpl::true_</inherit><purpose>An array dataset is a dataset. </purpose></struct-specialization>








</namespace>






<function id="doxygen.a00867_1a8b6980e00baff544b7209898a6edeeaa" name="make"><type><classname>monomorphic::init_list</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>std::initializer_list&lt; T &gt; &amp;&amp;</paramtype></parameter></function>
<function id="doxygen.a00867_1afe2a253bb8bfc4ed8b80cab461c4f34a" name="make"><type>std::enable_if&lt;!<classname>monomorphic::has_dataset</classname>&lt; T, Args... &gt;::value, <classname>monomorphic::init_list</classname>&lt; T &gt; &gt;::type</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Args"><type>class ...</type></template-nontype-parameter>
        </template><parameter name="arg0"><paramtype>T &amp;&amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter></function>








































</namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00800" name="boost/test/data/monomorphic/join.hpp">
<para>Defines dataset join operation. </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="data">
<namespace name="monomorphic">
<struct-specialization id="doxygen.a01180" name="is_dataset"><template>
      <template-type-parameter name="DataSet1"/>
      <template-type-parameter name="DataSet2"/>
    </template><specialization><template-arg>join&lt; DataSet1</template-arg><template-arg>DataSet2 &gt;</template-arg></specialization><inherit access="public">boost::mpl::true_</inherit></struct-specialization><class id="doxygen.a01172" name="join"><template>
      <template-type-parameter name="DataSet1"/>
      <template-type-parameter name="DataSet2"/>
    </template><purpose>Defines a new dataset from the concatenation of two datasets. </purpose><description><para>The size of the resulting dataset is the sum of the two underlying datasets. The arity of the datasets should match. </para></description><struct id="doxygen.a01176" name="iterator"><method-group name="public member functions">
<constructor id="doxygen.a01176_1a98b7d6d7fce28916abc0bf726e281e65" specifiers="explicit"><parameter name="it1"><paramtype>dataset1_iter &amp;&amp;</paramtype></parameter><parameter name="it2"><paramtype>dataset2_iter &amp;&amp;</paramtype></parameter><parameter name="first_size"><paramtype><classname>data::size_t</classname></paramtype></parameter></constructor>
<method id="doxygen.a01176_1aac217b5d03df1b08a2a1c52a696832a9" name="operator*" cv="const"><type>sample_t</type></method>
<method id="doxygen.a01176_1ab90a44980939321784acf50faea15b51" name="operator++"><type>void</type></method>
</method-group>
</struct><typedef id="doxygen.a01172_1a903c628c45863deef4535d7224f553b8" name="sample_t"><type>typename std::conditional&lt; std::is_reference&lt; iter1_ret &gt;::value &amp;&amp;std::is_reference&lt; iter2_ret &gt;::value &amp;&amp;std::is_same&lt; iter1_ret, iter2_ret &gt;::value, iter1_ret, typename std::remove_reference&lt; iter1_ret &gt;::type &gt;::type</type></typedef>
<data-member id="doxygen.a01172_1a70ef8a043945915575353165caef69d1" name="arity" specifiers="static"><type>const int</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a01172_1a12cd44f060439c635201d42f2976c3f0"><parameter name="ds1"><paramtype>DataSet1 &amp;&amp;</paramtype></parameter><parameter name="ds2"><paramtype>DataSet2 &amp;&amp;</paramtype></parameter><purpose>Constructor. </purpose></constructor>
<constructor id="doxygen.a01172_1aa0a6a906b6e2684504bea0aeec99912a"><parameter name="j"><paramtype><classname>join</classname> &amp;&amp;</paramtype></parameter><purpose>Move constructor. </purpose></constructor>
<method id="doxygen.a01172_1aa3b48403afc25767d6e03bc465942f77" name="size" cv="const"><type><classname>data::size_t</classname></type><purpose>dataset interface </purpose></method>
<method id="doxygen.a01172_1ac3818096a46433502226324c8f121c26" name="begin" cv="const"><type><classname>iterator</classname></type></method>
</method-group>
</class><namespace name="result_of">
<struct id="doxygen.a01184" name="join"><template>
      <template-type-parameter name="DataSet1Gen"/>
      <template-type-parameter name="DataSet2Gen"/>
    </template><purpose>Result type of the join operation on datasets. </purpose><typedef id="doxygen.a01184_1af59cbea15014d06e341a1283626d1c2a" name="type"><type><classname>monomorphic::join</classname>&lt; typename DataSet1Gen::type, typename DataSet2Gen::type &gt;</type></typedef>
</struct></namespace>



<function id="doxygen.a00868_1a117345d685805ee1faa396b9db83c511" name="operator+"><type>boost::lazy_enable_if_c&lt; <classname>is_dataset</classname>&lt; DataSet1 &gt;::value &amp;&amp;<classname>is_dataset</classname>&lt; DataSet2 &gt;::value, <classname>result_of::join</classname>&lt; mpl::identity&lt; DataSet1 &gt;, mpl::identity&lt; DataSet2 &gt; &gt; &gt;::type</type><template>
          <template-type-parameter name="DataSet1"/>
          <template-type-parameter name="DataSet2"/>
        </template><parameter name="ds1"><paramtype>DataSet1 &amp;&amp;</paramtype></parameter><parameter name="ds2"><paramtype>DataSet2 &amp;&amp;</paramtype></parameter></function>
<function id="doxygen.a00868_1ac5ce2ac918a65195c6b4e1b37afe69f9" name="operator+"><type>boost::lazy_enable_if_c&lt; <classname>is_dataset</classname>&lt; DataSet1 &gt;::value &amp;&amp;!<classname>is_dataset</classname>&lt; DataSet2 &gt;::value, <classname>result_of::join</classname>&lt; mpl::identity&lt; DataSet1 &gt;, <classname>data::result_of::make</classname>&lt; DataSet2 &gt; &gt; &gt;::type</type><template>
          <template-type-parameter name="DataSet1"/>
          <template-type-parameter name="DataSet2"/>
        </template><parameter name="ds1"><paramtype>DataSet1 &amp;&amp;</paramtype></parameter><parameter name="ds2"><paramtype>DataSet2 &amp;&amp;</paramtype></parameter></function>
<function id="doxygen.a00868_1a753727f0b59be64cccdd27b609e7ceae" name="operator+"><type>boost::lazy_enable_if_c&lt;!<classname>is_dataset</classname>&lt; DataSet1 &gt;::value &amp;&amp;<classname>is_dataset</classname>&lt; DataSet2 &gt;::value, <classname>result_of::join</classname>&lt; <classname>data::result_of::make</classname>&lt; DataSet1 &gt;, mpl::identity&lt; DataSet2 &gt; &gt; &gt;::type</type><template>
          <template-type-parameter name="DataSet1"/>
          <template-type-parameter name="DataSet2"/>
        </template><parameter name="ds1"><paramtype>DataSet1 &amp;&amp;</paramtype></parameter><parameter name="ds2"><paramtype>DataSet2 &amp;&amp;</paramtype></parameter></function>



</namespace>
















































</namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00803" name="boost/test/data/monomorphic/singleton.hpp">
<para>Defines single element monomorphic dataset. </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="data">
<namespace name="monomorphic">
<struct-specialization id="doxygen.a01196" name="is_dataset"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>singleton&lt; T &gt;</template-arg></specialization><inherit access="public">boost::mpl::true_</inherit></struct-specialization><class id="doxygen.a01188" name="singleton"><template>
      <template-type-parameter name="T"/>
    </template><purpose>Models a single element data set. </purpose><struct id="doxygen.a01192" name="iterator"><method-group name="public member functions">
<constructor id="doxygen.a01192_1ae7a24972d6e5abe85babb432c056d649" specifiers="explicit"><parameter name="owner"><paramtype><classname>singleton</classname>&lt; T &gt; const *</paramtype></parameter></constructor>
<method id="doxygen.a01192_1acb7fc13b713527955daa40063f4eaf57" name="operator*" cv="const"><type>sample const &amp;</type></method>
<method id="doxygen.a01192_1ad88c9f78c729a7d896f7eec9d3e52004" name="operator++"><type>void</type></method>
</method-group>
</struct><data-member id="doxygen.a01188_1a5002bd25586739236ad59874d396983a" name="arity" specifiers="static"><type>const int</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a01188_1a7994da71af766f8fc8998840b68e0dba" specifiers="explicit"><parameter name="value"><paramtype>T &amp;&amp;</paramtype></parameter><purpose>Constructor. </purpose></constructor>
<constructor id="doxygen.a01188_1ae892d7e72802caea74daa6d0f53c543f"><parameter name="s"><paramtype><classname>singleton</classname> &amp;&amp;</paramtype></parameter><purpose>Move constructor. </purpose></constructor>
<method id="doxygen.a01188_1acb31c6ac39ddf4a5cfbc994c5b416f9f" name="value" cv="const"><type>T const &amp;</type><purpose>Value access method. </purpose></method>
<method id="doxygen.a01188_1ad3873d8e4ac01cac3c34c245c1006a59" name="size" cv="const"><type><classname>data::size_t</classname></type><purpose>dataset interface </purpose></method>
<method id="doxygen.a01188_1abf967c783660c947cd5d19ae4ba057d6" name="begin" cv="const"><type><classname>iterator</classname></type></method>
</method-group>
</class>








</namespace>




<function id="doxygen.a00867_1aa432c57fe1872af2ba0c93ea3fb27cbd" name="make"><type><classname>monomorphic::singleton</classname>&lt; char * &gt;</type><parameter name="str"><paramtype>char *</paramtype></parameter></function>
<function id="doxygen.a00867_1a208c093235250d2a7e32ee6d836f3003" name="make"><type><classname>monomorphic::singleton</classname>&lt; char const * &gt;</type><parameter name="str"><paramtype>char const *</paramtype></parameter></function>

































<function id="doxygen.a00867_1acd7a04d45a12f14ceb45391fe70b1dcf" name="make"><type>std::enable_if&lt;!<classname>is_container_forward_iterable</classname>&lt; T &gt;::value &amp;&amp;!<classname>monomorphic::is_dataset</classname>&lt; T &gt;::value &amp;&amp;!boost::is_array&lt; typenameboost::remove_reference&lt; T &gt;::type &gt;::value, <classname>monomorphic::singleton</classname>&lt; T &gt; &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="v"><paramtype>T &amp;&amp;</paramtype></parameter></function>








</namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00806" name="boost/test/data/monomorphic/zip.hpp">
<para>Defines monomorphic dataset based on zipping of 2 other monomorphic datasets. </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="data">
<namespace name="monomorphic">
<struct-specialization id="doxygen.a01208" name="is_dataset"><template>
      <template-type-parameter name="DataSet1"/>
      <template-type-parameter name="DataSet2"/>
    </template><specialization><template-arg>zip&lt; DataSet1</template-arg><template-arg>DataSet2 &gt;</template-arg></specialization><inherit access="public">boost::mpl::true_</inherit><purpose>Zipped datasets results in a dataset. </purpose></struct-specialization><class id="doxygen.a01200" name="zip"><template>
      <template-type-parameter name="DataSet1"/>
      <template-type-parameter name="DataSet2"/>
    </template><purpose>Zip datasets. </purpose><description><para>A zip of two datasets is a dataset whose arity is the sum of the operand datasets arity. The size is given by the function creating the instance (see <computeroutput>operator^</computeroutput> on datasets). </para></description><struct id="doxygen.a01204" name="iterator"><typedef id="doxygen.a01204_1ab928f569047174181cb712d6c09580c7" name="iterator_sample"><type>decltype( sample_merge(*std::declval&lt; dataset1_iter &gt;(), *std::declval&lt; dataset2_iter &gt;()))</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.a01204_1a4627fb433aa31ab55019aefa045dedf9" specifiers="explicit"><parameter name="iter1"><paramtype>dataset1_iter</paramtype></parameter><parameter name="iter2"><paramtype>dataset2_iter</paramtype></parameter></constructor>
<method id="doxygen.a01204_1a9c153b436e84795372b090f1e2016f3d" name="operator*" cv="const"><type>iterator_sample</type></method>
<method id="doxygen.a01204_1abf0ee5daeb88dc1c7be43812531c882b" name="operator++"><type>void</type></method>
</method-group>
</struct><data-member id="doxygen.a01200_1a7ea34e4892945f6b7bcdd9d7540a601b" name="arity" specifiers="static"><type>const int</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a01200_1abe8b2ee7c50c963dc10919869c294cea"><parameter name="ds1"><paramtype>DataSet1 &amp;&amp;</paramtype></parameter><parameter name="ds2"><paramtype>DataSet2 &amp;&amp;</paramtype></parameter><purpose>Constructor. </purpose><description><para>The datasets are moved and not copied. </para></description></constructor>
<constructor id="doxygen.a01200_1a52b46bb6e6d8d29ccee5cd3bf4f2948d"><parameter name="j"><paramtype><classname>zip</classname> &amp;&amp;</paramtype></parameter><purpose>Move constructor. </purpose></constructor>
<method id="doxygen.a01200_1afb5a409903fd1e7b3b09b78c154d2d3f" name="size" cv="const"><type><classname>data::size_t</classname></type></method>
<method id="doxygen.a01200_1acee5e049a9b1ca0a7a6ee5baba69088d" name="begin" cv="const"><type><classname>iterator</classname></type></method>
</method-group>
<method-group name="private member functions">
<method id="doxygen.a01200_1afaecdba00cbe6205b78b0c4c59b346e0" name="zip_size" cv="const"><type><classname>data::size_t</classname></type><purpose>Handles the sise of the resulting zipped dataset. </purpose></method>
</method-group>
</class><namespace name="result_of">
<struct id="doxygen.a01212" name="zip"><template>
      <template-type-parameter name="DS1Gen"/>
      <template-type-parameter name="DS2Gen"/>
    </template><purpose>Result type of the zip operator. </purpose><typedef id="doxygen.a01212_1a9d446fd97ad999bf3e911b95a7707879" name="type"><type><classname>monomorphic::zip</classname>&lt; typename DS1Gen::type, typename DS2Gen::type &gt;</type></typedef>
</struct></namespace>






<function id="doxygen.a00868_1acbbcf383c950e8d5a94c31c57295ea3d" name="operator^"><type>boost::lazy_enable_if_c&lt; <classname>is_dataset</classname>&lt; DataSet1 &gt;::value &amp;&amp;<classname>is_dataset</classname>&lt; DataSet2 &gt;::value, <classname>result_of::zip</classname>&lt; mpl::identity&lt; DataSet1 &gt;, mpl::identity&lt; DataSet2 &gt; &gt; &gt;::type</type><template>
          <template-type-parameter name="DataSet1"/>
          <template-type-parameter name="DataSet2"/>
        </template><parameter name="ds1"><paramtype>DataSet1 &amp;&amp;</paramtype></parameter><parameter name="ds2"><paramtype>DataSet2 &amp;&amp;</paramtype></parameter><purpose>Overload operator for zip support. </purpose></function>
<function id="doxygen.a00868_1ac0db344f32730bb299509f107b0532f4" name="operator^"><type>boost::lazy_enable_if_c&lt; <classname>is_dataset</classname>&lt; DataSet1 &gt;::value &amp;&amp;!<classname>is_dataset</classname>&lt; DataSet2 &gt;::value, <classname>result_of::zip</classname>&lt; mpl::identity&lt; DataSet1 &gt;, <classname>data::result_of::make</classname>&lt; DataSet2 &gt; &gt; &gt;::type</type><template>
          <template-type-parameter name="DataSet1"/>
          <template-type-parameter name="DataSet2"/>
        </template><parameter name="ds1"><paramtype>DataSet1 &amp;&amp;</paramtype></parameter><parameter name="ds2"><paramtype>DataSet2 &amp;&amp;</paramtype></parameter></function>
<function id="doxygen.a00868_1a52526226b74b5151d3a3fd50627accec" name="operator^"><type>boost::lazy_enable_if_c&lt;!<classname>is_dataset</classname>&lt; DataSet1 &gt;::value &amp;&amp;<classname>is_dataset</classname>&lt; DataSet2 &gt;::value, <classname>result_of::zip</classname>&lt; <classname>data::result_of::make</classname>&lt; DataSet1 &gt;, mpl::identity&lt; DataSet2 &gt; &gt; &gt;::type</type><template>
          <template-type-parameter name="DataSet1"/>
          <template-type-parameter name="DataSet2"/>
        </template><parameter name="ds1"><paramtype>DataSet1 &amp;&amp;</paramtype></parameter><parameter name="ds2"><paramtype>DataSet2 &amp;&amp;</paramtype></parameter></function>
</namespace>
















































</namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00779" name="boost/test/data/size.hpp">
<para>simple dataset size abstraction (can be infinite) </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="data">
<class id="doxygen.a01096" name="size_t"><purpose>Utility for handling the size of a dataset. </purpose><struct id="doxygen.a01100" name="dummy"><method-group name="public member functions">
<method id="doxygen.a01100_1ab1bcac555faf733d3b92207b1a2b19a0" name="nonnull"><type>void</type></method>
</method-group>
</struct><method-group name="public member functions">
<constructor id="doxygen.a01096_1a9928e89ca5b65e15d6cbbc3e64e51660"><parameter name="s"><paramtype>std::size_t</paramtype><default>0</default></parameter></constructor>
<constructor id="doxygen.a01096_1a606849ec334bca8230d29a7eb8e7ca36" specifiers="explicit"><parameter name=""><paramtype>bool</paramtype></parameter></constructor>
<constructor id="doxygen.a01096_1a9ddde0cb255ef1ecc4653481ba185888"><template>
          <template-type-parameter name="T"/>
        </template><parameter name="v"><paramtype>T</paramtype></parameter></constructor>
<method id="doxygen.a01096_1a04486d953ce10d1e5610cc6faf65b48e" name="value" cv="const"><type>std::size_t</type></method>
<method id="doxygen.a01096_1a14c14e9fd3eff2e288a664f063469022" name="is_inf" cv="const"><type>bool</type></method>
<method id="doxygen.a01096_1abc897031af9bd0176ce844c464999a86" name="conversion-operator" cv="const"><type>safe_bool</type></method>
<method id="doxygen.a01096_1ae0a1fe35d1eae23826c3cb35ed83a55e" name="operator--"><type><classname>data::size_t</classname></type></method>
<method id="doxygen.a01096_1ae61b5d655eb7b274062705325b90696a" name="operator--"><type><classname>data::size_t</classname></type><parameter name=""><paramtype>int</paramtype></parameter></method>
<method id="doxygen.a01096_1ab1cf77d69cf18275d8b0b8b29e5d7864" name="operator++"><type><classname>data::size_t</classname></type></method>
<method id="doxygen.a01096_1af9544e74c328c0123330e981994b21cc" name="operator++"><type><classname>data::size_t</classname></type><parameter name=""><paramtype>int</paramtype></parameter></method>
<method id="doxygen.a01096_1ac781b7b2b845f7fa7e3a39287e380fa5" name="operator+="><type><classname>data::size_t</classname> &amp;</type><parameter name="rhs"><paramtype>std::size_t</paramtype></parameter></method>
<method id="doxygen.a01096_1a7416aab246bb9460ad6e110b4f0a39b1" name="operator+="><type><classname>data::size_t</classname> &amp;</type><parameter name="rhs"><paramtype><classname>data::size_t</classname></paramtype></parameter></method>
<method id="doxygen.a01096_1a5183137be1a0e8aa0fc4a4361b771123" name="operator-="><type><classname>data::size_t</classname> &amp;</type><parameter name="rhs"><paramtype>std::size_t</paramtype></parameter></method>
<method id="doxygen.a01096_1a2cb0025dbfc76381f211a2bfe44e51fa" name="operator-="><type><classname>data::size_t</classname> &amp;</type><parameter name="rhs"><paramtype><classname>data::size_t</classname></paramtype></parameter></method>
</method-group>
</class>













<function id="doxygen.a00867_1a911bc149c9b124de072f6f38ed46f73f" name="operator&gt;"><type>bool</type><parameter name="lhs"><paramtype><classname>data::size_t</classname></paramtype></parameter><parameter name="rhs"><paramtype>std::size_t</paramtype></parameter></function>
<function id="doxygen.a00867_1a4e7f7c574fb7e4b92f176610e93e1658" name="operator&gt;"><type>bool</type><parameter name="lhs"><paramtype>std::size_t</paramtype></parameter><parameter name="rhs"><paramtype><classname>data::size_t</classname></paramtype></parameter></function>
<function id="doxygen.a00867_1afb368c67944a78a952206476b951026d" name="operator&gt;"><type>bool</type><parameter name="lhs"><paramtype><classname>data::size_t</classname></paramtype></parameter><parameter name="rhs"><paramtype><classname>data::size_t</classname></paramtype></parameter></function>
<function id="doxygen.a00867_1ac7999b6f82b94b40d0c14e65c3a64713" name="operator&gt;="><type>bool</type><parameter name="lhs"><paramtype><classname>data::size_t</classname></paramtype></parameter><parameter name="rhs"><paramtype>std::size_t</paramtype></parameter></function>
<function id="doxygen.a00867_1a59baf0607d8e0d84430a4b89cca0163d" name="operator&gt;="><type>bool</type><parameter name="lhs"><paramtype>std::size_t</paramtype></parameter><parameter name="rhs"><paramtype><classname>data::size_t</classname></paramtype></parameter></function>
<function id="doxygen.a00867_1aa3070505311ebba5c1dcd8f3d6bb2601" name="operator&gt;="><type>bool</type><parameter name="lhs"><paramtype><classname>data::size_t</classname></paramtype></parameter><parameter name="rhs"><paramtype><classname>data::size_t</classname></paramtype></parameter></function>
<function id="doxygen.a00867_1a7b19b479ef99ca6290dab346d1d2e6c9" name="operator&lt;"><type>bool</type><parameter name="lhs"><paramtype><classname>data::size_t</classname></paramtype></parameter><parameter name="rhs"><paramtype>std::size_t</paramtype></parameter></function>
<function id="doxygen.a00867_1a9325b28321491eb47eab03acb0161a39" name="operator&lt;"><type>bool</type><parameter name="lhs"><paramtype>std::size_t</paramtype></parameter><parameter name="rhs"><paramtype><classname>data::size_t</classname></paramtype></parameter></function>
<function id="doxygen.a00867_1a2a6f582d1a741e8210c7df11bbd3c450" name="operator&lt;"><type>bool</type><parameter name="lhs"><paramtype><classname>data::size_t</classname></paramtype></parameter><parameter name="rhs"><paramtype><classname>data::size_t</classname></paramtype></parameter></function>
<function id="doxygen.a00867_1a8c98e781ba9e515b96c392adcb616606" name="operator&lt;="><type>bool</type><parameter name="lhs"><paramtype><classname>data::size_t</classname></paramtype></parameter><parameter name="rhs"><paramtype>std::size_t</paramtype></parameter></function>
<function id="doxygen.a00867_1a757acc6221f81fc2ebe22f93e86b7776" name="operator&lt;="><type>bool</type><parameter name="lhs"><paramtype>std::size_t</paramtype></parameter><parameter name="rhs"><paramtype><classname>data::size_t</classname></paramtype></parameter></function>
<function id="doxygen.a00867_1ac4dfb402d1777d79d21c2be5fb30392a" name="operator&lt;="><type>bool</type><parameter name="lhs"><paramtype><classname>data::size_t</classname></paramtype></parameter><parameter name="rhs"><paramtype><classname>data::size_t</classname></paramtype></parameter></function>
<function id="doxygen.a00867_1ad7e0b2b9c8172a8f12da0897b777f2ac" name="operator=="><type>bool</type><parameter name="lhs"><paramtype><classname>data::size_t</classname></paramtype></parameter><parameter name="rhs"><paramtype>std::size_t</paramtype></parameter></function>
<function id="doxygen.a00867_1a2d6d4dc7d0055e86e0a9ee3720eebc4c" name="operator=="><type>bool</type><parameter name="lhs"><paramtype>std::size_t</paramtype></parameter><parameter name="rhs"><paramtype><classname>data::size_t</classname></paramtype></parameter></function>
<function id="doxygen.a00867_1af833b7ad7c8745576d5f1ba880367c2a" name="operator=="><type>bool</type><parameter name="lhs"><paramtype><classname>data::size_t</classname></paramtype></parameter><parameter name="rhs"><paramtype><classname>data::size_t</classname></paramtype></parameter></function>
<function id="doxygen.a00867_1a41f962b5f6cbe6690bb0e65464b37757" name="operator!="><type>bool</type><parameter name="lhs"><paramtype><classname>data::size_t</classname></paramtype></parameter><parameter name="rhs"><paramtype>std::size_t</paramtype></parameter></function>
<function id="doxygen.a00867_1a6159ef6746610489264f1ff1e75a4f28" name="operator!="><type>bool</type><parameter name="lhs"><paramtype>std::size_t</paramtype></parameter><parameter name="rhs"><paramtype><classname>data::size_t</classname></paramtype></parameter></function>
<function id="doxygen.a00867_1a9e55d9e1c7f233f410297afdc18fcca4" name="operator!="><type>bool</type><parameter name="lhs"><paramtype><classname>data::size_t</classname></paramtype></parameter><parameter name="rhs"><paramtype><classname>data::size_t</classname></paramtype></parameter></function>
<function id="doxygen.a00867_1aa739fa3822dad20270707d745166e327" name="operator+"><type><classname>data::size_t</classname></type><parameter name="lhs"><paramtype><classname>data::size_t</classname></paramtype></parameter><parameter name="rhs"><paramtype>std::size_t</paramtype></parameter></function>
<function id="doxygen.a00867_1aa1560d92044b8ee38f5161218c1b90ba" name="operator+"><type><classname>data::size_t</classname></type><parameter name="lhs"><paramtype>std::size_t</paramtype></parameter><parameter name="rhs"><paramtype><classname>data::size_t</classname></paramtype></parameter></function>
<function id="doxygen.a00867_1a91390c2e67d71e9d5471ef8baeab67bb" name="operator+"><type><classname>data::size_t</classname></type><parameter name="lhs"><paramtype><classname>data::size_t</classname></paramtype></parameter><parameter name="rhs"><paramtype><classname>data::size_t</classname></paramtype></parameter></function>
<function id="doxygen.a00867_1a0e13eed76ad4c2ceda7978e81c30c8f2" name="operator*"><type><classname>data::size_t</classname></type><parameter name="lhs"><paramtype><classname>data::size_t</classname></paramtype></parameter><parameter name="rhs"><paramtype>std::size_t</paramtype></parameter></function>
<function id="doxygen.a00867_1ab253fcf349fc553618490ee9ff115fff" name="operator*"><type><classname>data::size_t</classname></type><parameter name="lhs"><paramtype>std::size_t</paramtype></parameter><parameter name="rhs"><paramtype><classname>data::size_t</classname></paramtype></parameter></function>
<function id="doxygen.a00867_1a8aabd52881dec0b51dc2264c2d089ba5" name="operator*"><type><classname>data::size_t</classname></type><parameter name="lhs"><paramtype><classname>data::size_t</classname></paramtype></parameter><parameter name="rhs"><paramtype><classname>data::size_t</classname></paramtype></parameter></function>
<function id="doxygen.a00867_1a8448ab970381d05b7b9dd5daca3787b7" name="operator&lt;&lt;"><type>std::basic_ostream&lt; CharT1, Tr &gt; &amp;</type><template>
          <template-type-parameter name="CharT1"/>
          <template-type-parameter name="Tr"/>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; CharT1, Tr &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype><classname>data::size_t</classname> const &amp;</paramtype></parameter></function>









</namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00773" name="boost/test/data/test_case.hpp">
<para>test case family based on data generator </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="data">
















































</namespace>






</namespace>
</namespace>
<macro id="doxygen.a00773_1ab0ace717689a981487c578d08c907581" name="BOOST_TEST_DATASET_VARIADIC"/>
<macro id="doxygen.a00773_1a6b18dd52df35d285b99469edf1c085fc" name="BOOST_DATA_TEST_CASE_PARAM" kind="functionlike"><macro-parameter name="r"/><macro-parameter name="_"/><macro-parameter name="i"/><macro-parameter name="param"/></macro>
<macro id="doxygen.a00773_1a8dcf36ba6b1f7912f1776f291c9d80b7" name="BOOST_DATA_TEST_CONTEXT" kind="functionlike"><macro-parameter name="r"/><macro-parameter name="_"/><macro-parameter name="param"/></macro>
<macro id="doxygen.a00773_1ae1b53b99feea744e23fa8aa33d83c827" name="BOOST_DATA_TEST_CASE_PARAMS" kind="functionlike"><macro-parameter name="params"/></macro>
<macro id="doxygen.a00773_1a74fc68442bfd508c7ba7e76360919ac0" name="BOOST_DATA_TEST_CASE_IMPL" kind="functionlike"><macro-parameter name="arity"/><macro-parameter name="F"/><macro-parameter name="test_name"/><macro-parameter name="dataset"/><macro-parameter name="params"/></macro>
<macro id="doxygen.a00773_1a2648035fb332412d33548766d285f3a8" name="BOOST_DATA_TEST_CASE_WITH_PARAMS" kind="functionlike"><macro-parameter name="F"/><macro-parameter name="test_name"/><macro-parameter name="dataset"/><macro-parameter name="..."/></macro>
<macro id="doxygen.a00773_1a44b8688898b2832ecfa51767660464ba" name="BOOST_DATA_TEST_CASE_NO_PARAMS" kind="functionlike"><macro-parameter name="F"/><macro-parameter name="test_name"/><macro-parameter name="dataset"/></macro>
<macro id="doxygen.a00773_1a2ff11d7248efe9603461b3c9030bd02b" name="BOOST_DATA_TEST_CASE" kind="functionlike"><macro-parameter name="..."/></macro>
<macro id="doxygen.a00773_1a221b25054cab51b6c9b7b11db9d03a90" name="BOOST_DATA_TEST_CASE_F" kind="functionlike"><macro-parameter name="F"/><macro-parameter name="..."/></macro>
</header>
<header id="doxygen.a00716" name="boost/test/debug.hpp">
<para>defines portable debug interfaces </para><para>Intended to standardize interface of programs with debuggers </para><namespace name="boost">
<namespace name="debug">
<struct id="doxygen.a00896" name="dbg_startup_info"><purpose>Collection of data, which is used by debugger starter routine. </purpose></struct></namespace>
</namespace>
</header>
<header id="doxygen.a00710" name="boost/test/debug_config.hpp">
<para>user's config for Boost.Test debugging support </para><para>This file is intended to be edited by end user to specify varios macros, which configure debugger interface Alterntively you can set these parameters in your own sources/makefiles </para></header>
<header id="doxygen.a00713" name="boost/test/detail/global_typedef.hpp">
<para>some trivial global typedefs </para><namespace name="boost">
<namespace name="unit_test">
<struct id="doxygen.a00892" name="static_constant"><template>
      <template-type-parameter name="T"/>
    </template><data-member id="doxygen.a00892_1a6819ea0e77be84b06e2948d97a9aa838" name="value" specifiers="static"><type>T</type></data-member>
</struct><enum id="doxygen.a00855_1ad2083dc687e475fa29571d0ee2dbe67b" name="test_unit_type"><enumvalue id="doxygen.a00855_1ad2083dc687e475fa29571d0ee2dbe67bac0ee5c48cb486c05a3f9dfe20f333a27" name="TUT_CASE"><default>0x01</default></enumvalue><enumvalue id="doxygen.a00855_1ad2083dc687e475fa29571d0ee2dbe67ba7eafe7a04342a3c900e290a7390667ad" name="TUT_SUITE"><default>0x10</default></enumvalue><enumvalue id="doxygen.a00855_1ad2083dc687e475fa29571d0ee2dbe67ba262ecbe3c03d4563abfde7d265152858" name="TUT_ANY"><default>0x11</default></enumvalue></enum>
<enum id="doxygen.a00855_1aff3508748a2be9cc00f99b3cea34d799" name="assertion_result"><enumvalue id="doxygen.a00855_1aff3508748a2be9cc00f99b3cea34d799a74948dcb93a647bfaf4199afd9c2eca1" name="AR_FAILED"/><enumvalue id="doxygen.a00855_1aff3508748a2be9cc00f99b3cea34d799ac91d50eb595b06b3892ee9466aad214a" name="AR_PASSED"/><enumvalue id="doxygen.a00855_1aff3508748a2be9cc00f99b3cea34d799ae3fa0fb16534a200105dc10ef585b343" name="AR_TRIGGERED"/></enum>
<typedef id="doxygen.a00855_1a342d43e1c6b3a771205410a4b727cb6b" name="counter_t"><type>unsigned long</type></typedef>
<typedef id="doxygen.a00855_1a8b826aeca85736f8c77a2e80f4cc51c9" name="test_unit_id"><type>unsigned long</type></typedef>
<data-member id="doxygen.a00855_1aadfeffb8876b9760c8e217fcf75bc7e0" name="INV_TEST_UNIT_ID"><type>const test_unit_id</type></data-member>
<data-member id="doxygen.a00855_1ae672af1b400473b3ebd00be0ca4f5dbb" name="MAX_TEST_CASE_ID"><type>const test_unit_id</type></data-member>
<data-member id="doxygen.a00855_1a59e018578964f7a897a200df8d11b5d3" name="MIN_TEST_CASE_ID"><type>const test_unit_id</type></data-member>
<data-member id="doxygen.a00855_1ab04b0fc78273a05b80e4ce8bd0f08f3f" name="MAX_TEST_SUITE_ID"><type>const test_unit_id</type></data-member>
<data-member id="doxygen.a00855_1aa99157df260d3f29c22ae495961278cc" name="MIN_TEST_SUITE_ID"><type>const test_unit_id</type></data-member>






</namespace>
</namespace>
<macro id="doxygen.a00713_1a944f9cab7de78ca60d1570702acc71bc" name="BOOST_TEST_L" kind="functionlike"><macro-parameter name="s"/></macro>
<macro id="doxygen.a00713_1a477e6af9115b4934d1562c759e108538" name="BOOST_TEST_STRINGIZE" kind="functionlike"><macro-parameter name="s"/></macro>
<macro id="doxygen.a00713_1ab11d7d15fca277cc1f5170469357910e" name="BOOST_TEST_EMPTY_STRING"/>
<macro id="doxygen.a00713_1a56c00e5fda680f92769f72f064dc6d17" name="BOOST_TEST_SINGLETON_CONS_NO_CTOR" kind="functionlike"><macro-parameter name="type"/></macro>
<macro id="doxygen.a00713_1a882c58f745e07821358135c2b491fd4f" name="BOOST_TEST_SINGLETON_CONS" kind="functionlike"><macro-parameter name="type"/></macro>
<macro id="doxygen.a00713_1aeeb199918d1d17292620bea54af2ca8d" name="BOOST_TEST_SINGLETON_CONS_IMPL" kind="functionlike"><macro-parameter name="type"/></macro>
<macro id="doxygen.a00713_1a97c1e8e74e75ca9370c667d44acb4821" name="BOOST_TEST_SINGLETON_INST" kind="functionlike"><macro-parameter name="inst"/></macro>
</header>
<header id="doxygen.a00719" name="boost/test/execution_monitor.hpp">
<para>Defines public interface of the Execution Monitor and related classes. </para><namespace name="boost">
<class id="doxygen.a00920" name="execution_aborted"><purpose>This is a trivial default constructible class. Use it to report graceful abortion of a monitored function execution. </purpose></class><class id="doxygen.a00904" name="execution_exception"><purpose>This class is used to report any kind of an failure during execution of a monitored function inside of <link linkend="doxygen.a00912">execution_monitor</link>. </purpose><description><para>The instance of this class is thrown out of <link linkend="doxygen.a00912_1a6e5bb9bb9bceaa52644920790193da9a">execution_monitor::execute</link> invocation when failure is detected. Regardless of a kind of failure occurred the instance will provide a uniform way to catch and report it.</para><para>One important design rationale for this class is that we should be ready to work after fatal memory corruptions or out of memory conditions. To facilitate this class never allocates any memory and assumes that strings it refers to are either some constants or live in a some kind of persistent (preallocated) memory. </para></description><struct id="doxygen.a00908" name="location"><purpose>Simple model for the location of failure in a source code. </purpose><data-member id="doxygen.a00908_1ab7d135c10652bef92c3d857f599e5da5" name="m_file_name"><type>const_string</type><purpose>File name. </purpose></data-member>
<data-member id="doxygen.a00908_1a7736847ad97b9bc1f910a612cb38bc8c" name="m_line_num"><type>size_t</type><purpose>Line number. </purpose></data-member>
<data-member id="doxygen.a00908_1ae61ca4dbc202553201e3508bdb8a0642" name="m_function"><type>const_string</type><purpose>Function name. </purpose></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a00908_1a726d382e166ea16c75783e0493976bb9" specifiers="explicit"><parameter name="file_name"><paramtype>char const *</paramtype><default>0</default></parameter><parameter name="line_num"><paramtype>size_t</paramtype><default>0</default></parameter><parameter name="func"><paramtype>char const *</paramtype><default>0</default></parameter></constructor>
<constructor id="doxygen.a00908_1a93da8bd22451e9f9884f0e8066a29ba0" specifiers="explicit"><parameter name="file_name"><paramtype>const_string</paramtype></parameter><parameter name="line_num"><paramtype>size_t</paramtype><default>0</default></parameter><parameter name="func"><paramtype>char const *</paramtype><default>0</default></parameter></constructor>
</method-group>
</struct><method-group name="Constructors">
<constructor id="doxygen.a00904_1af88cc0447e51f784d1418eb4aaf528fb"><parameter name="ec"><paramtype>error_code</paramtype><description><para>error code </para></description></parameter><parameter name="what_msg"><paramtype>const_string</paramtype><description><para>error message </para></description></parameter><parameter name="location"><paramtype><classname>location</classname> const &amp;</paramtype><description><para>error location </para></description></parameter><purpose>Constructs instance based on message, location and error code. </purpose><description><para>
</para></description></constructor>
</method-group>
<method-group name="Access methods">
<method id="doxygen.a00904_1ac69d7a47fc97b023d5643f186006cf59" name="code" cv="const"><type>error_code</type><purpose>Exception error code. </purpose></method>
<method id="doxygen.a00904_1a2c7de7a46a0fb451e5d5b56180a43e3a" name="what" cv="const"><type>const_string</type><purpose>Exception message. </purpose></method>
<method id="doxygen.a00904_1a0be6557b3762279bb8f0847ff761a1a9" name="where" cv="const"><type><classname>location</classname> const &amp;</type><purpose>Exception location. </purpose></method>
</method-group>
<enum id="doxygen.a00904_1ad9dfa8b8077567a56c8474ccd2e21902" name="error_code"><enumvalue id="doxygen.a00904_1ad9dfa8b8077567a56c8474ccd2e21902a75b4661a065bb23f9bf95875d366a3b1" name="no_error"><default>0</default><purpose>for completeness only; never returned </purpose></enumvalue><enumvalue id="doxygen.a00904_1ad9dfa8b8077567a56c8474ccd2e21902ab625bd9414f9f450c485e6a5a06a42d2" name="user_error"><default>200</default><purpose>user reported non-fatal error </purpose></enumvalue><enumvalue id="doxygen.a00904_1ad9dfa8b8077567a56c8474ccd2e21902adcb42e87f80a70e96de99b2dcd8867b8" name="cpp_exception_error"><default>205</default><purpose>see note (1) above </purpose></enumvalue><enumvalue id="doxygen.a00904_1ad9dfa8b8077567a56c8474ccd2e21902abcff4ef7e72844eba2ac32f7db85f05f" name="system_error"><default>210</default><purpose>see note (2) above </purpose></enumvalue><enumvalue id="doxygen.a00904_1ad9dfa8b8077567a56c8474ccd2e21902a667e179aa6b215732144d01fef8fffd7" name="timeout_error"><default>215</default><purpose>only detectable on certain platforms </purpose></enumvalue><enumvalue id="doxygen.a00904_1ad9dfa8b8077567a56c8474ccd2e21902ad25db41fcd027d0033cf69db3305b5d7" name="user_fatal_error"><default>220</default><purpose>user reported fatal error </purpose></enumvalue><enumvalue id="doxygen.a00904_1ad9dfa8b8077567a56c8474ccd2e21902ab4a99cbe6d241b3beaf3e748b0295d1e" name="system_fatal_error"><default>225</default><purpose>see note (2) above </purpose></enumvalue><purpose>These values are sometimes used as program return codes. The particular values have been chosen to avoid conflicts with commonly used program return codes: values &lt; 100 are often user assigned, values &gt; 255 are sometimes used to report system errors. Gaps in values allow for orderly expansion. </purpose><description><para><note><para>(1) Only uncaught C++ exceptions are treated as errors. If a function catches a C++ exception, it never reaches the <link linkend="doxygen.a00912">execution_monitor</link>.</para>
</note>
The implementation decides what is a system_fatal_error and what is just a system_exception. Fatal errors are so likely to have corrupted machine state (like a stack overflow or addressing exception) that it is unreasonable to continue execution.</para><para><note><para>(2) These errors include Unix signals and Windows structured exceptions. They are often initiated by hardware traps. </para>
</note>
</para></description></enum>
</class><class id="doxygen.a00912" name="execution_monitor"><purpose>Function execution monitor. </purpose><description><para>This class is used to uniformly detect and report an occurrence of several types of signals and exceptions, reducing various errors to a uniform <link linkend="doxygen.a00904">execution_exception</link> that is returned to a caller.</para><para>The <link linkend="doxygen.a00912">execution_monitor</link> behavior can be customized through a set of public parameters (properties) associated with the <link linkend="doxygen.a00912">execution_monitor</link> instance. All parameters are implemented as public unit_test::readwrite_property data members of the class <link linkend="doxygen.a00912">execution_monitor</link>. </para></description><data-member id="doxygen.a00912_1afb952a1fe2fc265981a44865e1e17a05" name="p_catch_system_errors"><type>unit_test::readwrite_property&lt; bool &gt;</type><purpose>Should monitor catch system errors. </purpose><description><para>The <emphasis>p_catch_system_errors</emphasis> property is a boolean flag (default value is true) specifying whether or not <link linkend="doxygen.a00912">execution_monitor</link> should trap system errors/system level exceptions/signals, which would cause program to crash in a regular case (without <link linkend="doxygen.a00912">execution_monitor</link>). Set this property to false, for example, if you wish to force coredump file creation. The Unit Test Framework provides a runtime parameter <computeroutput>--catch_system_errors=yes</computeroutput> to alter the behavior in monitored test cases. </para></description></data-member>
<data-member id="doxygen.a00912_1afcad434249db997e4606468cab73a5d3" name="p_auto_start_dbg"><type>unit_test::readwrite_property&lt; bool &gt;</type><purpose>Should monitor try to attach debugger in case of caught system error. </purpose><description><para>The <emphasis>p_auto_start_dbg</emphasis> property is a boolean flag (default value is false) specifying whether or not <link linkend="doxygen.a00912">execution_monitor</link> should try to attach debugger in case system error is caught. </para></description></data-member>
<data-member id="doxygen.a00912_1aae1990c1066c2da9e3fabe733681c589" name="p_timeout"><type>unit_test::readwrite_property&lt; unsigned long int &gt;</type><purpose>Specifies the seconds that elapse before a timer_error occurs. </purpose><description><para>The <emphasis>p_timeout</emphasis> property is an integer timeout (in microseconds) for monitored function execution. Use this parameter to monitor code with possible deadlocks or infinite loops. This feature is only available for some operating systems (not yet Microsoft Windows). </para></description></data-member>
<data-member id="doxygen.a00912_1a7936d976686e92494f18de4dc8c36e6b" name="p_use_alt_stack"><type>unit_test::readwrite_property&lt; bool &gt;</type><purpose>Should monitor use alternative stack for the signal catching. </purpose><description><para>The <emphasis>p_use_alt_stack</emphasis> property is a boolean flag (default value is false) specifying whether or not <link linkend="doxygen.a00912">execution_monitor</link> should use an alternative stack for the sigaction based signal catching. When enabled the signals are delivered to the <link linkend="doxygen.a00912">execution_monitor</link> on a stack different from current execution stack, which is safer in case if it is corrupted by monitored function. For more details on alternative stack handling see appropriate manuals. </para></description></data-member>
<data-member id="doxygen.a00912_1a4511f36e895f59481684060cf9741d1f" name="p_detect_fp_exceptions"><type>unit_test::readwrite_property&lt; unsigned &gt;</type><purpose>Should monitor try to detect hardware floating point exceptions (!= 0), and which specific exception to catch. </purpose><description><para>The <emphasis>p_detect_fp_exceptions</emphasis> property is a boolean flag (default value is false) specifying whether or not <link linkend="doxygen.a00912">execution_monitor</link> should install hardware traps for the floating point exception on platforms where it's supported. </para></description></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a00912_1abf8c5dcfcbdb60ab20fd778c09f7f820"><purpose>Default constructor initializes all execution monitor properties. </purpose></constructor>
<method id="doxygen.a00912_1a6e5bb9bb9bceaa52644920790193da9a" name="execute"><type>int</type><parameter name="F"><paramtype>boost::function&lt; int()&gt; const &amp;</paramtype><description><para>Function to monitor </para></description></parameter><purpose>Execution monitor entry point for functions returning integer value. </purpose><description><para>This method executes supplied function F inside a try/catch block and also may include other unspecified platform dependent error detection code.</para><para>This method throws an <link linkend="doxygen.a00904">execution_exception</link> on an uncaught C++ exception, a hardware or software signal, trap, or other user exception.</para><para><note><para><link linkend="doxygen.a00912_1a6e5bb9bb9bceaa52644920790193da9a">execute()</link> doesn't consider it an error for F to return a non-zero value. </para>
</note>


<formalpara><title>See Also:</title><para><link linkend="doxygen.a00912_1aa3dd353a18e899648646b01d8757b19b">vexecute</link> </para>
</formalpara>
</para></description><returns><para>value returned by function call F(). </para>
</returns></method>
<method id="doxygen.a00912_1aa3dd353a18e899648646b01d8757b19b" name="vexecute"><type>void</type><parameter name="F"><paramtype>boost::function&lt; void()&gt; const &amp;</paramtype><description><para>Function to monitor </para></description></parameter><purpose>Execution monitor entry point for functions returning void. </purpose><description><para>This method is semantically identical to <link linkend="doxygen.a00912_1a6e5bb9bb9bceaa52644920790193da9a">execution_monitor::execute</link>, but doesn't produce any result code. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00912_1a6e5bb9bb9bceaa52644920790193da9a">execute</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00912_1a4eff52558e85f85d314208b83cf44750" name="erase_exception_translator"><type>void</type><parameter name="tag"><paramtype>const_string</paramtype><description><para>tag associated with translator you wants to erase </para></description></parameter><purpose>Erases custom exception translator based on a tag. </purpose><description><para>Use the same tag as the one used during translator registration 
</para></description></method>
<method id="doxygen.a00912_1aceae7fc819b420cc9c032ae94079c628" name="erase_exception_translator"><type>void</type><template>
          <template-type-parameter name="ExceptionType"/>
        </template><parameter name=""><paramtype>boost::type&lt; ExceptionType &gt; *</paramtype><default>0</default></parameter><purpose>Erases custom exception translator based on an exception type. </purpose><description><para>tparam ExceptionType Exception type for which you want to erase the translator </para></description></method>
</method-group>
<method-group name="private member functions">
<method id="doxygen.a00912_1acfe5198520c5cd8ec73c313c04f80308" name="catch_signals"><type>int</type><parameter name="F"><paramtype>boost::function&lt; int()&gt; const &amp;</paramtype></parameter></method>
</method-group>
</class><class id="doxygen.a00924" name="system_error"><data-member id="doxygen.a00924_1a3f4ac48d3e2e65c2e6f16f3d1ad1379a" name="p_errno"><type>long const</type></data-member>
<data-member id="doxygen.a00924_1ae4f3680f9c6654f3dffab53a9e282e02" name="p_failed_exp"><type>char const *const</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a00924_1a4c33c7212342273b3f1254385b3e7a6a" specifiers="explicit"><parameter name="exp"><paramtype>char const *</paramtype></parameter></constructor>
</method-group>
</class><namespace name="fpe">
<enum id="doxygen.a00859_1a85718f50ad710e359729c414e1a4b9db" name="masks"><enumvalue id="doxygen.a00859_1a85718f50ad710e359729c414e1a4b9dbadc506b9fc0c60b47b54f3f8f9adc98d0" name="BOOST_FPE_OFF"><default>0</default></enumvalue><enumvalue id="doxygen.a00859_1a85718f50ad710e359729c414e1a4b9dba06c80c10fcfa268f341c153ae3d546ee" name="BOOST_FPE_DIVBYZERO"><default>BOOST_FPE_OFF</default></enumvalue><enumvalue id="doxygen.a00859_1a85718f50ad710e359729c414e1a4b9dbad53006865ae7c25adea3eb7d5164024e" name="BOOST_FPE_INEXACT"><default>BOOST_FPE_OFF</default></enumvalue><enumvalue id="doxygen.a00859_1a85718f50ad710e359729c414e1a4b9dba9d1889838193e51baf0eb75b2127eb9d" name="BOOST_FPE_INVALID"><default>BOOST_FPE_OFF</default></enumvalue><enumvalue id="doxygen.a00859_1a85718f50ad710e359729c414e1a4b9dba5f4b45f1ed5743a803851b9d40b907fb" name="BOOST_FPE_OVERFLOW"><default>BOOST_FPE_OFF</default></enumvalue><enumvalue id="doxygen.a00859_1a85718f50ad710e359729c414e1a4b9dba2b1ee8a7e4bcbd8be0ba787ce5c2c894" name="BOOST_FPE_UNDERFLOW"><default>BOOST_FPE_OFF</default></enumvalue><enumvalue id="doxygen.a00859_1a85718f50ad710e359729c414e1a4b9dbabe035e0f72012ce300240c24fef724be" name="BOOST_FPE_ALL"><default>BOOST_FPE_OFF</default></enumvalue><enumvalue id="doxygen.a00859_1a85718f50ad710e359729c414e1a4b9dbae9082a2536f19ea58e0f277b430202ca" name="BOOST_FPE_INV"><default>BOOST_FPE_ALL+1</default></enumvalue></enum>
<function id="doxygen.a00859_1ad689fc2c82a94ec5768312c582ec680f" name="enable"><type>unsigned</type><parameter name="mask"><paramtype>unsigned</paramtype></parameter></function>
<function id="doxygen.a00859_1a12aac4060fe63686cb807162716d0665" name="disable"><type>unsigned</type><parameter name="mask"><paramtype>unsigned</paramtype></parameter></function>
</namespace>
</namespace>
<macro id="doxygen.a00719_1a51fdd44d8f52e01d58df4f316ff61471" name="BOOST_TEST_DISABLE_ALT_STACK"><purpose>Disables the support of the alternative stack during the compilation of the Boost.test framework. This is especially useful in case it is not possible to detect the lack of alternative stack support for your compiler (for instance, ESXi). </purpose></macro>
</header>
<header id="doxygen.a00722" name="boost/test/framework.hpp">
<para>Defines Unit Test Framework mono-state interfaces. The framework interfaces are based on Monostate design pattern. </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="framework">
<struct id="doxygen.a00928" name="context_generator"><method-group name="public member functions">
<constructor id="doxygen.a00928_1a16b19f3f0759d27eadc1ea0592f1f199"/>
<method id="doxygen.a00928_1a2ec9c4ac335f9e0790dd287dd8e76e09" name="is_empty" cv="const"><type>bool</type><purpose>Is there any context? </purpose></method>
<method id="doxygen.a00928_1af160bdb472aeeb654d7522ac7824f0c9" name="next" cv="const"><type>const_string</type><purpose>Give me next frame; empty - last frame. </purpose></method>
</method-group>
</struct><struct id="doxygen.a00936" name="internal_error"><inherit access="public">std::runtime_error</inherit><purpose>This exception type is used to report internal Boost.Test framework errors. </purpose><method-group name="public member functions">
<constructor id="doxygen.a00936_1a5adcf7e7f244cabd1418df02942cac28"><parameter name="m"><paramtype>const_string</paramtype></parameter></constructor>
</method-group>
</struct><struct id="doxygen.a00944" name="nothing_to_test"><data-member id="doxygen.a00944_1a2c288e8c414071e617bfb63cd33cff23" name="m_result_code"><type>int</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a00944_1af8cef7d57f67500444a78175d2d1822a" specifiers="explicit"><parameter name="rc"><paramtype>int</paramtype></parameter></constructor>
</method-group>
</struct><struct id="doxygen.a00940" name="setup_error"><inherit access="public">std::runtime_error</inherit><purpose>This exception type is used to report test module setup errors. </purpose><method-group name="public member functions">
<constructor id="doxygen.a00940_1adf3906da35a9ef72ad33acb5157898a8"><parameter name="m"><paramtype>const_string</paramtype></parameter></constructor>
</method-group>
</struct><namespace name="impl">
<struct id="doxygen.a00932" name="master_test_suite_name_setter"><method-group name="public member functions">
<constructor id="doxygen.a00932_1a8f884731c84b0eb67eadec51320324a4"><parameter name="name"><paramtype>const_string</paramtype></parameter></constructor>
</method-group>
</struct><function id="doxygen.a00861_1a2023f48d1003c4a1cd00d2db84edbbf3" name="setup_for_execution"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter></function>
<function id="doxygen.a00861_1aa0898391d8fa4f6ce959f23571313181" name="setup_loggers"><type>void</type></function>
</namespace>
<free-function-group name="Unit Test Framework initialization and shutdown">
<function id="doxygen.a00860_1a9f012dd3ef928181dc1c4d896f4fe3a5" name="init"><type>void</type><parameter name="init_func"><paramtype>init_unit_test_func</paramtype><description><para>test module initialization routine </para></description></parameter><parameter name="argc"><paramtype>int</paramtype><description><para>command line arguments collection </para></description></parameter><parameter name="argv"><paramtype>char *</paramtype><description><para>command line arguments collection </para></description></parameter><purpose>This function performs initialization of the framework mono-state. </purpose><description><para>It needs to be called every time before the test is started. 
</para></description></function>
<function id="doxygen.a00860_1a6a95564b913ee2b951073568f222762f" name="finalize_setup_phase"><type>void</type><parameter name="tu"><paramtype>test_unit_id</paramtype><default>INV_TEST_UNIT_ID</default><description><para>Optional id of the test unit representing root of test tree. If absent, master test suite is used </para></description></parameter><purpose>This function applies all the decorators and figures out default run status. This argument facilitates an ability of the test cases to prepare some other test units (primarily used internally for self testing). </purpose><description><para>
</para></description></function>
<function id="doxygen.a00860_1a3fe4ed335905de4d22b8be381129e624" name="test_in_progress"><type>bool</type><purpose>This function returns true when testing is in progress (setup is finished). </purpose></function>
<function id="doxygen.a00860_1a7be340e3194af95dd45edbfe06453641" name="shutdown"><type>void</type><purpose>This function shuts down the framework and clears up its mono-state. </purpose><description><para>It needs to be at the very end of test module execution </para></description></function>
</free-function-group>
<free-function-group name="Test unit registration">
<function id="doxygen.a00860_1ac470bd1ee2c590c1a7e941ce7973241f" name="current_auto_test_suite"><type><classname>test_suite</classname> &amp;</type><parameter name="ts"><paramtype><classname>test_suite</classname> *</paramtype><default>0</default><description><para>test suite to push back to the queue </para></description></parameter><parameter name="push_or_pop"><paramtype>bool</paramtype><default>true</default><description><para>should we push ts to the queue or pop leaf test suite instead </para></description></parameter><purpose>Provides both read and write access to current "leaf" auto test suite during the test unit registration phase. </purpose><description><para>During auto-registration phase the framework maintain a FIFO queue of test units being registered. New test units become children of the current "leaf" test suite and if this is test suite it is pushed back into queue and becomes a new leaf. When test suite registration is completed, a test suite is popped from the back of the queue. Only automatically registered test suites should be added to this queue. Master test suite is always a zero element in this queue, so if no other test suites are registered all test cases are added to master test suite. This function facilitates all three possible actions:<itemizedlist>
<listitem><para>if no argument are provided it returns the current queue leaf test suite</para>
</listitem><listitem><para>if test suite is provided and no second argument are set, test suite is added to the queue</para>
</listitem><listitem><para>if no test suite are provided and last argument is false, the semantic of this function is similar to queue pop: last element is popped from the queue 

</para>
</listitem></itemizedlist>
</para></description></function>
<function id="doxygen.a00860_1a8099e5801cb76e83e44efe9e40b1aad6" name="register_test_unit"><type>void</type><parameter name="tc"><paramtype><classname>test_case</classname> *</paramtype><description><para>test case to register </para></description></parameter><purpose>This function add new test case into the global collection of test units the framework aware of. </purpose><description><para>This function also assignes unique test unit id for every test case. Later on one can use this id to locate the test case if necessary. This is the way for the framework to maintain weak references between test units. 
</para></description></function>
<function id="doxygen.a00860_1a5e1e15a90c013ca9693c79140bd69fc7" name="register_test_unit"><type>void</type><parameter name="ts"><paramtype><classname>test_suite</classname> *</paramtype><description><para>test suite to register </para></description></parameter><purpose>This function add new test suite into the global collection of test units the framework aware of. </purpose><description><para>This function also assignes unique test unit id for every test suite. Later on one can use this id to locate the test case if necessary. This is the way for the framework to maintain weak references between test units. 
</para></description></function>
<function id="doxygen.a00860_1ac633e89d0f65443476393b1a3d1c22ad" name="deregister_test_unit"><type>void</type><parameter name="tu"><paramtype><classname>test_unit</classname> *</paramtype><description><para>test unit to deregister </para></description></parameter><purpose>This function removes the test unit from the collection of known test units and destroys the test unit object. </purpose><description><para>This function also assigns unique test unit id for every test case. Later on one can use this id to located the test case if necessary. This is the way for the framework to maintain weak references between test units. 
</para></description></function>
<function id="doxygen.a00860_1af7c66227261f3259303e1d7701058cbe" name="clear"><type>void</type><purpose>After this call the framework can be reinitialized to perform a second test run during the same program lifetime. </purpose></function>
</free-function-group>
<free-function-group name="Test observer registration">
<function id="doxygen.a00860_1a44433831b2b7e97ac2504f530d6842db" name="register_observer"><type>void</type><parameter name="to"><paramtype><classname>test_observer</classname> &amp;</paramtype><description><para>test observer object to add </para></description></parameter><purpose>Observer lifetime should exceed the the testing execution timeframe. </purpose><description><para>
</para></description></function>
<function id="doxygen.a00860_1a752ef63301f37b7c8b9827a1b5808ffd" name="deregister_observer"><type>void</type><parameter name="to"><paramtype><classname>test_observer</classname> &amp;</paramtype><description><para>test observer object to exclude </para></description></parameter><purpose>Excludes the observer object form the framework's list of test observers. </purpose><description><para>
</para></description></function>
</free-function-group>
<free-function-group name="Global fixtures registration">
<function id="doxygen.a00860_1a68407bd1064a58c44a4461f8345f40b4" name="register_global_fixture"><type>void</type><parameter name="tuf"><paramtype>global_fixture &amp;</paramtype><description><para>fixture to add </para></description></parameter><purpose>Adds a new global fixture to be setup before any other tests starts and tore down after any other tests finished. Test unit fixture lifetime should exceed the testing execution timeframe. </purpose><description><para>
</para></description></function>
<function id="doxygen.a00860_1a738e803f4c14da3f12aed5705bad9313" name="deregister_global_fixture"><type>void</type><parameter name="tuf"><paramtype>global_fixture &amp;</paramtype><description><para>fixture to remove </para></description></parameter><purpose>Removes a test global fixture from the framework. </purpose><description><para>Test unit fixture lifetime should exceed the testing execution timeframe 
</para></description></function>
</free-function-group>
<free-function-group name="Assertion/uncaught exception context support">
<function id="doxygen.a00860_1a4fe702b19ba9fc15dca2836d45a2bc77" name="add_context"><type>int</type><parameter name="context_descr"><paramtype>lazy_ostream const &amp;</paramtype><description><para>context frame message </para></description></parameter><parameter name="sticky"><paramtype>bool</paramtype><description><para>is this sticky frame or not </para></description></parameter><purpose>Records context frame message. </purpose><description><para>Some context frames are sticky - they can only explicitly cleared by specifying context id. Other (non sticky) context frames cleared after every assertion. 

</para></description><returns><para>id of the newly created frame </para>
</returns></function>
<function id="doxygen.a00860_1abb8d36ba3a26686d62fd1effc351cb8e" name="clear_context"><type>void</type><parameter name="context_id"><paramtype>int</paramtype><default>-1</default></parameter><purpose>Erases context frame (when test exits context scope) </purpose><description><para>If context_id is passed clears that specific context frame identified by this id, otherwise clears all non sticky contexts. </para></description></function>
<function id="doxygen.a00860_1ad0398459bb0e077c0720cb0f96afa69c" name="get_context"><type><classname>context_generator</classname></type><purpose>Produces an instance of small "delegate" object, which facilitates access to collected context. </purpose></function>
</free-function-group>
<free-function-group name="Access to registered test units.">
<function id="doxygen.a00860_1a3f1610f79cd70af1f0792b31eea92a67" name="master_test_suite"><type><classname>master_test_suite_t</classname> &amp;</type><purpose>There is only only master test suite per test module. </purpose><description><para>
</para></description><returns><para>a reference the master test suite instance </para>
</returns></function>
<function id="doxygen.a00860_1af4d92cd4e358fd7ccefcfdfaa6d4d5ba" name="current_test_unit"><type><classname>test_unit</classname> const &amp;</type><purpose>This function provides an access to the test unit currently being executed. </purpose><description><para>The difference with current_test_case is about the time between a test-suite is being set up or torn down (fixtures) and when the test-cases of that suite start. This function is only valid during test execution phase. <formalpara><title>See Also:</title><para><link linkend="doxygen.a00860_1aff36c34e89c440125121ef47ee3f1e0d">current_test_case_id</link>, <link linkend="doxygen.a00860_1a8ec19b9f8d081a73b6295104be12bf32">current_test_case</link> </para>
</formalpara>
</para></description></function>
<function id="doxygen.a00860_1a8ec19b9f8d081a73b6295104be12bf32" name="current_test_case"><type><classname>test_case</classname> const &amp;</type><purpose>This function provides an access to the test case currently being executed. </purpose><description><para>This function is only valid during test execution phase. <formalpara><title>See Also:</title><para><link linkend="doxygen.a00860_1aff36c34e89c440125121ef47ee3f1e0d">current_test_case_id</link> </para>
</formalpara>
</para></description></function>
<function id="doxygen.a00860_1aff36c34e89c440125121ef47ee3f1e0d" name="current_test_case_id"><type>test_unit_id</type><purpose>This function provides an access to an id of the test case currently being executed. </purpose><description><para>This function safer than current_test_case, cause if wont throw if no test case is being executed. <formalpara><title>See Also:</title><para><link linkend="doxygen.a00860_1a8ec19b9f8d081a73b6295104be12bf32">current_test_case</link> </para>
</formalpara>
</para></description></function>
<function id="doxygen.a00860_1abdacf0293bb940f31443d8c42f031532" name="get"><type><classname>test_unit</classname> &amp;</type><parameter name="tu_id"><paramtype>test_unit_id</paramtype><description><para>id of a test unit to locate </para></description></parameter><parameter name="tu_type"><paramtype>test_unit_type</paramtype><description><para>type of a test unit to locate </para></description></parameter><purpose>This function provides access to a test unit by id and type combination. It will throw if no test unit located. </purpose><description><para>

</para></description><returns><para>located test unit </para>
</returns></function>
<function id="doxygen.a00860_1a951fec26e4e6b5189e9fd8e22cfb7b69" name="get"><type>UnitType &amp;</type><template>
          <template-type-parameter name="UnitType"><purpose><para>compile time type of test unit to get (<link linkend="doxygen.a01032">test_suite</link> or <link linkend="doxygen.a01028">test_case</link>) </para></purpose></template-type-parameter>
        </template><parameter name="id"><paramtype>test_unit_id</paramtype><description><para>id of test unit to get </para></description></parameter><purpose>This function template provides access to a typed test unit by id. </purpose><description><para>It will throw if you specify incorrect test unit type 

</para></description></function>
</free-function-group>
<free-function-group name="Test initiation interface">
<function id="doxygen.a00860_1abbae11c3f5ce001a9471ff580aa8feb4" name="run"><type>void</type><parameter name="tu"><paramtype>test_unit_id</paramtype><default>INV_TEST_UNIT_ID</default><description><para>Optional id of the test unit or test unit itself from which the test is started. If absent, master test suite is used </para></description></parameter><parameter name="continue_test"><paramtype>bool</paramtype><default>true</default><description><para>true == continue test if it was already started, false == restart the test from scratch regardless </para></description></parameter><purpose>Initiates test execution. </purpose><description><para>This function is used to start the test execution from a specific "root" test unit. If no root provided, test is started from master test suite. This second argument facilitates an ability of the test cases to start some other test units (primarily used internally for self testing). 
</para></description></function>
<function id="doxygen.a00860_1a5b5909e990182f39c34a6a825c6cd03d" name="run"><type>void</type><parameter name="tu"><paramtype><classname>test_unit</classname> const *</paramtype></parameter><parameter name="continue_test"><paramtype>bool</paramtype><default>true</default></parameter><purpose>Initiates test execution. Same as other overload. </purpose></function>
</free-function-group>
<free-function-group name="Test events dispatchers">
<function id="doxygen.a00860_1aceb25223d74d2c706f92fd3aaaaf0104" name="assertion_result"><type>void</type><parameter name="ar"><paramtype>unit_test::assertion_result</paramtype></parameter></function>
<function id="doxygen.a00860_1a22bb04be670db141c3435f4470672577" name="exception_caught"><type>void</type><parameter name=""><paramtype><classname>execution_exception</classname> const &amp;</paramtype></parameter><purpose>Reports uncaught exception to all test observers. </purpose></function>
<function id="doxygen.a00860_1a6e9476304b65427b96a61c601c1df203" name="test_unit_aborted"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Reports aborted test unit to all test observers. </purpose></function>
<function id="doxygen.a00860_1a00cdd004631fa4bfa26d8e0834096cc1" name="test_aborted"><type>void</type><purpose>Reports aborted test module to all test observers. </purpose></function>
</free-function-group>
</namespace>
<typedef id="doxygen.a00855_1a72abef43f4c112974a41417cc53f96e4" name="init_unit_test_func"><purpose>Test module initialization routine signature. </purpose><description><para>Different depending on whether BOOST_TEST_ALTERNATIVE_INIT_API is defined or not </para></description><type><classname>test_suite</classname> *(*</type></typedef>






</namespace>
</namespace>
<macro id="doxygen.a00722_1a74365e8617b4256a9bcba9582a033969" name="BOOST_TEST_SETUP_ASSERT" kind="functionlike"><macro-parameter name="cond"/><macro-parameter name="msg"/></macro>
</header>
<header id="doxygen.a00743" name="boost/test/output/compiler_log_formatter.hpp">
<para>Contains the formatter for the Human Readable Format (HRF) </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="output">
<class id="doxygen.a00984" name="compiler_log_formatter"><inherit access="public">boost::unit_test::unit_test_log_formatter</inherit><purpose>Log formatter for the Human Readable Format (HRF) log format. </purpose><method-group name="public member functions">
<constructor id="doxygen.a00984_1ae7abdcd8128f8bb7bc8709351102f50c"/>
<method id="doxygen.a00984_1acf4682d8802185819f7cce9b9e93ca26" name="log_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages to </para></description></parameter><parameter name="test_cases_amount"><paramtype>counter_t</paramtype><description><para>total test case amount to be run </para></description></parameter><purpose>Invoked at the beginning of test module execution. </purpose><description><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00984_1ab13471a32750088a58791be52aa13235">log_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00984_1ab13471a32750088a58791be52aa13235" name="log_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked at the end of test module execution. </purpose><description><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00984_1acf4682d8802185819f7cce9b9e93ca26">log_start</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00984_1af7615f033f09fa4a4462789d43f6177e" name="log_build_info" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="log_build_info"><paramtype>bool</paramtype><description><para>indicates if build info should be logged or not </para></description></parameter><purpose>Invoked when Unit Test Framework build information is requested. </purpose><description><para>
</para></description></method>
<method id="doxygen.a00984_1aa3aa8c2c7970eafae08a8944cf044d0a" name="test_unit_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype><description><para>test unit being started </para></description></parameter><purpose>Invoked when test unit starts (either test suite or test case) </purpose><description><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00984_1ae0a5da3d52c5d59b90ddb2791055d48d">test_unit_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00984_1ae0a5da3d52c5d59b90ddb2791055d48d" name="test_unit_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype><description><para>test unit being finished </para></description></parameter><parameter name="elapsed"><paramtype>unsigned long</paramtype><description><para>time in microseconds spend executing this test unit </para></description></parameter><purpose>Invoked when test unit finishes. </purpose><description><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00984_1aa3aa8c2c7970eafae08a8944cf044d0a">test_unit_start</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00984_1a65a57d470924cd5a5a1c64e17324fa66" name="test_unit_skipped" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype><description><para>skipped test unit </para></description></parameter><parameter name=""><paramtype>const_string</paramtype></parameter><purpose>Invoked if test unit skipped for any reason. </purpose><description><para>
</para></description></method>
<method id="doxygen.a00984_1a952137e54684b2de8f78f428d9dd6867" name="log_exception_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="lcd"><paramtype><classname>log_checkpoint_data</classname> const &amp;</paramtype><description><para>information about the last checkpoint before the exception was triggered </para></description></parameter><parameter name="ex"><paramtype><classname>execution_exception</classname> const &amp;</paramtype><description><para>information about the caught exception </para></description></parameter><purpose>Invoked when Unit Test Framework detects uncaught exception. </purpose><description><para>The framwork calls this function when an uncaught exception it detected. This call is followed by context information:<itemizedlist>
<listitem><para>one call to <computeroutput>entry_context_start</computeroutput>,</para>
</listitem><listitem><para>as many calls to <computeroutput>log_entry_context</computeroutput> as there are context entries</para>
</listitem><listitem><para>one call to <computeroutput>entry_context_finish</computeroutput> </para>
</listitem></itemizedlist>
</para><para>The logging of the exception information is finilized by a call to <computeroutput>log_exception_finish</computeroutput>.</para><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00984_1acfc901b8749410a8cfbf48dbe323c410">log_exception_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00984_1acfc901b8749410a8cfbf48dbe323c410" name="log_exception_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked when Unit Test Framework detects uncaught exception. </purpose><description><para>Call to this function finishes uncaught exception report. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00984_1a952137e54684b2de8f78f428d9dd6867">log_exception_start</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00984_1ab5bccbb20f15f4f151b1de3816678baa" name="log_entry_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="led"><paramtype><classname>log_entry_data</classname> const &amp;</paramtype><description><para>log entry attributes </para></description></parameter><parameter name="let"><paramtype>log_entry_types</paramtype><description><para>log entry type log_entry_finish </para></description></parameter><purpose>Invoked by Unit Test Framework to start new log entry. </purpose><description><para>Call to this function starts new log entry. It is followed by series of log_entry_value calls and finally call to log_entry_finish. A log entry may consist of one or more values being reported. Some of these values will be plain strings, while others can be complicated expressions in a form of "lazy" expression template lazy_ostream. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00984_1a0ed1cb2878c24f15c73ca9ba259fac10">log_entry_value</link>, <link linkend="doxygen.a00984_1ad3f8a2743cf714f7106eb54757081bc4">log_entry_finish</link></para>
</formalpara>
<note><para>call to this function may happen before any call to test_unit_start or all calls to test_unit_finish as the framework might log errors raised during global initialization/shutdown. </para>
</note>
</para></description></method>
<method id="doxygen.a00984_1a0ed1cb2878c24f15c73ca9ba259fac10" name="log_entry_value" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into. </para></description></parameter><parameter name="value"><paramtype>const_string</paramtype><description><para>log entry string value </para></description></parameter><purpose>Invoked by Unit Test Framework to report a log entry content. </purpose><description><para>This is one of two overloaded methods to report log entry content. This one is used to report plain string value. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00984_1ab5bccbb20f15f4f151b1de3816678baa">log_entry_start</link>, <link linkend="doxygen.a00984_1ad3f8a2743cf714f7106eb54757081bc4">log_entry_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00984_1acba1909c4193f980f28a02d464b6e240" name="log_entry_value" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="value"><paramtype>lazy_ostream const &amp;</paramtype><description><para>log entry "lazy" value </para></description></parameter><purpose>Invoked by Unit Test Framework to report a log entry content. </purpose><description><para>This is one of two overloaded methods to report log entry content. This one is used to report some complicated expression passed as an expression template lazy_ostream. In most cases default implementation provided by the framework should work as is (it just converts the lazy expression into a string. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00984_1ab5bccbb20f15f4f151b1de3816678baa">log_entry_start</link>, <link linkend="doxygen.a00984_1ad3f8a2743cf714f7106eb54757081bc4">log_entry_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00984_1ad3f8a2743cf714f7106eb54757081bc4" name="log_entry_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked by Unit Test Framework to finish a log entry report. </purpose><description><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00984_1ab5bccbb20f15f4f151b1de3816678baa">log_entry_start</link>, <link linkend="doxygen.a00984_1ab5bccbb20f15f4f151b1de3816678baa">log_entry_start</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00984_1aff9cc2b80bf2f86db68cf9102a0ff264" name="entry_context_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="l"><paramtype>log_level</paramtype><description><para>entry log_level, to be used to fine tune the message </para></description></parameter><purpose>Invoked by Unit Test Framework to start log entry context report. </purpose><description><para>Unit Test Framework logs for failed assertions and uncaught exceptions context if one was defined by a test module. Context consists of multiple "scopes" identified by description messages assigned by the test module using BOOST_TEST_INFO/BOOST_TEST_CONTEXT statements. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00984_1ae7c1aab4ce517b3cb23e37955dd1fb25">log_entry_context</link>, <link linkend="doxygen.a00984_1aacb90a1a8b3190009ab7b46dfcff0ccb">entry_context_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00984_1ae7c1aab4ce517b3cb23e37955dd1fb25" name="log_entry_context" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="l"><paramtype>log_level</paramtype><description><para>entry log_level, to be used to fine tune the message </para></description></parameter><parameter name="value"><paramtype>const_string</paramtype><description><para>context "scope" description </para></description></parameter><purpose>Invoked by Unit Test Framework to report log entry context "scope" description. </purpose><description><para>Each "scope" description is reported by separate call to log_entry_context. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00984_1ab5bccbb20f15f4f151b1de3816678baa">log_entry_start</link>, <link linkend="doxygen.a00984_1aacb90a1a8b3190009ab7b46dfcff0ccb">entry_context_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00984_1aacb90a1a8b3190009ab7b46dfcff0ccb" name="entry_context_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="l"><paramtype>log_level</paramtype><description><para>entry log_level, to be used to fine tune the message </para></description></parameter><purpose>Invoked by Unit Test Framework to finish log entry context report. </purpose><description><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00984_1ab5bccbb20f15f4f151b1de3816678baa">log_entry_start</link>, entry_context_context </para>
</formalpara>
</para></description></method>
<method name="test_unit_skipped" specifiers="virtual"><type>void</type><parameter name=""><paramtype>std::ostream &amp;</paramtype></parameter><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Deprecated version of this interface. </purpose><description><para><xrefsect id="a00851_1_deprecated000001"><xreftitle>Deprecated</xreftitle><xrefdescription/></xrefsect></para></description></method>
<method name="test_unit_aborted" specifiers="virtual"><type>void</type><parameter name=""><paramtype>std::ostream &amp;</paramtype></parameter><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Invoked when a test unit is aborted. </purpose></method>
<method name="test_unit_timed_out" specifiers="virtual"><type>void</type><parameter name=""><paramtype>std::ostream &amp;</paramtype></parameter><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Invoked when a test unit times-out. </purpose></method>
<method name="set_log_level" specifiers="virtual"><type>void</type><parameter name="new_log_level"><paramtype>log_level</paramtype></parameter><purpose>Sets the log level of the logger/formatter. </purpose><description><para>Some loggers need to manage the log level by their own. This member function let the implementation decide of that. <formalpara><title>Since Boost 1.62</title><para/>
</formalpara>
</para></description></method>
<method name="get_log_level" cv="const" specifiers="virtual"><type>log_level</type><purpose>Returns the log level of the logger/formatter. </purpose><description><para><formalpara><title>Since Boost 1.62</title><para/>
</formalpara>
</para></description></method>
<method name="get_default_stream_description" cv="const" specifiers="virtual"><type>std::string</type><purpose>Returns a default stream for this logger. </purpose><description><para>The returned string describes the stream as if it was passed from the command line <computeroutput>"--log_sink"</computeroutput> parameter. With that regards, <emphasis role="bold">stdout</emphasis> and <emphasis role="bold">stderr</emphasis> have special meaning indicating the standard output or error stream respectively.</para><para><formalpara><title>Since Boost 1.62</title><para/>
</formalpara>
</para></description></method>
</method-group>
<method-group name="protected member functions">
<method id="doxygen.a00984_1a975fbf0cfa03020c629ab269a162b5ff" name="print_prefix" specifiers="virtual"><type>void</type><parameter name=""><paramtype>std::ostream &amp;</paramtype></parameter><parameter name="file"><paramtype>const_string</paramtype></parameter><parameter name="line"><paramtype>std::size_t</paramtype></parameter></method>
</method-group>
</class></namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00740" name="boost/test/output/plain_report_formatter.hpp">
<namespace name="boost">
<namespace name="unit_test">
<namespace name="output">
<class id="doxygen.a00980" name="plain_report_formatter"><inherit access="public">boost::unit_test::results_reporter::format</inherit><method-group name="public member functions">
<constructor id="doxygen.a00980_1a700d633dc9626feb8e883ed9e7a0962d"/>
<method id="doxygen.a00980_1ac527b1855f63f15cfd82b3b7226b515d" name="results_report_start" specifiers="virtual"><type>void</type><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method id="doxygen.a00980_1aa2d78b246479d7071ba84ba2f7b2045c" name="results_report_finish" specifiers="virtual"><type>void</type><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method id="doxygen.a00980_1a7510a085c616feef89ec8f09a6810c6f" name="test_unit_report_start" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method id="doxygen.a00980_1a4882ae427e093cbd4d511534ad2aa225" name="test_unit_report_finish" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method id="doxygen.a00980_1a0a13a2d5e653b6ec9d4f8a4c5539b8a6" name="do_confirmation_report" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
</method-group>
</class></namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00737" name="boost/test/output/xml_log_formatter.hpp">
<namespace name="boost">
<namespace name="unit_test">
<namespace name="output">
<class id="doxygen.a00976" name="xml_log_formatter"><inherit access="public">boost::unit_test::unit_test_log_formatter</inherit><method-group name="public member functions">
<method id="doxygen.a00976_1abd1ed5e768727b4b94212559e1f87a89" name="log_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages to </para></description></parameter><parameter name="test_cases_amount"><paramtype>counter_t</paramtype><description><para>total test case amount to be run </para></description></parameter><purpose>Invoked at the beginning of test module execution. </purpose><description><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00976_1ac287d420fc8a58d4a7200c2ac58cf976">log_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00976_1ac287d420fc8a58d4a7200c2ac58cf976" name="log_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked at the end of test module execution. </purpose><description><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00976_1abd1ed5e768727b4b94212559e1f87a89">log_start</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00976_1a9efdcaede6c417c6d881d56add556887" name="log_build_info" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="log_build_info"><paramtype>bool</paramtype><description><para>indicates if build info should be logged or not </para></description></parameter><purpose>Invoked when Unit Test Framework build information is requested. </purpose><description><para>
</para></description></method>
<method id="doxygen.a00976_1ab5c109b583d74858bb91f14c162944e6" name="test_unit_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype><description><para>test unit being started </para></description></parameter><purpose>Invoked when test unit starts (either test suite or test case) </purpose><description><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00976_1a9276dd5c28b20eb5481d3ef3b6650868">test_unit_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00976_1a9276dd5c28b20eb5481d3ef3b6650868" name="test_unit_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype><description><para>test unit being finished </para></description></parameter><parameter name="elapsed"><paramtype>unsigned long</paramtype><description><para>time in microseconds spend executing this test unit </para></description></parameter><purpose>Invoked when test unit finishes. </purpose><description><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00976_1ab5c109b583d74858bb91f14c162944e6">test_unit_start</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00976_1a1f754042def097e2e436e9e9fae8c91c" name="test_unit_skipped" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype><description><para>skipped test unit </para></description></parameter><parameter name=""><paramtype>const_string</paramtype></parameter><purpose>Invoked if test unit skipped for any reason. </purpose><description><para>
</para></description></method>
<method id="doxygen.a00976_1a1920ee34f234c154ee13e4c6e1f1b1b8" name="log_exception_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="lcd"><paramtype><classname>log_checkpoint_data</classname> const &amp;</paramtype><description><para>information about the last checkpoint before the exception was triggered </para></description></parameter><parameter name="ex"><paramtype><classname>execution_exception</classname> const &amp;</paramtype><description><para>information about the caught exception </para></description></parameter><purpose>Invoked when Unit Test Framework detects uncaught exception. </purpose><description><para>The framwork calls this function when an uncaught exception it detected. This call is followed by context information:<itemizedlist>
<listitem><para>one call to <computeroutput>entry_context_start</computeroutput>,</para>
</listitem><listitem><para>as many calls to <computeroutput>log_entry_context</computeroutput> as there are context entries</para>
</listitem><listitem><para>one call to <computeroutput>entry_context_finish</computeroutput> </para>
</listitem></itemizedlist>
</para><para>The logging of the exception information is finilized by a call to <computeroutput>log_exception_finish</computeroutput>.</para><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00976_1a9c4c7d8f5cd10845d32dd73f992254a4">log_exception_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00976_1a9c4c7d8f5cd10845d32dd73f992254a4" name="log_exception_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked when Unit Test Framework detects uncaught exception. </purpose><description><para>Call to this function finishes uncaught exception report. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00976_1a1920ee34f234c154ee13e4c6e1f1b1b8">log_exception_start</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00976_1a22b397b101d4a636846f65c5ba3cb4e2" name="log_entry_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="led"><paramtype><classname>log_entry_data</classname> const &amp;</paramtype><description><para>log entry attributes </para></description></parameter><parameter name="let"><paramtype>log_entry_types</paramtype><description><para>log entry type log_entry_finish </para></description></parameter><purpose>Invoked by Unit Test Framework to start new log entry. </purpose><description><para>Call to this function starts new log entry. It is followed by series of log_entry_value calls and finally call to log_entry_finish. A log entry may consist of one or more values being reported. Some of these values will be plain strings, while others can be complicated expressions in a form of "lazy" expression template lazy_ostream. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00976_1a80a7ed43200c7506c7f9c0d13664a5d7">log_entry_value</link>, <link linkend="doxygen.a00976_1a43dbc9d1e75fd9735e5ab7b697db8c2a">log_entry_finish</link></para>
</formalpara>
<note><para>call to this function may happen before any call to test_unit_start or all calls to test_unit_finish as the framework might log errors raised during global initialization/shutdown. </para>
</note>
</para></description></method>
<method id="doxygen.a00976_1a80a7ed43200c7506c7f9c0d13664a5d7" name="log_entry_value" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into. </para></description></parameter><parameter name="value"><paramtype>const_string</paramtype><description><para>log entry string value </para></description></parameter><purpose>Invoked by Unit Test Framework to report a log entry content. </purpose><description><para>This is one of two overloaded methods to report log entry content. This one is used to report plain string value. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00976_1a22b397b101d4a636846f65c5ba3cb4e2">log_entry_start</link>, <link linkend="doxygen.a00976_1a43dbc9d1e75fd9735e5ab7b697db8c2a">log_entry_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00976_1a43dbc9d1e75fd9735e5ab7b697db8c2a" name="log_entry_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked by Unit Test Framework to finish a log entry report. </purpose><description><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00976_1a22b397b101d4a636846f65c5ba3cb4e2">log_entry_start</link>, <link linkend="doxygen.a00976_1a22b397b101d4a636846f65c5ba3cb4e2">log_entry_start</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00976_1a17ce626ba9f089cab946671e804ffa17" name="entry_context_start" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="l"><paramtype>log_level</paramtype><description><para>entry log_level, to be used to fine tune the message </para></description></parameter><purpose>Invoked by Unit Test Framework to start log entry context report. </purpose><description><para>Unit Test Framework logs for failed assertions and uncaught exceptions context if one was defined by a test module. Context consists of multiple "scopes" identified by description messages assigned by the test module using BOOST_TEST_INFO/BOOST_TEST_CONTEXT statements. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00976_1ae6f0d087e1b8393c72ac3e3ea356f714">log_entry_context</link>, <link linkend="doxygen.a00976_1a78920db01e86b1d0365a9e4b93ebb068">entry_context_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00976_1ae6f0d087e1b8393c72ac3e3ea356f714" name="log_entry_context" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="l"><paramtype>log_level</paramtype><description><para>entry log_level, to be used to fine tune the message </para></description></parameter><parameter name="value"><paramtype>const_string</paramtype><description><para>context "scope" description </para></description></parameter><purpose>Invoked by Unit Test Framework to report log entry context "scope" description. </purpose><description><para>Each "scope" description is reported by separate call to log_entry_context. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00976_1a22b397b101d4a636846f65c5ba3cb4e2">log_entry_start</link>, <link linkend="doxygen.a00976_1a78920db01e86b1d0365a9e4b93ebb068">entry_context_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00976_1a78920db01e86b1d0365a9e4b93ebb068" name="entry_context_finish" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="l"><paramtype>log_level</paramtype><description><para>entry log_level, to be used to fine tune the message </para></description></parameter><purpose>Invoked by Unit Test Framework to finish log entry context report. </purpose><description><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00976_1a22b397b101d4a636846f65c5ba3cb4e2">log_entry_start</link>, entry_context_context </para>
</formalpara>
</para></description></method>
<method id="doxygen.a00976_1a5298f47ddf6c5504fb43de904d2ddc9d" name="log_entry_value" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="value"><paramtype>lazy_ostream const &amp;</paramtype><description><para>log entry "lazy" value </para></description></parameter><purpose>Invoked by Unit Test Framework to report a log entry content. </purpose><description><para>This is one of two overloaded methods to report log entry content. This one is used to report some complicated expression passed as an expression template lazy_ostream. In most cases default implementation provided by the framework should work as is (it just converts the lazy expression into a string. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a00976_1a22b397b101d4a636846f65c5ba3cb4e2">log_entry_start</link>, <link linkend="doxygen.a00976_1a43dbc9d1e75fd9735e5ab7b697db8c2a">log_entry_finish</link> </para>
</formalpara>
</para></description></method>
<method name="test_unit_skipped" specifiers="virtual"><type>void</type><parameter name=""><paramtype>std::ostream &amp;</paramtype></parameter><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Deprecated version of this interface. </purpose><description><para><xrefsect id="a00851_1_deprecated000001"><xreftitle>Deprecated</xreftitle><xrefdescription/></xrefsect></para></description></method>
<method name="test_unit_aborted" specifiers="virtual"><type>void</type><parameter name=""><paramtype>std::ostream &amp;</paramtype></parameter><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Invoked when a test unit is aborted. </purpose></method>
<method name="test_unit_timed_out" specifiers="virtual"><type>void</type><parameter name=""><paramtype>std::ostream &amp;</paramtype></parameter><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Invoked when a test unit times-out. </purpose></method>
<method name="set_log_level" specifiers="virtual"><type>void</type><parameter name="new_log_level"><paramtype>log_level</paramtype></parameter><purpose>Sets the log level of the logger/formatter. </purpose><description><para>Some loggers need to manage the log level by their own. This member function let the implementation decide of that. <formalpara><title>Since Boost 1.62</title><para/>
</formalpara>
</para></description></method>
<method name="get_log_level" cv="const" specifiers="virtual"><type>log_level</type><purpose>Returns the log level of the logger/formatter. </purpose><description><para><formalpara><title>Since Boost 1.62</title><para/>
</formalpara>
</para></description></method>
<method name="get_default_stream_description" cv="const" specifiers="virtual"><type>std::string</type><purpose>Returns a default stream for this logger. </purpose><description><para>The returned string describes the stream as if it was passed from the command line <computeroutput>"--log_sink"</computeroutput> parameter. With that regards, <emphasis role="bold">stdout</emphasis> and <emphasis role="bold">stderr</emphasis> have special meaning indicating the standard output or error stream respectively.</para><para><formalpara><title>Since Boost 1.62</title><para/>
</formalpara>
</para></description></method>
</method-group>
</class></namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00746" name="boost/test/output/xml_report_formatter.hpp">
<namespace name="boost">
<namespace name="unit_test">
<namespace name="output">
<class id="doxygen.a00988" name="xml_report_formatter"><inherit access="public">boost::unit_test::results_reporter::format</inherit><method-group name="public member functions">
<method id="doxygen.a00988_1a15922e8f25f43e3f1c54e2a1855c6bb6" name="results_report_start" specifiers="virtual"><type>void</type><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method id="doxygen.a00988_1aa9074aa3a864a17558de3f35d38b161a" name="results_report_finish" specifiers="virtual"><type>void</type><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method id="doxygen.a00988_1ac30a75ca193df22b6f92356f06aaabd1" name="test_unit_report_start" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method id="doxygen.a00988_1adf5b82a2052b465a3360f9f322f3044a" name="test_unit_report_finish" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method id="doxygen.a00988_1a2dae7abe7930ea969c45241a537e05fc" name="do_confirmation_report" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
</method-group>
</class></namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00764" name="boost/test/parameterized_test.hpp">
<para>generators and helper macros for parameterized tests </para><namespace name="boost">
<namespace name="unit_test">



<function id="doxygen.a00855_1afa5e7352a2f70c874b01c00f9ebb5103" name="make_test_case"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="ParamType"/>
          <template-type-parameter name="ParamIter"/>
        </template><parameter name="test_func"><paramtype>boost::function&lt; void(ParamType)&gt; const &amp;</paramtype></parameter><parameter name="tc_name"><paramtype>const_string</paramtype></parameter><parameter name="tc_file"><paramtype>const_string</paramtype></parameter><parameter name="tc_line"><paramtype>std::size_t</paramtype></parameter><parameter name="par_begin"><paramtype>ParamIter</paramtype></parameter><parameter name="par_end"><paramtype>ParamIter</paramtype></parameter></function>
<function id="doxygen.a00855_1ac756cd8a1177bfea724e1070e360158a" name="make_test_case"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="ParamType"/>
          <template-type-parameter name="ParamIter"/>
        </template><parameter name="test_func"><paramtype>void(*)(ParamType)</paramtype></parameter><parameter name="tc_name"><paramtype>const_string</paramtype></parameter><parameter name="tc_file"><paramtype>const_string</paramtype></parameter><parameter name="tc_line"><paramtype>std::size_t</paramtype></parameter><parameter name="par_begin"><paramtype>ParamIter</paramtype></parameter><parameter name="par_end"><paramtype>ParamIter</paramtype></parameter></function>
<function id="doxygen.a00855_1aa230c29f6a58597a13f29708b1037970" name="make_test_case"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="UserTestCase"/>
          <template-type-parameter name="ParamType"/>
          <template-type-parameter name="ParamIter"/>
        </template><parameter name="test_method"><paramtype>void(UserTestCase::*)(ParamType)</paramtype></parameter><parameter name="tc_name"><paramtype>const_string</paramtype></parameter><parameter name="tc_file"><paramtype>const_string</paramtype></parameter><parameter name="tc_line"><paramtype>std::size_t</paramtype></parameter><parameter name="user_test_case"><paramtype>boost::shared_ptr&lt; UserTestCase &gt; const &amp;</paramtype></parameter><parameter name="par_begin"><paramtype>ParamIter</paramtype></parameter><parameter name="par_end"><paramtype>ParamIter</paramtype></parameter></function>
</namespace>
</namespace>
<macro id="doxygen.a00764_1a3e066c9c1917063948848419259103db" name="BOOST_PARAM_TEST_CASE" kind="functionlike"><macro-parameter name="function"/><macro-parameter name="begin"/><macro-parameter name="end"/></macro>
<macro id="doxygen.a00764_1af2755dbd4fe59a76f73595c6e2423c43" name="BOOST_PARAM_CLASS_TEST_CASE" kind="functionlike"><macro-parameter name="function"/><macro-parameter name="tc_instance"/><macro-parameter name="begin"/><macro-parameter name="end"/></macro>
</header>
<header id="doxygen.a00758" name="boost/test/progress_monitor.hpp">
<para>defines simple text based progress monitor </para><namespace name="boost">
<namespace name="unit_test">
<class id="doxygen.a01016" name="progress_monitor_t"><inherit access="public">boost::unit_test::test_observer</inherit><purpose>This class implements test observer interface and updates test progress as test units finish or get aborted. </purpose><method-group name="Test observer interface">
<method id="doxygen.a01016_1a79c7568f1f0e9fb7797f835a0c7d5d9c" name="test_start" specifiers="virtual"><type>void</type><parameter name=""><paramtype>counter_t</paramtype></parameter><parameter name=""><paramtype>test_unit_id</paramtype></parameter><purpose>Called before the framework starts executing the test cases. </purpose><description><para>
</para></description></method>
<method id="doxygen.a01016_1a613786f6040d9543761fbcd4d73555d4" name="test_aborted" specifiers="virtual"><type>void</type><purpose>Called when a critical error is detected. </purpose><description><para>The critical errors are mainly the signals sent by the system and caught by the Boost.Test framework. Since the running binary may be in incoherent/instable state, the test execution is aborted and all remaining tests are discarded.</para><para><note><para>may be called before <link linkend="doxygen.a00956_1a8ebc971fd12c0b1a962788e1e18ca6f8">test_observer::test_unit_finish()</link> </para>
</note>
</para></description></method>
<method id="doxygen.a01016_1a17b2dffe9c8c7abc1a0988b9729ae106" name="test_unit_finish" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name=""><paramtype>unsigned long</paramtype></parameter><purpose>Called at each end of a test unit. </purpose><description><para>
</para></description></method>
<method id="doxygen.a01016_1acd739f39c37f6347d253ae2e2dad1965" name="test_unit_skipped" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name=""><paramtype>const_string</paramtype></parameter></method>
<method id="doxygen.a01016_1a8d243e0a502de3a52d68ca68291cb197" name="priority" specifiers="virtual"><type>int</type><purpose>The priority indicates the order at which this observer is initialized and tore down in the UTF framework. The order is lowest to highest priority. </purpose></method>
</method-group>
<method-group name="Configuration">
<method id="doxygen.a01016_1ab957baa72c0a877b12b2310e52ae5e0f" name="set_stream"><type>void</type><parameter name=""><paramtype>std::ostream &amp;</paramtype></parameter></method>
</method-group>
<method-group name="public member functions">
<method name="test_finish" specifiers="virtual"><type>void</type><purpose>Called after the framework ends executing the test cases. </purpose><description><para><note><para>The call is made with a reversed priority order. </para>
</note>
</para></description></method>
<method name="test_unit_start" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Called before the framework starts executing a test unit. </purpose><description><para>
</para></description></method>
<method name="test_unit_skipped" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>backward compatibility </purpose></method>
<method name="test_unit_timed_out" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Called when the test timed out. </purpose><description><para>This function is called to signal that a test unit (case or suite) timed out. A valid test unit is available through <link linkend="doxygen.a00860_1af4d92cd4e358fd7ccefcfdfaa6d4d5ba">boost::unit_test::framework::current_test_unit</link> </para></description></method>
<method name="test_unit_aborted" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Called when a test unit indicates a fatal error. </purpose><description><para>A fatal error happens when<itemizedlist>
<listitem><para>a strong assertion (with <computeroutput>REQUIRE</computeroutput>) fails, which indicates that the test case cannot continue</para>
</listitem><listitem><para>an unexpected exception is caught by the Boost.Test framework </para>
</listitem></itemizedlist>
</para></description></method>
<method name="assertion_result" specifiers="virtual"><type>void</type><parameter name=""><paramtype>unit_test::assertion_result</paramtype></parameter></method>
<method name="exception_caught" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>execution_exception</classname> const &amp;</paramtype></parameter><purpose>Called when an exception is intercepted. </purpose><description><para>In case an exception is intercepted, this call happens before the call to <link linkend="doxygen.a00956_1a6d6300ce56d310dfd0914822487adb0a">test_unit_aborted</link> in order to log additional data about the exception. </para></description></method>
</method-group>
</class>





</namespace>
</namespace>
</header>
<header id="doxygen.a00755" name="boost/test/results_collector.hpp">
<para>Defines testing result collector components. </para><para>Defines classes for keeping track (test_results) and collecting (results_collector_t) the states of the test units. </para><namespace name="boost">
<namespace name="unit_test">
<class id="doxygen.a01012" name="results_collector_t"><inherit access="public">boost::unit_test::test_observer</inherit><purpose>Collects and combines the test results. </purpose><description><para>This class collects and combines the results of the test unit during the execution of the test tree. The <link linkend="doxygen.a01012_1a338e23e7c34bbc4edc6847bf9f9fdd59">results_collector_t::results()</link> function combines the test results on a subtree of the test tree.</para><para><formalpara><title>See Also:</title><para><link linkend="doxygen.a00956">boost::unit_test::test_observer</link> </para>
</formalpara>
</para></description><method-group name="public member functions">
<method id="doxygen.a01012_1a513abf719834137c40ec7231352504e2" name="test_start" specifiers="virtual"><type>void</type><parameter name=""><paramtype>counter_t</paramtype></parameter><parameter name=""><paramtype>test_unit_id</paramtype></parameter><purpose>Called before the framework starts executing the test cases. </purpose><description><para>
</para></description></method>
<method id="doxygen.a01012_1a1c5da0e6daf9203312a80e02ee934374" name="test_unit_start" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Called before the framework starts executing a test unit. </purpose><description><para>
</para></description></method>
<method id="doxygen.a01012_1a78ff3df39832dd6482856e6a22a589ab" name="test_unit_finish" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name=""><paramtype>unsigned long</paramtype></parameter><purpose>Called at each end of a test unit. </purpose><description><para>
</para></description></method>
<method id="doxygen.a01012_1a2b785d6e673c1e9069935b4d6465f293" name="test_unit_skipped" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name=""><paramtype>const_string</paramtype></parameter></method>
<method id="doxygen.a01012_1aa9377b6c705a83a8831b0cf01f3390cc" name="test_unit_aborted" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Called when a test unit indicates a fatal error. </purpose><description><para>A fatal error happens when<itemizedlist>
<listitem><para>a strong assertion (with <computeroutput>REQUIRE</computeroutput>) fails, which indicates that the test case cannot continue</para>
</listitem><listitem><para>an unexpected exception is caught by the Boost.Test framework </para>
</listitem></itemizedlist>
</para></description></method>
<method id="doxygen.a01012_1a9297aa2326a9a8a030a01fb6e2dfe07b" name="test_unit_timed_out" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Called when the test timed out. </purpose><description><para>This function is called to signal that a test unit (case or suite) timed out. A valid test unit is available through <link linkend="doxygen.a00860_1af4d92cd4e358fd7ccefcfdfaa6d4d5ba">boost::unit_test::framework::current_test_unit</link> </para></description></method>
<method id="doxygen.a01012_1a8c073ea758119073e87fe9522971ab86" name="assertion_result" specifiers="virtual"><type>void</type><parameter name=""><paramtype>unit_test::assertion_result</paramtype></parameter></method>
<method id="doxygen.a01012_1ad7b9dbae123665bc2706b8ca3222aa88" name="exception_caught" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>execution_exception</classname> const &amp;</paramtype></parameter><purpose>Called when an exception is intercepted. </purpose><description><para>In case an exception is intercepted, this call happens before the call to <link linkend="doxygen.a01012_1aa9377b6c705a83a8831b0cf01f3390cc">test_unit_aborted</link> in order to log additional data about the exception. </para></description></method>
<method id="doxygen.a01012_1a31b3b0438c1645630217e88fdc628591" name="priority" specifiers="virtual"><type>int</type><purpose>The priority indicates the order at which this observer is initialized and tore down in the UTF framework. The order is lowest to highest priority. </purpose></method>
<method id="doxygen.a01012_1a338e23e7c34bbc4edc6847bf9f9fdd59" name="results" cv="const"><type><classname>test_results</classname> const &amp;</type><parameter name="tu_id"><paramtype>test_unit_id</paramtype><description><para>id of a test unit </para></description></parameter><purpose>Results access per test unit. </purpose><description><para>
</para></description></method>
<method name="test_finish" specifiers="virtual"><type>void</type><purpose>Called after the framework ends executing the test cases. </purpose><description><para><note><para>The call is made with a reversed priority order. </para>
</note>
</para></description></method>
<method name="test_aborted" specifiers="virtual"><type>void</type><purpose>Called when a critical error is detected. </purpose><description><para>The critical errors are mainly the signals sent by the system and caught by the Boost.Test framework. Since the running binary may be in incoherent/instable state, the test execution is aborted and all remaining tests are discarded.</para><para><note><para>may be called before <link linkend="doxygen.a00956_1a8ebc971fd12c0b1a962788e1e18ca6f8">test_observer::test_unit_finish()</link> </para>
</note>
</para></description></method>
<method name="test_unit_skipped" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>backward compatibility </purpose></method>
</method-group>
</class><class id="doxygen.a01008" name="test_results"><purpose>Collection of attributes constituting test unit results. </purpose><description><para>This class is a collection of attributes describing a test result.</para><para>The attributes presented as public properties on an instance of the class. In addition summary conclusion methods are presented to generate simple answer to pass/fail question </para></description><data-member id="doxygen.a01008_1ad2aaa1146a1dc932d99f2ba12ea6335a" name="p_test_suites"><type>counter_prop</type><purpose>Number of test suites. </purpose></data-member>
<data-member id="doxygen.a01008_1a26e2b8115a4abec2d452778d220ef8c2" name="p_assertions_passed"><type>counter_prop</type><purpose>Number of successful assertions. </purpose></data-member>
<data-member id="doxygen.a01008_1a25f5e2adb828239e15ab54e729ad88d6" name="p_assertions_failed"><type>counter_prop</type><purpose>Number of failing assertions. </purpose></data-member>
<data-member id="doxygen.a01008_1ac23e402227048910c9f64c65bbb82fa1" name="p_warnings_failed"><type>counter_prop</type><purpose>Number of warnings. </purpose></data-member>
<data-member id="doxygen.a01008_1a290c8f92443850535dd4563233d95b21" name="p_expected_failures"><type>counter_prop</type></data-member>
<data-member id="doxygen.a01008_1ac78040cd0f6a3dfc1df3d6b27262206b" name="p_test_cases_passed"><type>counter_prop</type><purpose>Number of successfull test cases. </purpose></data-member>
<data-member id="doxygen.a01008_1a4a22d102203d7119d8079c51b4cf5f66" name="p_test_cases_warned"><type>counter_prop</type><purpose>Number of warnings in test cases. </purpose></data-member>
<data-member id="doxygen.a01008_1a869bd0857b88e0c9671368b68ee1bdfa" name="p_test_cases_failed"><type>counter_prop</type><purpose>Number of failing test cases. </purpose></data-member>
<data-member id="doxygen.a01008_1a4f37027a801aa107839ef61d06dde044" name="p_test_cases_skipped"><type>counter_prop</type><purpose>Number of skipped test cases. </purpose></data-member>
<data-member id="doxygen.a01008_1ac6082db0ddbbb58cab1e1b739c1b3778" name="p_test_cases_aborted"><type>counter_prop</type><purpose>Number of aborted test cases. </purpose></data-member>
<data-member id="doxygen.a01008_1ae2e44aec35ba83502a1f73c7d6fa74a9" name="p_test_cases_timed_out"><type>counter_prop</type><purpose>Number of timed out test cases. </purpose></data-member>
<data-member id="doxygen.a01008_1a40904c4c72806ad201ddcd6821fe79c3" name="p_test_suites_timed_out"><type>counter_prop</type><purpose>Number of timed out test suites. </purpose></data-member>
<data-member id="doxygen.a01008_1a909adac8a602705b0f27ba64c6281788" name="p_duration_microseconds"><type>counter_prop</type><purpose>Duration of the test in microseconds. </purpose></data-member>
<data-member id="doxygen.a01008_1a0c8010b453f5b163f278eb5ad8c4fb89" name="p_aborted"><type>bool_prop</type><purpose>Indicates that the test unit execution has been aborted. </purpose></data-member>
<data-member id="doxygen.a01008_1a26ae45a8a5e0d344449ef3d5eba8b594" name="p_skipped"><type>bool_prop</type><purpose>Indicates that the test unit execution has been skipped. </purpose></data-member>
<data-member id="doxygen.a01008_1a906a7b618410ae8eedf0f7127451d391" name="p_timed_out"><type>bool_prop</type><purpose>Indicates that the test unit has timed out. </purpose></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a01008_1ad4d7f6e9b99d0998b40a00d189dd7302"/>
<method id="doxygen.a01008_1ac09bdea49aedab35e0554a33befafb2e" name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>counter_t</paramtype></parameter><parameter name=""><paramtype>(<classname>results_collector_t</classname>)(<classname>test_results</classname>)(results_collect_helper)</paramtype></parameter><purpose>Type representing counter like public property. </purpose></method>
<method id="doxygen.a01008_1a6016632344cb0bb73b57bd57c4c6398b" name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>bool</paramtype></parameter><parameter name=""><paramtype>(<classname>results_collector_t</classname>)(<classname>test_results</classname>)(results_collect_helper)</paramtype></parameter><purpose>Type representing boolean like public property. </purpose></method>
<method id="doxygen.a01008_1a69ae7404109a776919039123027f3b53" name="passed" cv="const"><type>bool</type><purpose>Returns true if test unit passed. </purpose></method>
<method id="doxygen.a01008_1a57408cee8bd11c62f7abafb13d7ed492" name="skipped" cv="const"><type>bool</type><purpose>Returns true if test unit skipped. </purpose><description><para>For test suites, this indicates if the test suite itself has been marked as skipped, and not if the test suite contains any skipped test. </para></description></method>
<method id="doxygen.a01008_1aa3f098259a9e54839564e9c2b4e56aa8" name="aborted" cv="const"><type>bool</type><purpose>Returns true if the test unit was aborted (hard failure) </purpose></method>
<method id="doxygen.a01008_1a995b9ea3b670d07348a2f21dd77b5591" name="result_code" cv="const"><type>int</type><purpose>Produces result code for the test unit execution. </purpose><description><para>This methhod return one of the result codes defined in <computeroutput>boost/cstdlib.hpp</computeroutput> 
</para></description><returns><para><itemizedlist>
<listitem><para><computeroutput>boost::exit_success</computeroutput> on success,</para>
</listitem><listitem><para><computeroutput>boost::exit_exception_failure</computeroutput> in case test unit was aborted for any reason (including uncaught exception)</para>
</listitem><listitem><para>and <computeroutput>boost::exit_test_failure</computeroutput> otherwise </para>
</listitem></itemizedlist>
</para>
</returns></method>
<method id="doxygen.a01008_1ae952c3912aa34ab6973c342a9ddf6c5e" name="operator+="><type>void</type><parameter name=""><paramtype><classname>test_results</classname> const &amp;</paramtype></parameter><purpose>Combines the results of the current instance with another. </purpose><description><para>Only the counters are updated and the <computeroutput>p_aborted</computeroutput> and <computeroutput>p_skipped</computeroutput> are left unchanged. </para></description></method>
<method id="doxygen.a01008_1a51bca6fd7b5963d05a6a4cb6a510e229" name="clear"><type>void</type><purpose>Resets the current state of the result. </purpose></method>
</method-group>
</class>





</namespace>
</namespace>
</header>
<header id="doxygen.a00752" name="boost/test/results_reporter.hpp">
<para>defines testing result reporter interfaces </para><para>This file defines interfaces that are responsible for results reporting. Interface is presented in a form of free standing function implemented in namespace result_reporter </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="results_reporter">
<class id="doxygen.a01004" name="format"><purpose>Results report formatter interface. </purpose><description><para>This is abstract interface for the report formatter used by results reporter routines. You can define a custom formatter by implementing this interface and setting the formatter using set_format function. This is usually done during test module initialization </para></description><method-group name="public member functions">
<destructor id="doxygen.a01004_1a6dd081934cbc11084e4a8de5209f9121" specifiers="virtual"/>
<method id="doxygen.a01004_1ab1c9e924612f7ba0cdf2665c7b288f8c" name="results_report_start" cv="= 0" specifiers="virtual"><type>void</type><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method id="doxygen.a01004_1a81b86781bfec28e3d4799bd68b6789e7" name="results_report_finish" cv="= 0" specifiers="virtual"><type>void</type><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method id="doxygen.a01004_1a3ebcf64666d12e05cbc950b143785201" name="test_unit_report_start" cv="= 0" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method id="doxygen.a01004_1a853ccfb90d714c001b35eea226261a91" name="test_unit_report_finish" cv="= 0" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
<method id="doxygen.a01004_1ab545282f1e45bb734c7f57dc2486b060" name="do_confirmation_report" cv="= 0" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name="ostr"><paramtype>std::ostream &amp;</paramtype></parameter></method>
</method-group>
</class><free-function-group name="report configuration">
<function id="doxygen.a00865_1a81631af7b80d7f2436e92fac294c9be1" name="set_level"><type>void</type><parameter name="l"><paramtype>report_level</paramtype><description><para>report level </para></description></parameter><purpose>Sets reporting level. </purpose><description><para>There are only four possible levels for results report:<itemizedlist>
<listitem><para>confirmation report (boost::unit_test::CONFIRMATION_REPORT). This report level only produces short confirmation message about test module pass/fail status</para>
</listitem><listitem><para>short report (boost::unit_test::SHORT_REPORT). This report level produces short summary report for failed/passed assertions and test units.</para>
</listitem><listitem><para>detailed report (boost::unit_test::DETAILED_REPORT). This report level produces detailed report per test unit for passed/failed assertions and uncaught exceptions</para>
</listitem><listitem><para>no report (boost::unit_test::NO_REPORT). This report level produces no results report. This is used for test modules running as part of some kind of continues integration framework 
</para>
</listitem></itemizedlist>
</para></description></function>
<function id="doxygen.a00865_1ad1320e7814adabf4a074af0976cf25a9" name="set_stream"><type>void</type><parameter name=""><paramtype>std::ostream &amp;</paramtype></parameter><purpose>Sets output stream for results reporting. </purpose><description><para>By default std::cerr is used. Use this function to set a different stream. The framework refers to the stream by reference, so you need to make sure the stream object lifetime exceeds the testing main scope. </para></description></function>
<function id="doxygen.a00865_1a57cc3450c28bc17f0f696984d5116396" name="set_format"><type>void</type><parameter name="of"><paramtype>output_format</paramtype><description><para>one of the presefined enumeration values for output formats </para></description></parameter><purpose>Sets one of the predefined formats. </purpose><description><para>The framework implements two results report formats:<itemizedlist>
<listitem><para>plain human readable format (boost::unit_test::OF_CLF)</para>
</listitem><listitem><para>XML format (boost::unit_test::OF_XML) 
</para>
</listitem></itemizedlist>
</para></description></function>
<function id="doxygen.a00865_1a0aef835152cb81c4d6d9101b8f36b6a1" name="set_format"><type>void</type><parameter name="f"><paramtype><classname>results_reporter::format</classname> *</paramtype><description><para>pointer to heap allocated instance of custom report formatter class </para></description></parameter><purpose>Sets custom report formatter. </purpose><description><para>The framework takes ownership of the pointer passed as an argument. So this should be a pointer to a heap allocated object 
</para></description></function>
<function id="doxygen.a00865_1a227f587bbb2f43d38eec0c670a4db9ef" name="get_stream"><type>std::ostream &amp;</type><purpose>Access to configured results reporter stream. </purpose><description><para>Use this stream to report additional information abut test module execution </para></description></function>
</free-function-group>
<function id="doxygen.a00865_1a784edc82e7b61b7da889863768a062ed" name="make_report"><type>void</type><parameter name="l"><paramtype>report_level</paramtype><default>INV_REPORT_LEVEL</default></parameter><parameter name=""><paramtype>test_unit_id</paramtype><default>INV_TEST_UNIT_ID</default></parameter></function>
<function id="doxygen.a00865_1a43fa008a506e4f6df312b050069cfa09" name="confirmation_report"><type>void</type><parameter name="id"><paramtype>test_unit_id</paramtype><default>INV_TEST_UNIT_ID</default></parameter></function>
<function id="doxygen.a00865_1a74883544bc983aa3b2231a0a2851df93" name="short_report"><type>void</type><parameter name="id"><paramtype>test_unit_id</paramtype><default>INV_TEST_UNIT_ID</default></parameter></function>
<function id="doxygen.a00865_1ad54a11701d354ebb00f2df6d5405fac9" name="detailed_report"><type>void</type><parameter name="id"><paramtype>test_unit_id</paramtype><default>INV_TEST_UNIT_ID</default></parameter></function>
</namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00725" name="boost/test/tools/assertion_result.hpp">
<para>Enhanced result for test predicate that include message explaining failure. </para><namespace name="boost">
<namespace name="test_tools">
<class id="doxygen.a00948" name="assertion_result"><purpose>Type used for storing the result of an assertion. </purpose><struct id="doxygen.a00952" name="dummy"><method-group name="public member functions">
<method id="doxygen.a00952_1a004e335fbee25e4732e519a5481922ed" name="nonnull"><type>void</type></method>
</method-group>
</struct><method-group name="public member functions">
<constructor id="doxygen.a00948_1ab23f10331b3e3594614e5d38e5f30027"><parameter name="pv_"><paramtype>bool</paramtype></parameter></constructor>
<constructor id="doxygen.a00948_1aa0e01abc67168e5b8b0fb8afacd1a00c"><template>
          <template-type-parameter name="BoolConvertable"/>
        </template><parameter name="pv_"><paramtype>BoolConvertable const &amp;</paramtype></parameter></constructor>
<method id="doxygen.a00948_1a07b617e2e15c47f601a0c10d382d04f6" name="operator!" cv="const"><type>bool</type></method>
<copy-assignment id="doxygen.a00948_1a11ce3a665818e99b64a5da9b41946a27"><type>void</type><parameter name="pv_"><paramtype>bool</paramtype></parameter></copy-assignment>
<method id="doxygen.a00948_1a91bf77b035011a7566dc6a5f71a4f31c" name="conversion-operator" cv="const"><type>safe_bool</type></method>
<method id="doxygen.a00948_1a314557dae41cd4d43518a6abe2e44f15" name="BOOST_READONLY_PROPERTY"><type/><parameter name=""><paramtype>bool</paramtype></parameter><parameter name=""><paramtype>(<classname>assertion_result</classname>)</paramtype></parameter></method>
<method id="doxygen.a00948_1ace61b2a1506bcb2b0f77794e89eaea04" name="has_empty_message" cv="const"><type>bool</type></method>
<method id="doxygen.a00948_1a05c33fc88e978908136494886628e055" name="message"><type>wrap_stringstream &amp;</type></method>
<method id="doxygen.a00948_1a753159b57007aa99fad07a25d5ab7382" name="message" cv="const"><type>const_string</type></method>
</method-group>
</class><typedef id="doxygen.a00862_1a82c3436151101a45512bbc7cc0a26892" name="predicate_result"><type><classname>assertion_result</classname></type></typedef>









</namespace>
</namespace>
</header>
<header id="doxygen.a00836" name="boost/test/tools/detail/bitwise_manip.hpp">
<para>Bitwise comparison manipulator implementation. </para><namespace name="boost">
<namespace name="test_tools">
<struct id="doxygen.a01404" name="bitwise"><purpose>Bitwise comparison manipulator This is a terminal for the expression. </purpose></struct><function id="doxygen.a00862_1aa03c61302954340a969ee16d957d9b11" name="operator&lt;&lt;"><type>unit_test::lazy_ostream &amp;</type><parameter name="o"><paramtype>unit_test::lazy_ostream &amp;</paramtype></parameter><parameter name=""><paramtype><classname>bitwise</classname></paramtype></parameter></function>
<function id="doxygen.a00862_1a2444b6b8f93426fab95ca5514e82897d" name="operator&lt;&lt;"><type>std::ostream &amp;</type><parameter name="o"><paramtype>std::ostream &amp;</paramtype></parameter><parameter name=""><paramtype><classname>bitwise</classname></paramtype></parameter></function>







</namespace>
</namespace>
</header>
<header id="doxygen.a00839" name="boost/test/tools/detail/lexicographic_manip.hpp">
<para>Lexicographic comparison manipulator implementation. </para><namespace name="boost">
<namespace name="test_tools">
<struct id="doxygen.a01408" name="lexicographic"><purpose>Lexicographic comparison manipulator, for containers This is a terminal that involves evaluation of the expression. </purpose></struct>

<function id="doxygen.a00862_1aee7e86626540fa805ea44fe60f9f2ecc" name="operator&lt;&lt;"><type>unit_test::lazy_ostream &amp;</type><parameter name="o"><paramtype>unit_test::lazy_ostream &amp;</paramtype></parameter><parameter name=""><paramtype><classname>lexicographic</classname></paramtype></parameter></function>
<function id="doxygen.a00862_1a6bd3aa06b7cef83b78b08d1179570c93" name="operator&lt;&lt;"><type>std::ostream &amp;</type><parameter name="o"><paramtype>std::ostream &amp;</paramtype></parameter><parameter name=""><paramtype><classname>lexicographic</classname></paramtype></parameter></function>





</namespace>
</namespace>
</header>
<header id="doxygen.a00842" name="boost/test/tools/detail/per_element_manip.hpp">
<para>Per element comparison manipulator implementation. </para><namespace name="boost">
<namespace name="test_tools">
<struct id="doxygen.a01412" name="per_element"><purpose>Per element comparison manipulator, for containers This is a terminal that involves evaluation of the expression. </purpose></struct>



<function id="doxygen.a00862_1a98e7eb95c31743bfc69963ccd588b2ab" name="operator&lt;&lt;"><type>unit_test::lazy_ostream &amp;</type><parameter name="o"><paramtype>unit_test::lazy_ostream &amp;</paramtype></parameter><parameter name=""><paramtype><classname>per_element</classname></paramtype></parameter></function>
<function id="doxygen.a00862_1aa5cab8f8d206adc2185b01940e7bc2d7" name="operator&lt;&lt;"><type>std::ostream &amp;</type><parameter name="o"><paramtype>std::ostream &amp;</paramtype></parameter><parameter name=""><paramtype><classname>per_element</classname></paramtype></parameter></function>



</namespace>
</namespace>
</header>
<header id="doxygen.a00845" name="boost/test/tools/detail/tolerance_manip.hpp">
<para>Floating point comparison tolerance manipulators. </para><para>This file defines several manipulators for floating point comparison. These manipulators are intended to be used with BOOST_TEST. </para><namespace name="boost">
<namespace name="test_tools">






<function id="doxygen.a00862_1aee17fecb420ad95dc8c3911007e7c897" name="tolerance"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="FPT"/>
        </template><parameter name="v"><paramtype>FPT</paramtype></parameter><description><para>Tolerance manipulator</para><para>These functions return a manipulator that can be used in conjunction with BOOST_TEST in order to specify the tolerance with which floating point comparisons are made. </para></description></function>
<function id="doxygen.a00862_1a11cedc107ba9e56887cf909b540dfaf8" name="tolerance"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="FPT"/>
        </template><parameter name="v"><paramtype>fpc::percent_tolerance_t&lt; FPT &gt;</paramtype></parameter></function>
<function id="doxygen.a00862_1a950386f1b28e313daddf7cda2e5a4980" name="tolerance"><type><emphasis>unspecified</emphasis></type></function>
</namespace>
</namespace>
</header>
<header id="doxygen.a00830" name="boost/test/tools/floating_point_comparison.hpp">
<para>algorithms for comparing floating point values </para><namespace name="boost">
<namespace name="math">
<namespace name="fpc">
<class id="doxygen.a01332" name="close_at_tolerance"><template>
      <template-type-parameter name="FPT"/>
    </template><purpose>Predicate for comparing floating point numbers. </purpose><description><para>This predicate is used to compare floating point numbers. In addition the comparison produces maximum related difference, which can be used to generate detailed error message The methods for comparing floating points are detailed in the documentation. The method is chosen by the <link linkend="doxygen.a00881_1ae51e6d0e8d3818c31a3311f5ec2cac67">boost::math::fpc::strength</link> given at construction.</para><para>This predicate is not suitable for comparing to 0 or to infinity. </para></description><typedef id="doxygen.a01332_1a0d1bfaed99908523eefa78bda5ee85bb" name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.a01332_1adec11957fd9deb9b44bc18ce5c64ff58" specifiers="explicit"><template>
          <template-type-parameter name="ToleranceType"/>
        </template><parameter name="tolerance"><paramtype>ToleranceType</paramtype></parameter><parameter name="fpc_strength"><paramtype>fpc::strength</paramtype><default>FPC_STRONG</default></parameter></constructor>
<method id="doxygen.a01332_1a378b828b93688c83adbb7fc05a69a0de" name="fraction_tolerance" cv="const"><type>FPT</type><purpose>Returns the tolerance. </purpose></method>
<method id="doxygen.a01332_1a49c5ca5da9f82d9f78b37cfe5e97cb7d" name="strength" cv="const"><type>fpc::strength</type><purpose>Returns the comparison method. </purpose></method>
<method id="doxygen.a01332_1a46179a3a2b404017a3842c5c15e21e19" name="tested_rel_diff" cv="const"><type>FPT</type><purpose>Returns the failing fraction. </purpose></method>
<method id="doxygen.a01332_1aa14edc3c408509dfa9de182b59f257b3" name="operator()" cv="const"><type>bool</type><parameter name="left"><paramtype>FPT</paramtype><description><para>first floating point number to be compared </para></description></parameter><parameter name="right"><paramtype>FPT</paramtype><description><para>second floating point number to be compared</para></description></parameter><description><para>Compares two floating point numbers a and b such that their "left" relative difference |a-b|/a and/or "right" relative difference |a-b|/b does not exceed specified relative (fraction) tolerance.</para><para>
What is reported by <computeroutput>tested_rel_diff</computeroutput> in case of failure depends on the comparison method:<itemizedlist>
<listitem><para>for <computeroutput>FPC_STRONG:</computeroutput> the max of the two fractions</para>
</listitem><listitem><para>for <computeroutput>FPC_WEAK:</computeroutput> the min of the two fractions The rationale behind is to report the tolerance to set in order to make a test pass. </para>
</listitem></itemizedlist>
</para></description></method>
</method-group>
</class><class id="doxygen.a01304" name="is_abstract_class_or_function"><template>
      <template-type-parameter name="T"/>
    </template><data-member id="doxygen.a01304_1a5bc1e226f8fdccc699a7a39672a891d2" name="value" specifiers="static"><type>const bool</type></data-member>
<method-group name="private static functions">
<method id="doxygen.a01304_1a6d08de90c96e24b6d14cec88c5063979" name="test" specifiers="static"><type>char</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name=""><paramtype>U(*)</paramtype></parameter></method>
<method id="doxygen.a01304_1abd5274d89734d1bc7870e38a032b3c4d" name="test" specifiers="static"><type>Two</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name=""><paramtype>...</paramtype></parameter></method>
</method-group>
</class><struct id="doxygen.a01316" name="percent_tolerance_t"><template>
      <template-type-parameter name="FPT"/>
    </template><data-member id="doxygen.a01316_1aba0fea9f5e4ab72fd87ea44fc4bf34c9" name="m_value"><type>FPT</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a01316_1a42b07d915cab595f201aec0a20ae3ba4" specifiers="explicit"><parameter name="v"><paramtype>FPT</paramtype></parameter></constructor>
</method-group>
</struct><class id="doxygen.a01336" name="small_with_tolerance"><template>
      <template-type-parameter name="FPT"/>
    </template><purpose>Predicate for comparing floating point numbers against 0. </purpose><description><para>Serves the same purpose as <link linkend="doxygen.a01332">boost::math::fpc::close_at_tolerance</link>, but used when one of the operand is null. </para></description><typedef id="doxygen.a01336_1a628e53dea0e421672e24051b66459e77" name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.a01336_1a313a1a2e9fdc6358c905d24223f4649b" specifiers="explicit"><parameter name="tolerance"><paramtype>FPT</paramtype></parameter></constructor>
<method id="doxygen.a01336_1a2f6b77c8e81e15d8e685fe9f54387dd9" name="operator()" cv="const"><type>bool</type><parameter name="fpv"><paramtype>FPT</paramtype></parameter></method>
</method-group>
</class><struct id="doxygen.a01312" name="tolerance_based"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">tolerance_based_delegate::type</inherit><purpose>Indicates if a type can be compared using a tolerance scheme. </purpose><description><para>This is a metafunction that should evaluate to <computeroutput>mpl::true_</computeroutput> if the type <computeroutput>T</computeroutput> can be compared using a tolerance based method, typically for floating point types.</para><para>This metafunction can be specialized further to declare user types that are floating point (eg. boost.multiprecision). </para></description></struct><struct id="doxygen.a01296" name="tolerance_based_delegate"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="enabled"><type>bool</type></template-nontype-parameter>
    </template></struct><struct-specialization id="doxygen.a01300" name="tolerance_based_delegate"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>false</template-arg></specialization><inherit access="public">mpl::false_</inherit></struct-specialization><struct-specialization id="doxygen.a01308" name="tolerance_based_delegate"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>true</template-arg></specialization><inherit access="public">mpl::bool_&lt; is_floating_point&lt; T &gt;::value||(!std::numeric_limits&lt; T &gt;::is_integer &amp;&amp;std::numeric_limits&lt; T &gt;::is_specialized &amp;&amp;!std::numeric_limits&lt; T &gt;::is_exact)&gt;</inherit></struct-specialization><enum id="doxygen.a00881_1ae51e6d0e8d3818c31a3311f5ec2cac67" name="strength"><enumvalue id="doxygen.a00881_1ae51e6d0e8d3818c31a3311f5ec2cac67af43646357d2190e62d7faba1ad6fc2eb" name="FPC_STRONG"><purpose>"Very close" - equation 2' in docs, the default </purpose></enumvalue><enumvalue id="doxygen.a00881_1ae51e6d0e8d3818c31a3311f5ec2cac67a409b5c7fa0bc897ec1afcbed2d6750ff" name="FPC_WEAK"><purpose>"Close enough" - equation 3' in docs. </purpose></enumvalue><purpose>Method for comparing floating point numbers. </purpose></enum>
<function id="doxygen.a00881_1acba1a3888a2c1ae4bcf079bb25761350" name="operator&lt;&lt;"><type>std::ostream &amp;</type><template>
          <template-type-parameter name="FPT"/>
        </template><parameter name="out"><paramtype>std::ostream &amp;</paramtype></parameter><parameter name="t"><paramtype><classname>percent_tolerance_t</classname>&lt; FPT &gt;</paramtype></parameter></function>
<function id="doxygen.a00881_1a31daa7da6bb8b7f9b0d22000ba4964d7" name="percent_tolerance"><type><classname>percent_tolerance_t</classname>&lt; FPT &gt;</type><template>
          <template-type-parameter name="FPT"/>
        </template><parameter name="v"><paramtype>FPT</paramtype></parameter></function>
<function id="doxygen.a00881_1a64753ae54f51e658ad44506931f80a14" name="is_small"><type>bool</type><template>
          <template-type-parameter name="FPT"/>
        </template><parameter name="fpv"><paramtype>FPT</paramtype></parameter><parameter name="tolerance"><paramtype>FPT</paramtype></parameter></function>
</namespace>
</namespace>
</namespace>
</header>
<header id="doxygen.a00767" name="boost/test/tools/output_test_stream.hpp">
<para>output_test_stream class definition </para><namespace name="boost">
<namespace name="test_tools">
<class id="doxygen.a01052" name="output_test_stream"><inherit access="public">wrap_stringstream::wrapped_stream</inherit><purpose>Class to be used to simplify testing of ostream-based output operations. </purpose><method-group name="public member functions">
<constructor id="doxygen.a01052_1af6a2f4f0edbb626cfa45b1fa4e1a3bed" specifiers="explicit"><parameter name="pattern_file_name"><paramtype>const_string</paramtype><default>const_string()</default><description><para>indicates the name of the file for matching. If the string is empty, the standard input or output streams are used instead (depending on match_or_save) </para></description></parameter><parameter name="match_or_save"><paramtype>bool</paramtype><default>true</default><description><para>if true, the pattern file will be read, otherwise it will be written </para></description></parameter><parameter name="text_or_binary"><paramtype>bool</paramtype><default>true</default><description><para>if false, opens the stream in binary mode. Otherwise the stream is opened with default flags and the carriage returns are ignored. </para></description></parameter><purpose>Constructor. </purpose><description><para>
</para></description></constructor>
<destructor id="doxygen.a01052_1a019fdeb456018a49c2693516141def99"/>
<method id="doxygen.a01052_1a97a2ba1eb67c897601a3e77ee38d6845" name="is_empty" specifiers="virtual"><type><classname>assertion_result</classname></type><parameter name="flush_stream"><paramtype>bool</paramtype><default>true</default><description><para>if true, flushes the stream after the call </para></description></parameter><purpose>Checks if the stream is empty. </purpose><description><para>
</para></description></method>
<method id="doxygen.a01052_1a87713f96fdb0adae16981c7b301406cf" name="check_length" specifiers="virtual"><type><classname>assertion_result</classname></type><parameter name="length"><paramtype>std::size_t</paramtype><description><para>target length </para></description></parameter><parameter name="flush_stream"><paramtype>bool</paramtype><default>true</default><description><para>if true, flushes the stream after the call. Set to false to call additional checks on the same content. </para></description></parameter><purpose>Checks the length of the stream. </purpose><description><para>
</para></description></method>
<method id="doxygen.a01052_1a4ea91cfebcb1a4e47fb17a0ce81e3a5a" name="is_equal" specifiers="virtual"><type><classname>assertion_result</classname></type><parameter name="arg_"><paramtype>const_string</paramtype><description><para>the target stream </para></description></parameter><parameter name="flush_stream"><paramtype>bool</paramtype><default>true</default><description><para>if true, flushes the stream after the call. </para></description></parameter><purpose>Checks the content of the stream against a string. </purpose><description><para>
</para></description></method>
<method id="doxygen.a01052_1a49e9cd8a93aa13207dd5e4209268220a" name="match_pattern" specifiers="virtual"><type><classname>assertion_result</classname></type><parameter name="flush_stream"><paramtype>bool</paramtype><default>true</default><description><para>if true, flushes/resets the stream after the call. </para></description></parameter><purpose>Checks the content of the stream against a pattern file. </purpose><description><para>
</para></description></method>
<method id="doxygen.a01052_1a3ad3b690b7cd00bfb28e7b6eee9a533e" name="flush"><type>void</type><purpose>Flushes the stream. </purpose></method>
</method-group>
<method-group name="protected member functions">
<method id="doxygen.a01052_1a138739109ff4fe4adb9347a4c12b1a89" name="get_stream_string_representation" cv="const" specifiers="virtual"><type>std::string</type><purpose>Returns the string representation of the stream. </purpose><description><para>May be overriden in order to mutate the string before the matching operations. </para></description></method>
</method-group>
<method-group name="private member functions">
<method id="doxygen.a01052_1aa1a4c212d8db73ee3cb3fe80bb2d60ce" name="length"><type>std::size_t</type><purpose>Length of the stream. </purpose></method>
<method id="doxygen.a01052_1aed11e87850b4446716106721af23edac" name="sync" specifiers="virtual"><type>void</type><purpose>Synching the stream into an internal string representation. </purpose></method>
</method-group>
</class>








</namespace>
</namespace>
</header>
<header id="doxygen.a00731" name="boost/test/tree/observer.hpp">
<para>defines abstract interface for test observer </para><namespace name="boost">
<namespace name="unit_test">
<class id="doxygen.a00956" name="test_observer"><purpose>Generic test observer interface. </purpose><description><para>This interface is used by observers in order to receive notifications from the Boost.Test framework on the current execution state.</para><para>Several observers can be running at the same time, and it is not unusual to have interactions among them. The <link linkend="doxygen.a00956_1abaff2808176931cea89011b0a6c185b5">test_observer::priority</link> member function allows the specification of a particular order among them (lowest priority executed first, except specified otherwise). </para></description><method-group name="public member functions">
<method id="doxygen.a00956_1a6119266038e5cce55f68e015b4bd83a6" name="test_start" specifiers="virtual"><type>void</type><parameter name=""><paramtype>counter_t</paramtype></parameter><parameter name=""><paramtype>test_unit_id</paramtype></parameter><purpose>Called before the framework starts executing the test cases. </purpose><description><para>
</para></description></method>
<method id="doxygen.a00956_1a9b31e3b88415413c9606096c7fef98d4" name="test_finish" specifiers="virtual"><type>void</type><purpose>Called after the framework ends executing the test cases. </purpose><description><para><note><para>The call is made with a reversed priority order. </para>
</note>
</para></description></method>
<method id="doxygen.a00956_1a2b091fcb5d50e56c5301251b1123b056" name="test_aborted" specifiers="virtual"><type>void</type><purpose>Called when a critical error is detected. </purpose><description><para>The critical errors are mainly the signals sent by the system and caught by the Boost.Test framework. Since the running binary may be in incoherent/instable state, the test execution is aborted and all remaining tests are discarded.</para><para><note><para>may be called before <link linkend="doxygen.a00956_1a8ebc971fd12c0b1a962788e1e18ca6f8">test_observer::test_unit_finish()</link> </para>
</note>
</para></description></method>
<method id="doxygen.a00956_1a9cc84abde5438c7d6612cfae97916ee9" name="test_unit_start" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Called before the framework starts executing a test unit. </purpose><description><para>
</para></description></method>
<method id="doxygen.a00956_1a8ebc971fd12c0b1a962788e1e18ca6f8" name="test_unit_finish" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name=""><paramtype>unsigned long</paramtype></parameter><purpose>Called at each end of a test unit. </purpose><description><para>
</para></description></method>
<method id="doxygen.a00956_1a1700215d89b65eb4abed2d87a93a7f28" name="test_unit_skipped" specifiers="virtual"><type>void</type><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name=""><paramtype>const_string</paramtype></parameter></method>
<method id="doxygen.a00956_1abaa8d394132e32df6fb5fbd81136af03" name="test_unit_skipped" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>backward compatibility </purpose></method>
<method id="doxygen.a00956_1a4b1e92df0c418ab87e2e6b5c5eb94a8c" name="test_unit_timed_out" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Called when the test timed out. </purpose><description><para>This function is called to signal that a test unit (case or suite) timed out. A valid test unit is available through <link linkend="doxygen.a00860_1af4d92cd4e358fd7ccefcfdfaa6d4d5ba">boost::unit_test::framework::current_test_unit</link> </para></description></method>
<method id="doxygen.a00956_1a6d6300ce56d310dfd0914822487adb0a" name="test_unit_aborted" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Called when a test unit indicates a fatal error. </purpose><description><para>A fatal error happens when<itemizedlist>
<listitem><para>a strong assertion (with <computeroutput>REQUIRE</computeroutput>) fails, which indicates that the test case cannot continue</para>
</listitem><listitem><para>an unexpected exception is caught by the Boost.Test framework </para>
</listitem></itemizedlist>
</para></description></method>
<method id="doxygen.a00956_1af821c91a3134c5ce5ab4323fd5eb9bbb" name="assertion_result" specifiers="virtual"><type>void</type><parameter name=""><paramtype>unit_test::assertion_result</paramtype></parameter></method>
<method id="doxygen.a00956_1aaa0e46c1e67b57ffa9cb7edf59231a81" name="exception_caught" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>execution_exception</classname> const &amp;</paramtype></parameter><purpose>Called when an exception is intercepted. </purpose><description><para>In case an exception is intercepted, this call happens before the call to <link linkend="doxygen.a00956_1a6d6300ce56d310dfd0914822487adb0a">test_unit_aborted</link> in order to log additional data about the exception. </para></description></method>
<method id="doxygen.a00956_1abaff2808176931cea89011b0a6c185b5" name="priority" specifiers="virtual"><type>int</type><purpose>The priority indicates the order at which this observer is initialized and tore down in the UTF framework. The order is lowest to highest priority. </purpose></method>
</method-group>
<method-group name="protected member functions">
<destructor id="doxygen.a00956_1a8ebd3705a16ad8f6c108505fa41d3029"/>
</method-group>
</class>





</namespace>
</namespace>
</header>
<header id="doxygen.a00761" name="boost/test/tree/test_unit.hpp">
<para>Defines <link linkend="doxygen.a01020">test_unit</link>, <link linkend="doxygen.a01028">test_case</link>, <link linkend="doxygen.a01032">test_suite</link> and <link linkend="doxygen.a01036">master_test_suite_t</link>. </para><namespace name="boost">
<namespace name="unit_test">
<class id="doxygen.a01036" name="master_test_suite_t"><inherit access="public">boost::unit_test::test_suite</inherit><data-member id="doxygen.a01036_1a612e033cb8fb6b69592481bac2be9421" name="argc"><type>int</type></data-member>
<data-member id="doxygen.a01036_1a5fd0237ee7669347def4dbb51ef69631" name="argv"><type>char **</type></data-member>
<data-member name="p_type"><type>test_unit_type const</type><purpose>type for this test unit </purpose></data-member>
<data-member name="p_type_name"><type>const_string const</type><purpose>"case"/"suite"/"module" </purpose></data-member>
<data-member name="p_file_name"><type>const_string const</type></data-member>
<data-member name="p_line_num"><type>std::size_t const</type></data-member>
<data-member name="p_id"><type>id_t</type><purpose>unique id for this test unit </purpose></data-member>
<data-member name="p_parent_id"><type>parent_id_t</type><purpose>parent test suite id </purpose></data-member>
<data-member name="p_labels"><type>label_list_t</type><purpose>list of labels associated with this test unit </purpose></data-member>
<data-member name="p_dependencies"><type>id_list_t</type><purpose>list of test units this one depends on </purpose></data-member>
<data-member name="p_preconditions"><type>precond_list_t</type><purpose>user supplied preconditions for this test unit; </purpose></data-member>
<data-member name="p_name"><type>readwrite_property&lt; std::string &gt;</type><purpose>name for this test unit </purpose></data-member>
<data-member name="p_description"><type>readwrite_property&lt; std::string &gt;</type><purpose>description for this test unit </purpose></data-member>
<data-member name="p_timeout"><type>readwrite_property&lt; unsigned &gt;</type><purpose>timeout for the test unit execution in seconds </purpose></data-member>
<data-member name="p_expected_failures"><type>readwrite_property&lt; counter_t &gt;</type><purpose>number of expected failures in this test unit </purpose></data-member>
<data-member name="p_default_status"><type>readwrite_property&lt; run_status &gt;</type><purpose>run status obtained by this unit during setup phase </purpose></data-member>
<data-member name="p_run_status"><type>readwrite_property&lt; run_status &gt;</type><purpose>run status assigned to this unit before execution phase after applying all filters </purpose></data-member>
<data-member name="p_sibling_rank"><type>readwrite_property&lt; counter_t &gt;</type><purpose>rank of this test unit amoung siblings of the same parent </purpose></data-member>
<data-member name="p_decorators"><type>readwrite_property&lt; decor_list_t &gt;</type><purpose>automatically assigned decorators; execution is delayed till <link linkend="doxygen.a00860_1a6a95564b913ee2b951073568f222762f">framework::finalize_setup_phase</link> function </purpose></data-member>
<data-member name="p_fixtures"><type>readwrite_property&lt; fixture_list_t &gt;</type><purpose>fixtures associated with this test unit </purpose></data-member>
<method-group name="private member functions">
<constructor id="doxygen.a01036_1a049b79d172261901e52eb44bc1f1993a"/>
<constructor id="doxygen.a01036_1a35760f7e195831a3bc6763505ef381c4"><parameter name=""><paramtype>const <classname>master_test_suite_t</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment id="doxygen.a01036_1a5cabf1fe8eb5ac1e04dfab966839a4b0"><type><classname>master_test_suite_t</classname> &amp;</type><parameter name=""><paramtype><classname>master_test_suite_t</classname> const &amp;</paramtype></parameter></copy-assignment>
</method-group>
<enum name=""><enumvalue name="type"><default>TUT_SUITE</default></enumvalue></enum>
<enum name=""><enumvalue name="type"><default>TUT_ANY</default></enumvalue></enum>
<enum name="run_status"><enumvalue name="RS_DISABLED"/><enumvalue name="RS_ENABLED"/><enumvalue name="RS_INHERIT"/><enumvalue name="RS_INVALID"/></enum>
<typedef name="id_list"><type>std::vector&lt; test_unit_id &gt;</type></typedef>
<typedef name="fixture_list_t"><type>std::vector&lt; test_unit_fixture_ptr &gt;</type></typedef>
<typedef name="decor_list_t"><type>std::vector&lt; decorator::base_ptr &gt;</type></typedef>
<typedef name="precondition_t"><type>boost::function&lt; <classname>test_tools::assertion_result</classname>(test_unit_id)&gt;</type></typedef>
<method-group name="public member functions">
<method name="add"><type>void</type><parameter name="tu"><paramtype><classname>test_unit</classname> *</paramtype></parameter><parameter name="expected_failures"><paramtype>counter_t</paramtype><default>0</default></parameter><parameter name="timeout"><paramtype>unsigned</paramtype><default>0</default></parameter><purpose>Adds a test unit to a test suite. </purpose><description><para>It is possible to specify the timeout and the expected failures. </para></description></method>
<method name="add"><type>void</type><parameter name="gen"><paramtype><classname>test_unit_generator</classname> const &amp;</paramtype></parameter><parameter name="timeout"><paramtype>unsigned</paramtype><default>0</default></parameter><purpose>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </purpose></method>
<method name="add"><type>void</type><parameter name="gen"><paramtype><classname>test_unit_generator</classname> const &amp;</paramtype></parameter><parameter name="decorators"><paramtype>decorator::collector_t &amp;</paramtype></parameter><purpose>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </purpose></method>
<method name="add"><type>void</type><parameter name="gen_ptr"><paramtype>boost::shared_ptr&lt; <classname>test_unit_generator</classname> &gt;</paramtype></parameter><parameter name="decorators"><paramtype>decorator::collector_t &amp;</paramtype></parameter><purpose>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </purpose></method>
<method name="remove"><type>void</type><parameter name="id"><paramtype>test_unit_id</paramtype></parameter><purpose>Removes a test from the test suite. </purpose></method>
<method name="generate"><type>void</type><purpose>Generates all the delayed test_units from the generators. </purpose></method>
<method name="check_for_duplicate_test_cases"><type>void</type><purpose>Check for duplicates name in test cases. </purpose><description><para>Raises a setup_error if there are duplicates </para></description></method>
<method name="get" cv="const"><type>test_unit_id</type><parameter name="tu_name"><paramtype>const_string</paramtype></parameter></method>
<method name="size" cv="const"><type>std::size_t</type></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>test_unit_id</paramtype></parameter><parameter name=""><paramtype>(framework::state)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>test_unit_id</paramtype></parameter><parameter name=""><paramtype>(<classname>test_suite</classname>)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>id_list</paramtype></parameter><parameter name=""><paramtype>(<classname>test_unit</classname>)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>std::vector&lt; std::string &gt;</paramtype></parameter><parameter name=""><paramtype>(<classname>test_unit</classname>)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>std::vector&lt; precondition_t &gt;</paramtype></parameter><parameter name=""><paramtype>(<classname>test_unit</classname>)</paramtype></parameter></method>
<method name="depends_on"><type>void</type><parameter name="tu"><paramtype><classname>test_unit</classname> *</paramtype></parameter></method>
<method name="add_precondition"><type>void</type><parameter name=""><paramtype>precondition_t const &amp;</paramtype></parameter></method>
<method name="check_preconditions" cv="const"><type><classname>test_tools::assertion_result</classname></type></method>
<method name="add_label"><type>void</type><parameter name="l"><paramtype>const_string</paramtype></parameter></method>
<method name="has_label" cv="const"><type>bool</type><parameter name="l"><paramtype>const_string</paramtype></parameter></method>
<method name="increase_exp_fail"><type>void</type><parameter name="num"><paramtype>counter_t</paramtype></parameter></method>
<method name="is_enabled" cv="const"><type>bool</type></method>
<method name="full_name" cv="const"><type>std::string</type></method>
</method-group>
</class><class id="doxygen.a01028" name="test_case"><inherit access="public">boost::unit_test::test_unit</inherit><enum id="doxygen.a01028_1af39d1a6ac66315d309b468b569df7a89" name=""><enumvalue id="doxygen.a01028_1af39d1a6ac66315d309b468b569df7a89af931981cdcdd6c3e294ae51a4a504560" name="type"><default>TUT_CASE</default></enumvalue></enum>
<enum name=""><enumvalue name="type"><default>TUT_ANY</default></enumvalue></enum>
<enum name="run_status"><enumvalue name="RS_DISABLED"/><enumvalue name="RS_ENABLED"/><enumvalue name="RS_INHERIT"/><enumvalue name="RS_INVALID"/></enum>
<typedef name="id_list"><type>std::vector&lt; test_unit_id &gt;</type></typedef>
<typedef name="fixture_list_t"><type>std::vector&lt; test_unit_fixture_ptr &gt;</type></typedef>
<typedef name="decor_list_t"><type>std::vector&lt; decorator::base_ptr &gt;</type></typedef>
<typedef name="precondition_t"><type>boost::function&lt; <classname>test_tools::assertion_result</classname>(test_unit_id)&gt;</type></typedef>
<data-member id="doxygen.a01028_1a876a41cfd7676ab0f0e8b30a00118d64" name="p_test_func"><type>test_func</type></data-member>
<data-member name="p_type"><type>test_unit_type const</type><purpose>type for this test unit </purpose></data-member>
<data-member name="p_type_name"><type>const_string const</type><purpose>"case"/"suite"/"module" </purpose></data-member>
<data-member name="p_file_name"><type>const_string const</type></data-member>
<data-member name="p_line_num"><type>std::size_t const</type></data-member>
<data-member name="p_id"><type>id_t</type><purpose>unique id for this test unit </purpose></data-member>
<data-member name="p_parent_id"><type>parent_id_t</type><purpose>parent test suite id </purpose></data-member>
<data-member name="p_labels"><type>label_list_t</type><purpose>list of labels associated with this test unit </purpose></data-member>
<data-member name="p_dependencies"><type>id_list_t</type><purpose>list of test units this one depends on </purpose></data-member>
<data-member name="p_preconditions"><type>precond_list_t</type><purpose>user supplied preconditions for this test unit; </purpose></data-member>
<data-member name="p_name"><type>readwrite_property&lt; std::string &gt;</type><purpose>name for this test unit </purpose></data-member>
<data-member name="p_description"><type>readwrite_property&lt; std::string &gt;</type><purpose>description for this test unit </purpose></data-member>
<data-member name="p_timeout"><type>readwrite_property&lt; unsigned &gt;</type><purpose>timeout for the test unit execution in seconds </purpose></data-member>
<data-member name="p_expected_failures"><type>readwrite_property&lt; counter_t &gt;</type><purpose>number of expected failures in this test unit </purpose></data-member>
<data-member name="p_default_status"><type>readwrite_property&lt; run_status &gt;</type><purpose>run status obtained by this unit during setup phase </purpose></data-member>
<data-member name="p_run_status"><type>readwrite_property&lt; run_status &gt;</type><purpose>run status assigned to this unit before execution phase after applying all filters </purpose></data-member>
<data-member name="p_sibling_rank"><type>readwrite_property&lt; counter_t &gt;</type><purpose>rank of this test unit amoung siblings of the same parent </purpose></data-member>
<data-member name="p_decorators"><type>readwrite_property&lt; decor_list_t &gt;</type><purpose>automatically assigned decorators; execution is delayed till <link linkend="doxygen.a00860_1a6a95564b913ee2b951073568f222762f">framework::finalize_setup_phase</link> function </purpose></data-member>
<data-member name="p_fixtures"><type>readwrite_property&lt; fixture_list_t &gt;</type><purpose>fixtures associated with this test unit </purpose></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a01028_1a27ba5bb23034a002a8c79b120bb3b70d"><parameter name="tc_name"><paramtype>const_string</paramtype></parameter><parameter name="test_func"><paramtype>boost::function&lt; void()&gt; const &amp;</paramtype></parameter></constructor>
<constructor id="doxygen.a01028_1a0101500fd694ee0e987aabbfbc369860"><parameter name="tc_name"><paramtype>const_string</paramtype></parameter><parameter name="tc_file"><paramtype>const_string</paramtype></parameter><parameter name="tc_line"><paramtype>std::size_t</paramtype></parameter><parameter name="test_func"><paramtype>boost::function&lt; void()&gt; const &amp;</paramtype></parameter></constructor>
<method id="doxygen.a01028_1a6bca46a974a1eb01f683123b586b289b" name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>boost::function&lt; void()&gt;</paramtype></parameter><parameter name=""><paramtype>(<classname>test_case</classname>)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>test_unit_id</paramtype></parameter><parameter name=""><paramtype>(framework::state)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>test_unit_id</paramtype></parameter><parameter name=""><paramtype>(<classname>test_suite</classname>)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>id_list</paramtype></parameter><parameter name=""><paramtype>(<classname>test_unit</classname>)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>std::vector&lt; std::string &gt;</paramtype></parameter><parameter name=""><paramtype>(<classname>test_unit</classname>)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>std::vector&lt; precondition_t &gt;</paramtype></parameter><parameter name=""><paramtype>(<classname>test_unit</classname>)</paramtype></parameter></method>
<method name="depends_on"><type>void</type><parameter name="tu"><paramtype><classname>test_unit</classname> *</paramtype></parameter></method>
<method name="add_precondition"><type>void</type><parameter name=""><paramtype>precondition_t const &amp;</paramtype></parameter></method>
<method name="check_preconditions" cv="const"><type><classname>test_tools::assertion_result</classname></type></method>
<method name="add_label"><type>void</type><parameter name="l"><paramtype>const_string</paramtype></parameter></method>
<method name="has_label" cv="const"><type>bool</type><parameter name="l"><paramtype>const_string</paramtype></parameter></method>
<method name="increase_exp_fail"><type>void</type><parameter name="num"><paramtype>counter_t</paramtype></parameter></method>
<method name="is_enabled" cv="const"><type>bool</type></method>
<method name="full_name" cv="const"><type>std::string</type></method>
</method-group>
<method-group name="private member functions">
<destructor id="doxygen.a01028_1aecd12128e45bd7250ffef8773d9afd94"/>
</method-group>
</class><class id="doxygen.a01032" name="test_suite"><inherit access="public">boost::unit_test::test_unit</inherit><purpose>Class representing test suites. </purpose><enum id="doxygen.a01032_1a1024237889f124c9b416ab065f55833d" name=""><enumvalue id="doxygen.a01032_1a1024237889f124c9b416ab065f55833da54df3525c054603f277b140a7a3ea3f1" name="type"><default>TUT_SUITE</default></enumvalue></enum>
<enum name=""><enumvalue name="type"><default>TUT_ANY</default></enumvalue></enum>
<enum name="run_status"><enumvalue name="RS_DISABLED"/><enumvalue name="RS_ENABLED"/><enumvalue name="RS_INHERIT"/><enumvalue name="RS_INVALID"/></enum>
<typedef name="id_list"><type>std::vector&lt; test_unit_id &gt;</type></typedef>
<typedef name="fixture_list_t"><type>std::vector&lt; test_unit_fixture_ptr &gt;</type></typedef>
<typedef name="decor_list_t"><type>std::vector&lt; decorator::base_ptr &gt;</type></typedef>
<typedef name="precondition_t"><type>boost::function&lt; <classname>test_tools::assertion_result</classname>(test_unit_id)&gt;</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.a01032_1a315cfb054a792b27b2738008f8a4affe" specifiers="explicit"><parameter name="ts_name"><paramtype>const_string</paramtype></parameter><parameter name="ts_file"><paramtype>const_string</paramtype></parameter><parameter name="ts_line"><paramtype>std::size_t</paramtype></parameter></constructor>
<method id="doxygen.a01032_1a5ec4beee618e9144d2dbed66db25f2a7" name="add"><type>void</type><parameter name="tu"><paramtype><classname>test_unit</classname> *</paramtype></parameter><parameter name="expected_failures"><paramtype>counter_t</paramtype><default>0</default></parameter><parameter name="timeout"><paramtype>unsigned</paramtype><default>0</default></parameter><purpose>Adds a test unit to a test suite. </purpose><description><para>It is possible to specify the timeout and the expected failures. </para></description></method>
<method id="doxygen.a01032_1a5ffd460aeaddb2f6ce60fb847e84e1e0" name="add"><type>void</type><parameter name="gen"><paramtype><classname>test_unit_generator</classname> const &amp;</paramtype></parameter><parameter name="timeout"><paramtype>unsigned</paramtype><default>0</default></parameter><purpose>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </purpose></method>
<method id="doxygen.a01032_1ac30ffb2913d25e5ff14e76653728ea68" name="add"><type>void</type><parameter name="gen"><paramtype><classname>test_unit_generator</classname> const &amp;</paramtype></parameter><parameter name="decorators"><paramtype>decorator::collector_t &amp;</paramtype></parameter><purpose>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </purpose></method>
<method id="doxygen.a01032_1aa7a3dc8ce931ede367c2fa78b40bc450" name="add"><type>void</type><parameter name="gen_ptr"><paramtype>boost::shared_ptr&lt; <classname>test_unit_generator</classname> &gt;</paramtype></parameter><parameter name="decorators"><paramtype>decorator::collector_t &amp;</paramtype></parameter><purpose>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </purpose></method>
<method id="doxygen.a01032_1aea6914423983bd2345fa6810cad4e631" name="remove"><type>void</type><parameter name="id"><paramtype>test_unit_id</paramtype></parameter><purpose>Removes a test from the test suite. </purpose></method>
<method id="doxygen.a01032_1a843e4711135ca677b1ee3966d1f8271f" name="generate"><type>void</type><purpose>Generates all the delayed test_units from the generators. </purpose></method>
<method id="doxygen.a01032_1a241319e966e3ab5b96499047ea0761d4" name="check_for_duplicate_test_cases"><type>void</type><purpose>Check for duplicates name in test cases. </purpose><description><para>Raises a setup_error if there are duplicates </para></description></method>
<method id="doxygen.a01032_1a264e3a119902cd131f71a6c915c5b08c" name="get" cv="const"><type>test_unit_id</type><parameter name="tu_name"><paramtype>const_string</paramtype></parameter></method>
<method id="doxygen.a01032_1a55dff8abb15d08760801daf31d7ca4af" name="size" cv="const"><type>std::size_t</type></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>test_unit_id</paramtype></parameter><parameter name=""><paramtype>(framework::state)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>test_unit_id</paramtype></parameter><parameter name=""><paramtype>(<classname>test_suite</classname>)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>id_list</paramtype></parameter><parameter name=""><paramtype>(<classname>test_unit</classname>)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>std::vector&lt; std::string &gt;</paramtype></parameter><parameter name=""><paramtype>(<classname>test_unit</classname>)</paramtype></parameter></method>
<method name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>std::vector&lt; precondition_t &gt;</paramtype></parameter><parameter name=""><paramtype>(<classname>test_unit</classname>)</paramtype></parameter></method>
<method name="depends_on"><type>void</type><parameter name="tu"><paramtype><classname>test_unit</classname> *</paramtype></parameter></method>
<method name="add_precondition"><type>void</type><parameter name=""><paramtype>precondition_t const &amp;</paramtype></parameter></method>
<method name="check_preconditions" cv="const"><type><classname>test_tools::assertion_result</classname></type></method>
<method name="add_label"><type>void</type><parameter name="l"><paramtype>const_string</paramtype></parameter></method>
<method name="has_label" cv="const"><type>bool</type><parameter name="l"><paramtype>const_string</paramtype></parameter></method>
<method name="increase_exp_fail"><type>void</type><parameter name="num"><paramtype>counter_t</paramtype></parameter></method>
<method name="is_enabled" cv="const"><type>bool</type></method>
<method name="full_name" cv="const"><type>std::string</type></method>
</method-group>
<method-group name="protected member functions">
<constructor id="doxygen.a01032_1ae456513c21f7d9337327edda6f5aa13f" specifiers="explicit"><parameter name="module_name"><paramtype>const_string</paramtype></parameter></constructor>
<destructor id="doxygen.a01032_1ae9cdbf1d311e41ae1781194a39bdf654" specifiers="virtual"/>
</method-group>
<data-member name="p_type"><type>test_unit_type const</type><purpose>type for this test unit </purpose></data-member>
<data-member name="p_type_name"><type>const_string const</type><purpose>"case"/"suite"/"module" </purpose></data-member>
<data-member name="p_file_name"><type>const_string const</type></data-member>
<data-member name="p_line_num"><type>std::size_t const</type></data-member>
<data-member name="p_id"><type>id_t</type><purpose>unique id for this test unit </purpose></data-member>
<data-member name="p_parent_id"><type>parent_id_t</type><purpose>parent test suite id </purpose></data-member>
<data-member name="p_labels"><type>label_list_t</type><purpose>list of labels associated with this test unit </purpose></data-member>
<data-member name="p_dependencies"><type>id_list_t</type><purpose>list of test units this one depends on </purpose></data-member>
<data-member name="p_preconditions"><type>precond_list_t</type><purpose>user supplied preconditions for this test unit; </purpose></data-member>
<data-member name="p_name"><type>readwrite_property&lt; std::string &gt;</type><purpose>name for this test unit </purpose></data-member>
<data-member name="p_description"><type>readwrite_property&lt; std::string &gt;</type><purpose>description for this test unit </purpose></data-member>
<data-member name="p_timeout"><type>readwrite_property&lt; unsigned &gt;</type><purpose>timeout for the test unit execution in seconds </purpose></data-member>
<data-member name="p_expected_failures"><type>readwrite_property&lt; counter_t &gt;</type><purpose>number of expected failures in this test unit </purpose></data-member>
<data-member name="p_default_status"><type>readwrite_property&lt; run_status &gt;</type><purpose>run status obtained by this unit during setup phase </purpose></data-member>
<data-member name="p_run_status"><type>readwrite_property&lt; run_status &gt;</type><purpose>run status assigned to this unit before execution phase after applying all filters </purpose></data-member>
<data-member name="p_sibling_rank"><type>readwrite_property&lt; counter_t &gt;</type><purpose>rank of this test unit amoung siblings of the same parent </purpose></data-member>
<data-member name="p_decorators"><type>readwrite_property&lt; decor_list_t &gt;</type><purpose>automatically assigned decorators; execution is delayed till <link linkend="doxygen.a00860_1a6a95564b913ee2b951073568f222762f">framework::finalize_setup_phase</link> function </purpose></data-member>
<data-member name="p_fixtures"><type>readwrite_property&lt; fixture_list_t &gt;</type><purpose>fixtures associated with this test unit </purpose></data-member>
</class><class id="doxygen.a01020" name="test_unit"><enum id="doxygen.a01020_1a837bf30fd03cdf98f976d532c219477f" name=""><enumvalue id="doxygen.a01020_1a837bf30fd03cdf98f976d532c219477fad8eb7e2c1c1613e4631b82fe33c685de" name="type"><default>TUT_ANY</default></enumvalue></enum>
<enum id="doxygen.a01020_1a02aacda4d288ea49c972498885188c71" name="run_status"><enumvalue id="doxygen.a01020_1a02aacda4d288ea49c972498885188c71af693679be9f20176fdf908c32d1323b3" name="RS_DISABLED"/><enumvalue id="doxygen.a01020_1a02aacda4d288ea49c972498885188c71ac79afeda683a7d996874a9ab9b4cf964" name="RS_ENABLED"/><enumvalue id="doxygen.a01020_1a02aacda4d288ea49c972498885188c71a6c5108392f4ae218bb0bdc37ad68dcaa" name="RS_INHERIT"/><enumvalue id="doxygen.a01020_1a02aacda4d288ea49c972498885188c71ae30f2efefdfe3f0c889c90cd9daf2ae7" name="RS_INVALID"/></enum>
<typedef id="doxygen.a01020_1aaa6b5f7afc8de400a2ea146c825bc499" name="id_list"><type>std::vector&lt; test_unit_id &gt;</type></typedef>
<typedef id="doxygen.a01020_1ae547203b99cf0d2538e590cf1cee8e24" name="fixture_list_t"><type>std::vector&lt; test_unit_fixture_ptr &gt;</type></typedef>
<typedef id="doxygen.a01020_1ab0927266592f21c8676463162466d657" name="decor_list_t"><type>std::vector&lt; decorator::base_ptr &gt;</type></typedef>
<typedef id="doxygen.a01020_1af6db7ec0f56e7294a4887f1c2a8ecdbb" name="precondition_t"><type>boost::function&lt; <classname>test_tools::assertion_result</classname>(test_unit_id)&gt;</type></typedef>
<data-member id="doxygen.a01020_1a6a089682b7dc30019414f53dfe42b115" name="p_type"><type>test_unit_type const</type><purpose>type for this test unit </purpose></data-member>
<data-member id="doxygen.a01020_1a0ddea8b39e5907110137614ce097cd77" name="p_type_name"><type>const_string const</type><purpose>"case"/"suite"/"module" </purpose></data-member>
<data-member id="doxygen.a01020_1a04c5f68ee57f996dff3afd5fe0bebf88" name="p_file_name"><type>const_string const</type></data-member>
<data-member id="doxygen.a01020_1aff1bb380fbfad2014789623d86aa6270" name="p_line_num"><type>std::size_t const</type></data-member>
<data-member id="doxygen.a01020_1a01ebd9c2cc06d6d45f35de90f43ed52e" name="p_id"><type>id_t</type><purpose>unique id for this test unit </purpose></data-member>
<data-member id="doxygen.a01020_1a99c0a2b4f1706a94e7a44684be5cc82e" name="p_parent_id"><type>parent_id_t</type><purpose>parent test suite id </purpose></data-member>
<data-member id="doxygen.a01020_1af9ffc950197fc9eb82ef280a2a70603a" name="p_labels"><type>label_list_t</type><purpose>list of labels associated with this test unit </purpose></data-member>
<data-member id="doxygen.a01020_1aa1d68442d98010b08dbd0ead72fdf694" name="p_dependencies"><type>id_list_t</type><purpose>list of test units this one depends on </purpose></data-member>
<data-member id="doxygen.a01020_1a758ce580fa8835a3dc438c75f364103d" name="p_preconditions"><type>precond_list_t</type><purpose>user supplied preconditions for this test unit; </purpose></data-member>
<data-member id="doxygen.a01020_1ad9ee853bc4a3cae7fc5842ef73a73090" name="p_name"><type>readwrite_property&lt; std::string &gt;</type><purpose>name for this test unit </purpose></data-member>
<data-member id="doxygen.a01020_1a717c911666ce7f2a447c4a7fe5694b2d" name="p_description"><type>readwrite_property&lt; std::string &gt;</type><purpose>description for this test unit </purpose></data-member>
<data-member id="doxygen.a01020_1a7dabba25d8688c33c7ff7ef2949d0e30" name="p_timeout"><type>readwrite_property&lt; unsigned &gt;</type><purpose>timeout for the test unit execution in seconds </purpose></data-member>
<data-member id="doxygen.a01020_1a69ea7c448f62dcf3addf8ad9f0aaf727" name="p_expected_failures"><type>readwrite_property&lt; counter_t &gt;</type><purpose>number of expected failures in this test unit </purpose></data-member>
<data-member id="doxygen.a01020_1a2b3472066f764040494895f09278d511" name="p_default_status"><type>readwrite_property&lt; run_status &gt;</type><purpose>run status obtained by this unit during setup phase </purpose></data-member>
<data-member id="doxygen.a01020_1adb6bd8581cac0f96e3fc4263224e5b65" name="p_run_status"><type>readwrite_property&lt; run_status &gt;</type><purpose>run status assigned to this unit before execution phase after applying all filters </purpose></data-member>
<data-member id="doxygen.a01020_1aa86a3d8d18b43c4f4ab3e846f18feb44" name="p_sibling_rank"><type>readwrite_property&lt; counter_t &gt;</type><purpose>rank of this test unit amoung siblings of the same parent </purpose></data-member>
<data-member id="doxygen.a01020_1a888af101752b4f48071bb3229d4137ed" name="p_decorators"><type>readwrite_property&lt; decor_list_t &gt;</type><purpose>automatically assigned decorators; execution is delayed till <link linkend="doxygen.a00860_1a6a95564b913ee2b951073568f222762f">framework::finalize_setup_phase</link> function </purpose></data-member>
<data-member id="doxygen.a01020_1a9960399385e62cb8ab979cab1bafc4b6" name="p_fixtures"><type>readwrite_property&lt; fixture_list_t &gt;</type><purpose>fixtures associated with this test unit </purpose></data-member>
<method-group name="public member functions">
<method id="doxygen.a01020_1acec24ba0a06ed2ea35036fd3a2ca00d9" name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>test_unit_id</paramtype></parameter><parameter name=""><paramtype>(framework::state)</paramtype></parameter></method>
<method id="doxygen.a01020_1ae9c76251722156dd86751e7f5b0b7fd6" name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>test_unit_id</paramtype></parameter><parameter name=""><paramtype>(<classname>test_suite</classname>)</paramtype></parameter></method>
<method id="doxygen.a01020_1a52e34b3a6fb30d9a56068fd26dda2b54" name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>id_list</paramtype></parameter><parameter name=""><paramtype>(<classname>test_unit</classname>)</paramtype></parameter></method>
<method id="doxygen.a01020_1a796c749f1ab8913ba54ef5c90b681d0e" name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>std::vector&lt; std::string &gt;</paramtype></parameter><parameter name=""><paramtype>(<classname>test_unit</classname>)</paramtype></parameter></method>
<method id="doxygen.a01020_1a9ccdfe30ff1a51005678ee7e8ce8af71" name="BOOST_READONLY_PROPERTY"><type>typedef</type><parameter name=""><paramtype>std::vector&lt; precondition_t &gt;</paramtype></parameter><parameter name=""><paramtype>(<classname>test_unit</classname>)</paramtype></parameter></method>
<method id="doxygen.a01020_1aa3faab1852cdfc92e260ea3310c5fa50" name="depends_on"><type>void</type><parameter name="tu"><paramtype><classname>test_unit</classname> *</paramtype></parameter></method>
<method id="doxygen.a01020_1a2185f3f8ff2aab17190f2b6d4e5bcda1" name="add_precondition"><type>void</type><parameter name=""><paramtype>precondition_t const &amp;</paramtype></parameter></method>
<method id="doxygen.a01020_1a79fe1ec45091d44ac910d3f2012c5207" name="check_preconditions" cv="const"><type><classname>test_tools::assertion_result</classname></type></method>
<method id="doxygen.a01020_1a7495c0668e5917cd1c3c26f6bc297ebc" name="add_label"><type>void</type><parameter name="l"><paramtype>const_string</paramtype></parameter></method>
<method id="doxygen.a01020_1a031918d90d014cff332b13320e9fe06d" name="has_label" cv="const"><type>bool</type><parameter name="l"><paramtype>const_string</paramtype></parameter></method>
<method id="doxygen.a01020_1a04352705c2a42271a6b33c4e68b0842c" name="increase_exp_fail"><type>void</type><parameter name="num"><paramtype>counter_t</paramtype></parameter></method>
<method id="doxygen.a01020_1a00d6889e7af8dcfc66a3668987c7a5e5" name="is_enabled" cv="const"><type>bool</type></method>
<method id="doxygen.a01020_1adf66a0a8b222406c89623f8e5b2c4e58" name="full_name" cv="const"><type>std::string</type></method>
</method-group>
<method-group name="protected member functions">
<destructor id="doxygen.a01020_1af2f94ef7e2d495b10cc791e3d1f8a6ba"/>
<constructor id="doxygen.a01020_1ae5faa80c1cc3fb30f240f3ef8edff262"><parameter name="tu_name"><paramtype>const_string</paramtype></parameter><parameter name="tc_file"><paramtype>const_string</paramtype></parameter><parameter name="tc_line"><paramtype>std::size_t</paramtype></parameter><parameter name="t"><paramtype>test_unit_type</paramtype></parameter></constructor>
<constructor id="doxygen.a01020_1a01c3d671ad92a3e4e04d6ad9c15d7c21" specifiers="explicit"><parameter name="module_name"><paramtype>const_string</paramtype></parameter></constructor>
</method-group>
</class><class id="doxygen.a01024" name="test_unit_generator"><method-group name="public member functions">
<method id="doxygen.a01024_1a6596871aa4e0760d657e55e99c980a1a" name="next" cv="const = 0" specifiers="virtual"><type><classname>test_unit</classname> *</type></method>
</method-group>
<method-group name="protected member functions">
<destructor id="doxygen.a01024_1a372664d017b989a5a6e45d2cf1170f05"/>
</method-group>
</class><namespace name="framework">
<free-function-group name="Unit Test Framework initialization and shutdown">




</free-function-group>
<free-function-group name="Test unit registration">





</free-function-group>
<free-function-group name="Test observer registration">


</free-function-group>
<free-function-group name="Global fixtures registration">


</free-function-group>
<free-function-group name="Assertion/uncaught exception context support">



</free-function-group>
<free-function-group name="Access to registered test units.">






</free-function-group>
<free-function-group name="Test initiation interface">


</free-function-group>
<free-function-group name="Test events dispatchers">




</free-function-group>
</namespace>
<typedef id="doxygen.a00855_1a6f14d847b9da367eee8fe98bc5262d9c" name="test_unit_id_list"><type>std::vector&lt; test_unit_id &gt;</type></typedef>

<function id="doxygen.a00855_1aee91a052dcbc96ce22180b76c1231ba1" name="make_test_case"><type><classname>test_case</classname> *</type><parameter name="test_func"><paramtype>boost::function&lt; void()&gt; const &amp;</paramtype></parameter><parameter name="tc_name"><paramtype>const_string</paramtype></parameter><parameter name="tc_file"><paramtype>const_string</paramtype></parameter><parameter name="tc_line"><paramtype>std::size_t</paramtype></parameter></function>
<function id="doxygen.a00855_1ae48aa4087fc62e3a3061a5d12f0e898b" name="make_test_case"><type><classname>test_case</classname> *</type><template>
          <template-type-parameter name="UserTestCase"/>
          <template-type-parameter name="InstanceType"/>
        </template><parameter name="test_method"><paramtype>void(UserTestCase::*)()</paramtype></parameter><parameter name="tc_name"><paramtype>const_string</paramtype></parameter><parameter name="tc_file"><paramtype>const_string</paramtype></parameter><parameter name="tc_line"><paramtype>std::size_t</paramtype></parameter><parameter name="user_test_case"><paramtype>boost::shared_ptr&lt; InstanceType &gt;</paramtype></parameter></function>



</namespace>
</namespace>
</header>
<header id="doxygen.a00728" name="boost/test/unit_test.hpp">
<para>Entry point into the Unit Test Framework. </para><para>This header should be the only header necessary to include to start using the framework </para><namespace name="boost">
<namespace name="unit_test">
<function id="doxygen.a00855_1a078b408038e3300e258740f5888367d2" name="unit_test_main"><type>int</type><parameter name="init_func"><paramtype>init_unit_test_func</paramtype></parameter><parameter name="argc"><paramtype>int</paramtype></parameter><parameter name="argv"><paramtype>char *</paramtype></parameter></function>





</namespace>
</namespace>
</header>
<header id="doxygen.a00734" name="boost/test/unit_test_log.hpp">
<para>defines singleton class unit_test_log and all manipulators. unit_test_log has output stream like interface. It's implementation is completely hidden with pimple idiom </para><namespace name="boost">
<namespace name="unit_test">
<class id="doxygen.a00972" name="unit_test_log_t"><inherit access="public">boost::unit_test::test_observer</inherit><purpose>Manages the sets of loggers, their streams and log levels. </purpose><description><para>The Boost.Test framework allows for having several formatters/loggers at the same time, each of which having their own log level and output stream.</para><para>This class serves the purpose of<itemizedlist>
<listitem><para>exposing an interface to the test framework (as a <link linkend="doxygen.a00956">boost::unit_test::test_observer</link>)</para>
</listitem><listitem><para>exposing an interface to the testing tools</para>
</listitem><listitem><para>managing several loggers</para>
</listitem></itemizedlist>
</para><para><note><para>Accesses to the functions exposed by this class are made through the singleton <computeroutput>boost::unit_test::unit_test_log</computeroutput>.</para>
</note>
Users/developers willing to implement their own formatter need to:<itemizedlist>
<listitem><para>implement a <link linkend="doxygen.a01000">boost::unit_test::unit_test_log_formatter</link> that will output the desired format</para>
</listitem><listitem><para>register the formatter during a eg. global fixture using the method <computeroutput>set_formatter</computeroutput> (though the framework singleton).</para>
</listitem></itemizedlist>
</para><para><warning><para>this observer has a higher priority than the <link linkend="doxygen.a01012">boost::unit_test::results_collector_t</link>. This means that the various <link linkend="doxygen.a01008">boost::unit_test::test_results</link> associated to each test unit may not be available at the time the <computeroutput>test_unit_start</computeroutput>, <computeroutput>test_unit_finish</computeroutput> ... are called.</para>
</warning>
<formalpara><title>See Also:</title><para><itemizedlist>
<listitem><para><link linkend="doxygen.a00956">boost::unit_test::test_observer</link></para>
</listitem><listitem><para><link linkend="doxygen.a01000">boost::unit_test::unit_test_log_formatter</link> </para>
</listitem></itemizedlist>
</para>
</formalpara>
</para></description><method-group name="public member functions">
<method id="doxygen.a00972_1afa131ed8a625bcea883d3c480971f673" name="test_start" specifiers="virtual"><type>void</type><parameter name=""><paramtype>counter_t</paramtype></parameter><parameter name=""><paramtype>test_unit_id</paramtype></parameter><purpose>Called before the framework starts executing the test cases. </purpose><description><para>
</para></description></method>
<method id="doxygen.a00972_1a6ff1f3c17c6925599e142ea5110e565d" name="test_finish" specifiers="virtual"><type>void</type><purpose>Called after the framework ends executing the test cases. </purpose><description><para><note><para>The call is made with a reversed priority order. </para>
</note>
</para></description></method>
<method id="doxygen.a00972_1a26828ee3d6eb8a0493d8d346c6e20b9d" name="test_aborted" specifiers="virtual"><type>void</type><purpose>Called when a critical error is detected. </purpose><description><para>The critical errors are mainly the signals sent by the system and caught by the Boost.Test framework. Since the running binary may be in incoherent/instable state, the test execution is aborted and all remaining tests are discarded.</para><para><note><para>may be called before <link linkend="doxygen.a00956_1a8ebc971fd12c0b1a962788e1e18ca6f8">test_observer::test_unit_finish()</link> </para>
</note>
</para></description></method>
<method id="doxygen.a00972_1aa5b435eeee08f36e20ecd5d91a646250" name="test_unit_start" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Called before the framework starts executing a test unit. </purpose><description><para>
</para></description></method>
<method id="doxygen.a00972_1af8b9b06522f1dcf1310bc22f2e811d95" name="test_unit_finish" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name=""><paramtype>unsigned long</paramtype></parameter><purpose>Called at each end of a test unit. </purpose><description><para>
</para></description></method>
<method id="doxygen.a00972_1a1f76128b80b565db8b4630d2a4f61715" name="test_unit_skipped" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><parameter name=""><paramtype>const_string</paramtype></parameter></method>
<method id="doxygen.a00972_1acbf535b6350b4761ba59e219f377b914" name="test_unit_aborted" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Called when a test unit indicates a fatal error. </purpose><description><para>A fatal error happens when<itemizedlist>
<listitem><para>a strong assertion (with <computeroutput>REQUIRE</computeroutput>) fails, which indicates that the test case cannot continue</para>
</listitem><listitem><para>an unexpected exception is caught by the Boost.Test framework </para>
</listitem></itemizedlist>
</para></description></method>
<method id="doxygen.a00972_1a7513545ac67823c97bff81a8cee6c5da" name="test_unit_timed_out" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Called when the test timed out. </purpose><description><para>This function is called to signal that a test unit (case or suite) timed out. A valid test unit is available through <link linkend="doxygen.a00860_1af4d92cd4e358fd7ccefcfdfaa6d4d5ba">boost::unit_test::framework::current_test_unit</link> </para></description></method>
<method id="doxygen.a00972_1aa79304294b0ac0254ab161b921f73821" name="exception_caught" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>execution_exception</classname> const &amp;</paramtype></parameter><purpose>Called when an exception is intercepted. </purpose><description><para>In case an exception is intercepted, this call happens before the call to <link linkend="doxygen.a00972_1acbf535b6350b4761ba59e219f377b914">test_unit_aborted</link> in order to log additional data about the exception. </para></description></method>
<method id="doxygen.a00972_1abf29d32356e3b726760b74bf5a6fd948" name="priority" specifiers="virtual"><type>int</type><purpose>The priority indicates the order at which this observer is initialized and tore down in the UTF framework. The order is lowest to highest priority. </purpose></method>
<method id="doxygen.a00972_1ad625206a5570d2f583e6e229ff20ce30" name="set_stream"><type>void</type><parameter name=""><paramtype>std::ostream &amp;</paramtype></parameter><purpose>Sets the stream for all loggers. </purpose><description><para>This will override the log sink/stream of all loggers, whether enabled or not. </para></description></method>
<method id="doxygen.a00972_1a5c8a5bbbaee29cd3ef3de3336aac2447" name="set_stream"><type>void</type><parameter name=""><paramtype>output_format</paramtype></parameter><parameter name=""><paramtype>std::ostream &amp;</paramtype></parameter><purpose>Sets the stream for specific logger. </purpose><description><para><note><para>Has no effect if the specified format is not found </para>
</note>
<formalpara><title>Since Boost 1.62</title><para/>
</formalpara>
</para></description></method>
<method id="doxygen.a00972_1a367857c082cfb2c31f8ed0eebb8ae0fb" name="get_stream" cv="const"><type>std::ostream *</type><parameter name=""><paramtype>output_format</paramtype></parameter><purpose>Returns a pointer to the stream associated to specific logger. </purpose><description><para><note><para>Returns a null pointer if the format is not found </para>
</note>
<formalpara><title>Since Boost 1.67</title><para/>
</formalpara>
</para></description></method>
<method id="doxygen.a00972_1a99ad1c7bf471150706186a56a3734a92" name="set_threshold_level"><type>log_level</type><parameter name=""><paramtype>log_level</paramtype></parameter><purpose>Sets the threshold level for all loggers/formatters. </purpose><description><para>This will override the log level of all loggers, whether enabled or not. 
</para></description><returns><para>the minimum of the previous log level of all formatters (new in Boost 1.73) </para>
</returns></method>
<method id="doxygen.a00972_1a3a99da52bd4535f6e05bf93f700dcb67" name="set_threshold_level"><type>log_level</type><parameter name=""><paramtype>output_format</paramtype></parameter><parameter name=""><paramtype>log_level</paramtype></parameter><purpose>Sets the threshold/log level of a specific format. </purpose><description><para><note><para>Has no effect if the specified format is not found </para>
</note>
<formalpara><title>Since Boost 1.62</title><para/>
</formalpara>

</para></description><returns><para>the previous log level of the corresponding formatter (new in Boost 1.73) </para>
</returns></method>
<method id="doxygen.a00972_1a00ece0931de6b09ed89718ce2dce31d3" name="add_format"><type>void</type><parameter name=""><paramtype>output_format</paramtype></parameter><purpose>Add a format to the set of loggers. </purpose><description><para>Adding a logger means that the specified logger is enabled. The log level is managed by the formatter itself and specifies what events are forwarded to the underlying formatter. <formalpara><title>Since Boost 1.62</title><para/>
</formalpara>
</para></description></method>
<method id="doxygen.a00972_1a903b66706168293937d1a879cf168e43" name="set_format"><type>void</type><parameter name=""><paramtype>output_format</paramtype></parameter><purpose>Sets the format of the logger. </purpose><description><para>This will become the only active format of the logs. </para></description></method>
<method id="doxygen.a00972_1aa796f5ec18b502a517a0b1730397f814" name="get_formatter"><type><classname>unit_test_log_formatter</classname> *</type><parameter name=""><paramtype>output_format</paramtype></parameter><purpose>Returns the logger instance for a specific format. </purpose><description><para>
<formalpara><title>Since Boost 1.62</title><para/>
</formalpara>
</para></description><returns><para>the logger/formatter instance, or <computeroutput/>(unit_test_log_formatter*)0 if the format is not found. </para>
</returns></method>
<method id="doxygen.a00972_1a68d0b7a27ebd236c01ec31ab2ef7c77f" name="set_formatter"><type>void</type><parameter name=""><paramtype><classname>unit_test_log_formatter</classname> *</paramtype></parameter><purpose>Sets the logger instance. </purpose><description><para>The specified logger becomes the unique active one. The custom log formatter has the format <computeroutput>OF_CUSTOM_LOGGER</computeroutput>. If such a format exists already, its formatter gets replaced by the one given in argument.</para><para>The log level and output stream of the new formatter are taken from the currently active logger. In case several loggers are active, the order of priority is CUSTOM, HRF, XML, and JUNIT. If (unit_test_log_formatter*)0 is given as argument, the custom logger (if any) is removed.</para><para><note><para>The ownership of the pointer is transferred to the Boost.Test framework. This call is equivalent to<itemizedlist>
<listitem><para>a call to <computeroutput>add_formatter</computeroutput> </para>
</listitem><listitem><para>a call to <computeroutput>set_format(OF_CUSTOM_LOGGER)</computeroutput> </para>
</listitem><listitem><para>a configuration of the newly added logger with a previously configured stream and log level. </para>
</listitem></itemizedlist>
</para>
</note>
</para></description></method>
<method id="doxygen.a00972_1a06bfc5e5b9dde6d68d27993f260808ee" name="add_formatter"><type>void</type><parameter name="the_formatter"><paramtype><classname>unit_test_log_formatter</classname> *</paramtype></parameter><purpose>Adds a custom log formatter to the set of formatters. </purpose><description><para>The specified logger is added with the format <computeroutput>OF_CUSTOM_LOGGER</computeroutput>, such that it can be futher selected or its stream/log level can be specified. If there is already a custom logger (with <computeroutput>OF_CUSTOM_LOGGER</computeroutput>), then the existing one gets replaced by the one given in argument. The provided logger is added with an enabled state. If (unit_test_log_formatter*)0 is given as argument, the custom logger (if any) is removed and no other action is performed.</para><para><note><para>The ownership of the pointer is transferred to the Boost.Test framework. </para>
</note>
<formalpara><title>Since Boost 1.62</title><para/>
</formalpara>
</para></description></method>
<method id="doxygen.a00972_1a72336a9d5e819cfc26bd59736d43df25" name="set_checkpoint"><type>void</type><parameter name="file"><paramtype>const_string</paramtype></parameter><parameter name="line_num"><paramtype>std::size_t</paramtype></parameter><parameter name="msg"><paramtype>const_string</paramtype><default>const_string()</default></parameter></method>
<method id="doxygen.a00972_1a6c368c215ae1013cadc8bd12f0f91e86" name="operator&lt;&lt;"><type><classname>unit_test_log_t</classname> &amp;</type><parameter name=""><paramtype><classname>log::begin</classname> const &amp;</paramtype></parameter></method>
<method id="doxygen.a00972_1a17bdcc551903c5bc93869b1a200f2684" name="operator&lt;&lt;"><type><classname>unit_test_log_t</classname> &amp;</type><parameter name=""><paramtype><classname>log::end</classname> const &amp;</paramtype></parameter></method>
<method id="doxygen.a00972_1aab2236744379a2f8c4f550032aa8d855" name="operator&lt;&lt;"><type><classname>unit_test_log_t</classname> &amp;</type><parameter name=""><paramtype>log_level</paramtype></parameter></method>
<method id="doxygen.a00972_1a588bb9620f83eec3a911b4dc5db28d93" name="operator&lt;&lt;"><type><classname>unit_test_log_t</classname> &amp;</type><parameter name=""><paramtype>const_string</paramtype></parameter></method>
<method id="doxygen.a00972_1ae400845852b049672358fbe542f42f29" name="operator&lt;&lt;"><type><classname>unit_test_log_t</classname> &amp;</type><parameter name=""><paramtype>lazy_ostream const &amp;</paramtype></parameter></method>
<method id="doxygen.a00972_1a4440883e0015a9a2d516b599720eec89" name="operator()"><type><emphasis>unspecified</emphasis></type><parameter name=""><paramtype>log_level</paramtype></parameter></method>
<method id="doxygen.a00972_1a53edadabb9060db04fffee37da090882" name="configure"><type>void</type><purpose>Prepares internal states after log levels, streams and format has been set up. </purpose></method>
<method name="test_unit_skipped" specifiers="virtual"><type>void</type><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>backward compatibility </purpose></method>
<method name="assertion_result" specifiers="virtual"><type>void</type><parameter name=""><paramtype>unit_test::assertion_result</paramtype></parameter></method>
</method-group>
</class><namespace name="log">
<struct id="doxygen.a00960" name="begin"><data-member id="doxygen.a00960_1a3e134ca401e54654dbd131ab46e9ae11" name="m_file_name"><type>const_string</type></data-member>
<data-member id="doxygen.a00960_1a1de27f1aab15869355ed88e4be0621b8" name="m_line_num"><type>std::size_t</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a00960_1a3573ca6f0cc594424d620a3cc68ff8e1"><parameter name="fn"><paramtype>const_string</paramtype></parameter><parameter name="ln"><paramtype>std::size_t</paramtype></parameter></constructor>
</method-group>
</struct><struct id="doxygen.a00964" name="end"/></namespace>






</namespace>
</namespace>
<macro id="doxygen.a00734_1a91b2cc2ba1d433ee5fc1d2b6ad6a70fe" name="BOOST_TEST_LOG_ENTRY" kind="functionlike"><macro-parameter name="ll"/></macro>
<macro id="doxygen.a00734_1a36d865e99883a3d691f059195d6ad4e7" name="BOOST_TEST_FRAMEWORK_MESSAGE" kind="functionlike"><macro-parameter name="M"/></macro>
<macro id="doxygen.a00734_1a5c0090f80969eba84ed5dbf85a711e98" name="BOOST_TEST_MESSAGE" kind="functionlike"><macro-parameter name="M"/></macro>
<macro id="doxygen.a00734_1a1679c4ebe51b6f3f768784b03a374340" name="BOOST_TEST_PASSPOINT" kind="functionlike"><macro-parameter name=""/></macro>
<macro id="doxygen.a00734_1a706d4e5089ae8c54f7b7256c56af81d6" name="BOOST_TEST_CHECKPOINT" kind="functionlike"><macro-parameter name="M"/></macro>
</header>
<header id="doxygen.a00749" name="boost/test/unit_test_log_formatter.hpp">
<para>Defines unit test log formatter interface. </para><para>You can define a class with implements this interface and use an instance of it as a Unit Test Framework log formatter </para><namespace name="boost">
<namespace name="unit_test">
<struct id="doxygen.a00996" name="log_checkpoint_data"><purpose>Collection of log checkpoint attributes. </purpose><data-member id="doxygen.a00996_1abcde93b68ce076909b70b93062ce1d45" name="m_file_name"><type>const_string</type><purpose>log checkpoint file name </purpose></data-member>
<data-member id="doxygen.a00996_1a479879dc17b52fe88153731fd4081205" name="m_line_num"><type>std::size_t</type><purpose>log checkpoint file name </purpose></data-member>
<data-member id="doxygen.a00996_1a014a385aebe3f516157f7b7b91c8f72e" name="m_message"><type>std::string</type><purpose>log checkpoint message </purpose></data-member>
<method-group name="public member functions">
<method id="doxygen.a00996_1ad01e23d1927808042e6a33e19fef3940" name="clear"><type>void</type></method>
</method-group>
</struct><struct id="doxygen.a00992" name="log_entry_data"><purpose>Collection of log entry attributes. </purpose><data-member id="doxygen.a00992_1ad894404514537334ffdec304a221dcc2" name="m_file_name"><type>std::string</type><purpose>log entry file name </purpose></data-member>
<data-member id="doxygen.a00992_1a59625b25e7843582ca0278d125756ef3" name="m_line_num"><type>std::size_t</type><purpose>log entry line number </purpose></data-member>
<data-member id="doxygen.a00992_1a00480af174292d8daf171ae92500e588" name="m_level"><type>log_level</type><purpose>log entry level </purpose></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a00992_1a4fe494a0d9225276c3c4028fd6a3cc1a"/>
<method id="doxygen.a00992_1a0ca253eda27d98abb2fae3ed3e8700ef" name="clear"><type>void</type></method>
</method-group>
</struct><class id="doxygen.a01000" name="unit_test_log_formatter"><purpose>Abstract Unit Test Framework log formatter interface. </purpose><description><para>During the test module execution Unit Test Framework can report messages about success or failure of assertions, which test suites are being run and more (specifically which messages are reported depends on log level threshold selected by the user).</para><para>All these messages constitute Unit Test Framework log. There are many ways (formats) to present these messages to the user.</para><para>Boost.Test comes with three formats:<itemizedlist>
<listitem><para>Compiler-like log format: intended for human consumption/diagnostic</para>
</listitem><listitem><para>XML based log format: intended for processing by automated regression test systems.</para>
</listitem><listitem><para>JUNIT based log format: intended for processing by automated regression test systems.</para>
</listitem></itemizedlist>
</para><para>If you want to produce some other format you need to implement class with specific interface and use method <computeroutput><link linkend="doxygen.a00972_1a68d0b7a27ebd236c01ec31ab2ef7c77f">unit_test_log_t::set_formatter</link></computeroutput> during a test module initialization to set an active formatter. The class <link linkend="doxygen.a01000">unit_test_log_formatter</link> defines this interface.</para><para>This interface requires you to format all possible messages being produced in the log. These includes error messages about failed assertions, messages about caught exceptions and information messages about test units being started/ended. All the methods in this interface takes a reference to standard stream as a first argument. This is where final messages needs to be directed to. Also you are given all the information necessary to produce a message.</para><para><formalpara><title>Since Boost 1.62:</title><para><itemizedlist>
<listitem><para>Each formatter may indicate the default output stream. This is convenient for instance for streams intended for automated processing that indicate a file. See <computeroutput>get_default_stream_description</computeroutput> for more details.</para>
</listitem><listitem><para>Each formatter may manage its own log level through the getter/setter <computeroutput>get_log_level</computeroutput> and <computeroutput>set_log_level</computeroutput> .</para>
</listitem></itemizedlist>
</para>
</formalpara>
<formalpara><title>See Also:</title><para><itemizedlist>
<listitem><para><link linkend="doxygen.a00956">boost::unit_test::test_observer</link> for an indication of the calls of the test observer interface </para>
</listitem></itemizedlist>
</para>
</formalpara>
</para></description><enum id="doxygen.a01000_1ade138110acf915c5c5c7649d68c4dc85" name="log_entry_types"><enumvalue id="doxygen.a01000_1ade138110acf915c5c5c7649d68c4dc85a9e6c7f784583898f5ccca24e8f3a3e91" name="BOOST_UTL_ET_INFO"><purpose>Information message from the framework. </purpose></enumvalue><enumvalue id="doxygen.a01000_1ade138110acf915c5c5c7649d68c4dc85a59771ad5a87077ebc3edd740d37f2b34" name="BOOST_UTL_ET_MESSAGE"><purpose>Information message from the user. </purpose></enumvalue><enumvalue id="doxygen.a01000_1ade138110acf915c5c5c7649d68c4dc85a872ddb76135b938f3c721cbef45e9c47" name="BOOST_UTL_ET_WARNING"><purpose>Warning (non error) condition notification message. </purpose></enumvalue><enumvalue id="doxygen.a01000_1ade138110acf915c5c5c7649d68c4dc85a629666da41689a24098606e96c371c63" name="BOOST_UTL_ET_ERROR"><purpose>Non fatal error notification message. </purpose></enumvalue><enumvalue id="doxygen.a01000_1ade138110acf915c5c5c7649d68c4dc85a9e3d2151c4e9f19c38e514c38505d61f" name="BOOST_UTL_ET_FATAL_ERROR"><purpose>Fatal error notification message. </purpose></enumvalue><purpose>Types of log entries (messages written into a log) </purpose></enum>
<method-group name="public member functions">
<constructor id="doxygen.a01000_1a497b73a8557351b82c2600f0d11702b6"><purpose>Constructor. </purpose></constructor>
<destructor id="doxygen.a01000_1ad68a6d0e9e19fb4ab2a313882ec5513e" specifiers="virtual"/>
<method id="doxygen.a01000_1af1b8767bfc40d78338fde7f86896281b" name="log_start" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages to </para></description></parameter><parameter name="test_cases_amount"><paramtype>counter_t</paramtype><description><para>total test case amount to be run </para></description></parameter><purpose>Invoked at the beginning of test module execution. </purpose><description><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a01000_1ac066a07c02334b5f629efe3c0daa2577">log_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a01000_1ac066a07c02334b5f629efe3c0daa2577" name="log_finish" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked at the end of test module execution. </purpose><description><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a01000_1af1b8767bfc40d78338fde7f86896281b">log_start</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a01000_1a9a0107c45faa39b244e82d9b269a32bc" name="log_build_info" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="log_build_info"><paramtype>bool</paramtype><default>true</default><description><para>indicates if build info should be logged or not </para></description></parameter><purpose>Invoked when Unit Test Framework build information is requested. </purpose><description><para>
</para></description></method>
<method id="doxygen.a01000_1a2643aac73a801196c5cbc92206913ea4" name="test_unit_start" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype><description><para>test unit being started </para></description></parameter><purpose>Invoked when test unit starts (either test suite or test case) </purpose><description><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a01000_1a95121375cb2f71a3321f9b1c8f0f06a7">test_unit_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a01000_1a95121375cb2f71a3321f9b1c8f0f06a7" name="test_unit_finish" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype><description><para>test unit being finished </para></description></parameter><parameter name="elapsed"><paramtype>unsigned long</paramtype><description><para>time in microseconds spend executing this test unit </para></description></parameter><purpose>Invoked when test unit finishes. </purpose><description><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a01000_1a2643aac73a801196c5cbc92206913ea4">test_unit_start</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a01000_1aef0e0993f76b29caeb0111827a708b68" name="test_unit_skipped" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="tu"><paramtype><classname>test_unit</classname> const &amp;</paramtype><description><para>skipped test unit </para></description></parameter><parameter name=""><paramtype>const_string</paramtype></parameter><purpose>Invoked if test unit skipped for any reason. </purpose><description><para>
</para></description></method>
<method id="doxygen.a01000_1aff598650e56e60d0375cd2885169d517" name="test_unit_skipped" specifiers="virtual"><type>void</type><parameter name=""><paramtype>std::ostream &amp;</paramtype></parameter><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Deprecated version of this interface. </purpose><description><para><xrefsect id="a00851_1_deprecated000001"><xreftitle>Deprecated</xreftitle><xrefdescription/></xrefsect></para></description></method>
<method id="doxygen.a01000_1ae7f16291550ebc1f03c43b38a24df4cb" name="test_unit_aborted" specifiers="virtual"><type>void</type><parameter name=""><paramtype>std::ostream &amp;</paramtype></parameter><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Invoked when a test unit is aborted. </purpose></method>
<method id="doxygen.a01000_1a0c4ef633496b9f9955dd8705805745b8" name="test_unit_timed_out" specifiers="virtual"><type>void</type><parameter name=""><paramtype>std::ostream &amp;</paramtype></parameter><parameter name=""><paramtype><classname>test_unit</classname> const &amp;</paramtype></parameter><purpose>Invoked when a test unit times-out. </purpose></method>
<method id="doxygen.a01000_1a82bb3cfce5d9e686e2b54950e674c14d" name="log_exception_start" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="lcd"><paramtype><classname>log_checkpoint_data</classname> const &amp;</paramtype><description><para>information about the last checkpoint before the exception was triggered </para></description></parameter><parameter name="ex"><paramtype><classname>execution_exception</classname> const &amp;</paramtype><description><para>information about the caught exception </para></description></parameter><purpose>Invoked when Unit Test Framework detects uncaught exception. </purpose><description><para>The framwork calls this function when an uncaught exception it detected. This call is followed by context information:<itemizedlist>
<listitem><para>one call to <computeroutput>entry_context_start</computeroutput>,</para>
</listitem><listitem><para>as many calls to <computeroutput>log_entry_context</computeroutput> as there are context entries</para>
</listitem><listitem><para>one call to <computeroutput>entry_context_finish</computeroutput> </para>
</listitem></itemizedlist>
</para><para>The logging of the exception information is finilized by a call to <computeroutput>log_exception_finish</computeroutput>.</para><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a01000_1a9fb526c09d065131b001deb979dad947">log_exception_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a01000_1a9fb526c09d065131b001deb979dad947" name="log_exception_finish" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked when Unit Test Framework detects uncaught exception. </purpose><description><para>Call to this function finishes uncaught exception report. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a01000_1a82bb3cfce5d9e686e2b54950e674c14d">log_exception_start</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a01000_1a31a9ce2c3dba18e7d5aab2154c6469f0" name="log_entry_start" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="led"><paramtype><classname>log_entry_data</classname> const &amp;</paramtype><description><para>log entry attributes </para></description></parameter><parameter name="let"><paramtype>log_entry_types</paramtype><description><para>log entry type log_entry_finish </para></description></parameter><purpose>Invoked by Unit Test Framework to start new log entry. </purpose><description><para>Call to this function starts new log entry. It is followed by series of log_entry_value calls and finally call to log_entry_finish. A log entry may consist of one or more values being reported. Some of these values will be plain strings, while others can be complicated expressions in a form of "lazy" expression template lazy_ostream. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a01000_1ad85bd307b329f3558f47ed7cac6e0f7f">log_entry_value</link>, <link linkend="doxygen.a01000_1a9ac3c9d088304a7566b7f475095ecc4f">log_entry_finish</link></para>
</formalpara>
<note><para>call to this function may happen before any call to test_unit_start or all calls to test_unit_finish as the framework might log errors raised during global initialization/shutdown. </para>
</note>
</para></description></method>
<method id="doxygen.a01000_1ad85bd307b329f3558f47ed7cac6e0f7f" name="log_entry_value" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into. </para></description></parameter><parameter name="value"><paramtype>const_string</paramtype><description><para>log entry string value </para></description></parameter><purpose>Invoked by Unit Test Framework to report a log entry content. </purpose><description><para>This is one of two overloaded methods to report log entry content. This one is used to report plain string value. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a01000_1a31a9ce2c3dba18e7d5aab2154c6469f0">log_entry_start</link>, <link linkend="doxygen.a01000_1a9ac3c9d088304a7566b7f475095ecc4f">log_entry_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a01000_1a5298f47ddf6c5504fb43de904d2ddc9d" name="log_entry_value" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="value"><paramtype>lazy_ostream const &amp;</paramtype><description><para>log entry "lazy" value </para></description></parameter><purpose>Invoked by Unit Test Framework to report a log entry content. </purpose><description><para>This is one of two overloaded methods to report log entry content. This one is used to report some complicated expression passed as an expression template lazy_ostream. In most cases default implementation provided by the framework should work as is (it just converts the lazy expression into a string. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a01000_1a31a9ce2c3dba18e7d5aab2154c6469f0">log_entry_start</link>, <link linkend="doxygen.a01000_1a9ac3c9d088304a7566b7f475095ecc4f">log_entry_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a01000_1a9ac3c9d088304a7566b7f475095ecc4f" name="log_entry_finish" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><purpose>Invoked by Unit Test Framework to finish a log entry report. </purpose><description><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a01000_1a31a9ce2c3dba18e7d5aab2154c6469f0">log_entry_start</link>, <link linkend="doxygen.a01000_1a31a9ce2c3dba18e7d5aab2154c6469f0">log_entry_start</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a01000_1a5fef5e659e8bc8a145ce6369b7068405" name="entry_context_start" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="l"><paramtype>log_level</paramtype><description><para>entry log_level, to be used to fine tune the message </para></description></parameter><purpose>Invoked by Unit Test Framework to start log entry context report. </purpose><description><para>Unit Test Framework logs for failed assertions and uncaught exceptions context if one was defined by a test module. Context consists of multiple "scopes" identified by description messages assigned by the test module using BOOST_TEST_INFO/BOOST_TEST_CONTEXT statements. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a01000_1a5c6a6a5fdf1424841bdab36eea4f6001">log_entry_context</link>, <link linkend="doxygen.a01000_1ae7e141ef5b7807fdeb79b0e78756fe0d">entry_context_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a01000_1a5c6a6a5fdf1424841bdab36eea4f6001" name="log_entry_context" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="l"><paramtype>log_level</paramtype><description><para>entry log_level, to be used to fine tune the message </para></description></parameter><parameter name="value"><paramtype>const_string</paramtype><description><para>context "scope" description </para></description></parameter><purpose>Invoked by Unit Test Framework to report log entry context "scope" description. </purpose><description><para>Each "scope" description is reported by separate call to log_entry_context. 
<formalpara><title>See Also:</title><para><link linkend="doxygen.a01000_1a31a9ce2c3dba18e7d5aab2154c6469f0">log_entry_start</link>, <link linkend="doxygen.a01000_1ae7e141ef5b7807fdeb79b0e78756fe0d">entry_context_finish</link> </para>
</formalpara>
</para></description></method>
<method id="doxygen.a01000_1ae7e141ef5b7807fdeb79b0e78756fe0d" name="entry_context_finish" cv="= 0" specifiers="virtual"><type>void</type><parameter name="os"><paramtype>std::ostream &amp;</paramtype><description><para>output stream to write a messages into </para></description></parameter><parameter name="l"><paramtype>log_level</paramtype><description><para>entry log_level, to be used to fine tune the message </para></description></parameter><purpose>Invoked by Unit Test Framework to finish log entry context report. </purpose><description><para>
<formalpara><title>See Also:</title><para><link linkend="doxygen.a01000_1a31a9ce2c3dba18e7d5aab2154c6469f0">log_entry_start</link>, entry_context_context </para>
</formalpara>
</para></description></method>
<method id="doxygen.a01000_1aa9f6a2ebb54bd92b12f5c26513ede855" name="set_log_level" specifiers="virtual"><type>void</type><parameter name="new_log_level"><paramtype>log_level</paramtype></parameter><purpose>Sets the log level of the logger/formatter. </purpose><description><para>Some loggers need to manage the log level by their own. This member function let the implementation decide of that. <formalpara><title>Since Boost 1.62</title><para/>
</formalpara>
</para></description></method>
<method id="doxygen.a01000_1a5df814f08b27f68d15d41d5274b53481" name="get_log_level" cv="const" specifiers="virtual"><type>log_level</type><purpose>Returns the log level of the logger/formatter. </purpose><description><para><formalpara><title>Since Boost 1.62</title><para/>
</formalpara>
</para></description></method>
<method id="doxygen.a01000_1a1dbd75e2f8d5e65914b9e81bce97c4e7" name="get_default_stream_description" cv="const" specifiers="virtual"><type>std::string</type><purpose>Returns a default stream for this logger. </purpose><description><para>The returned string describes the stream as if it was passed from the command line <computeroutput>"--log_sink"</computeroutput> parameter. With that regards, <emphasis role="bold">stdout</emphasis> and <emphasis role="bold">stderr</emphasis> have special meaning indicating the standard output or error stream respectively.</para><para><formalpara><title>Since Boost 1.62</title><para/>
</formalpara>
</para></description></method>
</method-group>
</class>





</namespace>
</namespace>
</header>
<header id="doxygen.a00848" name="boost/test/unit_test_parameters.hpp">
<para>Provides access to various Unit Test Framework runtime parameters. </para><para>Primarily for use by the framework itself </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="runtime_config">
<class id="doxygen.a01428" name="stream_holder"><struct id="doxygen.a01432" name="callback_cleaner"><data-member id="doxygen.a01432_1a802b157fcadf9c289b617aabd15407a7" name="m_cleaner_callback"><type>boost::function&lt; void()&gt;</type></data-member>
<data-member id="doxygen.a01432_1a89120d0141452d1d4b730724746a4639" name="m_file"><type>std::ofstream</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.a01432_1a2499d3d42a7b6b6a8eb153c4c8111bb4"><parameter name="cleaner_callback"><paramtype>boost::function&lt; void()&gt;</paramtype></parameter></constructor>
<destructor id="doxygen.a01432_1ad32673191ea0335b9a574059f2a4d276"/>
</method-group>
</struct><method-group name="public member functions">
<constructor id="doxygen.a01428_1ac874e95b962dad5e8f3fa67cfa04efb8" specifiers="explicit"><parameter name="default_stream"><paramtype>std::ostream &amp;</paramtype><default>std::cout</default></parameter></constructor>
<method id="doxygen.a01428_1a2efd5fd70af36fa40b065fc94526068a" name="setup"><type>void</type><parameter name="stream_name"><paramtype>const const_string &amp;</paramtype></parameter><parameter name="cleaner_callback"><paramtype>boost::function&lt; void()&gt; const &amp;</paramtype><default>boost::function&lt; void()&gt;()</default></parameter></method>
<method id="doxygen.a01428_1a150db3331f17f887439a1398819ee658" name="ref" cv="const"><type>std::ostream &amp;</type></method>
</method-group>
</class><data-member id="doxygen.a00884_1af7cc7a5c0f2207661be8f416ca3d8315" name="btrt_auto_start_dbg"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1a501cb6e2470fa3d03a0e86fb17d1b2c9" name="btrt_break_exec_path"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1a0b807f273286ad1559a1d2a47ee5251a" name="btrt_build_info"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1ac7fe986a1533037f464b270332e8dd73" name="btrt_catch_sys_errors"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1a94ae14995b8f6326ddcc6c21fc364152" name="btrt_color_output"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1a4ac8a82568040f256b71486fcc3de138" name="btrt_detect_fp_except"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1a0a9b37ce9676cb905f3aa3bf50b54128" name="btrt_detect_mem_leaks"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1adbf57ca67874b01f1466925ec26d4e1e" name="btrt_list_content"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1a24688f65a572cdb54a568e5de4f25ccd" name="btrt_list_labels"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1ae2fc2d16e337cc3ede6a5a7567f88aeb" name="btrt_log_format"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1a3ae4da213031a8f4484cb15399365397" name="btrt_log_level"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1a2e20288e44bed2809998cca1cc30dba5" name="btrt_log_sink"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1a373984e02ddbb7f73ab791ce0300eef8" name="btrt_combined_logger"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1aaae1f9900e17675ef2af4951e9625b4e" name="btrt_output_format"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1a17839b486943fd35a75b2b7ba0d3a681" name="btrt_random_seed"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1ab533175b79da2de2734ad56fc3544c48" name="btrt_report_format"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1ae977f2cca90f1a2bda2537405debf4f1" name="btrt_report_level"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1a67bfe112d4c71f8a2ce2988e2a49de68" name="btrt_report_mem_leaks"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1add3ec4e10bf40c694526adbde92658ea" name="btrt_report_sink"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1a26d3773915fd4291bced0fa96155dcaa" name="btrt_result_code"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1a6855ad024b0fd226cd075e7946c16f5d" name="btrt_run_filters"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1a1a24d504aed426fdcabbef68c2ab89ab" name="btrt_save_test_pattern"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1ac5ea17638e7d3d14f22edc708fcfe177" name="btrt_show_progress"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1abd78bdc682488cd4dc65d86e94fa1fde" name="btrt_use_alt_stack"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1a5a21394206dd6a585e26fae42b8503fb" name="btrt_wait_for_debugger"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1a38135b36b5b2d581c3cde91125d05693" name="btrt_help"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1abc18c06299c4fb6098b7f8173f2f00c8" name="btrt_usage"><type>std::string</type></data-member>
<data-member id="doxygen.a00884_1acc127235ce555b9de4b906aeb3226ca2" name="btrt_version"><type>std::string</type></data-member>
<function id="doxygen.a00884_1a144eb1158c884bbe8c7f6c987911137a" name="init"><type>void</type><parameter name="argc"><paramtype>int &amp;</paramtype></parameter><parameter name="argv"><paramtype>char **</paramtype></parameter></function>
<function id="doxygen.a00884_1ae35906b1db9df3c2a5218a1a1c6105f1" name="argument_store"><type>runtime::arguments_store const &amp;</type><purpose>Access to arguments. </purpose></function>
<function id="doxygen.a00884_1ad270d1d676a3306b28c460bfe75e25a4" name="get"><type>T const &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="parameter_name"><paramtype>runtime::cstring</paramtype></parameter></function>
<function id="doxygen.a00884_1a8e3a1d88009294b7de07c18568f21215" name="has"><type>bool</type><parameter name="parameter_name"><paramtype>runtime::cstring</paramtype></parameter></function>
<function id="doxygen.a00884_1a8c9cedb81eda39295bc963dafe33619d" name="save_pattern"><type>bool</type><purpose>For public access. </purpose></function>
</namespace>






</namespace>
</namespace>
</header>
<header id="doxygen.a00824" name="boost/test/utils/algorithm.hpp">
<para>Addition to STL algorithms. </para><namespace name="boost">
<namespace name="unit_test">
<namespace name="utils">
<function id="doxygen.a00876_1aae6568ba19cefc3a3a788b21fc3352c6" name="mismatch"><type>std::pair&lt; InputIter1, InputIter2 &gt;</type><template>
          <template-type-parameter name="InputIter1"/>
          <template-type-parameter name="InputIter2"/>
        </template><parameter name="first1"><paramtype>InputIter1</paramtype><description><para>- first collection begin iterator </para></description></parameter><parameter name="last1"><paramtype>InputIter1</paramtype><description><para>- first collection end iterator </para></description></parameter><parameter name="first2"><paramtype>InputIter2</paramtype><description><para>- second collection begin iterator </para></description></parameter><parameter name="last2"><paramtype>InputIter2</paramtype><description><para>- second collection end iterator </para></description></parameter><purpose>this algorithm search through two collections for first mismatch position that get returned as a pair of iterators, first pointing to the mismatch position in first collection, second iterator in second one </purpose><description><para>
</para></description></function>
<function id="doxygen.a00876_1ac83b8f7562bcce78831a42b3cf666f38" name="mismatch"><type>std::pair&lt; InputIter1, InputIter2 &gt;</type><template>
          <template-type-parameter name="InputIter1"/>
          <template-type-parameter name="InputIter2"/>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="first1"><paramtype>InputIter1</paramtype><description><para>- first collection begin iterator </para></description></parameter><parameter name="last1"><paramtype>InputIter1</paramtype><description><para>- first collection end iterator </para></description></parameter><parameter name="first2"><paramtype>InputIter2</paramtype><description><para>- second collection begin iterator </para></description></parameter><parameter name="last2"><paramtype>InputIter2</paramtype><description><para>- second collection end iterator </para></description></parameter><parameter name="pred"><paramtype>Predicate</paramtype><description><para>- predicate to be used for search </para></description></parameter><purpose>this algorithm search through two collections for first mismatch position that get returned as a pair of iterators, first pointing to the mismatch position in first collection, second iterator in second one. This algorithms uses supplied predicate for collection elements comparison </purpose><description><para>
</para></description></function>
<function id="doxygen.a00876_1a2715f0bd371d2383b5a98e8c3b467738" name="find_first_not_of"><type>ForwardIterator1</type><template>
          <template-type-parameter name="ForwardIterator1"/>
          <template-type-parameter name="ForwardIterator2"/>
        </template><parameter name="first1"><paramtype>ForwardIterator1</paramtype><description><para>- first collection begin iterator </para></description></parameter><parameter name="last1"><paramtype>ForwardIterator1</paramtype><description><para>- first collection end iterator </para></description></parameter><parameter name="first2"><paramtype>ForwardIterator2</paramtype><description><para>- second collection begin iterator </para></description></parameter><parameter name="last2"><paramtype>ForwardIterator2</paramtype><description><para>- second collection end iterator </para></description></parameter><purpose>this algorithm search through first collection for first element that does not belong a second one </purpose><description><para>
</para></description></function>
<function id="doxygen.a00876_1afb14088a52c316dd2197edf5eef13455" name="find_first_not_of"><type>ForwardIterator1</type><template>
          <template-type-parameter name="ForwardIterator1"/>
          <template-type-parameter name="ForwardIterator2"/>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="first1"><paramtype>ForwardIterator1</paramtype><description><para>- first collection begin iterator </para></description></parameter><parameter name="last1"><paramtype>ForwardIterator1</paramtype><description><para>- first collection end iterator </para></description></parameter><parameter name="first2"><paramtype>ForwardIterator2</paramtype><description><para>- second collection begin iterator </para></description></parameter><parameter name="last2"><paramtype>ForwardIterator2</paramtype><description><para>- second collection end iterator </para></description></parameter><parameter name="pred"><paramtype>Predicate</paramtype><description><para>- predicate to be used for search </para></description></parameter><purpose>this algorithm search through first collection for first element that does not satisfy binary predicate in conjunction will any element in second collection </purpose><description><para>
</para></description></function>
<function id="doxygen.a00876_1a5e3f3949a9e6508fda31db7ac91b884f" name="find_last_of"><type>BidirectionalIterator1</type><template>
          <template-type-parameter name="BidirectionalIterator1"/>
          <template-type-parameter name="ForwardIterator2"/>
        </template><parameter name="first1"><paramtype>BidirectionalIterator1</paramtype><description><para>- first collection begin iterator </para></description></parameter><parameter name="last1"><paramtype>BidirectionalIterator1</paramtype><description><para>- first collection end iterator </para></description></parameter><parameter name="first2"><paramtype>ForwardIterator2</paramtype><description><para>- second collection begin iterator </para></description></parameter><parameter name="last2"><paramtype>ForwardIterator2</paramtype><description><para>- second collection end iterator </para></description></parameter><purpose>this algorithm search through first collection for last element that belongs to a second one </purpose><description><para>
</para></description></function>
<function id="doxygen.a00876_1a9e31135c9d9859151b904c3073ed828a" name="find_last_of"><type>BidirectionalIterator1</type><template>
          <template-type-parameter name="BidirectionalIterator1"/>
          <template-type-parameter name="ForwardIterator2"/>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="first1"><paramtype>BidirectionalIterator1</paramtype><description><para>- first collection begin iterator </para></description></parameter><parameter name="last1"><paramtype>BidirectionalIterator1</paramtype><description><para>- first collection end iterator </para></description></parameter><parameter name="first2"><paramtype>ForwardIterator2</paramtype><description><para>- second collection begin iterator </para></description></parameter><parameter name="last2"><paramtype>ForwardIterator2</paramtype><description><para>- second collection end iterator </para></description></parameter><parameter name="pred"><paramtype>Predicate</paramtype><description><para>- predicate to be used for search </para></description></parameter><purpose>this algorithm search through first collection for last element that satisfy binary predicate in conjunction will at least one element in second collection </purpose><description><para>
</para></description></function>
<function id="doxygen.a00876_1a8e39f3e99f1efc9dab17ddfb1548f50d" name="find_last_not_of"><type>BidirectionalIterator1</type><template>
          <template-type-parameter name="BidirectionalIterator1"/>
          <template-type-parameter name="ForwardIterator2"/>
        </template><parameter name="first1"><paramtype>BidirectionalIterator1</paramtype><description><para>- first collection begin iterator </para></description></parameter><parameter name="last1"><paramtype>BidirectionalIterator1</paramtype><description><para>- first collection end iterator </para></description></parameter><parameter name="first2"><paramtype>ForwardIterator2</paramtype><description><para>- second collection begin iterator </para></description></parameter><parameter name="last2"><paramtype>ForwardIterator2</paramtype><description><para>- second collection end iterator </para></description></parameter><purpose>this algorithm search through first collection for last element that does not belong to a second one </purpose><description><para>
</para></description></function>
<function id="doxygen.a00876_1a153dde6759367412ba25abe8af1bb85e" name="find_last_not_of"><type>BidirectionalIterator1</type><template>
          <template-type-parameter name="BidirectionalIterator1"/>
          <template-type-parameter name="ForwardIterator2"/>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="first1"><paramtype>BidirectionalIterator1</paramtype><description><para>- first collection begin iterator </para></description></parameter><parameter name="last1"><paramtype>BidirectionalIterator1</paramtype><description><para>- first collection end iterator </para></description></parameter><parameter name="first2"><paramtype>ForwardIterator2</paramtype><description><para>- second collection begin iterator </para></description></parameter><parameter name="last2"><paramtype>ForwardIterator2</paramtype><description><para>- second collection end iterator </para></description></parameter><parameter name="pred"><paramtype>Predicate</paramtype><description><para>- predicate to be used for search </para></description></parameter><purpose>this algorithm search through first collection for last element that does not satisfy binary predicate in conjunction will any element in second collection </purpose><description><para>
</para></description></function>
<function id="doxygen.a00876_1ab8a55970231d591e3855527a3a502041" name="replace_all_occurrences_of"><type>StringClass</type><template>
          <template-type-parameter name="StringClass"/>
          <template-type-parameter name="ForwardIterator"/>
        </template><parameter name="str"><paramtype>StringClass</paramtype><description><para>- string of operation </para></description></parameter><parameter name="first1"><paramtype>ForwardIterator</paramtype><description><para>- iterator to the beginning of the substrings to replace </para></description></parameter><parameter name="last1"><paramtype>ForwardIterator</paramtype><description><para>- iterator to the end of the substrings to replace </para></description></parameter><parameter name="first2"><paramtype>ForwardIterator</paramtype><description><para>- iterator to the beginning of the substrings to replace with </para></description></parameter><parameter name="last2"><paramtype>ForwardIterator</paramtype><description><para>- iterator to the end of the substrings to replace with </para></description></parameter><purpose>This algorithm replaces all occurrences of a set of substrings by another substrings. </purpose><description><para>
</para></description></function>
<function id="doxygen.a00876_1a9ac7f1f899c5ec66f603fcfe1ef073ef" name="replace_all_occurrences_with_wildcards"><type>StringClass</type><template>
          <template-type-parameter name="StringClass"/>
          <template-type-parameter name="ForwardIterator"/>
        </template><parameter name="str"><paramtype>StringClass</paramtype><description><para>- string to transform </para></description></parameter><parameter name="it_string_to_find"><paramtype>ForwardIterator</paramtype><description><para>- iterator to the beginning of the substrings to replace </para></description></parameter><parameter name="it_string_to_find_end"><paramtype>ForwardIterator</paramtype><description><para>- iterator to the end of the substrings to replace </para></description></parameter><parameter name="it_string_to_replace"><paramtype>ForwardIterator</paramtype><description><para>- iterator to the beginning of the substrings to replace with </para></description></parameter><parameter name="it_string_to_replace_end"><paramtype>ForwardIterator</paramtype><description><para>- iterator to the end of the substrings to replace with</para></description></parameter><purpose>This algorithm replaces all occurrences of a string with basic wildcards with another (optionally containing wildcards as well). </purpose><description><para>
The wildcard is the symbol '*'. Only a unique wildcard per string is supported. The replacement string may also contain a wildcard, in which case it is considered as a placeholder to the content of the wildcard in the source string. Example:<itemizedlist>
<listitem><para>In order to replace the occurrences of <computeroutput>'time="some-variable-value"'</computeroutput> to a constant string, one may use <computeroutput>'time="*"'</computeroutput> as the string to search for, and 'time="0.0"' as the replacement string.</para>
</listitem><listitem><para>In order to replace the occurrences of 'file.cpp(XX)' per 'file.cpp:XX', where XX is a variable to keep, on may use <computeroutput>'file.cpp(*)'</computeroutput> as the string to search for, and 'file.cpp:*' as the replacement string. </para>
</listitem></itemizedlist>
</para></description></function>
</namespace>






</namespace>
</namespace>
<macro id="doxygen.a00824_1a7917b4e3c6d442950e28e95852afa6b7" name="BOOST_TEST_BIND1ST" kind="functionlike"><macro-parameter name="F"/><macro-parameter name="A"/></macro>
</header>
<header id="doxygen.a00833" name="boost/test/utils/is_forward_iterable.hpp">
<para>Defines the is_forward_iterable collection type trait. </para><namespace name="boost">
<namespace name="unit_test">
<struct id="doxygen.a01392" name="bt_iterator_traits"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="is_forward_iterable"><type>bool</type><default>is_forward_iterable&lt;T&gt;::value</default></template-nontype-parameter>
    </template><purpose>Helper structure for accessing the content of a container or an array. </purpose></struct><struct-specialization id="doxygen.a01396" name="bt_iterator_traits"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>true</template-arg></specialization><typedef id="doxygen.a01396_1a661e16514b7a2d6b6a45e7289f5bf9a3" name="const_iterator"><type>decltype(boost::declval&lt; typename boost::add_const&lt; typename boost::remove_reference&lt; T &gt;::type &gt;::type &gt;().begin())</type></typedef>
<typedef id="doxygen.a01396_1a2489da4b996f4fc33d16a5bf2736bcf9" name="value_type"><type>std::iterator_traits&lt; const_iterator &gt;::value_type</type></typedef>
<method-group name="public member functions">
<method id="doxygen.a01396_1a5eb821efb26679bc4d78e1b41a76026f" name="BOOST_STATIC_ASSERT"><type/><parameter name=""><paramtype>(<classname>is_forward_iterable</classname>&lt; T &gt;::value)</paramtype></parameter></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.a01396_1a3467856159acb5e3099eb3e3134c5c68" name="begin" specifiers="static"><type>const_iterator</type><parameter name="container"><paramtype>T const &amp;</paramtype></parameter></method>
<method id="doxygen.a01396_1a7a34c4f54263a9242875d197335f6db0" name="end" specifiers="static"><type>const_iterator</type><parameter name="container"><paramtype>T const &amp;</paramtype></parameter></method>
<method id="doxygen.a01396_1a20681f143477229518f411c9ec0d0953" name="size" specifiers="static"><type>std::size_t</type><parameter name="container"><paramtype>T const &amp;</paramtype></parameter></method>
</method-group>
<method-group name="private static functions">
<method id="doxygen.a01396_1afd31be9c9cebcf6bb6aec289acbd72ad" name="size" specifiers="static"><type>std::size_t</type><parameter name="container"><paramtype>T const &amp;</paramtype></parameter><parameter name=""><paramtype>std::true_type</paramtype></parameter></method>
<method id="doxygen.a01396_1a2f633e260cfe18cfd05154592c34f79a" name="size" specifiers="static"><type>std::size_t</type><parameter name="container"><paramtype>T const &amp;</paramtype></parameter><parameter name=""><paramtype>std::false_type</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization id="doxygen.a01400" name="bt_iterator_traits"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="N"><type>std::size_t</type></template-nontype-parameter>
    </template><specialization><template-arg>T[N]</template-arg><template-arg>true</template-arg></specialization><typedef id="doxygen.a01400_1a6e948d740104e5307f596eaa91b1b5e2" name="T_const"><type>boost::add_const&lt; T &gt;::type</type></typedef>
<typedef id="doxygen.a01400_1a5f8ca1437da9512a003b0deda2bbf119" name="const_iterator"><type>boost::add_pointer&lt; T_const &gt;::type</type></typedef>
<typedef id="doxygen.a01400_1ab056f4aa7d7a46ec87a9f6ea49d7bb0d" name="value_type"><type>T</type></typedef>
<method-group name="public static functions">
<method id="doxygen.a01400_1a26db132b0c71436ec71b330bfb85af66" name="begin" specifiers="static"><type>const_iterator</type><parameter name="array"><paramtype>T_const(&amp;)</paramtype></parameter></method>
<method id="doxygen.a01400_1ae8e58c03c7425b574fa6a7189bd9325d" name="end" specifiers="static"><type>const_iterator</type><parameter name="array"><paramtype>T_const(&amp;)</paramtype></parameter></method>
<method id="doxygen.a01400_1aaa8835e41e908cd8c9e4f56d841dfb57" name="size" specifiers="static"><type>std::size_t</type><parameter name=""><paramtype>T_const(&amp;)</paramtype></parameter></method>
</method-group>
</struct-specialization><struct id="doxygen.a01388" name="is_container_forward_iterable"><template>
      <template-type-parameter name="T"/>
    </template><description><para>Indicates that a specific type implements the forward iterable concept. </para></description><enum id="doxygen.a01388_1ab84cd6d5e9ee03670afdd0db2dee8b6b" name=""><enumvalue id="doxygen.a01388_1ab84cd6d5e9ee03670afdd0db2dee8b6ba311bbcd8c3d46ca3580b72d0588677fc" name="value"><default>is_fwd_it_t::value</default></enumvalue></enum>
<typedef id="doxygen.a01388_1a1a9f34de29b3c900dc1786db25fd4b0b" name="T_ref"><type>std::remove_reference&lt; T &gt;::type</type></typedef>
<typedef id="doxygen.a01388_1acd80d3a2f9ade5db2ff8e7cba201aced" name="is_fwd_it_t"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.a01388_1a0c7f1dc9567aec06be5a0e1ec61a45c7" name="type"><type>mpl::bool_&lt; is_fwd_it_t::value &gt;</type></typedef>
</struct><struct id="doxygen.a01340" name="is_forward_iterable"><template>
      <template-type-parameter name="T"/>
    </template><description><para>Indicates that a specific type implements the forward iterable concept. </para></description><enum id="doxygen.a01340_1a7227c484c23196fd8d148d261f2b3847" name=""><enumvalue id="doxygen.a01340_1a7227c484c23196fd8d148d261f2b3847ae721d5b61adac3c01b6ffedb6bf067a1" name="value"><default>is_fwd_it_t::value</default></enumvalue></enum>
<typedef id="doxygen.a01340_1a942c33e154a2a670ac0802ca08632b78" name="T_ref"><type>std::remove_reference&lt; T &gt;::type</type></typedef>
<typedef id="doxygen.a01340_1a75f1777f78aaf37bf1d9b6f0a8af8d43" name="is_fwd_it_t"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.a01340_1a02dca1429f3525a18e6e720947df42f3" name="type"><type>mpl::bool_&lt; is_fwd_it_t::value &gt;</type></typedef>
</struct>





</namespace>
</namespace>
</header>
<header id="doxygen.a00827" name="boost/test/utils/named_params.hpp">
<namespace name="boost">
<namespace name="nfp">
<struct id="doxygen.a01272" name="has_param"><template>
      <template-type-parameter name="NP"/>
      <template-type-parameter name="Keyword"/>
    </template><inherit access="public">is_same&lt; NP::id, Keyword::id &gt;</inherit><purpose>has_param&lt;Params,Keyword&gt;::value is true if Params has parameter corresponding to the Keyword </purpose></struct><struct-specialization id="doxygen.a01276" name="has_param"><template>
      <template-type-parameter name="NP"/>
      <template-type-parameter name="Rest"/>
      <template-type-parameter name="Keyword"/>
    </template><specialization><template-arg>named_parameter_combine&lt; NP</template-arg><template-arg>Rest &gt;</template-arg><template-arg>Keyword</template-arg></specialization><inherit access="public">mpl::or_&lt; is_same&lt; NP::id, Keyword::id &gt;::type, has_param&lt; Rest, Keyword &gt;::type &gt;</inherit></struct-specialization><struct id="doxygen.a01252" name="is_named_param_pack"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">mpl::false_</inherit><purpose>is_named_param_pack&lt;T&gt;::value is true if T is parameters pack </purpose></struct><struct-specialization id="doxygen.a01256" name="is_named_param_pack"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="unique_id"/>
      <template-type-parameter name="RefType"/>
    </template><specialization><template-arg>named_parameter&lt; T</template-arg><template-arg>unique_id</template-arg><template-arg>RefType &gt;</template-arg></specialization><inherit access="public">mpl::true_</inherit></struct-specialization><struct-specialization id="doxygen.a01260" name="is_named_param_pack"><template>
      <template-type-parameter name="NP"/>
      <template-type-parameter name="Rest"/>
    </template><specialization><template-arg>named_parameter_combine&lt; NP</template-arg><template-arg>Rest &gt;</template-arg></specialization><inherit access="public">mpl::true_</inherit></struct-specialization><struct id="doxygen.a01236" name="keyword"><template>
      <template-type-parameter name="unique_id"/>
      <template-nontype-parameter name="required"><type>bool</type><default>false</default></template-nontype-parameter>
    </template><typedef id="doxygen.a01236_1ac0c42909948befb135883778c9648de7" name="id"><type>unique_id</type></typedef>
<method-group name="public member functions">
<copy-assignment id="doxygen.a01236_1a3c8e14b6fa15103f67c1dfffdc5ca16f" cv="const"><type><classname>named_parameter</classname>&lt; T const, unique_id &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></copy-assignment>
<copy-assignment id="doxygen.a01236_1ae01a75122af3c8b78bc1b725e519215c" cv="const"><type><classname>named_parameter</classname>&lt; T, unique_id &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></copy-assignment>
<copy-assignment id="doxygen.a01236_1a30e23c87b4d728f8a2f3de8e81ab91d5" cv="const"><type><classname>named_parameter</classname>&lt; char const *, unique_id, char const * &gt;</type><parameter name="t"><paramtype>char const *</paramtype></parameter></copy-assignment>
</method-group>
</struct><struct id="doxygen.a01244" name="named_parameter"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="unique_id"/>
      <template-type-parameter name="RefType"/>
    </template><typedef id="doxygen.a01244_1a289b3a22e9f93a7c73af268032b831e1" name="data_type"><type>T</type></typedef>
<typedef id="doxygen.a01244_1a01104c14233f21cc4455b065671f68fe" name="ref_type"><type>RefType</type></typedef>
<typedef id="doxygen.a01244_1a1791f176e29b1de4d6f97442dd0c514c" name="id"><type>unique_id</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.a01244_1ae15fcc86405e893bb4ff96cfb4bad7a8" specifiers="explicit"><parameter name="v"><paramtype>ref_type</paramtype></parameter></constructor>
<constructor id="doxygen.a01244_1ae1e1d816a9a15dd7edfcb34931739fb0"><parameter name="np"><paramtype><classname>named_parameter</classname> const &amp;</paramtype></parameter></constructor>
<method id="doxygen.a01244_1a65995f6572048ddac7a9c3a93b58c23f" name="operator[]" cv="const"><type>ref_type</type><parameter name=""><paramtype><classname>keyword</classname>&lt; unique_id, true &gt;</paramtype></parameter></method>
<method id="doxygen.a01244_1a8982bbebd02d65464a8310a0f1964514" name="operator[]" cv="const"><type>ref_type</type><parameter name=""><paramtype><classname>keyword</classname>&lt; unique_id, false &gt;</paramtype></parameter></method>
<method id="doxygen.a01244_1a4eb1e8400330b3dc89b41c91986f2564" name="operator[]" cv="const"><type><classname>nil</classname></type><template>
          <template-type-parameter name="UnknownId"/>
        </template><parameter name=""><paramtype><classname>keyword</classname>&lt; UnknownId, false &gt;</paramtype></parameter></method>
<method id="doxygen.a01244_1a2c5c783a223f7217f85fe15ae83199e8" name="has" cv="const"><type>bool</type><parameter name=""><paramtype><classname>keyword</classname>&lt; unique_id, false &gt;</paramtype></parameter></method>
<method id="doxygen.a01244_1ab89f3f555f85f8bbd1ea796fbf8a6272" name="has" cv="const"><type>bool</type><template>
          <template-type-parameter name="UnknownId"/>
        </template><parameter name=""><paramtype><classname>keyword</classname>&lt; UnknownId, false &gt;</paramtype></parameter></method>
<method id="doxygen.a01244_1a00b0f2bc8f979098c055b56e8fbf4a46" name="erase" cv="const"><type>void</type><parameter name=""><paramtype><classname>keyword</classname>&lt; unique_id, false &gt;</paramtype></parameter></method>
<method id="doxygen.a01244_1acb4c8f665f428dee55d9d5df23cdd93d" name="erase" cv="const"><type>void</type><template>
          <template-type-parameter name="UnknownId"/>
        </template><parameter name=""><paramtype><classname>keyword</classname>&lt; UnknownId, false &gt;</paramtype></parameter></method>
<method id="doxygen.a01244_1a709f2608c6f0b1a545d2cc9a6df2d0d5" name="apply_to" cv="const"><type>void</type><template>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="V"><paramtype>Visitor &amp;</paramtype></parameter></method>
<method name="operator," cv="const"><type><classname>named_parameter_combine</classname>&lt; NP, <classname>named_parameter</classname>&lt; T, unique_id, RefType &gt; &gt;</type><parameter name="np"><paramtype>NP const &amp;</paramtype></parameter></method>
</method-group>
</struct><struct id="doxygen.a01248" name="named_parameter_combine"><template>
      <template-type-parameter name="NP"/>
      <template-type-parameter name="Rest"><default>nil</default></template-type-parameter>
    </template><inherit access="public">boost::nfp::nil</inherit><typedef id="doxygen.a01248_1a20671017fbc2ae7df9396e18e94695fb" name="res_type"><type>NP::ref_type</type></typedef>
<typedef id="doxygen.a01248_1a114dc592b45ae13abafe8ef994aadb6a" name="self_type"><type><classname>named_parameter_combine</classname>&lt; NP, Rest &gt;</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.a01248_1a0fa220c79f3d76cc27ec82be13c339f7"><parameter name="np"><paramtype>NP const &amp;</paramtype></parameter><parameter name="r"><paramtype>Rest const &amp;</paramtype></parameter></constructor>
<method id="doxygen.a01248_1af0ef5d489d94c022daa5fc6495b2ac5f" name="operator[]" cv="const"><type>res_type</type><parameter name="kw"><paramtype><classname>keyword</classname>&lt; typename NP::id, true &gt;</paramtype></parameter></method>
<method id="doxygen.a01248_1a0436cbce4d5e9856162efcab355023c5" name="operator[]" cv="const"><type>res_type</type><parameter name="kw"><paramtype><classname>keyword</classname>&lt; typename NP::id, false &gt;</paramtype></parameter></method>
<method id="doxygen.a01248_1aa6b924fd801b9649b714a91de8fb0e23" name="has" cv="const"><type>bool</type><parameter name="kw"><paramtype><classname>keyword</classname>&lt; typename NP::id, false &gt;</paramtype></parameter></method>
<method id="doxygen.a01248_1a7670dbffb06a0ee2e425469f8b038630" name="erase" cv="const"><type>void</type><parameter name="kw"><paramtype><classname>keyword</classname>&lt; typename NP::id, false &gt;</paramtype></parameter></method>
<method id="doxygen.a01248_1a58e5d73ace17267fd45ba8d61cb946c7" name="apply_to" cv="const"><type>void</type><template>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="V"><paramtype>Visitor &amp;</paramtype></parameter></method>
<method name="conversion-operator" cv="const"><type>T const &amp;</type><template>
          <template-type-parameter name="T"/>
        </template></method>
<method name="any_cast" cv="const"><type>T</type><template>
          <template-type-parameter name="T"/>
        </template></method>
<method name="operator()"><type><classname>nil</classname></type><template>
          <template-type-parameter name="Arg1"/>
        </template><parameter name=""><paramtype>Arg1 const &amp;</paramtype></parameter></method>
<method name="operator()"><type><classname>nil</classname></type><template>
          <template-type-parameter name="Arg1"/>
          <template-type-parameter name="Arg2"/>
        </template><parameter name=""><paramtype>Arg1 const &amp;</paramtype></parameter><parameter name=""><paramtype>Arg2 const &amp;</paramtype></parameter></method>
<method name="operator()"><type><classname>nil</classname></type><template>
          <template-type-parameter name="Arg1"/>
          <template-type-parameter name="Arg2"/>
          <template-type-parameter name="Arg3"/>
        </template><parameter name=""><paramtype>Arg1 const &amp;</paramtype></parameter><parameter name=""><paramtype>Arg2 const &amp;</paramtype></parameter><parameter name=""><paramtype>Arg3 const &amp;</paramtype></parameter></method>
<method name="operator," cv="const"><type><classname>named_parameter_combine</classname>&lt; NP, <classname>named_parameter_combine</classname>&lt; NP, <classname>nil</classname> &gt; &gt;</type><parameter name="np"><paramtype>NP const &amp;</paramtype></parameter></method>
</method-group>
<method-group name="public static functions">
<method name="inst" specifiers="static"><type><classname>nil</classname> &amp;</type></method>
</method-group>
</struct><struct id="doxygen.a01284" name="nil"><method-group name="public member functions">
<method id="doxygen.a01284_1aeba0863e687f41e206a6614bdbe1288d" name="conversion-operator" cv="const"><type>T const &amp;</type><template>
          <template-type-parameter name="T"/>
        </template></method>
<method id="doxygen.a01284_1a1aedf6268d25078ac7c52219013baf4d" name="any_cast" cv="const"><type>T</type><template>
          <template-type-parameter name="T"/>
        </template></method>
<method id="doxygen.a01284_1aa7d8a426f7ce1235b9423929c52266a5" name="operator()"><type><classname>nil</classname></type><template>
          <template-type-parameter name="Arg1"/>
        </template><parameter name=""><paramtype>Arg1 const &amp;</paramtype></parameter></method>
<method id="doxygen.a01284_1aa76043d7efd27a3eb18de7da3c493b8e" name="operator()"><type><classname>nil</classname></type><template>
          <template-type-parameter name="Arg1"/>
          <template-type-parameter name="Arg2"/>
        </template><parameter name=""><paramtype>Arg1 const &amp;</paramtype></parameter><parameter name=""><paramtype>Arg2 const &amp;</paramtype></parameter></method>
<method id="doxygen.a01284_1a42aaa04bf7dba69db02c631bf5486ad4" name="operator()"><type><classname>nil</classname></type><template>
          <template-type-parameter name="Arg1"/>
          <template-type-parameter name="Arg2"/>
          <template-type-parameter name="Arg3"/>
        </template><parameter name=""><paramtype>Arg1 const &amp;</paramtype></parameter><parameter name=""><paramtype>Arg2 const &amp;</paramtype></parameter><parameter name=""><paramtype>Arg3 const &amp;</paramtype></parameter></method>
<method id="doxygen.a01284_1ada2f69669510381a1757893698fe7a90" name="apply_to" cv="const"><type>void</type><template>
          <template-type-parameter name="Visitor"/>
        </template><parameter name=""><paramtype>Visitor &amp;</paramtype></parameter></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.a01284_1ada4fd2e16626ae6280fc58ec920b4d5f" name="inst" specifiers="static"><type><classname>nil</classname> &amp;</type></method>
</method-group>
<method-group name="private member functions">
<constructor id="doxygen.a01284_1ad6465fc0ffb81c5da5992375495b6c50"/>
</method-group>
</struct><struct id="doxygen.a01264" name="param_type"><template>
      <template-type-parameter name="NP"/>
      <template-type-parameter name="Keyword"/>
      <template-type-parameter name="DefaultType"><default>void</default></template-type-parameter>
    </template><inherit access="public">mpl::if_&lt; is_same&lt; NP::id, Keyword::id &gt;::type, remove_cv&lt; NP::data_type &gt;::type, void &gt;</inherit><purpose>param_type&lt;Params,Keyword,Default&gt;::type is the type of the parameter corresponding to the Keyword (if parameter is present) or Default </purpose></struct><struct-specialization id="doxygen.a01268" name="param_type"><template>
      <template-type-parameter name="NP"/>
      <template-type-parameter name="Rest"/>
      <template-type-parameter name="Keyword"/>
      <template-type-parameter name="DefaultType"/>
    </template><specialization><template-arg>named_parameter_combine&lt; NP</template-arg><template-arg>Rest &gt;</template-arg><template-arg>Keyword</template-arg><template-arg>DefaultType</template-arg></specialization><inherit access="public">mpl::if_&lt; is_same&lt; NP::id, Keyword::id &gt;::type, remove_cv&lt; NP::data_type &gt;::type, param_type&lt; Rest, Keyword, DefaultType &gt;::type &gt;</inherit></struct-specialization><struct id="doxygen.a01240" name="typed_keyword"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="unique_id"/>
      <template-nontype-parameter name="required"><type>bool</type></template-nontype-parameter>
    </template><inherit access="public">boost::nfp::keyword&lt; unique_id, required &gt;</inherit><method-group name="public member functions">
<copy-assignment id="doxygen.a01240_1a6a76d3b9a2771b2f6d53303813efc8e2" cv="const"><type><classname>named_parameter</classname>&lt; T const, unique_id &gt;</type><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></copy-assignment>
<copy-assignment id="doxygen.a01240_1ac0151a1556fe126b5fd7d023e48a9899" cv="const"><type><classname>named_parameter</classname>&lt; T, unique_id &gt;</type><parameter name="t"><paramtype>T &amp;</paramtype></parameter></copy-assignment>
</method-group>
<typedef name="id"><type>unique_id</type></typedef>
</struct><struct-specialization id="doxygen.a01292" name="typed_keyword"><template>
      <template-type-parameter name="unique_id"/>
      <template-nontype-parameter name="required"><type>bool</type></template-nontype-parameter>
    </template><specialization><template-arg>bool</template-arg><template-arg>unique_id</template-arg><template-arg>required</template-arg></specialization><inherit access="public">boost::nfp::keyword&lt; unique_id, required &gt;</inherit><inherit access="public">boost::nfp::named_parameter&lt; bool, unique_id, bool &gt;</inherit><typedef id="doxygen.a01292_1a8f1410deac22d6cd64ca3ab2a4ce6935" name="id"><type>unique_id</type></typedef>
<typedef name="data_type"><type>bool</type></typedef>
<typedef name="ref_type"><type>bool</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.a01292_1afe0ba35c85e1f3f0355b78e95e639813"/>
<method id="doxygen.a01292_1aaf784a75d8dd96272adf9296d23b675e" name="operator!" cv="const"><type><classname>named_parameter</classname>&lt; bool, unique_id, bool &gt;</type></method>
<method name="operator[]" cv="const"><type>ref_type</type><parameter name=""><paramtype><classname>keyword</classname>&lt; unique_id, true &gt;</paramtype></parameter></method>
<method name="operator[]" cv="const"><type>ref_type</type><parameter name=""><paramtype><classname>keyword</classname>&lt; unique_id, false &gt;</paramtype></parameter></method>
<method name="operator[]" cv="const"><type><classname>nil</classname></type><parameter name=""><paramtype><classname>keyword</classname>&lt; UnknownId, false &gt;</paramtype></parameter></method>
<method name="has" cv="const"><type>bool</type><parameter name=""><paramtype><classname>keyword</classname>&lt; unique_id, false &gt;</paramtype></parameter></method>
<method name="has" cv="const"><type>bool</type><parameter name=""><paramtype><classname>keyword</classname>&lt; UnknownId, false &gt;</paramtype></parameter></method>
<method name="erase" cv="const"><type>void</type><parameter name=""><paramtype><classname>keyword</classname>&lt; unique_id, false &gt;</paramtype></parameter></method>
<method name="erase" cv="const"><type>void</type><parameter name=""><paramtype><classname>keyword</classname>&lt; UnknownId, false &gt;</paramtype></parameter></method>
<method name="apply_to" cv="const"><type>void</type><parameter name="V"><paramtype>Visitor &amp;</paramtype></parameter></method>
<method name="operator," cv="const"><type><classname>named_parameter_combine</classname>&lt; NP, <classname>named_parameter</classname>&lt; bool, unique_id, bool &gt; &gt;</type><parameter name="np"><paramtype>NP const &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><typedef id="doxygen.a00877_1a8265f9a9cd56dcdb61ff5a3f81fca790" name="no_params_type"><type><classname>named_parameter</classname>&lt; char, struct no_params_type_t, char &gt;</type></typedef>
<function id="doxygen.a00877_1adb0ae577de32dc11161ac04d4c4cff07" name="opt_assign"><type>enable_if_c&lt;!<classname>has_param</classname>&lt; Params, Keyword &gt;::value, void &gt;::type</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Params"/>
          <template-type-parameter name="Keyword"/>
        </template><parameter name=""><paramtype>T &amp;</paramtype></parameter><parameter name=""><paramtype>Params const &amp;</paramtype></parameter><parameter name=""><paramtype>Keyword</paramtype></parameter></function>
<function id="doxygen.a00877_1a62fce83667fd3dec90b5e44b0522400d" name="opt_assign"><type>enable_if_c&lt; <classname>has_param</classname>&lt; Params, Keyword &gt;::value, void &gt;::type</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Params"/>
          <template-type-parameter name="Keyword"/>
        </template><parameter name="target"><paramtype>T &amp;</paramtype></parameter><parameter name="p"><paramtype>Params const &amp;</paramtype></parameter><parameter name="k"><paramtype>Keyword</paramtype></parameter></function>
<function id="doxygen.a00877_1a24f4ec90ae96073d366799fee7df8f9c" name="opt_get"><type>T</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Params"/>
          <template-type-parameter name="Keyword"/>
        </template><parameter name="p"><paramtype>Params const &amp;</paramtype></parameter><parameter name="k"><paramtype>Keyword</paramtype></parameter><parameter name="default_val"><paramtype>T</paramtype></parameter></function>
<function id="doxygen.a00877_1a81298b80f7ea1d395b7586eb8e4717b6" name="opt_append"><type>enable_if_c&lt;!<classname>has_param</classname>&lt; Params, <classname>keyword</classname>&lt; typenameNP::id &gt; &gt;::value, <classname>named_parameter_combine</classname>&lt; NP, Params &gt; &gt;::type</type><template>
          <template-type-parameter name="Params"/>
          <template-type-parameter name="NP"/>
        </template><parameter name="params"><paramtype>Params const &amp;</paramtype></parameter><parameter name="np"><paramtype>NP const &amp;</paramtype></parameter></function>
<function id="doxygen.a00877_1ad314434f443a5c08fdd8684859a078bd" name="opt_append"><type>enable_if_c&lt; <classname>has_param</classname>&lt; Params, <classname>keyword</classname>&lt; typenameNP::id &gt; &gt;::value, Params &gt;::type</type><template>
          <template-type-parameter name="Params"/>
          <template-type-parameter name="NP"/>
        </template><parameter name="params"><paramtype>Params const &amp;</paramtype></parameter><parameter name=""><paramtype>NP const &amp;</paramtype></parameter></function>
</namespace>
</namespace>
</header>
</library-reference>