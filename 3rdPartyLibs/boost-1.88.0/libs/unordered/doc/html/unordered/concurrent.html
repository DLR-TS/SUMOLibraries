<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Concurrent Containers :: Boost.Unordered</title>
    <meta name="generator" content="Antora 3.1.10">
    <link rel="stylesheet" href="../unordered/_/css/site.css">
  </head>
  <body class="article">
<div class="body">
<div class="nav-container" data-component="unordered" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="intro.html">Boost.Unordered</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="intro.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="buckets.html">Basics of Hash Tables</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="hash_equality.html">Equality Predicates and Hash Functions</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="regular.html">Regular Containers</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="concurrent.html">Concurrent Containers</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="hash_quality.html">Hash Quality</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="compliance.html">Standard Compliance</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="structures.html">Data Structures</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="debuggability.html">Debuggability</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="benchmarks.html">Benchmarks</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="rationale.html">Implementation Rationale</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="ref.html">Reference</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_map_fwd.html"><code>&lt;boost/unordered/unordered_map_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_map_top.html"><code>&lt;boost/unordered_map.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_map.html"><code>&lt;boost/unordered/unordered_map.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/unordered_map.html"><code>unordered_map</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/unordered_multimap.html"><code>unordered_multimap</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_set_fwd.html"><code>&lt;boost/unordered/unordered_set_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_set_top.html"><code>&lt;boost/unordered_set.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_set.html"><code>&lt;boost/unordered/unordered_set.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/unordered_set.html"><code>unordered_set</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/unordered_multiset.html"><code>unordered_multiset</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/hash_traits.html">Hash Traits</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/stats.html">Statistics</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_flat_map_fwd.html"><code>&lt;boost/unordered/unordered_flat_map_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_flat_map.html"><code>&lt;boost/unordered/unordered_flat_map.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/unordered_flat_map.html"><code>unordered_flat_map</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_flat_set_fwd.html"><code>&lt;boost/unordered/unordered_flat_set_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_flat_set.html"><code>&lt;boost/unordered/unordered_flat_set.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/unordered_flat_set.html"><code>unordered_flat_set</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_node_map_fwd.html"><code>&lt;boost/unordered/unordered_node_map_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_node_map.html"><code>&lt;boost/unordered/unordered_node_map.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/unordered_node_map.html"><code>unordered_node_map</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_node_set_fwd.html"><code>&lt;boost/unordered/unordered_node_set_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_node_set.html"><code>&lt;boost/unordered/unordered_node_set.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/unordered_node_set.html"><code>unordered_node_set</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_concurrent_flat_map_fwd.html"><code>&lt;boost/unordered/concurrent_flat_map_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_concurrent_flat_map.html"><code>&lt;boost/unordered/concurrent_flat_map.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/concurrent_flat_map.html"><code>concurrent_flat_map</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_concurrent_flat_set_fwd.html"><code>&lt;boost/unordered/concurrent_flat_set_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_concurrent_flat_set.html"><code>&lt;boost/unordered/concurrent_flat_set.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/concurrent_flat_set.html"><code>concurrent_flat_set</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_concurrent_node_map_fwd.html"><code>&lt;boost/unordered/concurrent_node_map_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_concurrent_node_map.html"><code>&lt;boost/unordered/concurrent_node_map.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/concurrent_node_map.html"><code>concurrent_node_map</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_concurrent_node_set_fwd.html"><code>&lt;boost/unordered/concurrent_node_set_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_concurrent_node_set.html"><code>&lt;boost/unordered/concurrent_node_set.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/concurrent_node_set.html"><code>concurrent_node_set</code></a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="changes.html">Change Log</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="bibliography.html">Bibliography</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="copyright.html">Copyright and License</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="intro.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="intro.html">Boost.Unordered</a></li>
    <li><a href="concurrent.html">Concurrent Containers</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Concurrent Containers</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Boost.Unordered provides <code>boost::concurrent_node_set</code>, <code>boost::concurrent_node_map</code>,
<code>boost::concurrent_flat_set</code> and <code>boost::concurrent_flat_map</code>,
hash tables that allow concurrent write/read access from
different threads without having to implement any synchronzation mechanism on the user&#8217;s side.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::vector&lt;int&gt;                    input;
boost::concurrent_flat_map&lt;int,int&gt; m;

...

// process input in parallel
const int                 num_threads = 8;
std::vector&lt;std::jthread&gt; threads;
std::size_t               chunk = input.size() / num_threads; // how many elements per thread

for (int i = 0; i &lt; num_threads; ++i) {
  threads.emplace_back([&amp;,i] {
    // calculate the portion of input this thread takes care of
    std::size_t start = i * chunk;
    std::size_t end = (i == num_threads - 1)? input.size(): (i + 1) * chunk;

    for (std::size_t n = start; n &lt; end; ++n) {
      m.emplace(input[n], calculation(input[n]));
    }
  });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, threads access <code>m</code> without synchronization, just as we&#8217;d do in a
single-threaded scenario. In an ideal setting, if a given workload is distributed among
<em>N</em> threads, execution is <em>N</em> times faster than with one thread —this limit is
never attained in practice due to synchronization overheads and <em>contention</em> (one thread
waiting for another to leave a locked portion of the map), but Boost.Unordered concurrent containers
are designed to perform with very little overhead and typically achieve <em>linear scaling</em>
(that is, performance is proportional to the number of threads up to the number of
logical cores in the CPU).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="concurrent_visitation_based_api"><a class="anchor" href="#concurrent_visitation_based_api"></a>Visitation-based API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The first thing a new user of Boost.Unordered concurrent containers
will notice is that these classes <em>do not provide iterators</em> (which makes them technically
not <a href="https://en.cppreference.com/w/cpp/named_req/Container" target="_blank" rel="noopener">Containers</a>
in the C++ standard sense). The reason for this is that iterators are inherently
thread-unsafe. Consider this hypothetical code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">auto it = m.find(k);  // A: get an iterator pointing to the element with key k
if (it != m.end() ) {
  some_function(*it); // B: use the value of the element
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In a multithreaded scenario, the iterator <code>it</code> may be invalid at point B if some other
thread issues an <code>m.erase(k)</code> operation between A and B. There are designs that
can remedy this by making iterators lock the element they point to, but this
approach lends itself to high contention and can easily produce deadlocks in a program.
<code>operator[]</code> has similar concurrency issues, and is not provided by
<code>boost::concurrent_flat_map</code>/<code>boost::concurrent_node_map</code> either. Instead, element access is done through
so-called <em>visitation functions</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">m.visit(k, [](const auto&amp; x) { // x is the element with key k (if it exists)
  some_function(x);            // use it
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>The visitation function passed by the user (in this case, a lambda function)
is executed internally by Boost.Unordered in
a thread-safe manner, so it can access the element without worrying about other
threads interfering in the process.</p>
</div>
<div class="paragraph">
<p>On the other hand, a visitation function can <em>not</em> access the container itself:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">m.visit(k, [&amp;](const auto&amp; x) {
  some_function(x, m.size()); // forbidden: m can't be accessed inside visitation
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Access to a different container is allowed, though:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">m.visit(k, [&amp;](const auto&amp; x) {
  if (some_function(x)) {
    m2.insert(x); // OK, m2 is a different boost::concurrent_flat_map
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>But, in general, visitation functions should be as lightweight as possible to
reduce contention and increase parallelization. In some cases, moving heavy work
outside of visitation may be beneficial:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::optional&lt;value_type&gt; o;
bool found = m.visit(k, [&amp;](const auto&amp; x) {
  o = x;
});
if (found) {
  some_heavy_duty_function(*o);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Visitation is prominent in the API provided by concurrent containers, and
many classical operations have visitation-enabled variations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">m.insert_or_visit(x, [](auto&amp; y) {
  // if insertion failed because of an equivalent element y,
  // do something with it, for instance:
  ++y.second; // increment the mapped part of the element
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that in this last example the visitation function could actually <em>modify</em>
the element: as a general rule, operations on a concurrent map <code>m</code>
will grant visitation functions const/non-const access to  the element depending on whether
<code>m</code> is const/non-const. Const access can be always be explicitly requested
by using <code>cvisit</code> overloads (for instance, <code>insert_or_cvisit</code>) and may result
in higher parallelization. For concurrent sets, on the other hand,
visitation is always const access.</p>
</div>
<div class="paragraph">
<p>Although expected to be used much less frequently, concurrent containers
also provide insertion operations where an element can be visited right after
element creation (in addition to the usual visitation when an equivalent
element already exists):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">  m.insert_and_cvisit(x,
    [](const auto&amp; y) {
      std::cout&lt;&lt; "(" &lt;&lt; y.first &lt;&lt; ", " &lt;&lt; y.second &lt;&lt;") inserted\n";
    },
    [](const auto&amp; y) {
      std::cout&lt;&lt; "(" &lt;&lt; y.first &lt;&lt; ", " &lt;&lt; y.second &lt;&lt; ") already exists\n";
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>Consult the references of
<code><a href="reference/concurrent_node_set.html#concurrent_node_set" class="xref page">boost::concurrent_node_set</a></code>,
<code><a href="reference/concurrent_node_map.html#concurrent_node_map" class="xref page">boost::concurrent_node_map</a></code>,
<code><a href="reference/concurrent_flat_set.html#concurrent_flat_set" class="xref page">boost::concurrent_flat_set</a></code> and
<code><a href="reference/concurrent_flat_map.html#concurrent_flat_map" class="xref page">boost::concurrent_flat_map</a></code>
for the complete list of visitation-enabled operations.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="concurrent_whole_table_visitation"><a class="anchor" href="#concurrent_whole_table_visitation"></a>Whole-Table Visitation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the absence of iterators, <code>visit_all</code> is provided
as an alternative way to process all the elements in the container:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">m.visit_all([](auto&amp; x) {
  x.second = 0; // reset the mapped part of the element
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>In C++17 compilers implementing standard parallel algorithms, whole-table
visitation can be parallelized:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">m.visit_all(std::execution::par, [](auto&amp; x) { // run in parallel
  x.second = 0; // reset the mapped part of the element
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Traversal can be interrupted midway:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">// finds the key to a given (unique) value

int  key = 0;
int  value = ...;
bool found = !m.visit_while([&amp;](const auto&amp; x) {
  if(x.second == value) {
    key = x.first;
    return false; // finish
  }
  else {
    return true;  // keep on visiting
  }
});

if(found) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is one last whole-table visitation operation, <code>erase_if</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">m.erase_if([](auto&amp; x) {
  return x.second == 0; // erase the elements whose mapped value is zero
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>visit_while</code> and <code>erase_if</code> can also be parallelized. Note that, in order to increase efficiency,
whole-table visitation operations do not block the table during execution: this implies that elements
may be inserted, modified or erased by other threads during visitation. It is
advisable not to assume too much about the exact global state of a concurrent container
at any point in your program.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="concurrent_bulk_visitation"><a class="anchor" href="#concurrent_bulk_visitation"></a>Bulk visitation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Suppose you have an <code>std::array</code> of keys you want to look up for in a concurrent map:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::array&lt;int, N&gt; keys;
...
for(const auto&amp; key: keys) {
  m.visit(key, [](auto&amp; x) { ++x.second; });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Bulk visitation</em> allows us to pass all the keys in one operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">m.visit(keys.begin(), keys.end(), [](auto&amp; x) { ++x.second; });</code></pre>
</div>
</div>
<div class="paragraph">
<p>This functionality is not provided for mere syntactic convenience, though: by processing all the
keys at once, some internal optimizations can be applied that increase
performance over the regular, one-at-a-time case (consult the
<a href="benchmarks.html#benchmarks_boostconcurrent_flatnode_map" class="xref page">benchmarks</a>). In fact, it may be beneficial
to buffer incoming keys so that they can be bulk visited in chunks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">static constexpr auto bulk_visit_size = boost::concurrent_flat_map&lt;int,int&gt;::bulk_visit_size;
std::array&lt;int, bulk_visit_size&gt; buffer;
std::size_t                      i=0;
while(...) { // processing loop
  ...
  buffer[i++] = k;
  if(i == bulk_visit_size) {
    map.visit(buffer.begin(), buffer.end(), [](auto&amp; x) { ++x.second; });
    i = 0;
  }
  ...
}
// flush remaining keys
map.visit(buffer.begin(), buffer.begin() + i, [](auto&amp; x) { ++x.second; });</code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s a latency/throughput tradeoff here: it will take longer for incoming keys to
be processed (since they are buffered), but the number of processed keys per second
is higher. <code>bulk_visit_size</code> is the recommended chunk size —smaller buffers
may yield worse performance.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="concurrent_blocking_operations"><a class="anchor" href="#concurrent_blocking_operations"></a>Blocking Operations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Concurrent containers can be copied, assigned, cleared and merged just like any other
Boost.Unordered container. Unlike most other operations, these are <em>blocking</em>,
that is, all other threads are prevented from accesing the tables involved while a copy, assignment,
clear or merge operation is in progress. Blocking is taken care of automatically by the library
and the user need not take any special precaution, but overall performance may be affected.</p>
</div>
<div class="paragraph">
<p>Another blocking operation is <em>rehashing</em>, which happens explicitly via <code>rehash</code>/<code>reserve</code>
or during insertion when the table&#8217;s load hits <code>max_load()</code>. As with non-concurrent containers,
reserving space in advance of bulk insertions will generally speed up the process.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="concurrent_interoperability_with_non_concurrent_containers"><a class="anchor" href="#concurrent_interoperability_with_non_concurrent_containers"></a>Interoperability with non-concurrent containers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As open-addressing and concurrent containers are based on the same internal data structure,
they can be efficiently move-constructed from their non-concurrent counterpart, and vice versa.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Concurrent/non-concurrent interoperatibility</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>boost::concurrent_node_set</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>boost::unordered_node_set</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>boost::concurrent_node_map</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>boost::unordered_node_map</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>boost::concurrent_flat_set</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>boost::unordered_flat_set</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>boost::concurrent_flat_map</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>boost::unordered_flat_map</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>This interoperability comes handy in multistage scenarios where parts of the data processing happen
in parallel whereas other steps are non-concurrent (or non-modifying). In the following example,
we want to construct a histogram from a huge input vector of words:
the population phase can be done in parallel with <code>boost::concurrent_flat_map</code> and results
then transferred to the final container.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">std::vector&lt;std::string&gt; words = ...;

// Insert words in parallel
boost::concurrent_flat_map&lt;std::string_view, std::size_t&gt; m0;
std::for_each(
  std::execution::par, words.begin(), words.end(),
  [&amp;](const auto&amp; word) {
    m0.try_emplace_or_visit(word, 1, [](auto&amp; x) { ++x.second; });
  });

// Transfer to a regular unordered_flat_map
boost::unordered_flat_map m=std::move(m0);</code></pre>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../unordered/_/js/site.js" data-ui-root-path="../unordered/_"></script>
<script async src="../unordered/_/js/vendor/highlight.js"></script>
  </body>
</html>
