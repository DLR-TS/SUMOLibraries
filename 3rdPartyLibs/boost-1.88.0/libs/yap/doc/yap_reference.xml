<?xml version="1.0" standalone="yes"?>
<library-reference id="headers"><title>Headers</title><header id="doxygen.headers.algorithm_8hpp" name="boost/yap/algorithm.hpp">
<namespace name="boost">
<namespace name="yap">
<struct id="doxygen.headers.structboost_1_1yap_1_1expression__function" name="expression_function"><template>
      <template-type-parameter name="Expr"/>
    </template><description><para>A callable type that evaluates its contained expression when called.</para><para><formalpara><title>See Also:</title><para><computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1a30d04ee48096df16ab6c869eb3e78dde">make_expression_function()</link></computeroutput> </para>
</formalpara>
</para></description><data-member id="doxygen.headers.structboost_1_1yap_1_1expression__function_1ab0bb691b3a991ad8d358cd0d6de26660" name="expr"><type>Expr</type></data-member>
<method-group name="public member functions">
<method id="doxygen.headers.structboost_1_1yap_1_1expression__function_1a946c6424d5e9056e376d4bee0ebc7339" name="operator()"><type>decltype(auto)</type><template>
          <template-nontype-parameter name="U"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="u"><paramtype>U &amp;&amp;...</paramtype></parameter></method>
</method-group>
</struct>

































<function id="doxygen.headers.namespaceboost_1_1yap_1a58c92dfea9f95b7a3f58247f8664f5f4" name="deref"><type>decltype(auto)</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;&amp;</paramtype></parameter><description><para>"Dereferences" a reference-expression, forwarding its referent to the caller. </para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a1827574c3a11821c03649a3bff42ea24" name="value"><type>decltype(auto)</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="x"><paramtype>T &amp;&amp;</paramtype></parameter><description><para>Forwards the sole element of <emphasis>x</emphasis> to the caller, possibly calling <computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1a58c92dfea9f95b7a3f58247f8664f5f4">deref()</link></computeroutput> first if <emphasis>x</emphasis> is a reference expression, or forwards <emphasis>x</emphasis> to the caller unchanged.</para><para>More formally:</para><para><itemizedlist>
<listitem><para>If <emphasis>x</emphasis> is not an expression, <emphasis>x</emphasis> is forwarded to the caller.</para>
</listitem><listitem><para>Otherwise, if <emphasis>x</emphasis> is a reference expression, the result is <computeroutput>value(deref(x))</computeroutput>.</para>
</listitem><listitem><para>Otherwise, if <emphasis>x</emphasis> is an expression with only one value (a unary expression or a terminal expression), the result is the forwarded first element of <emphasis>x</emphasis>.</para>
</listitem><listitem><para>Otherwise, <emphasis>x</emphasis> is forwarded to the caller. </para>
</listitem></itemizedlist>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1aabc8294dcb33813e9209c4410da541ac" name="get"><type>decltype(auto)</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="I"/>
        </template><parameter name="expr"><paramtype>Expr &amp;&amp;</paramtype></parameter><parameter name="i"><paramtype>I const &amp;</paramtype></parameter><description><para>Forwards the <emphasis>i</emphasis>-th element of <emphasis>expr</emphasis> to the caller. If <emphasis>expr</emphasis> is a reference expression, the result is <computeroutput>get(deref(expr),
 i)</computeroutput>.</para><para><note><para><computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1aabc8294dcb33813e9209c4410da541ac">get()</link></computeroutput> is only valid if <emphasis>Expr</emphasis> is an expression. </para>
</note>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a5cbb0f4b842ee2af1be83b62b53b2d8e" name="get_c"><type>decltype(auto)</type><template>
          <template-nontype-parameter name="I"><type>long long</type></template-nontype-parameter>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;&amp;</paramtype></parameter><description><para>Returns <computeroutput>get(expr, boost::hana::llong_c&lt;I&gt;)</computeroutput>. </para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a184da8d47376463214e90a30ac590415" name="left"><type>decltype(auto)</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;&amp;</paramtype></parameter><description><para>Returns the left operand in a binary operator expression.</para><para>Equivalent to <computeroutput>get(expr, 0_c)</computeroutput>.</para><para><note><para><computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1a184da8d47376463214e90a30ac590415">left()</link></computeroutput> is only valid if <emphasis>Expr</emphasis> is a binary operator expression. </para>
</note>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a16830edaeada1f44038a39e09e429314" name="right"><type>decltype(auto)</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;&amp;</paramtype></parameter><description><para>Returns the right operand in a binary operator expression.</para><para>Equivalent to <computeroutput>get(expr, 1_c)</computeroutput>.</para><para><note><para><computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1a16830edaeada1f44038a39e09e429314">right()</link></computeroutput> is only valid if <emphasis>Expr</emphasis> is a binary operator expression. </para>
</note>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1ae95cc40cff3a028a884e9e4d47e25d9a" name="cond"><type>decltype(auto)</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;&amp;</paramtype></parameter><description><para>Returns the condition expression in an if_else expression.</para><para>Equivalent to <computeroutput>get(expr, 0_c)</computeroutput>.</para><para><note><para><computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1ae95cc40cff3a028a884e9e4d47e25d9a">cond()</link></computeroutput> is only valid if <emphasis>Expr</emphasis> is an <computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a9d0388ee4c3399a602e1eee09e115840">expr_kind::if_else</link></computeroutput> expression. </para>
</note>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a8fa884df786e8a4d0de3d4b5d08e6c4d" name="then"><type>decltype(auto)</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;&amp;</paramtype></parameter><description><para>Returns the then-expression in an if_else expression.</para><para>Equivalent to <computeroutput>get(expr, 1_c)</computeroutput>.</para><para><note><para><computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1a8fa884df786e8a4d0de3d4b5d08e6c4d">then()</link></computeroutput> is only valid if <emphasis>Expr</emphasis> is an <computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a9d0388ee4c3399a602e1eee09e115840">expr_kind::if_else</link></computeroutput> expression. </para>
</note>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a5085fd5762782bd8a76345b6f72fb71c" name="else_"><type>decltype(auto)</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;&amp;</paramtype></parameter><description><para>Returns the else-expression in an if_else expression.</para><para>Equivalent to <computeroutput>get(expr, 2_c)</computeroutput>.</para><para><note><para><computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1a5085fd5762782bd8a76345b6f72fb71c">else_()</link></computeroutput> is only valid if <emphasis>Expr</emphasis> is an <computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a9d0388ee4c3399a602e1eee09e115840">expr_kind::if_else</link></computeroutput> expression. </para>
</note>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a37d7a40ac3e8e057f23cd6fa8e2c570c" name="callable"><type>decltype(auto)</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;&amp;</paramtype></parameter><description><para>Returns the callable in a call expression.</para><para>Equivalent to <computeroutput>get(expr, 0)</computeroutput>.</para><para><note><para><computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1a37d7a40ac3e8e057f23cd6fa8e2c570c">callable()</link></computeroutput> is only valid if <emphasis>Expr</emphasis> is an <computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a53b9e9679a8ea25880376080b76f98ad">expr_kind::call</link></computeroutput> expression. </para>
</note>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1ab6f3631e784dd0542a77387e3c692b5c" name="argument"><type>decltype(auto)</type><template>
          <template-nontype-parameter name="I"><type>long long</type></template-nontype-parameter>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;&amp;</paramtype></parameter><parameter name="i"><paramtype>hana::llong&lt; I &gt;</paramtype></parameter><description><para>Returns the <emphasis>i-th</emphasis> argument expression in a call expression.</para><para>Equivalent to <computeroutput>get(expr, i + 1)</computeroutput>.</para><para><note><para><computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1ab6f3631e784dd0542a77387e3c692b5c">argument()</link></computeroutput> is only valid if <emphasis>Expr</emphasis> is an <computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a53b9e9679a8ea25880376080b76f98ad">expr_kind::call</link></computeroutput> expression. </para>
</note>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a3ca74e1fa557179324c3759549501a72" name="make_expression"><type>auto</type><template>
          <template-nontype-parameter name="ExprTemplate"><type>template&lt; expr_kind, class &gt; class</type></template-nontype-parameter>
          <template-nontype-parameter name="Kind"><type>expr_kind</type></template-nontype-parameter>
          <template-nontype-parameter name="T"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="t"><paramtype>T &amp;&amp;...</paramtype></parameter><description><para>Makes a new expression instantiated from the expression template <emphasis>ExprTemplate</emphasis>, of kind <emphasis>Kind</emphasis>, with the given values as its elements.</para><para>For each parameter P:</para><para><itemizedlist>
<listitem><para>If P is an expression, P is moved into the result if P is an rvalue and captured by reference into the result otherwise.</para>
</listitem><listitem><para>Otherwise, P is wrapped in a terminal expression.</para>
</listitem></itemizedlist>
</para><para><note><para><computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1a4a1092e875a0425af9800b8447f43189">make_expression()</link></computeroutput> is only valid if the number of parameters passed is appropriate for <emphasis>Kind</emphasis>. </para>
</note>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1aa754c76e96fa7eafe3951afa9d256478" name="make_terminal"><type>auto</type><template>
          <template-nontype-parameter name="ExprTemplate"><type>template&lt; expr_kind, class &gt; class</type></template-nontype-parameter>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;&amp;</paramtype></parameter><description><para>Makes a new terminal expression instantiated from the expression template <emphasis>ExprTemplate</emphasis>, with the given value as its sole element.</para><para><note><para><computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1a7a32957d0ccac762c901a12905a6e985">make_terminal()</link></computeroutput> is only valid if <emphasis>T</emphasis> is <emphasis role="bold">not</emphasis> an expression. </para>
</note>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a400188ffc7742bb8eb2e69c811ccf132" name="as_expr"><type>decltype(auto)</type><template>
          <template-nontype-parameter name="ExprTemplate"><type>template&lt; expr_kind, class &gt; class</type></template-nontype-parameter>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;&amp;</paramtype></parameter><description><para>Returns an expression formed from <emphasis>t</emphasis> as follows:</para><para><itemizedlist>
<listitem><para>If <emphasis>t</emphasis> is an expression, <emphasis>t</emphasis> is forwarded to the caller.</para>
</listitem><listitem><para>Otherwise, <emphasis>t</emphasis> is wrapped in a terminal expression. </para>
</listitem></itemizedlist>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a30d04ee48096df16ab6c869eb3e78dde" name="make_expression_function"><type>auto</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;&amp;</paramtype></parameter><description><para>Returns a callable object that <emphasis>expr</emphasis> has been forwarded into. This is useful for using expressions as function objects.</para><para>Lvalue expressions are stored in the result by reference; rvalue expressions are moved into the result.</para><para><note><para><computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1a30d04ee48096df16ab6c869eb3e78dde">make_expression_function()</link></computeroutput> is only valid if <emphasis>Expr</emphasis> is an expression. </para>
</note>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1af4f30d11916622320c421082408bf8c0" name="replacements"><type>auto</type><template>
          <template-nontype-parameter name="T"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="t"><paramtype>T &amp;&amp;...</paramtype></parameter><description><para>Returns a transform object that replaces placeholders within an expression with the given values. </para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1acf4669f0121359dd4079ee371eeace90" name="replace_placeholders"><type>decltype(auto)</type><template>
          <template-type-parameter name="Expr"/>
          <template-nontype-parameter name="T"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="expr"><paramtype>Expr &amp;&amp;</paramtype></parameter><parameter name="t"><paramtype>T &amp;&amp;...</paramtype></parameter><description><para>Returns <emphasis>expr</emphasis> with the placeholders replaced by YAP terminals containing the given values.</para><para><note><para><computeroutput>replace_placeholders(expr, t...)</computeroutput> is only valid if <emphasis>expr</emphasis> is an expression, and <computeroutput>max_p &lt;= sizeof...(t)</computeroutput>, where <computeroutput>max_p</computeroutput> is the maximum placeholder index in <emphasis>expr</emphasis>. </para>
</note>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a160b93c8d28215970ca0b1ac2d4270e5" name="evaluation"><type>auto</type><template>
          <template-nontype-parameter name="T"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="t"><paramtype>T &amp;&amp;...</paramtype></parameter><description><para>Returns a transform object that evaluates an expression using the built-in semantics. The transform replaces any placeholders with the given values. </para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1aa1bcb690cafa777e2032616133da0b2f" name="evaluate"><type>decltype(auto)</type><template>
          <template-type-parameter name="Expr"/>
          <template-nontype-parameter name="T"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="expr"><paramtype>Expr &amp;&amp;</paramtype></parameter><parameter name="t"><paramtype>T &amp;&amp;...</paramtype></parameter><description><para>Evaluates <emphasis>expr</emphasis> using the built-in semantics, replacing any placeholders with the given values.</para><para><note><para><computeroutput>evaluate(expr)</computeroutput> is only valid if <emphasis>expr</emphasis> is an expression. </para>
</note>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a19030c29aa00bb02fe1d7897241a7e50" name="transform"><type>decltype(auto)</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="Transform"/>
          <template-nontype-parameter name="Transforms"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="expr"><paramtype>Expr &amp;&amp;</paramtype></parameter><parameter name="transform"><paramtype>Transform &amp;&amp;</paramtype></parameter><parameter name="transforms"><paramtype>Transforms &amp;&amp;...</paramtype></parameter><description><para>Returns the result of transforming (all or part of) <emphasis>expr</emphasis> using whatever overloads of <computeroutput>Transform::operator()</computeroutput> match <emphasis>expr</emphasis>.</para><para><note><para>Transformations can do anything: they may have side effects; they may mutate values; they may mutate types; and they may do any combination of these. </para>
</note>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a530f8c59f3f85b44ce6ebcb7b4cdb8c6" name="transform_strict"><type>decltype(auto)</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="Transform"/>
          <template-nontype-parameter name="Transforms"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="expr"><paramtype>Expr &amp;&amp;</paramtype></parameter><parameter name="transform"><paramtype>Transform &amp;&amp;</paramtype></parameter><parameter name="transforms"><paramtype>Transforms &amp;&amp;...</paramtype></parameter><description><para>Returns the result of transforming <emphasis>expr</emphasis> using whichever overload of <computeroutput>Transform::operator()</computeroutput> best matches <emphasis>expr</emphasis>. If no overload of <computeroutput>Transform::operator()</computeroutput> matches, a compile-time error results.</para><para><note><para>Transformations can do anything: they may have side effects; they may mutate values; they may mutate types; and they may do any combination of these. </para>
</note>
</para></description></function>
</namespace>
</namespace>
</header>
<header id="doxygen.headers.algorithm__fwd_8hpp" name="boost/yap/algorithm_fwd.hpp">
<namespace name="boost">
<namespace name="yap">
<struct id="doxygen.headers.structboost_1_1yap_1_1expr__tag" name="expr_tag"><template>
      <template-nontype-parameter name="Kind"><type>expr_kind</type></template-nontype-parameter>
    </template><description><para>Used as the tag-type passed to a transform function written in the tag-transform form. </para></description><data-member id="doxygen.headers.structboost_1_1yap_1_1expr__tag_1af4bbfee8cc319f29cf696668f901fdf4" name="kind" specifiers="static"><type>const expr_kind</type></data-member>
</struct><struct id="doxygen.headers.structboost_1_1yap_1_1is__expr" name="is_expr"><template>
      <template-type-parameter name="Expr"/>
    </template><description><para>A metafunction that evaluates to std::true_type if <emphasis>Expr</emphasis> is an Expression, and std::false_type otherwise. </para></description></struct><struct id="doxygen.headers.structboost_1_1yap_1_1minimal__expr" name="minimal_expr"><template>
      <template-nontype-parameter name="Kind"><type>expr_kind</type></template-nontype-parameter>
      <template-type-parameter name="Tuple"/>
    </template><description><para>Used as the expression template returned by some operations inside YAP when YAP does not have an expression template it was told to use. For instance, if <link linkend="doxygen.headers.namespaceboost_1_1yap_1a19030c29aa00bb02fe1d7897241a7e50">transform()</link> creates a new expression by transforming an existing expression's elements, it will attempt to create the new expression using the existing one's expression template. If no such template exists because the existing expression was not made from an expression template, <link linkend="doxygen.headers.structboost_1_1yap_1_1minimal__expr">minimal_expr</link> is used. </para></description><data-member id="doxygen.headers.structboost_1_1yap_1_1minimal__expr_1a8807787dfde94e162997c8b81ab12e19" name="kind" specifiers="static"><type>expr_kind const</type></data-member>
<data-member id="doxygen.headers.structboost_1_1yap_1_1minimal__expr_1a07a8302004c5d39f5e9193f17085a528" name="elements"><type>Tuple</type></data-member>
</struct><struct id="doxygen.headers.structboost_1_1yap_1_1placeholder" name="placeholder"><template>
      <template-nontype-parameter name="I"><type>long long</type></template-nontype-parameter>
    </template><inherit access="public">hana::llong&lt; I &gt;</inherit><description><para>The type used to represent the index of a placeholder terminal. </para></description></struct><namespace name="literals">
<function id="doxygen.headers.namespaceboost_1_1yap_1_1literals_1a4d64c85a4fdf42d89f09b3f96fa84433" name="operator&quot;&quot;_p"><type>auto</type><template>
          <template-nontype-parameter name="c"><type>char...</type></template-nontype-parameter>
        </template><description><para>Creates literal placeholders. Placeholder indices are 1-based. </para></description></function>
</namespace>
<enum id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228" name="expr_kind"><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a02fa08484c2cb813afa5ea20c8069b9b" name="expr_ref"><default>0</default><purpose>A (possibly <computeroutput>const</computeroutput>) reference to another expression. </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228aede997b0caf2ec398110d79d9eba38bb" name="terminal"><default>1</default><purpose>A terminal expression. </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228ac4bb485390e425b490b0706d4f408467" name="unary_plus"><default>2</default><purpose><computeroutput>+</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a2d11beba811e6ec7b47d7a801cf8173f" name="negate"><default>3</default><purpose><computeroutput>-</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228ae62c3122c9a8b525c007ee997498fc08" name="dereference"><default>4</default><purpose><computeroutput>*</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228ae6c27da919729d57801e6aa56be4a5e3" name="complement"><default>5</default><purpose><computeroutput>~</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228ae0843218086a4607d723239aa2216f16" name="address_of"><default>6</default><purpose><computeroutput>&amp;</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228aae757037cf76855c26e2e65685e89f55" name="logical_not"><default>7</default><purpose><computeroutput>!</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a8919fa99781d5598de007509c3a5269d" name="pre_inc"><default>8</default><purpose><computeroutput>++</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a87dcbfe470e7019e7321eb742b99d42f" name="pre_dec"><default>9</default><purpose><computeroutput>--</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228ad0c46829eefd46fe1fd35c14bbe11f8f" name="post_inc"><default>10</default><purpose><computeroutput>++</computeroutput>(int) </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a2d7accf1ab76ee7aa4a1dbac9ecee775" name="post_dec"><default>11</default><purpose><computeroutput>--</computeroutput>(int) </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228abc9e94a9606c06cd9d0dcff07b6148ec" name="shift_left"><default>12</default><purpose><computeroutput>&lt;&lt;</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a066380d27185d48e0c5e3c5a521a8e1d" name="shift_right"><default>13</default><purpose><computeroutput>&gt;&gt;</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a315c29c2c556bb0ed00d61c6f0c3fd7c" name="multiplies"><default>14</default><purpose><computeroutput>*</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a52bebbb66bc9495a9eaed1852c8210f4" name="divides"><default>15</default><purpose><computeroutput>/</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a06efba23b1f3a9b846a25c6b49f30348" name="modulus"><default>16</default><purpose><computeroutput>%</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228ad7d18cfb3a0d8293e2f5d94ea30e04d2" name="plus"><default>17</default><purpose><computeroutput>+</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228adabe6e597b70e5760826aea1dcc564f7" name="minus"><default>18</default><purpose><computeroutput>-</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228ae37e8d912e8f7b8f9b5ef9452ba47ff1" name="less"><default>19</default><purpose><computeroutput>&lt;</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a7b8dc4fb0fb55fc8eb69ff080c45ed7e" name="greater"><default>20</default><purpose><computeroutput>&gt;</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a77932225fb35fc4b74dc8fabf0992dac" name="less_equal"><default>21</default><purpose><computeroutput>&lt;=</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a5675102b0e596d9d43bbb0e0f8ea07e2" name="greater_equal"><default>22</default><purpose><computeroutput>&gt;=</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a56f8abc81f3535d33fd6561081826b73" name="equal_to"><default>23</default><purpose><computeroutput>==</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a0d00275e78120507118a046c8b52ebf8" name="not_equal_to"><default>24</default><purpose><computeroutput>!=</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a315912cc635af16775fc13643e531b94" name="logical_or"><default>25</default><purpose><computeroutput>||</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a9b6843a9b70903262e93e19d668b1387" name="logical_and"><default>26</default><purpose><computeroutput>&amp;&amp;</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a2a90cd923ab195168c5bc80f6f3e03ea" name="bitwise_and"><default>27</default><purpose><computeroutput>&amp;</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228ad823bdc16fb140683e3c274c5c13de20" name="bitwise_or"><default>28</default><purpose><computeroutput/>| </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a320ca8207163cd63fc60307c388dd01c" name="bitwise_xor"><default>29</default><purpose><computeroutput>^</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228ab6d00dc1ba038e5901cd6c06b2daa192" name="comma"><default>30</default><purpose><computeroutput/>, </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a4cbf66efef9c29070906b68565e85d36" name="mem_ptr"><default>31</default><purpose><computeroutput>-&gt;*</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a4de8aa8803f1d41cf317eb0eadc2eb3c" name="assign"><default>32</default><purpose><computeroutput>=</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a47902d5d95af4bfec53de99f5ad7fcca" name="shift_left_assign"><default>33</default><purpose><computeroutput>&lt;&lt;=</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a9538a5cc6eaa10cbc5df5aea234249f2" name="shift_right_assign"><default>34</default><purpose><computeroutput>&gt;&gt;=</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a120438402e37158550537517d2eead43" name="multiplies_assign"><default>35</default><purpose><computeroutput>*=</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228ac7f2538db797f688c54417a9a1aee5d6" name="divides_assign"><default>36</default><purpose><computeroutput>/=</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228af886d1f332b63249f381949a80dbfe08" name="modulus_assign"><default>37</default><purpose><computeroutput>%=</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228ad980afb996824afa7b6cea9074587870" name="plus_assign"><default>38</default><purpose><computeroutput>+=</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a79fabdd65220c8a6ffe02929318dc8a7" name="minus_assign"><default>39</default><purpose><computeroutput>-=</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a975161f40c535f13fa4d6165485e2245" name="bitwise_and_assign"><default>40</default><purpose><computeroutput>&amp;=</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a231084095f394f72f88daa133cad02bc" name="bitwise_or_assign"><default>41</default><purpose><computeroutput/>|= </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228aed5f835bb9d0657ab5fd7dcfd84686e5" name="bitwise_xor_assign"><default>42</default><purpose><computeroutput>^=</computeroutput> </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a8796114e5be2cd5eb900e81d6b20cf9c" name="subscript"><default>43</default><purpose><computeroutput/>[] </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a9d0388ee4c3399a602e1eee09e115840" name="if_else"><default>44</default><purpose>Analogous to <computeroutput/>?: . </purpose></enumvalue><enumvalue id="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a53b9e9679a8ea25880376080b76f98ad" name="call"><default>45</default><purpose><computeroutput/>() </purpose></enumvalue><description><para>The enumeration representing all the kinds of expressions supported in YAP. </para></description></enum>
<typedef id="doxygen.headers.namespaceboost_1_1yap_1acbc022247790e39015b12349dc0c317f" name="terminal"><description><para>A convenience alias for a terminal expression holding a <emphasis>T</emphasis>, instantiated from expression template <emphasis>expr_template</emphasis>. </para></description><type>expr_template&lt; expr_kind::terminal, hana::tuple&lt; T &gt; &gt;</type></typedef>
<typedef id="doxygen.headers.namespaceboost_1_1yap_1a30950dd2febf9962a5da0a655c319938" name="expression_ref"><description><para>A convenience alias for a reference expression holding an expression <emphasis>T</emphasis>, instantiated from expression template <emphasis>expr_template</emphasis>. </para></description><type>expr_template&lt; expr_kind::expr_ref, hana::tuple&lt; std::remove_reference_t&lt; T &gt; * &gt; &gt;</type></typedef>























































</namespace>
</namespace>
</header>
<header id="doxygen.headers.config_8hpp" name="boost/yap/config.hpp">
<macro id="doxygen.headers.config_8hpp_1af3d42b62a1e1985b56d47ce7f816070e" name="BOOST_NO_CONSTEXPR_IF"><description><para>Indicates whether the compiler supports constexpr if.</para><para>If the user does not define any value for this, we assume that the compiler does not have the necessary support. Note that this is a temporary hack; this should eventually be a Boost-wide macro. </para></description></macro>
</header>
<header id="doxygen.headers.expression_8hpp" name="boost/yap/expression.hpp">
<namespace name="boost">
<namespace name="yap">
<struct id="doxygen.headers.structboost_1_1yap_1_1expression" name="expression"><template>
      <template-nontype-parameter name="Kind"><type>expr_kind</type></template-nontype-parameter>
      <template-type-parameter name="Tuple"/>
    </template><description><para>Reference expression template that provides all operator overloads.</para><para><note><para>Due to a limitation of Doxygen, each of the <computeroutput><link linkend="doxygen.headers.structboost_1_1yap_1_1expression_1acce471b134babbe0a58f92e03396b4b5">value()</link></computeroutput>, <computeroutput><link linkend="doxygen.headers.structboost_1_1yap_1_1expression_1aaf657da5bf99303e851a25b807b58857">left()</link></computeroutput>, <computeroutput><link linkend="doxygen.headers.structboost_1_1yap_1_1expression_1a2320b27bb693e2e3958faff20aff140b">right()</link></computeroutput>, and operator overloads listed here is a stand-in for three member functions. For each function <computeroutput>f</computeroutput>, the listing here is: <programlisting language="c++">return_type f (); 
</programlisting> However, there are actually three functions: <programlisting language="c++">return_type f () const &amp;;
return_type f () &amp;;
return_type f () &amp;&amp;;
</programlisting> </para>
</note>
</para></description><typedef id="doxygen.headers.structboost_1_1yap_1_1expression_1ab307c1bc7d4c38ba72db248442a96dbd" name="tuple_type"><type>Tuple</type></typedef>
<data-member id="doxygen.headers.structboost_1_1yap_1_1expression_1abde2e4c457ae65a24e100e9c760a95a2" name="kind" specifiers="static"><type>const expr_kind</type></data-member>
<data-member id="doxygen.headers.structboost_1_1yap_1_1expression_1a08b1634e5172b3830d524b8565ab986e" name="elements"><type>tuple_type</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.headers.structboost_1_1yap_1_1expression_1a0411b4e42a7042d5db7323226e84bc5f"><description><para>Default constructor. Does nothing. </para></description></constructor>
<constructor id="doxygen.headers.structboost_1_1yap_1_1expression_1aab494fba94138eb424362082ba53aac6"><parameter name="rhs"><paramtype>tuple_type &amp;&amp;</paramtype></parameter><description><para>Moves <emphasis>rhs</emphasis> into the only data mamber, <computeroutput>elements</computeroutput>. </para></description></constructor>
<method id="doxygen.headers.structboost_1_1yap_1_1expression_1acce471b134babbe0a58f92e03396b4b5" name="value"><type>decltype(auto)</type><description><para>A convenience member function that dispatches to the free function <computeroutput><link linkend="doxygen.headers.structboost_1_1yap_1_1expression_1acce471b134babbe0a58f92e03396b4b5">value()</link></computeroutput>. </para></description></method>
<method id="doxygen.headers.structboost_1_1yap_1_1expression_1aaf657da5bf99303e851a25b807b58857" name="left"><type>decltype(auto)</type><description><para>A convenience member function that dispatches to the free function <computeroutput><link linkend="doxygen.headers.structboost_1_1yap_1_1expression_1aaf657da5bf99303e851a25b807b58857">left()</link></computeroutput>. </para></description></method>
<method id="doxygen.headers.structboost_1_1yap_1_1expression_1a2320b27bb693e2e3958faff20aff140b" name="right"><type>decltype(auto)</type><description><para>A convenience member function that dispatches to the free function <computeroutput><link linkend="doxygen.headers.structboost_1_1yap_1_1expression_1a2320b27bb693e2e3958faff20aff140b">right()</link></computeroutput>. </para></description></method>
</method-group>
</struct><struct-specialization id="doxygen.headers.structboost_1_1yap_1_1expression_3_01expr__kind_1_1terminal_00_01hana_1_1tuple_3_01T_01_4_01_4" name="expression"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>expr_kind::terminal</template-arg><template-arg>hana::tuple&lt; T &gt;</template-arg></specialization><description><para>Terminal expression specialization of the reference expression template.</para><para><note><para>Due to a limitation of Doxygen, the <computeroutput><link linkend="doxygen.headers.structboost_1_1yap_1_1expression_3_01expr__kind_1_1terminal_00_01hana_1_1tuple_3_01T_01_4_01_4_1a352185b3671fd9e3ed1a8d7ddca77af7">value()</link></computeroutput> member and each of the operator overloads listed here is a stand-in for three member functions. For each function <computeroutput>f</computeroutput>, the listing here is: <programlisting language="c++">return_type f (); 
</programlisting> However, there are actually three functions: <programlisting language="c++">return_type f () const &amp;;
return_type f () &amp;;
return_type f () &amp;&amp;;
</programlisting> </para>
</note>
</para></description><typedef id="doxygen.headers.structboost_1_1yap_1_1expression_3_01expr__kind_1_1terminal_00_01hana_1_1tuple_3_01T_01_4_01_4_1ae25f20591cd36da601034dd0b68c4ecc" name="tuple_type"><type>hana::tuple&lt; T &gt;</type></typedef>
<data-member id="doxygen.headers.structboost_1_1yap_1_1expression_3_01expr__kind_1_1terminal_00_01hana_1_1tuple_3_01T_01_4_01_4_1a3be11a56e842ea8a2d80f5bf396d534a" name="kind" specifiers="static"><type>const expr_kind</type></data-member>
<data-member id="doxygen.headers.structboost_1_1yap_1_1expression_3_01expr__kind_1_1terminal_00_01hana_1_1tuple_3_01T_01_4_01_4_1ad6a45bc342b0ed2d1ed08c8af97438fd" name="elements"><type>tuple_type</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.headers.structboost_1_1yap_1_1expression_3_01expr__kind_1_1terminal_00_01hana_1_1tuple_3_01T_01_4_01_4_1a1e31ba0cacc084037c33246243a7fe09"><description><para>Default constructor. Does nothing. </para></description></constructor>
<constructor id="doxygen.headers.structboost_1_1yap_1_1expression_3_01expr__kind_1_1terminal_00_01hana_1_1tuple_3_01T_01_4_01_4_1ac95dbbef7a9250b5815d60e730e061c5"><parameter name="t"><paramtype>T &amp;&amp;</paramtype></parameter><description><para>Forwards <emphasis>t</emphasis> into <computeroutput>elements</computeroutput>. </para></description></constructor>
<constructor id="doxygen.headers.structboost_1_1yap_1_1expression_3_01expr__kind_1_1terminal_00_01hana_1_1tuple_3_01T_01_4_01_4_1a92df7438b3b9611ca0702b24a3d31a49"><parameter name="rhs"><paramtype>hana::tuple&lt; T &gt; const &amp;</paramtype></parameter><description><para>Copies <emphasis>rhs</emphasis> into the only data mamber, <computeroutput>elements</computeroutput>. </para></description></constructor>
<constructor id="doxygen.headers.structboost_1_1yap_1_1expression_3_01expr__kind_1_1terminal_00_01hana_1_1tuple_3_01T_01_4_01_4_1a65c9ddf0e1fd762d856b408aaa0c57dc"><parameter name="rhs"><paramtype>hana::tuple&lt; T &gt; &amp;&amp;</paramtype></parameter><description><para>Moves <emphasis>rhs</emphasis> into the only data mamber, <computeroutput>elements</computeroutput>. </para></description></constructor>
<method id="doxygen.headers.structboost_1_1yap_1_1expression_3_01expr__kind_1_1terminal_00_01hana_1_1tuple_3_01T_01_4_01_4_1a352185b3671fd9e3ed1a8d7ddca77af7" name="value"><type>decltype(auto)</type><description><para>A convenience member function that dispatches to the free function <computeroutput><link linkend="doxygen.headers.structboost_1_1yap_1_1expression_3_01expr__kind_1_1terminal_00_01hana_1_1tuple_3_01T_01_4_01_4_1a352185b3671fd9e3ed1a8d7ddca77af7">value()</link></computeroutput>. </para></description></method>
</method-group>
</struct-specialization>

<function id="doxygen.headers.namespaceboost_1_1yap_1a2f75fc826486b58472b3b81097cf0c1e" name="operator+"><type>auto</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name=""><paramtype>Expr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a835bf2c8a57e5572849469d6f3acb0cf">BOOST_YAP_USER_UNARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a87fc70fa425a7653e5358f9270a37f95" name="operator-"><type>auto</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name=""><paramtype>Expr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a835bf2c8a57e5572849469d6f3acb0cf">BOOST_YAP_USER_UNARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a5dc4e203681f7b6308adeb737068ca74" name="operator*"><type>auto</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name=""><paramtype>Expr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a835bf2c8a57e5572849469d6f3acb0cf">BOOST_YAP_USER_UNARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1ac3d326d8a1831303c5271bc536d09b82" name="operator~"><type>auto</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name=""><paramtype>Expr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a835bf2c8a57e5572849469d6f3acb0cf">BOOST_YAP_USER_UNARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1ad8b6fd6f163c4934a61cdaf6fce4f8c5" name="operator&amp;"><type>auto</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name=""><paramtype>Expr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a835bf2c8a57e5572849469d6f3acb0cf">BOOST_YAP_USER_UNARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a3e1ec873f6997b17c3ef482d1dd96275" name="operator!"><type>auto</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name=""><paramtype>Expr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a835bf2c8a57e5572849469d6f3acb0cf">BOOST_YAP_USER_UNARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1ad1923c67812c8ec64874646fca5bf893" name="operator++"><type>auto</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name=""><paramtype>Expr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a835bf2c8a57e5572849469d6f3acb0cf">BOOST_YAP_USER_UNARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a37407e2d7e22c2abb89d1959514af8cd" name="operator--"><type>auto</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name=""><paramtype>Expr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a835bf2c8a57e5572849469d6f3acb0cf">BOOST_YAP_USER_UNARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1aa55dc4ce6707f7cc36f372c5be35e07e" name="operator++"><type>auto</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name=""><paramtype>Expr &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a835bf2c8a57e5572849469d6f3acb0cf">BOOST_YAP_USER_UNARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1aa9d0e2c98a3ae1590d156caae7e72540" name="operator--"><type>auto</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name=""><paramtype>Expr &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a835bf2c8a57e5572849469d6f3acb0cf">BOOST_YAP_USER_UNARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a68502ac42e34f8d852118b5a0c72200a" name="operator&lt;&lt;"><type>auto</type><template>
          <template-type-parameter name="LExpr"/>
          <template-type-parameter name="RExpr"/>
        </template><parameter name="lhs"><paramtype>LExpr &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype>RExpr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7">BOOST_YAP_USER_BINARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a1c28bf5ddcb28465d958b3a72def3c56" name="operator&gt;&gt;"><type>auto</type><template>
          <template-type-parameter name="LExpr"/>
          <template-type-parameter name="RExpr"/>
        </template><parameter name="lhs"><paramtype>LExpr &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype>RExpr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7">BOOST_YAP_USER_BINARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a215ecd8b671d33f1c88b1dd7e762500a" name="operator*"><type>auto</type><template>
          <template-type-parameter name="LExpr"/>
          <template-type-parameter name="RExpr"/>
        </template><parameter name="lhs"><paramtype>LExpr &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype>RExpr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7">BOOST_YAP_USER_BINARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a790b3b780956a9a15a4770fa42c13c55" name="operator/"><type>auto</type><template>
          <template-type-parameter name="LExpr"/>
          <template-type-parameter name="RExpr"/>
        </template><parameter name="lhs"><paramtype>LExpr &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype>RExpr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7">BOOST_YAP_USER_BINARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a2470c91192c8965327ac927f91b12e84" name="operator%"><type>auto</type><template>
          <template-type-parameter name="LExpr"/>
          <template-type-parameter name="RExpr"/>
        </template><parameter name="lhs"><paramtype>LExpr &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype>RExpr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7">BOOST_YAP_USER_BINARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a3ca0fa4f924e68c6b4df7652ddb14cbb" name="operator+"><type>auto</type><template>
          <template-type-parameter name="LExpr"/>
          <template-type-parameter name="RExpr"/>
        </template><parameter name="lhs"><paramtype>LExpr &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype>RExpr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7">BOOST_YAP_USER_BINARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a64dc13180d734875d66caad54124884f" name="operator-"><type>auto</type><template>
          <template-type-parameter name="LExpr"/>
          <template-type-parameter name="RExpr"/>
        </template><parameter name="lhs"><paramtype>LExpr &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype>RExpr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7">BOOST_YAP_USER_BINARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a96133deb37a88320cf9c91b3690d5beb" name="operator&lt;"><type>auto</type><template>
          <template-type-parameter name="LExpr"/>
          <template-type-parameter name="RExpr"/>
        </template><parameter name="lhs"><paramtype>LExpr &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype>RExpr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7">BOOST_YAP_USER_BINARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a6df1e6638e2bed9f523b0107ebc208fa" name="operator&gt;"><type>auto</type><template>
          <template-type-parameter name="LExpr"/>
          <template-type-parameter name="RExpr"/>
        </template><parameter name="lhs"><paramtype>LExpr &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype>RExpr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7">BOOST_YAP_USER_BINARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a61d761e2bd01977a8081540d0a47266b" name="operator&lt;="><type>auto</type><template>
          <template-type-parameter name="LExpr"/>
          <template-type-parameter name="RExpr"/>
        </template><parameter name="lhs"><paramtype>LExpr &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype>RExpr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7">BOOST_YAP_USER_BINARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1ad6bb6517890b6fd04bbc13bfa0a4e1d8" name="operator&gt;="><type>auto</type><template>
          <template-type-parameter name="LExpr"/>
          <template-type-parameter name="RExpr"/>
        </template><parameter name="lhs"><paramtype>LExpr &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype>RExpr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7">BOOST_YAP_USER_BINARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1ac48921a24b50eedc60c3905c3e09df99" name="operator=="><type>auto</type><template>
          <template-type-parameter name="LExpr"/>
          <template-type-parameter name="RExpr"/>
        </template><parameter name="lhs"><paramtype>LExpr &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype>RExpr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7">BOOST_YAP_USER_BINARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a852e212eeb03f2d79b313a0d508d5a95" name="operator!="><type>auto</type><template>
          <template-type-parameter name="LExpr"/>
          <template-type-parameter name="RExpr"/>
        </template><parameter name="lhs"><paramtype>LExpr &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype>RExpr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7">BOOST_YAP_USER_BINARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a8f2e88c433d13b6ef6fe46c3e90c6fd9" name="operator||"><type>auto</type><template>
          <template-type-parameter name="LExpr"/>
          <template-type-parameter name="RExpr"/>
        </template><parameter name="lhs"><paramtype>LExpr &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype>RExpr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7">BOOST_YAP_USER_BINARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a4df37ae85e863b9dfd048fc9aada8b4d" name="operator&amp;&amp;"><type>auto</type><template>
          <template-type-parameter name="LExpr"/>
          <template-type-parameter name="RExpr"/>
        </template><parameter name="lhs"><paramtype>LExpr &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype>RExpr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7">BOOST_YAP_USER_BINARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a4912a54f3c2901779a3cac757d80c392" name="operator&amp;"><type>auto</type><template>
          <template-type-parameter name="LExpr"/>
          <template-type-parameter name="RExpr"/>
        </template><parameter name="lhs"><paramtype>LExpr &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype>RExpr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7">BOOST_YAP_USER_BINARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1af09483d8f9145d92d186e905d17a0b2e" name="operator|"><type>auto</type><template>
          <template-type-parameter name="LExpr"/>
          <template-type-parameter name="RExpr"/>
        </template><parameter name="lhs"><paramtype>LExpr &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype>RExpr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7">BOOST_YAP_USER_BINARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1ac99dab130b76fe38c85226492ef59a1f" name="operator^"><type>auto</type><template>
          <template-type-parameter name="LExpr"/>
          <template-type-parameter name="RExpr"/>
        </template><parameter name="lhs"><paramtype>LExpr &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype>RExpr &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7">BOOST_YAP_USER_BINARY_OPERATOR</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a9458c41b89ed9cd39cce086e15858a9c" name="if_else"><type>auto</type><template>
          <template-type-parameter name="Expr1"/>
          <template-type-parameter name="Expr2"/>
          <template-type-parameter name="Expr3"/>
        </template><parameter name="expr1"><paramtype>Expr1 &amp;&amp;</paramtype></parameter><parameter name="expr2"><paramtype>Expr2 &amp;&amp;</paramtype></parameter><parameter name="expr3"><paramtype>Expr3 &amp;&amp;</paramtype></parameter><description><para><formalpara><title>See Also:</title><para><link linkend="doxygen.headers.user__macros_8hpp_1aa0e733297b330471a525bbce2eac1986">BOOST_YAP_USER_EXPR_IF_ELSE</link> for full semantics. </para>
</formalpara>
</para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a4a1092e875a0425af9800b8447f43189" name="make_expression"><type>auto</type><template>
          <template-nontype-parameter name="Kind"><type>expr_kind</type></template-nontype-parameter>
          <template-nontype-parameter name="T"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="t"><paramtype>T &amp;&amp;...</paramtype></parameter><description><para>Returns <computeroutput>make_expression&lt;boost::yap::expression, Kind&gt;(...)</computeroutput>. </para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a7a32957d0ccac762c901a12905a6e985" name="make_terminal"><type>auto</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;&amp;</paramtype></parameter><description><para>Returns <computeroutput>make_terminal&lt;boost::yap::expression&gt;(t)</computeroutput>. </para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a34f68af690560e540b65c251095585f6" name="as_expr"><type>decltype(auto)</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;&amp;</paramtype></parameter><description><para>Returns <computeroutput>as_expr&lt;boost::yap::expression&gt;(t)</computeroutput>. </para></description></function>





















</namespace>
</namespace>
</header>
<header id="doxygen.headers.print_8hpp" name="boost/yap/print.hpp">
<namespace name="boost">
<namespace name="yap">
<function id="doxygen.headers.namespaceboost_1_1yap_1a6653389af9f73261031ac2d3804a6c11" name="op_string"><type>char const *</type><parameter name="kind"><paramtype>expr_kind</paramtype></parameter><description><para>Returns the <computeroutput>char const *</computeroutput> string for the spelling of the C++ operator associated with <emphasis>kind</emphasis>. It returns the special values "ref" and "term" for the non-operator kinds <computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228a02fa08484c2cb813afa5ea20c8069b9b">expr_kind::expr_ref</link></computeroutput> amd <computeroutput><link linkend="doxygen.headers.namespaceboost_1_1yap_1ad99d2de607e5e1f27d4de9cb4b283228aede997b0caf2ec398110d79d9eba38bb">expr_kind::terminal</link></computeroutput>, respectively. </para></description></function>
<function id="doxygen.headers.namespaceboost_1_1yap_1a9446e8e01e08cfa00715a1416d17fdbc" name="print"><type>std::ostream &amp;</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="os"><paramtype>std::ostream &amp;</paramtype></parameter><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><description><para>Prints expression <emphasis>expr</emphasis> to stream <emphasis>os</emphasis>. Returns <emphasis>os</emphasis>. </para></description></function>





















































</namespace>
</namespace>
</header>
<header id="doxygen.headers.user__macros_8hpp" name="boost/yap/user_macros.hpp">
<macro id="doxygen.headers.user__macros_8hpp_1a835bf2c8a57e5572849469d6f3acb0cf" name="BOOST_YAP_USER_UNARY_OPERATOR" kind="functionlike"><macro-parameter name="op_name"><description><para>The operator to be overloaded; this must be one of the <emphasis role="bold">unary</emphasis> enumerators in <computeroutput>expr_kind</computeroutput>, without the <computeroutput>expr_kind::</computeroutput> qualification.</para></description></macro-parameter><macro-parameter name="expr_template"><description><para>The expression template to which the overloads apply. <emphasis>expr_template</emphasis> must be an ExpressionTemplate.</para></description></macro-parameter><macro-parameter name="result_expr_template"><description><para>The expression template to use to instantiate the result expression. <emphasis>result_expr_template</emphasis> must be an ExpressionTemplate. </para></description></macro-parameter><description><para>Defines operator overloads for unary operator <emphasis>op_name</emphasis> that each take an expression instantiated from <emphasis>expr_template</emphasis> and return an expression instantiated from the <emphasis>result_expr_template</emphasis> expression template. One overload is defined for each of the qualifiers <computeroutput>const &amp;</computeroutput>, <computeroutput>&amp;</computeroutput>, and <computeroutput>&amp;&amp;</computeroutput>. For the lvalue reference overloads, the argument is captured by reference into the resulting expression. For the rvalue reference overload, the argument is moved into the resulting expression.</para><para>Example: <programlisting language="c++"/></para><para>
</para></description></macro>
<macro id="doxygen.headers.user__macros_8hpp_1a69f2ddbdd70ed2ed3eaea7494daafba7" name="BOOST_YAP_USER_BINARY_OPERATOR" kind="functionlike"><macro-parameter name="op_name"><description><para>The operator to be overloaded; this must be one of the <emphasis role="bold">binary</emphasis> enumerators in <computeroutput>expr_kind</computeroutput>, except assign, subscript, or call, without the <computeroutput>expr_kind::</computeroutput> qualification.</para></description></macro-parameter><macro-parameter name="expr_template"><description><para>The expression template to which the overloads apply. <emphasis>expr_template</emphasis> must be an ExpressionTemplate.</para></description></macro-parameter><macro-parameter name="result_expr_template"><description><para>The expression template to use to instantiate the result expression. <emphasis>result_expr_template</emphasis> must be an ExpressionTemplate. </para></description></macro-parameter><description><para>Defines operator overloads for binary operator <emphasis>op_name</emphasis> that each produce an expression instantiated from the <emphasis>expr_template</emphasis> expression template. One overload is defined for each of the qualifiers <computeroutput>const &amp;</computeroutput>, <computeroutput>&amp;</computeroutput>, and <computeroutput>&amp;&amp;</computeroutput>. For the lvalue reference overloads, <computeroutput>*this</computeroutput> is captured by reference into the resulting expression. For the rvalue reference overload, <computeroutput>*this</computeroutput> is moved into the resulting expression.</para><para>Note that this does not work for yap::expr_kinds assign, subscript, or call. Use BOOST_YAP_USER_ASSIGN_OPERATOR, BOOST_YAP_USER_SUBSCRIPT_OPERATOR, or BOOST_YAP_USER_CALL_OPERATOR for those, respectively.</para><para>Example: <programlisting language="c++"/></para><para>
</para></description></macro>
<macro id="doxygen.headers.user__macros_8hpp_1a76c957eb06827a15e68bfb18c8ceffef" name="BOOST_YAP_USER_ASSIGN_OPERATOR" kind="functionlike"><macro-parameter name="this_type"><description><para>The type of the class the operator is a member of; this is required to avoid clashing with the assignment and move assignement operators.</para></description></macro-parameter><macro-parameter name="expr_template"><description><para>The expression template to use to instantiate the result expression. <emphasis>expr_template</emphasis> must be an ExpressionTemplate. </para></description></macro-parameter><description><para>Defines operator overloads for <emphasis>operator=()</emphasis> that each produce an expression instantiated from the <emphasis>expr_template</emphasis> expression template. One overload is defined for each of the qualifiers <computeroutput>const &amp;</computeroutput>, <computeroutput>&amp;</computeroutput>, and <computeroutput>&amp;&amp;</computeroutput>. For the lvalue reference overloads, <computeroutput>*this</computeroutput> is captured by reference into the resulting expression. For the rvalue reference overload, <computeroutput>*this</computeroutput> is moved into the resulting expression.</para><para>The <emphasis>rhs</emphasis> parameter to each of the defined overloads may be any type, including an expression, except that the overloads are constrained by std::enable_if&lt;&gt; not to conflict with the assignment and move assignement operators. If <emphasis>rhs</emphasis> is a non-expression, it is wrapped in a terminal expression.</para><para>Example: <programlisting language="c++"/></para><para>
</para></description></macro>
<macro id="doxygen.headers.user__macros_8hpp_1a4920d9ddb0c72a810b9b2ad0bbf4da01" name="BOOST_YAP_USER_SUBSCRIPT_OPERATOR" kind="functionlike"><macro-parameter name="expr_template"><description><para>The expression template to use to instantiate the result expression. <emphasis>expr_template</emphasis> must be an ExpressionTemplate. </para></description></macro-parameter><description><para>Defines operator overloads for <emphasis>operator[]()</emphasis> that each produce an expression instantiated from the <emphasis>expr_template</emphasis> expression template. One overload is defined for each of the qualifiers <computeroutput>const &amp;</computeroutput>, <computeroutput>&amp;</computeroutput>, and <computeroutput>&amp;&amp;</computeroutput>. For the lvalue reference overloads, <computeroutput>*this</computeroutput> is captured by reference into the resulting expression. For the rvalue reference overload, <computeroutput>*this</computeroutput> is moved into the resulting expression.</para><para>The <emphasis>rhs</emphasis> parameter to each of the defined overloads may be any type, including an expression, except that the overloads are constrained by std::enable_if&lt;&gt; not to conflict with the assignment and move assignement operators. If <emphasis>rhs</emphasis> is a non-expression, it is wrapped in a terminal expression.</para><para>Example: <programlisting language="c++"/></para><para>
</para></description></macro>
<macro id="doxygen.headers.user__macros_8hpp_1a354d76c0c6f798907ab22755d86f5007" name="BOOST_YAP_USER_CALL_OPERATOR" kind="functionlike"><macro-parameter name="expr_template"><description><para>The expression template to use to instantiate the result expression. <emphasis>expr_template</emphasis> must be an ExpressionTemplate. </para></description></macro-parameter><description><para>Defines operator overloads for the call operator taking any number of parameters ("operator()") that each produce an expression instantiated from the <emphasis>expr_template</emphasis> expression template. One overload is defined for each of the qualifiers <computeroutput>const &amp;</computeroutput>, <computeroutput>&amp;</computeroutput>, and <computeroutput>&amp;&amp;</computeroutput>. For the lvalue reference overloads, <computeroutput>*this</computeroutput> is captured by reference into the resulting expression. For the rvalue reference overload, <computeroutput>*this</computeroutput> is moved into the resulting expression.</para><para>The <emphasis>u</emphasis> parameters to each of the defined overloads may be any type, including an expression. Each non-expression is wrapped in a terminal expression.</para><para>Example: <programlisting language="c++"/></para><para>
</para></description></macro>
<macro id="doxygen.headers.user__macros_8hpp_1a1d28a3fdbc84354d12b4affcc61ec9e5" name="BOOST_YAP_USER_CALL_OPERATOR_N" kind="functionlike"><macro-parameter name="expr_template"><description><para>The expression template to use to instantiate the result expression. <emphasis>expr_template</emphasis> must be an ExpressionTemplate.</para></description></macro-parameter><macro-parameter name="n"><description><para>The number of parameters accepted by the operator() overloads. n must be &lt;= BOOST_PP_LIMIT_REPEAT. </para></description></macro-parameter><description><para>Defines operator overloads for the call operator taking N parameters ("operator()(t0, t1, ... tn-1)") that each produce an expression instantiated from the <emphasis>expr_template</emphasis> expression template. One overload is defined for each of the qualifiers <computeroutput>const &amp;</computeroutput>, <computeroutput>&amp;</computeroutput>, and <computeroutput>&amp;&amp;</computeroutput>. For the lvalue reference overloads, <computeroutput>*this</computeroutput> is captured by reference into the resulting expression. For the rvalue reference overload, <computeroutput>*this</computeroutput> is moved into the resulting expression.</para><para>The <emphasis>u</emphasis> parameters to each of the defined overloads may be any type, including an expression. Each non-expression is wrapped in a terminal expression.</para><para>Example: <programlisting language="c++"/></para><para>
</para></description></macro>
<macro id="doxygen.headers.user__macros_8hpp_1aa0e733297b330471a525bbce2eac1986" name="BOOST_YAP_USER_EXPR_IF_ELSE" kind="functionlike"><macro-parameter name="expr_template"><description><para>The expression template to use to instantiate the result expression. <emphasis>expr_template</emphasis> must be an ExpressionTemplate. </para></description></macro-parameter><description><para>Defines a 3-parameter function <computeroutput>if_else()</computeroutput> that acts as an analogue to the ternary operator (<computeroutput>?:</computeroutput>), since the ternary operator is not user-overloadable. The return type of <computeroutput>if_else()</computeroutput> is an expression instantiated from the <emphasis>expr_template</emphasis> expression template.</para><para>At least one parameter to <computeroutput>if_else()</computeroutput> must be an expression.</para><para>For each parameter E passed to <computeroutput>if_else()</computeroutput>, if E is an rvalue, E is moved into the result, and otherwise E is captured by reference into the result.</para><para>Example: <programlisting language="c++"/></para><para>
</para></description></macro>
<macro id="doxygen.headers.user__macros_8hpp_1ada604555faf074a1860172a39303f713" name="BOOST_YAP_USER_UDT_ANY_IF_ELSE" kind="functionlike"><macro-parameter name="expr_template"><description><para>The expression template to use to instantiate the result expression. <emphasis>expr_template</emphasis> must be an ExpressionTemplate.</para></description></macro-parameter><macro-parameter name="udt_trait"><description><para>A trait template to use to constrain which types are accepted as template parameters to <computeroutput>if_else()</computeroutput>. </para></description></macro-parameter><description><para>Defines a function <computeroutput>if_else()</computeroutput> that acts as an analogue to the ternary operator (<computeroutput>?:</computeroutput>), since the ternary operator is not user-overloadable. The return type of <computeroutput>if_else()</computeroutput> is an expression instantiated from the <emphasis>expr_template</emphasis> expression template.</para><para>Each parameter to <computeroutput>if_else()</computeroutput> may be any type that is <emphasis role="bold">not</emphasis> an expression. At least on parameter must be a type <computeroutput>T</computeroutput> for which <programlisting language="c++">udt_trait&lt;std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;&gt;::value
</programlisting> is true. Each parameter is wrapped in a terminal expression.</para><para>Example: <programlisting language="c++"/></para><para>
</para></description></macro>
<macro id="doxygen.headers.user__macros_8hpp_1aa9983b01946946553fe90322028540b7" name="BOOST_YAP_USER_UDT_UNARY_OPERATOR" kind="functionlike"><macro-parameter name="op_name"><description><para>The operator to be overloaded; this must be one of the <emphasis role="bold">unary</emphasis> enumerators in <computeroutput>expr_kind</computeroutput>, without the <computeroutput>expr_kind::</computeroutput> qualification.</para></description></macro-parameter><macro-parameter name="expr_template"><description><para>The expression template to use to instantiate the result expression. <emphasis>expr_template</emphasis> must be an ExpressionTemplate.</para></description></macro-parameter><macro-parameter name="udt_trait"><description><para>A trait template to use to constrain which types are accepted as template parameters to the defined operator overload. </para></description></macro-parameter><description><para>Defines a free/non-member operator overload for unary operator <emphasis>op_name</emphasis> that produces an expression instantiated from the <emphasis>expr_template</emphasis> expression template.</para><para>The parameter to the defined operator overload may be any type that is <emphasis role="bold">not</emphasis> an expression and for which <programlisting language="c++">udt_trait&lt;std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;&gt;::value 
</programlisting> is true. The parameter is wrapped in a terminal expression.</para><para>Example: <programlisting language="c++"/></para><para>
</para></description></macro>
<macro id="doxygen.headers.user__macros_8hpp_1aeba73764e8f1f0262d721de067212589" name="BOOST_YAP_USER_UDT_UDT_BINARY_OPERATOR" kind="functionlike"><macro-parameter name="op_name"><description><para>The operator to be overloaded; this must be one of the <emphasis role="bold">binary</emphasis> enumerators in <computeroutput>expr_kind</computeroutput>, without the <computeroutput>expr_kind::</computeroutput> qualification.</para></description></macro-parameter><macro-parameter name="expr_template"><description><para>The expression template to use to instantiate the result expression. <emphasis>expr_template</emphasis> must be an ExpressionTemplate.</para></description></macro-parameter><macro-parameter name="t_udt_trait"><description><para>A trait template to use to constrain which types are accepted as <emphasis>T</emphasis> template parameters to the defined operator overload.</para></description></macro-parameter><macro-parameter name="u_udt_trait"><description><para>A trait template to use to constrain which types are accepted as <emphasis>U</emphasis> template parameters to the defined operator overload. </para></description></macro-parameter><description><para>Defines a free/non-member operator overload for binary operator <emphasis>op_name</emphasis> that produces an expression instantiated from the <emphasis>expr_template</emphasis> expression template.</para><para>The <emphasis>lhs</emphasis> parameter to the defined operator overload may be any type that is <emphasis role="bold">not</emphasis> an expression and for which <programlisting language="c++">t_udt_trait&lt;std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;&gt;::value 
</programlisting> is true. The parameter is wrapped in a terminal expression.</para><para>The <emphasis>rhs</emphasis> parameter to the defined operator overload may be any type that is <emphasis role="bold">not</emphasis> an expression and for which <programlisting language="c++">u_udt_trait&lt;std::remove_cv_t&lt;std::remove_reference_t&lt;U&gt;&gt;&gt;::value 
</programlisting> is true. The parameter is wrapped in a terminal expression.</para><para>Example: <programlisting language="c++"/></para><para>
</para></description></macro>
<macro id="doxygen.headers.user__macros_8hpp_1a0e4b0bec43b86ad9dcf945db53154b0f" name="BOOST_YAP_USER_UDT_ANY_BINARY_OPERATOR" kind="functionlike"><macro-parameter name="op_name"><description><para>The operator to be overloaded; this must be one of the <emphasis role="bold">binary</emphasis> enumerators in <computeroutput>expr_kind</computeroutput>, without the <computeroutput>expr_kind::</computeroutput> qualification.</para></description></macro-parameter><macro-parameter name="expr_template"><description><para>The expression template to use to instantiate the result expression. <emphasis>expr_template</emphasis> must be an ExpressionTemplate.</para></description></macro-parameter><macro-parameter name="udt_trait"><description><para>A trait template to use to constrain which types are accepted as template parameters to the defined operator overload. </para></description></macro-parameter><description><para>Defines a free/non-member operator overload for binary operator <emphasis>op_name</emphasis> that produces an expression instantiated from the <emphasis>expr_template</emphasis> expression template.</para><para>The <emphasis>lhs</emphasis> and <emphasis>rhs</emphasis> parameters to the defined operator overload may be any types that are <emphasis role="bold">not</emphasis> expressions. Each parameter is wrapped in a terminal expression.</para><para>At least one of the parameters to the defined operator overload must be a type <computeroutput>T</computeroutput> for which <programlisting language="c++">udt_trait&lt;std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;&gt;::value 
</programlisting> is true.</para><para>Example: <programlisting language="c++"/></para><para>
</para></description></macro>
<macro id="doxygen.headers.user__macros_8hpp_1a41bd0e25eb1c4ebec282e3d444a15e66" name="BOOST_YAP_USER_LITERAL_PLACEHOLDER_OPERATOR" kind="functionlike"><macro-parameter name="expr_template"><description><para>The expression template to use to instantiate the result expression. <emphasis>expr_template</emphasis> must be an ExpressionTemplate. </para></description></macro-parameter><description><para>Defines user defined literal template that creates literal placeholders instantiated from the <emphasis>expr_template</emphasis> expression template. It is recommended that you put this in its own namespace.</para><para>
</para></description></macro>
</header>
<header id="doxygen.headers.yap_8hpp" name="boost/yap/yap.hpp">
</header>
</library-reference>