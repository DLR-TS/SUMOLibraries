<?xml version="1.0" standalone="yes"?>
<library-reference id="shared_library_reference"><title>Shared Library Reference</title><header id="doxygen.shared_library_reference.alias_8hpp" name="boost/dll/alias.hpp">
<para>Includes alias methods and macro. You can include this header or <link linkend="doxygen.shared_library_reference.shared__library_8hpp">boost/dll/shared_library.hpp</link> to reduce dependencies in case you do not use the refcountable functions. </para><namespace name="boost">
<namespace name="dll">












</namespace>
</namespace>
<macro id="doxygen.shared_library_reference.alias_8hpp_1a999436ae51109c6cfdd49fa776c9ca2e" name="BOOST_DLL_FORCE_ALIAS_INSTANTIATION"><description><para>Define this macro to explicitly specify translation unit in which alias must be instantiated. See section 'Limitations' for more info. You may find usage examples in source codes of almost each tutorial. Must be used in code, when  <link linkend="BOOST_DLL_FORCE_NO_WEAK_EXPORTS">BOOST_DLL_FORCE_NO_WEAK_EXPORTS</link> is defined </para></description></macro>
<macro id="doxygen.shared_library_reference.alias_8hpp_1a080c15c55a3a372193e158156fc77f6a" name="BOOST_DLL_FORCE_NO_WEAK_EXPORTS"><description><para>Define this macro to disable exporting weak symbols and start using the  <link linkend="BOOST_DLL_FORCE_ALIAS_INSTANTIATION">BOOST_DLL_FORCE_ALIAS_INSTANTIATION</link>. This may be useful for working around linker problems or to test your program for compatibility with linkers that do not support export of weak symbols. </para></description></macro>
<macro id="doxygen.shared_library_reference.alias_8hpp_1a18e217f7c26bce9cb08c64f41fbd6178" name="BOOST_DLL_SELECTANY"><purpose>Macro that allows linker to select any occurrence of this symbol instead of failing with 'multiple definitions' error at linktime. </purpose><description><para>This macro does not work on Android, IBM XL C/C++ and MinGW+Windows because of linker problems with exporting weak symbols (See <ulink url="https://code.google.com/p/android/issues/detail?id=70206">https://code.google.com/p/android/issues/detail?id=70206</ulink>, <ulink url="https://sourceware.org/bugzilla/show_bug.cgi?id=17480">https://sourceware.org/bugzilla/show_bug.cgi?id=17480</ulink>) </para></description></macro>
<macro id="doxygen.shared_library_reference.alias_8hpp_1a77c8964c8b614e76a662bb500babac74" name="BOOST_DLL_SECTION" kind="functionlike"><macro-parameter name="SectionName"><description><para>Name of the section. Must be a valid C identifier without quotes not longer than 8 bytes. </para></description></macro-parameter><macro-parameter name="Permissions"><description><para>Can be "read" or "write" (without quotes!). </para></description></macro-parameter><purpose>Macro that puts symbol to a specific section. On MacOS all the sections are put into "__DATA" segment. </purpose><description><para>
</para></description></macro>
<macro id="doxygen.shared_library_reference.alias_8hpp_1ad9f8b1de81ae3b24cd938c7bacb27eef" name="BOOST_DLL_ALIAS" kind="functionlike"><macro-parameter name="FunctionOrVar"><description><para>Function or variable for which an alias must be made. </para></description></macro-parameter><macro-parameter name="AliasName"><description><para>Name of the alias. Must be a valid C identifier.</para></description></macro-parameter><purpose>Makes an alias name for exported function or variable. </purpose><description><para>This macro is useful in cases of long mangled C++ names. For example some <computeroutput>void boost::foo(std::string)</computeroutput> function name will change to something like <computeroutput>N5boostN3foosE</computeroutput> after mangling. Importing function by <computeroutput>N5boostN3foosE</computeroutput> name does not looks user friendly, especially assuming the fact that different compilers have different mangling schemes. AliasName is the name that won't be mangled and can be used as a portable import name.</para><para>Can be used in any namespace, including global. FunctionOrVar must be fully qualified, so that address of it could be taken. Multiple different aliases for a single variable/function are allowed.</para><para>Make sure that AliasNames are unique per library/executable. Functions or variables in global namespace must not have names same as AliasNames.</para><para>Same AliasName in different translation units must point to the same FunctionOrVar.</para><para>Puts all the aliases into the <emphasis role="bold">"boostdll"</emphasis> read only section of the binary. Equal to  <link linkend="BOOST_DLL_ALIAS_SECTIONED">BOOST_DLL_ALIAS_SECTIONED</link>(FunctionOrVar, AliasName, boostdll).</para><para>
<emphasis role="bold">Example:</emphasis> <programlisting language="c++">namespace foo {
  void bar(std::string&amp;);

  BOOST_DLL_ALIAS(foo::bar, foo_bar)
}

BOOST_DLL_ALIAS(foo::bar, foo_bar_another_alias_name)
</programlisting></para><para><emphasis role="bold">See:</emphasis>  <link linkend="BOOST_DLL_ALIAS_SECTIONED">BOOST_DLL_ALIAS_SECTIONED</link> for making alias in a specific section. </para></description></macro>
<macro id="doxygen.shared_library_reference.alias_8hpp_1af10683bc3be11abe1957b186fcec2bd2" name="BOOST_DLL_ALIAS_SECTIONED" kind="functionlike"><macro-parameter name="FunctionOrVar"><description><para>Function or variable for which an alias must be made. </para></description></macro-parameter><macro-parameter name="AliasName"><description><para>Name of the alias. Must be a valid C identifier. </para></description></macro-parameter><macro-parameter name="SectionName"><description><para>Name of the section. Must be a valid C identifier without quotes not longer than 8 bytes.</para></description></macro-parameter><purpose>Same as  <link linkend="BOOST_DLL_ALIAS">BOOST_DLL_ALIAS</link> but puts alias name into the user specified section. </purpose><description><para>
<emphasis role="bold">Example:</emphasis> <programlisting language="c++">namespace foo {
  void bar(std::string&amp;);

  BOOST_DLL_ALIAS_SECTIONED(foo::bar, foo_bar, sect_1) // section "sect_1" now exports "foo_bar"
}
</programlisting> </para></description></macro>
<macro id="doxygen.shared_library_reference.alias_8hpp_1af6db740861079eab68b0629d98d74cd8" name="BOOST_DLL_AUTO_ALIAS" kind="functionlike"><macro-parameter name="FunctionOrVar"><description><para>Function or variable for which an unmangled alias must be made.</para></description></macro-parameter><purpose>Exports variable or function with unmangled alias name. </purpose><description><para>This macro is useful in cases of long mangled C++ names. For example some <computeroutput>void boost::foo(std::string)</computeroutput> function name will change to something like <computeroutput>N5boostN3foosE</computeroutput> after mangling. Importing function by <computeroutput>N5boostN3foosE</computeroutput> name does not looks user friendly, especially assuming the fact that different compilers have different mangling schemes.*</para><para>Must be used in scope where FunctionOrVar declared. FunctionOrVar must be a valid C name, which means that it must not contain <computeroutput>::</computeroutput>.</para><para>Functions or variables in global namespace must not have names same as FunctionOrVar.</para><para>Puts all the aliases into the <emphasis role="bold">"boostdll"</emphasis> read only section of the binary. Almost same as  <link linkend="BOOST_DLL_ALIAS">BOOST_DLL_ALIAS</link>(FunctionOrVar, FunctionOrVar).</para><para>
<emphasis role="bold">Example:</emphasis> <programlisting language="c++">namespace foo {
  void bar(std::string&amp;);
  BOOST_DLL_AUTO_ALIAS(bar)
}
</programlisting></para><para><emphasis role="bold">See:</emphasis>  <link linkend="BOOST_DLL_ALIAS">BOOST_DLL_ALIAS</link> for making an alias with different names. </para></description></macro>
</header>
<header id="doxygen.shared_library_reference.config_8hpp" name="boost/dll/config.hpp">
<para>Imports filesystem, error_code, errc, system_error, make_error_code from Boost or C++17 into <computeroutput>boost::dll::fs</computeroutput> namespace. </para><namespace name="boost">
<namespace name="dll">
<namespace name="fs">
<typedef id="doxygen.shared_library_reference.config_8hpp_1a939779dd5b1ae0a53b2a7bb25c743340" name="path"><description><para>Alias to <computeroutput>std::filesystem::path</computeroutput> if  <link linkend="BOOST_DLL_USE_STD_FS">BOOST_DLL_USE_STD_FS</link> is defined by user. Alias to <computeroutput>boost::filesystem::path</computeroutput> otherwise. </para></description><type>std::conditional_t&lt; BOOST_DLL_USE_STD_FS, std::filesystem::path, boost::filesystem::path &gt;</type></typedef>
<typedef id="doxygen.shared_library_reference.config_8hpp_1ac4ea858513fc38c6eff42301364fa4b8" name="error_code"><description><para>Alias to <computeroutput>std::error_code</computeroutput> if  <link linkend="BOOST_DLL_USE_STD_FS">BOOST_DLL_USE_STD_FS</link> is defined by user. boost::system::error_code otherwise. </para></description><type>std::conditional_t&lt; BOOST_DLL_USE_STD_FS, std::error_code, boost::system::error_code &gt;</type></typedef>
<typedef id="doxygen.shared_library_reference.config_8hpp_1a3d99fa00649a98c9ad8a43f80882e2be" name="system_error"><description><para>Alias to <computeroutput>std::system_error</computeroutput> if  <link linkend="BOOST_DLL_USE_STD_FS">BOOST_DLL_USE_STD_FS</link> is defined by user. Alias to <computeroutput>boost::system::system_error</computeroutput> otherwise. </para></description><type>std::conditional_t&lt; BOOST_DLL_USE_STD_FS, std::system_error, boost::system::system_error &gt;</type></typedef>
</namespace>












</namespace>
</namespace>
<macro id="doxygen.shared_library_reference.config_8hpp_1a1384f665ec72490413602bcf2b9379e5" name="BOOST_DLL_USE_STD_FS"><purpose>Define this macro to make Boost.DLL use C++17's std::filesystem::path and std::system_error. </purpose></macro>
<macro id="doxygen.shared_library_reference.config_8hpp_1a38dfec27290aea1e4cb5742fefdea045" name="BOOST_DLL_USE_BOOST_SHARED_PTR"><description><para>Define this macro to make Boost.DLL use boost::shared_ptr instead of std::shared_ptr. This macro will be removed after a few releases, consider migrating to std::shared_ptr. <sbr/>
 </para></description></macro>
</header>
<header id="doxygen.shared_library_reference.library__info_8hpp" name="boost/dll/library_info.hpp">
<para>Contains only the <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1library__info">boost::dll::library_info</link> class that is capable of extracting different information from binaries. </para><namespace name="boost">
<namespace name="dll">
<class id="doxygen.shared_library_reference.classboost_1_1dll_1_1library__info" name="library_info"><inherit access="private">noncopyable</inherit><purpose>Class that is capable of extracting different information from a library or binary file. Currently understands ELF, MACH-O and PE formats on all the platforms. </purpose><method-group name="public member functions">
<constructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1library__info_1afd1c68ca7bd15d8564843fc26f3fc0df" specifiers="explicit"><parameter name="library_path"><paramtype>const boost::dll::fs::path &amp;</paramtype><description><para>Path to the binary file from which the info must be extracted. </para></description></parameter><parameter name="throw_if_not_native_format"><paramtype>bool</paramtype><default>true</default><description><para>Throw an exception if this file format is not supported by OS. </para></description></parameter><description><para>Opens file with specified path and prepares for information extraction. 

</para></description><throws><simpara><classname>std::exception</classname> based exceptions. </simpara>
</throws></constructor>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1library__info_1a49c81392841f50e51563a6b58b736018" name="sections"><type>std::vector&lt; std::string &gt;</type><description><para>

</para></description><returns><para>List of sections that exist in binary file. </para>
</returns><throws><simpara><classname>std::exception</classname> based exceptions. </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1library__info_1aa04fa8ba8489a1ee8ee8694c6168941d" name="symbols"><type>std::vector&lt; std::string &gt;</type><description><para>

</para></description><returns><para>List of all the exportable symbols from all the sections that exist in binary file. </para>
</returns><throws><simpara><classname>std::exception</classname> based exceptions. </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1library__info_1a672d308dd3aa07a46da66b4fd7bf5f0a" name="symbols"><type>std::vector&lt; std::string &gt;</type><parameter name="section_name"><paramtype>const char *</paramtype><description><para>Name of the section from which symbol names must be returned. </para></description></parameter><description><para>


This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description><returns><para>List of symbols from the specified section. </para>
</returns><throws><simpara><classname>std::exception</classname> based exceptions.</simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1library__info_1a55454664cc82a38245b3502fc52bc96e" name="symbols"><type>std::vector&lt; std::string &gt;</type><parameter name="section_name"><paramtype>const std::string &amp;</paramtype></parameter></method>
</method-group>
</class>











</namespace>
</namespace>
</header>
<header id="doxygen.shared_library_reference.runtime__symbol__info_8hpp" name="boost/dll/runtime_symbol_info.hpp">
<para>Provides methods for getting acceptable by <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library">boost::dll::shared_library</link> location of symbol, source line or program. </para><namespace name="boost">
<namespace name="dll">




<function id="doxygen.shared_library_reference.runtime__symbol__info_8hpp_1ab16edf0e9013a0d019ff1daf40824afc" name="symbol_location_ptr"><type>boost::dll::fs::path</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="ptr_to_symbol"><paramtype>T</paramtype><description><para>Pointer to symbol which location is to be determined. </para></description></parameter><parameter name="ec"><paramtype>std::error_code &amp;</paramtype><description><para>Variable that will be set to the result of the operation. </para></description></parameter><description><para>On success returns full path and name to the binary object that holds symbol pointed by ptr_to_symbol.</para><para>


<emphasis role="bold">Examples:</emphasis> <programlisting language="c++">int main() {
   dll::symbol_location_ptr(std::set_terminate(0));       // returns "/some/path/libmy_terminate_handler.so"
   dll::symbol_location_ptr(::signal(SIGSEGV, SIG_DFL));  // returns "/some/path/libmy_symbol_handler.so"
}
</programlisting> </para></description><returns><para>Path to the binary object that holds symbol or empty path in case error. </para>
</returns><throws><simpara><classname>std::bad_alloc</classname> in case of insufficient memory. Overload that does not accept  <link linkend="boost.dll.fs.error_code">boost::dll::fs::error_code</link> also throws  <link linkend="boost.dll.fs.system_error">boost::dll::fs::system_error</link>.</simpara>
</throws></function>
<function id="doxygen.shared_library_reference.runtime__symbol__info_8hpp_1a3134c47d201067dcb2e17425d2c7a08e" name="symbol_location_ptr"><type>boost::dll::fs::path</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="ptr_to_symbol"><paramtype>T</paramtype></parameter></function>
<function id="doxygen.shared_library_reference.runtime__symbol__info_8hpp_1a9ff31447ff4ccf4147d5d8cbbd134652" name="symbol_location"><type>boost::dll::fs::path</type><template>
          <template-type-parameter name="T"><purpose><para>Type of the symbol, must not be explicitly specified. </para></purpose></template-type-parameter>
        </template><parameter name="symbol"><paramtype>const T &amp;</paramtype><description><para>Symbol which location is to be determined. </para></description></parameter><parameter name="ec"><paramtype>std::error_code &amp;</paramtype><description><para>Variable that will be set to the result of the operation. </para></description></parameter><description><para>On success returns full path and name of the binary object that holds symbol.</para><para>



<emphasis role="bold">Examples:</emphasis> <programlisting language="c++">int var;
void foo() {}

int main() {
   dll::symbol_location(var);                     // returns program location
   dll::symbol_location(foo);                     // returns program location
   dll::symbol_location(std::cerr);               // returns location of libstdc++: "/usr/lib/x86_64-linux-gnu/libstdc++.so.6"
   dll::symbol_location(std::placeholders::_1);   // returns location of libstdc++: "/usr/lib/x86_64-linux-gnu/libstdc++.so.6"
   dll::symbol_location(std::puts);               // returns location of libc: "/lib/x86_64-linux-gnu/libc.so.6"
}
</programlisting> </para></description><returns><para>Path to the binary object that holds symbol or empty path in case error. </para>
</returns><throws><simpara><classname>std::bad_alloc</classname> in case of insufficient memory. Overload that does not accept  <link linkend="boost.dll.fs.error_code">boost::dll::fs::error_code</link> also throws  <link linkend="boost.dll.fs.system_error">boost::dll::fs::system_error</link>.</simpara>
</throws></function>
<function id="doxygen.shared_library_reference.runtime__symbol__info_8hpp_1a93277af09c4a69c94257f28e12fce0e6" name="symbol_location"><type>boost::dll::fs::path</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="symbol"><paramtype>const T &amp;</paramtype></parameter></function>
<function id="doxygen.shared_library_reference.runtime__symbol__info_8hpp_1a276250d0518256cf5f180a1cfeee1a6c" name="this_line_location"><type>boost::dll::fs::path</type><parameter name="ec"><paramtype>std::error_code &amp;</paramtype><description><para>Variable that will be set to the result of the operation. </para></description></parameter><description><para>On success returns full path and name of the binary object that holds the current line of code (the line in which the <computeroutput>this_line_location()</computeroutput> method was called).</para><para>

</para></description><throws><simpara><classname>std::bad_alloc</classname> in case of insufficient memory. Overload that does not accept  <link linkend="boost.dll.fs.error_code">boost::dll::fs::error_code</link> also throws  <link linkend="boost.dll.fs.system_error">boost::dll::fs::system_error</link>. </simpara>
</throws></function>
<function id="doxygen.shared_library_reference.runtime__symbol__info_8hpp_1a84176539bb46073e9894c34ee6eff0bd" name="this_line_location"><type>boost::dll::fs::path</type></function>
<function id="doxygen.shared_library_reference.runtime__symbol__info_8hpp_1ad4f62eae484acfa53de57045fd18dde7" name="program_location"><type>boost::dll::fs::path</type><parameter name="ec"><paramtype>std::error_code &amp;</paramtype><description><para>Variable that will be set to the result of the operation. </para></description></parameter><description><para>On success returns full path and name of the currently running program (the one which contains the <computeroutput>main()</computeroutput> function).</para><para>Return value can be used as a parameter for <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library">shared_library</link>. See Tutorial "Linking plugin into the executable" for usage example. Flag '-rdynamic' must be used when linking the plugin into the executable on Linux OS.</para><para>

</para></description><throws><simpara><classname>std::bad_alloc</classname> in case of insufficient memory. Overload that does not accept  <link linkend="boost.dll.fs.error_code">boost::dll::fs::error_code</link> also throws  <link linkend="boost.dll.fs.system_error">boost::dll::fs::system_error</link>. </simpara>
</throws></function>
<function id="doxygen.shared_library_reference.runtime__symbol__info_8hpp_1a73d84ce487df7a966cd8a05c601f9b4c" name="program_location"><type>boost::dll::fs::path</type></function>
</namespace>
</namespace>
</header>
<header id="doxygen.shared_library_reference.shared__library_8hpp" name="boost/dll/shared_library.hpp">
<para>Contains the <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library">boost::dll::shared_library</link> class, core class for all the DLL/DSO operations. </para><namespace name="boost">
<namespace name="dll">
<class id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library" name="shared_library"><purpose>This class can be used to load a Dynamic link libraries (DLL's) or Shared Libraries, also know as dynamic shared objects (DSO's) and get their exported symbols (functions and variables). </purpose><description><para><link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library">shared_library</link> instances share reference count to an actual loaded DLL/DSO, so it is safe and memory efficient to have multiple instances of <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library">shared_library</link> referencing the same DLL/DSO even if those instances were loaded using different paths (relative + absolute) referencing the same object.</para><para>On Linux/POSIX link with library "dl". "-fvisibility=hidden" flag is also recommended for use on Linux/POSIX. </para></description><typedef id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a2156f2fea24b024a6f3de6f738454f26" name="native_handle_t"><type>platform_specific</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a5342750ce76cb563168bd5c59bc3d613"><description><para>Creates in anstance that does not reference any DLL/DSO.</para><para>

</para></description><postconditions><para>this-&gt;<link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a768114474404dc56ef584b512dfd2b44">is_loaded()</link> returns false. </para>
</postconditions><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></constructor>
<constructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a454d04d32a889c9dce94d19b7624ad7c"><parameter name="lib"><paramtype>const <classname>shared_library</classname> &amp;</paramtype><description><para>A library to copy. </para></description></parameter><description><para>Copy constructor that increments the reference count of an underlying shared library. Same as calling constructor with <computeroutput>lib.location()</computeroutput> parameter.</para><para>


xmlonly &lt;link linkend='boost.dll.fs.system_error'&gt;boost::dll::fs::system_error&lt;/link&gt;, std::bad_alloc in case of insufficient memory. </para></description><postconditions><para>lib == *this </para>
</postconditions><throws><simpara><classname/> </simpara>
</throws></constructor>
<constructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a6db4d24cf06441047ee057c5bedeaab5"><parameter name="lib"><paramtype>const <classname>shared_library</classname> &amp;</paramtype><description><para>A shared library to copy. </para></description></parameter><parameter name="ec"><paramtype>std::error_code &amp;</paramtype><description><para>Variable that will be set to the result of the operation. </para></description></parameter><description><para>Copy constructor that increments the reference count of an underlying shared library. Same as calling constructor with <computeroutput>lib.location(), ec</computeroutput> parameters.</para><para>


</para></description><postconditions><para>lib == *this </para>
</postconditions><throws><simpara><classname>std::bad_alloc</classname> in case of insufficient memory. </simpara>
</throws></constructor>
<constructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a097eb8ef42cbc14f764e67f584475168" cv="noexcept"><parameter name="lib"><paramtype><classname>shared_library</classname> &amp;&amp;</paramtype><description><para>A shared library to move from. </para></description></parameter><description><para>Move constructor. Does not invalidate existing symbols and functions loaded from lib.</para><para>


</para></description><postconditions><para>lib.is_loaded() returns false, this-&gt;<link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a768114474404dc56ef584b512dfd2b44">is_loaded()</link> return true. </para>
</postconditions><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></constructor>
<constructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a1ab469a0d809f3b579c1dbcd5be7c0f7" specifiers="explicit"><parameter name="lib_path"><paramtype>const boost::dll::fs::path &amp;</paramtype><description><para>Library file name. Can handle std::string, const char*, std::wstring, const wchar_t* or  <link linkend="boost.dll.fs.path">boost::dll::fs::path</link>. </para></description></parameter><parameter name="mode"><paramtype>load_mode::type</paramtype><default>load_mode::default_mode</default><description><para>A mode that will be used on library load. </para></description></parameter><description><para>Loads a library by specified path with a specified mode.</para><para>

xmlonly &lt;link linkend='boost.dll.fs.system_error'&gt;boost::dll::fs::system_error&lt;/link&gt;, std::bad_alloc in case of insufficient memory. </para></description><throws><simpara><classname/> </simpara>
</throws></constructor>
<constructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a6767e3551e9160709021e2d7dd61f675"><parameter name="lib_path"><paramtype>const boost::dll::fs::path &amp;</paramtype><description><para>Library file name. Can handle std::string, const char*, std::wstring, const wchar_t* or  <link linkend="boost.dll.fs.path">boost::dll::fs::path</link>. </para></description></parameter><parameter name="ec"><paramtype>std::error_code &amp;</paramtype><description><para>Variable that will be set to the result of the operation. </para></description></parameter><parameter name="mode"><paramtype>load_mode::type</paramtype><default>load_mode::default_mode</default><description><para>A mode that will be used on library load. </para></description></parameter><description><para>Loads a library by specified path with a specified mode.</para><para>

This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description><throws><simpara><classname>std::bad_alloc</classname> in case of insufficient memory.</simpara>
</throws></constructor>
<constructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a7b5ee4d4ba44be12dd96965d9c0a85fc"><parameter name="lib_path"><paramtype>const boost::dll::fs::path &amp;</paramtype></parameter><parameter name="mode"><paramtype>load_mode::type</paramtype></parameter><parameter name="ec"><paramtype>std::error_code &amp;</paramtype></parameter></constructor>
<constructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a1e4ccaa07bee776041458bac929ea5ae" specifiers="explicit" cv="noexcept"><parameter name="handle"><paramtype>native_handle_t</paramtype><description><para>The native handle. </para></description></parameter><description><para>Takes ownership of a loaded library.</para><para>
</para></description></constructor>
<copy-assignment id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a49d9fa037377791d9a19c5e4f395fc6e"><type><classname>shared_library</classname> &amp;</type><parameter name="lib"><paramtype>const <classname>shared_library</classname> &amp;</paramtype><description><para>A shared library to assign from. </para></description></parameter><description><para>Assignment operator. If this-&gt;<link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a768114474404dc56ef584b512dfd2b44">is_loaded()</link> then calls this-&gt;<link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a4f98671190fa5ccb035c8682ed26a140">unload()</link>. Does not invalidate existing symbols and functions loaded from lib.</para><para>


xmlonly &lt;link linkend='boost.dll.fs.system_error'&gt;boost::dll::fs::system_error&lt;/link&gt;, std::bad_alloc in case of insufficient memory. </para></description><postconditions><para>lib == *this </para>
</postconditions><throws><simpara><classname/> </simpara>
</throws></copy-assignment>
<copy-assignment id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a9d1a77d5ffcd4b4b5f085203ce46f7d0" cv="noexcept"><type><classname>shared_library</classname> &amp;</type><parameter name="lib"><paramtype><classname>shared_library</classname> &amp;&amp;</paramtype><description><para>A library to move from. </para></description></parameter><description><para>Move assignment operator. If this-&gt;<link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a768114474404dc56ef584b512dfd2b44">is_loaded()</link> then calls this-&gt;<link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a4f98671190fa5ccb035c8682ed26a140">unload()</link>. Does not invalidate existing symbols and functions loaded from lib.</para><para>


</para></description><postconditions><para>lib.is_loaded() returns false. </para>
</postconditions><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></copy-assignment>
<destructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a9dcb385da72f28e4d089af67a39f129e" cv="= default"><description><para>Destroys the object by calling <computeroutput><link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a4f98671190fa5ccb035c8682ed26a140">unload()</link></computeroutput>. If library was loaded multiple times by different instances, the actual DLL/DSO won't be unloaded until there is at least one instance that references the DLL/DSO.</para><para>
</para></description><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></destructor>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a076d9f34a75053e0b417ffb72acf3577" name="assign"><type><classname>shared_library</classname> &amp;</type><parameter name="lib"><paramtype>const <classname>shared_library</classname> &amp;</paramtype><description><para>A library to copy. </para></description></parameter><parameter name="ec"><paramtype>std::error_code &amp;</paramtype><description><para>Variable that will be set to the result of the operation. </para></description></parameter><description><para>Makes *this share the same shared object as lib. If *this is loaded, then unloads it.</para><para>


</para></description><postconditions><para>lib.location() == this-&gt;<link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a4a30a9e68d73ecee781d692cbf596eca">location()</link>, lib == *this </para>
</postconditions><throws><simpara><classname>std::bad_alloc</classname> in case of insufficient memory. </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1ac456f7a8000c86018d51b0d4eeb2a72d" name="assign"><type><classname>shared_library</classname> &amp;</type><parameter name="lib"><paramtype>const <classname>shared_library</classname> &amp;</paramtype><description><para>A library instance to assign from. </para></description></parameter><description><para>Makes *this share the same shared object as lib. If *this is loaded, then unloads it.</para><para>


xmlonly &lt;link linkend='boost.dll.fs.system_error'&gt;boost::dll::fs::system_error&lt;/link&gt;, std::bad_alloc in case of insufficient memory. </para></description><postconditions><para>lib.location() == this-&gt;<link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a4a30a9e68d73ecee781d692cbf596eca">location()</link> </para>
</postconditions><throws><simpara><classname/> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a4a953c50b86191dd96aa471bac8099a6" name="load"><type>void</type><parameter name="lib_path"><paramtype>const boost::dll::fs::path &amp;</paramtype><description><para>Library file name. Can handle std::string, const char*, std::wstring, const wchar_t* or  <link linkend="boost.dll.fs.path">boost::dll::fs::path</link>. </para></description></parameter><parameter name="mode"><paramtype>load_mode::type</paramtype><default>load_mode::default_mode</default><description><para>A mode that will be used on library load. </para></description></parameter><description><para>Loads a library by specified path with a specified mode.</para><para>Note that if some library is already loaded in this instance, load will call <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a4f98671190fa5ccb035c8682ed26a140">unload()</link> and then load the new provided library.</para><para>

xmlonly &lt;link linkend='boost.dll.fs.system_error'&gt;boost::dll::fs::system_error&lt;/link&gt;, std::bad_alloc in case of insufficient memory. </para></description><throws><simpara><classname/> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a3467b64cbfc5333fd11810dcbbefd83b" name="load"><type>void</type><parameter name="lib_path"><paramtype>const boost::dll::fs::path &amp;</paramtype><description><para>Library file name. Can handle std::string, const char*, std::wstring, const wchar_t* or  <link linkend="boost.dll.fs.path">boost::dll::fs::path</link>. </para></description></parameter><parameter name="ec"><paramtype>std::error_code &amp;</paramtype><description><para>Variable that will be set to the result of the operation. </para></description></parameter><parameter name="mode"><paramtype>load_mode::type</paramtype><default>load_mode::default_mode</default><description><para>A mode that will be used on library load. </para></description></parameter><description><para>Loads a library by specified path with a specified mode.</para><para>Note that if some library is already loaded in this instance, load will call <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a4f98671190fa5ccb035c8682ed26a140">unload()</link> and then load the new provided library.</para><para>

This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description><throws><simpara><classname>std::bad_alloc</classname> in case of insufficient memory.</simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a68cb5fdaa42eb2ea866ea4b435fd7c8b" name="load"><type>void</type><parameter name="lib_path"><paramtype>const boost::dll::fs::path &amp;</paramtype></parameter><parameter name="mode"><paramtype>load_mode::type</paramtype></parameter><parameter name="ec"><paramtype>std::error_code &amp;</paramtype></parameter></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a4f98671190fa5ccb035c8682ed26a140" name="unload" cv="noexcept"><type>void</type><description><para>Unloads a shared library. If library was loaded multiple times by different instances, the actual DLL/DSO won't be unloaded until there is at least one instance that references the DLL/DSO.</para><para>

</para></description><postconditions><para>this-&gt;<link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a768114474404dc56ef584b512dfd2b44">is_loaded()</link> returns false. </para>
</postconditions><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a768114474404dc56ef584b512dfd2b44" name="is_loaded" cv="const noexcept"><type>bool</type><description><para>Check if an library is loaded.</para><para>

</para></description><returns><para>true if a library has been loaded. </para>
</returns><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a420e60e9788bfa3b52aa3aab72ea3a5e" name="conversion-operator" cv="const noexcept" specifiers="explicit"><type>bool</type><description><para>Check if an library is loaded.</para><para>

</para></description><returns><para>true if a library has been loaded. </para>
</returns><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a61600573e373c540279ac3b5918dd8f1" name="has" cv="const noexcept"><type>bool</type><parameter name="symbol_name"><paramtype>const char *</paramtype><description><para>Null-terminated symbol name. Can handle std::string, char*, const char*. </para></description></parameter><description><para>Search for a given symbol on loaded library. Works for all symbols, including alias names.</para><para>


This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description><returns><para><computeroutput>true</computeroutput> if the loaded library contains a symbol with a given name. </para>
</returns><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1ac6d3a6b6218a32a25b8f9ee1f2cc4ab2" name="has" cv="const noexcept"><type>bool</type><parameter name="symbol_name"><paramtype>const std::string &amp;</paramtype></parameter></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a57ca07c405c026200cf5c7799ae36170" name="get" cv="const"><type>std::enable_if&lt; std::is_member_pointer&lt; T &gt;::value||std::is_reference&lt; T &gt;::value, T &gt;::type</type><template>
          <template-type-parameter name="T"><purpose><para>Type of the symbol that we are going to import. Must be explicitly specified. </para></purpose></template-type-parameter>
        </template><parameter name="symbol_name"><paramtype>const std::string &amp;</paramtype><description><para>Null-terminated symbol name. Can handle std::string, char*, const char*. </para></description></parameter><description><para>Returns reference to the symbol (function or variable) with the given name from the loaded library. This call will always succeed and throw nothing if call to <computeroutput>has(const char* )</computeroutput> member function with the same symbol name returned <computeroutput>true</computeroutput>.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">int&amp; i0 = lib.get&lt;int&gt;("integer_name");
int&amp; i1 = *lib.get&lt;int*&gt;("integer_alias_name");
</programlisting></para><para>



xmlonly &lt;link linkend='boost.dll.fs.system_error'&gt;boost::dll::fs::system_error&lt;/link&gt; if symbol does not exist or if the DLL/DSO was not loaded. </para></description><returns><para>Reference to the symbol. </para>
</returns><throws><simpara><classname/> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a5feaf1da478039b48f45304a3d712959" name="get" cv="const"><type>std::enable_if&lt;!(std::is_member_pointer&lt; T &gt;::value||std::is_reference&lt; T &gt;::value), T &amp; &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="symbol_name"><paramtype>const std::string &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a93ca3299942365309bef723f803aa0fc" name="get" cv="const"><type>std::enable_if&lt; std::is_member_pointer&lt; T &gt;::value||std::is_reference&lt; T &gt;::value, T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="symbol_name"><paramtype>const char *</paramtype></parameter></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1abf0dc58a1080204eaea2824a91fe1ee2" name="get" cv="const"><type>std::enable_if&lt;!(std::is_member_pointer&lt; T &gt;::value||std::is_reference&lt; T &gt;::value), T &amp; &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="symbol_name"><paramtype>const char *</paramtype></parameter></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a2e74443f85e1fd96a7f47a6a94131261" name="get_alias" cv="const"><type>T &amp;</type><template>
          <template-type-parameter name="T"><purpose><para>Type of the symbol that we are going to import. Must be explicitly specified.. </para></purpose></template-type-parameter>
        </template><parameter name="alias_name"><paramtype>const char *</paramtype><description><para>Null-terminated alias symbol name. Can handle std::string, char*, const char*. </para></description></parameter><description><para>Returns a symbol (function or variable) from a shared library by alias name of the symbol.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">int&amp; i = lib.get_alias&lt;int&gt;("integer_alias_name");
</programlisting></para><para>


xmlonly &lt;link linkend='boost.dll.fs.system_error'&gt;boost::dll::fs::system_error&lt;/link&gt; if symbol does not exist or if the DLL/DSO was not loaded.</para><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description><throws><simpara><classname/> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1ac773eeaa11c78ac11bcd440750b7c0b3" name="get_alias" cv="const"><type>T &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="alias_name"><paramtype>const std::string &amp;</paramtype></parameter></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a915bbd234b66500ecaf97d6dd576dc1f" name="native" cv="const noexcept"><type>native_handle_t</type><description><para>Returns the native handler of the loaded library.</para><para>
</para></description><returns><para>Platform-specific handle. </para>
</returns></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a4a30a9e68d73ecee781d692cbf596eca" name="location" cv="const"><type>boost::dll::fs::path</type><description><para>Returns full path and name of this shared object.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++"><link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a5342750ce76cb563168bd5c59bc3d613">shared_library</link> lib("test_lib.dll");
filesystem::path full_path = lib.location(); // C:\Windows\System32\test_lib.dll
</programlisting></para><para>

xmlonly &lt;link linkend='boost.dll.fs.system_error'&gt;boost::dll::fs::system_error&lt;/link&gt;, std::bad_alloc. </para></description><returns><para>Full path to the shared library. </para>
</returns><throws><simpara><classname/> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1aec6d6c4905cfcfe78a102f4f7d089d79" name="location" cv="const"><type>boost::dll::fs::path</type><parameter name="ec"><paramtype>std::error_code &amp;</paramtype><description><para>Variable that will be set to the result of the operation. </para></description></parameter><description><para>Returns full path and name of shared module.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++"><link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a5342750ce76cb563168bd5c59bc3d613">shared_library</link> lib("test_lib.dll");
filesystem::path full_path = lib.location(); // C:\Windows\System32\test_lib.dll
</programlisting></para><para>


</para></description><returns><para>Full path to the shared library. </para>
</returns><throws><simpara><classname>std::bad_alloc.</classname> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a2f918593e14788c2be148ac86ae6bf25" name="swap" cv="noexcept"><type>void</type><parameter name="rhs"><paramtype><classname>shared_library</classname> &amp;</paramtype><description><para>Library to swap with. </para></description></parameter><description><para>Swaps two libraries. Does not invalidate existing symbols and functions loaded from libraries.</para><para>

</para></description><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a3a0c6ead9ac034c79bec9f41deaebe13" name="suffix" specifiers="static"><type>boost::dll::fs::path</type><description><para>Returns suffix of shared module: in a call to <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a4a953c50b86191dd96aa471bac8099a6">load()</link> or the constructor/load.</para><para>
</para></description><returns><para>The suffix od shared module: ".dll" (Windows), ".so" (Unix/Linux/BSD), ".dylib" (MacOS/IOS) </para>
</returns></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a710b758049bfb6bcad95bf2381d493ec" name="decorate" specifiers="static"><type>boost::dll::fs::path</type><parameter name="sl"><paramtype>const boost::dll::fs::path &amp;</paramtype><description><para>the module name and path to decorate - for instance : /usr/lib/boost</para></description></parameter><description><para>Returns the decorated path to a shared module name, i.e. with needed prefix/suffix added.</para><para><emphasis role="bold">Recommendations:</emphasis> Use <computeroutput>load</computeroutput> with <computeroutput><link linkend="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a7aead736a07eaf25623ad7bfa1f0ee2dad42df8f173adb4aa7851d140c116ceb9">load_mode::append_decorations</link></computeroutput> instead of constructing the decorated path via <computeroutput><link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a710b758049bfb6bcad95bf2381d493ec">decorate()</link></computeroutput> and loading by it.</para><para>For instance, for a path like "path/to/boost" it returns :<itemizedlist>
<listitem><para>path/to/libboost.so on posix platforms</para>
</listitem><listitem><para>path/to/libboost.dylib on OSX</para>
</listitem><listitem><para>path/to/boost.dll on Windows</para>
</listitem></itemizedlist>
</para><para>Method handles both relative and absolute paths.</para><para><itemizedlist>
<listitem><para>Windows note: <computeroutput><link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a710b758049bfb6bcad95bf2381d493ec">decorate()</link></computeroutput> does not prepend "lib" to the decorated path. Use <computeroutput>load</computeroutput> with <computeroutput><link linkend="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a7aead736a07eaf25623ad7bfa1f0ee2dad42df8f173adb4aa7851d140c116ceb9">load_mode::append_decorations</link></computeroutput> for MinGW compatibility purpose.</para>
</listitem><listitem><para>Posix note: if the initial module name is already prepended with lib, only the <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a3a0c6ead9ac034c79bec9f41deaebe13">suffix()</link> is appended to the path</para>
</listitem></itemizedlist>
</para><para>

</para></description><returns><para>The decorated unportable path that may not exists in the filesystem or could be wrong due to platform specifics. </para>
</returns></method>
</method-group>
</class><function id="doxygen.shared_library_reference.shared__library_8hpp_1a6d51f221b149ece5780a5c09196e0390" name="operator=="><type>bool</type><parameter name="lhs"><paramtype>const <classname>shared_library</classname> &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>shared_library</classname> &amp;</paramtype></parameter><purpose>Very fast equality check that compares the actual DLL/DSO objects. Throws nothing. </purpose></function>
<function id="doxygen.shared_library_reference.shared__library_8hpp_1ac25b0987f5391b3328f8e79403fca6cf" name="operator!="><type>bool</type><parameter name="lhs"><paramtype>const <classname>shared_library</classname> &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>shared_library</classname> &amp;</paramtype></parameter><purpose>Very fast inequality check that compares the actual DLL/DSO objects. Throws nothing. </purpose></function>
<function id="doxygen.shared_library_reference.shared__library_8hpp_1a4852b13e9eebf480c7bcdc049138db94" name="operator&lt;"><type>bool</type><parameter name="lhs"><paramtype>const <classname>shared_library</classname> &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>shared_library</classname> &amp;</paramtype></parameter><purpose>Compare the actual DLL/DSO objects without any guarantee to be stable between runs. Throws nothing. </purpose></function>
<function id="doxygen.shared_library_reference.shared__library_8hpp_1a2c89f15322b6b790942047e5a439a543" name="swap"><type>void</type><parameter name="lhs"><paramtype><classname>shared_library</classname> &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>shared_library</classname> &amp;</paramtype></parameter><purpose>Swaps two shared libraries. Does not invalidate symbols and functions loaded from libraries. Throws nothing. </purpose></function>








</namespace>
</namespace>
</header>
<header id="doxygen.shared_library_reference.shared__library__load__mode_8hpp" name="boost/dll/shared_library_load_mode.hpp">
<para>Contains only the <link linkend="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a7aead736a07eaf25623ad7bfa1f0ee2d">boost::dll::load_mode::type</link> enum and operators related to it. </para><namespace name="boost">
<namespace name="dll">
<namespace name="load_mode">
<enum id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a7aead736a07eaf25623ad7bfa1f0ee2d" name="type"><enumvalue id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a7aead736a07eaf25623ad7bfa1f0ee2daa87aa807f4f29c945c57ad9489db63e0" name="default_mode"><description><para>Default open mode. See the <emphasis role="bold">Default:</emphasis> comments below to find out the flags that are enabled by default. </para></description></enumvalue><enumvalue id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a7aead736a07eaf25623ad7bfa1f0ee2da17d7a00379e716cbb263847f06e0d2a7" name="dont_resolve_dll_references"><description><para><emphasis role="bold">Platforms:</emphasis> Windows</para><para><emphasis role="bold">Default:</emphasis> disabled</para><para>If this value is used, and the executable module is a DLL, the system does not call DllMain for process and thread initialization and termination. Also, the system does not load additional executable modules that are referenced by the specified module.</para><para>Note Do not use this value; it is provided only for backward compatibility. If you are planning to access only data or resources in the DLL, use LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE or LOAD_LIBRARY_AS_IMAGE_RESOURCE or both. </para></description></enumvalue><enumvalue id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a7aead736a07eaf25623ad7bfa1f0ee2daa3e555b2310637f01d709c1b02fb3730" name="load_ignore_code_authz_level"><description><para><emphasis role="bold">Platforms:</emphasis> Windows</para><para><emphasis role="bold">Default:</emphasis> disabled</para><para>If this value is used, the system does not check AppLocker rules or apply Software Restriction Policies for the DLL. </para></description></enumvalue><enumvalue id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a7aead736a07eaf25623ad7bfa1f0ee2dad252c1bcbc4e74643e328625eeab382a" name="load_with_altered_search_path"><description><para><emphasis role="bold">Platforms:</emphasis> Windows</para><para><emphasis role="bold">Default:</emphasis> disabled</para><para>If this value is used and lpFileName specifies an absolute path, the system uses the alternate file search strategy.</para><para>This value cannot be combined with any LOAD_LIBRARY_SEARCH flag. </para></description></enumvalue><enumvalue id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a7aead736a07eaf25623ad7bfa1f0ee2dafb54d3aa5197bd25667c1c69829dfda4" name="rtld_lazy"><description><para><emphasis role="bold">Platforms:</emphasis> POSIX</para><para><emphasis role="bold">Default:</emphasis> enabled</para><para>Relocations shall be performed at an implementation-defined time, ranging from the time of the dlopen() call until the first reference to a given symbol occurs.</para><para>Specifying RTLD_LAZY should improve performance on implementations supporting dynamic symbol binding as a process may not reference all of the functions in any given object. And, for systems supporting dynamic symbol resolution for normal process execution, this behavior mimics the normal handling of process execution. </para></description></enumvalue><enumvalue id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a7aead736a07eaf25623ad7bfa1f0ee2daf57eec5cd1a7cacef56deafc56c3d133" name="rtld_now"><description><para><emphasis role="bold">Platforms:</emphasis> POSIX</para><para><emphasis role="bold">Default:</emphasis> disabled</para><para>All necessary relocations shall be performed when the object is first loaded. This may waste some processing if relocations are performed for functions that are never referenced. This behavior may be useful for plugins that need to know as soon as an object is loaded that all symbols referenced during execution are available. </para></description></enumvalue><enumvalue id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a7aead736a07eaf25623ad7bfa1f0ee2da320023d4da427b01f82302af267601a5" name="rtld_global"><description><para><emphasis role="bold">Platforms:</emphasis> POSIX</para><para><emphasis role="bold">Default:</emphasis> disabled</para><para>The object's symbols shall be made available for the relocation processing of any other object. In addition, symbol lookup using dlopen(0, mode) and an associated dlsym() allows objects loaded with this mode to be searched. </para></description></enumvalue><enumvalue id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a7aead736a07eaf25623ad7bfa1f0ee2da83befa2899fb795404a2b8bc61554a0f" name="rtld_local"><description><para><emphasis role="bold">Platforms:</emphasis> POSIX</para><para><emphasis role="bold">Default:</emphasis> enabled</para><para>The object's symbols shall not be made available for the relocation processing of any other object.</para><para>This is a default Windows behavior that can not be changed. </para></description></enumvalue><enumvalue id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a7aead736a07eaf25623ad7bfa1f0ee2da3c32983e935f557cdd2ebf264eaaa706" name="rtld_deepbind"><description><para><emphasis role="bold">Platforms:</emphasis> POSIX (requires glibc &gt;= 2.3.4)</para><para><emphasis role="bold">Default:</emphasis> disabled</para><para>The object will use its own symbols in preference to global symbols with the same name contained in libraries that have already been loaded. This flag is not specified in POSIX.1-2001. </para></description></enumvalue><enumvalue id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a7aead736a07eaf25623ad7bfa1f0ee2dad42df8f173adb4aa7851d140c116ceb9" name="append_decorations"><description><para><emphasis role="bold">Platforms:</emphasis> Windows, POSIX</para><para><emphasis role="bold">Default:</emphasis> disabled</para><para>Append a platform specific extension and prefix to shared library filename before trying to load it. If load attempt fails, try to load with exactly specified name.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">// Opens `./my_plugins/plugin1.dll` on Windows, `./my_plugins/libplugin1.so` on Linux, `./my_plugins/libplugin1.dylib` on MacOS.
// If that fails, loads `./my_plugins/plugin1`
<link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library">boost::dll::shared_library</link> lib("./my_plugins/plugin1", load_mode::append_decorations);
</programlisting> </para></description></enumvalue><enumvalue id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a7aead736a07eaf25623ad7bfa1f0ee2dafd471bd6b4959665ff9a54d3131b6f35" name="search_system_folders"><description><para><emphasis role="bold">Platforms:</emphasis> Windows, POSIX</para><para><emphasis role="bold">Default:</emphasis> disabled</para><para>Allow loading from system folders if path to library contains no parent path. </para></description></enumvalue><description><para>Library load modes.</para><para>Each of system family provides own modes. Flags not supported by a particular platform will be silently ignored.</para><para>For a detailed description of platform specific options see: <ulink url="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684179(v=vs.85).aspx">Windows specific options</ulink>, <ulink url="http://pubs.opengroup.org/onlinepubs/000095399/functions/dlopen.html">POSIX specific options</ulink>. </para></description></enum>
<function id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1ad8718ad1ea90d5c85cd254896975128c" name="operator|"><type>BOOST_CONSTEXPR type</type><parameter name="left"><paramtype>type</paramtype></parameter><parameter name="right"><paramtype>type</paramtype></parameter><purpose>Free operators for <link linkend="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a7aead736a07eaf25623ad7bfa1f0ee2d">load_mode::type</link> flag manipulation. </purpose></function>
<function id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a26fe915f1c1daaadf1185ca7f3ab2d68" name="operator|="><type>BOOST_CXX14_CONSTEXPR type &amp;</type><parameter name="left"><paramtype>type &amp;</paramtype></parameter><parameter name="right"><paramtype>type</paramtype></parameter></function>
<function id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1ae536793bb0aaa0eaaf0fcb2fbf04dc94" name="operator&amp;"><type>BOOST_CONSTEXPR type</type><parameter name="left"><paramtype>type</paramtype></parameter><parameter name="right"><paramtype>type</paramtype></parameter></function>
<function id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1aeea0f18865f0a3a222044b571aa3658d" name="operator&amp;="><type>BOOST_CXX14_CONSTEXPR type &amp;</type><parameter name="left"><paramtype>type &amp;</paramtype></parameter><parameter name="right"><paramtype>type</paramtype></parameter></function>
<function id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a6e6b773663b721f134057d150a90fcaa" name="operator^"><type>BOOST_CONSTEXPR type</type><parameter name="left"><paramtype>type</paramtype></parameter><parameter name="right"><paramtype>type</paramtype></parameter></function>
<function id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1a25517f970e6e279eafae3c33f97ae911" name="operator^="><type>BOOST_CXX14_CONSTEXPR type &amp;</type><parameter name="left"><paramtype>type &amp;</paramtype></parameter><parameter name="right"><paramtype>type</paramtype></parameter></function>
<function id="doxygen.shared_library_reference.shared__library__load__mode_8hpp_1ab9df356f99f3fcf1e9ec42a4a1db6724" name="operator~"><type>BOOST_CONSTEXPR type</type><parameter name="left"><paramtype>type</paramtype></parameter></function>
</namespace>












</namespace>
</namespace>
</header>
<header id="doxygen.shared_library_reference.smart__library_8hpp" name="boost/dll/smart_library.hpp">
<para>Contains the <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library">boost::dll::experimental::smart_library</link> class for loading mangled symbols. </para><para><warning><para>Experimental feature that relies on an incomplete implementation of platform specific C++ mangling. In case of an issue provide a PR with a fix and tests to <ulink url="https://github.com/boostorg/dll">https://github.com/boostorg/dll</ulink> . <link linkend="doxygen.shared_library_reference.smart__library_8hpp">boost/dll/smart_library.hpp</link> is not included in boost/dll.hpp </para>
</warning>
</para><namespace name="boost">
<namespace name="dll">
<namespace name="experimental">
<class id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library" name="smart_library"><purpose>This class is an extension of <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library">shared_library</link>, which allows to load C++ symbols. </purpose><description><para>This class allows type safe loading of overloaded functions, member-functions, constructors and variables. It also allows to overwrite classes so they can be loaded, while being declared with different names.</para><para><warning><para>Experimental feature that relies on an incomplete implementation of platform specific C++ mangling. In case of an issue provide a PR with a fix and tests to <ulink url="https://github.com/boostorg/dll">https://github.com/boostorg/dll</ulink></para>
</warning>
Currently known limitations:</para><para>Member functions must be defined outside of the class to be exported. That is: <programlisting language="c++">//not exported:
struct BOOST_SYMBOL_EXPORT my_class { void func() {} };
//exported
struct BOOST_SYMBOL_EXPORT my_class { void func(); };
void my_class::func() {}
</programlisting></para><para>With the current analysis, the first version does get exported in MSVC. MinGW also does export it, BOOST_SYMBOL_EXPORT is written before it. To allow this on windows one can use BOOST_DLL_MEMBER_EXPORT for this, so that MinGW and MSVC can provide those functions. This does however not work with gcc on linux.</para><para>Direct initialization of members. On linux the following member variable i will not be initialized when using the allocating constructor: <programlisting language="c++">struct BOOST_SYMBOL_EXPORT my_class { int i; my_class() : i(42) {} };
</programlisting></para><para>This does however not happen when the value is set inside the constructor function. </para></description><typedef id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a435f8746c65e9afb525fa15d8da36cf7" name="mangled_storage"><type><emphasis>unspecified</emphasis></type></typedef>
<method-group name="public member functions">
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a156b5b44ed1be2f79cf23b13857f9913" name="shared_lib" cv="const noexcept"><type>const <classname>shared_library</classname> &amp;</type><description><para>Get the underlying <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library">shared_library</link> </para></description></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a51212e822e0b370eedf1a8e5918f271f" name="symbol_storage" cv="const noexcept"><type>const mangled_storage &amp;</type><description><para>Access to the mangled storage, which is created on construction.</para><para>
</para></description><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1ad3d73b1b1a7363aec5a4206d81abeecb" name="symbol_storage" cv="noexcept"><type>mangled_storage &amp;</type><purpose>Overload, for current development. </purpose></method>
<constructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a2d7c4982300107b0b97267abb8bd33be" cv="= default"><description><para>Creates in anstance that does not reference any DLL/DSO.</para><para>

</para></description><postconditions><para>this-&gt;<link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a768114474404dc56ef584b512dfd2b44">is_loaded()</link> returns false. </para>
</postconditions><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></constructor>
<constructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1aa83355fe2c90155b9aa9472e8ee2f6b0"><parameter name="lib_path"><paramtype>const boost::dll::fs::path &amp;</paramtype><description><para>Library file name. Can handle std::string, const char*, std::wstring, const wchar_t* or  <link linkend="boost.dll.fs.path">boost::dll::fs::path</link>. </para></description></parameter><parameter name="mode"><paramtype>load_mode::type</paramtype><default>load_mode::default_mode</default><description><para>A mode that will be used on library load. </para></description></parameter><description><para>Loads a library by specified path with a specified mode.</para><para>

xmlonly &lt;link linkend='boost.dll.fs.system_error'&gt;boost::dll::fs::system_error&lt;/link&gt;, std::bad_alloc in case of insufficient memory.    </para></description><throws><simpara><classname/> </simpara>
</throws></constructor>
<constructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a8103619984d16233cbb3dd1a31ec11d8"><parameter name="lib_path"><paramtype>const boost::dll::fs::path &amp;</paramtype><description><para>Library file name. Can handle std::string, const char*, std::wstring, const wchar_t* or  <link linkend="boost.dll.fs.path">boost::dll::fs::path</link>. </para></description></parameter><parameter name="ec"><paramtype>boost::dll::fs::error_code &amp;</paramtype><description><para>Variable that will be set to the result of the operation. </para></description></parameter><parameter name="mode"><paramtype>load_mode::type</paramtype><default>load_mode::default_mode</default><description><para>A mode that will be used on library load. </para></description></parameter><description><para>Loads a library by specified path with a specified mode.</para><para>

This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.    </para></description><throws><simpara><classname>std::bad_alloc</classname> in case of insufficient memory.</simpara>
</throws></constructor>
<constructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a8fd9bfbf20917d13b9324184220cd1b0"><parameter name="lib_path"><paramtype>const boost::dll::fs::path &amp;</paramtype></parameter><parameter name="mode"><paramtype>load_mode::type</paramtype></parameter><parameter name="ec"><paramtype>boost::dll::fs::error_code &amp;</paramtype></parameter></constructor>
<constructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a692d732536a8d5b771fac684bc89394f" cv="= default"><parameter name="lib"><paramtype>const <classname>smart_library</classname> &amp;</paramtype><description><para>A <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library">smart_library</link> to move from.</para></description></parameter><description><para>copy a <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library">smart_library</link> object.</para><para>

</para></description><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></constructor>
<constructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a592fa252e82dae0e1f9351e0fc8f1859" cv="= default"><parameter name="lib"><paramtype><classname>smart_library</classname> &amp;&amp;</paramtype><description><para>A <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library">smart_library</link> to move from.</para></description></parameter><description><para>Move a <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library">smart_library</link> object.</para><para>

</para></description><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></constructor>
<constructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a753ef075a1a269d1a1a5e0763a7892b5" specifiers="explicit" cv="noexcept"><parameter name="lib"><paramtype>const <classname>shared_library</classname> &amp;</paramtype><description><para>A <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library">shared_library</link> to move from.</para></description></parameter><description><para>Construct from a <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library">shared_library</link> object.</para><para>

</para></description><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></constructor>
<constructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1aff3686addd66c5598dbe8dd47635f1cc" specifiers="explicit" cv="noexcept"><parameter name="lib"><paramtype><classname>shared_library</classname> &amp;&amp;</paramtype><description><para>A <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library">shared_library</link> to move from.</para></description></parameter><description><para>Construct from a <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library">shared_library</link> object.</para><para>

</para></description><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></constructor>
<destructor id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a7dbc2b3e3a8c7e5152f6d56c8a2daa8d" cv="= default"><description><para>Destroys the <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library">smart_library</link>. <computeroutput><link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a4f98671190fa5ccb035c8682ed26a140">unload()</link></computeroutput> is called if the DLL/DSO was loaded. If library was loaded multiple times by different instances of <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library">shared_library</link>, the actual DLL/DSO won't be unloaded until there is at least one instance of <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library">shared_library</link>.</para><para>
</para></description><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></destructor>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a4a953c50b86191dd96aa471bac8099a6" name="load"><type>void</type><parameter name="lib_path"><paramtype>const boost::dll::fs::path &amp;</paramtype><description><para>Library file name. Can handle std::string, const char*, std::wstring, const wchar_t* or  <link linkend="boost.dll.fs.path">boost::dll::fs::path</link>. </para></description></parameter><parameter name="mode"><paramtype>load_mode::type</paramtype><default>load_mode::default_mode</default><description><para>A mode that will be used on library load. </para></description></parameter><description><para>Loads a library by specified path with a specified mode.</para><para>Note that if some library is already loaded in this instance, load will call <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a4f98671190fa5ccb035c8682ed26a140">unload()</link> and then load the new provided library.</para><para>

xmlonly &lt;link linkend='boost.dll.fs.system_error'&gt;boost::dll::fs::system_error&lt;/link&gt;, std::bad_alloc in case of insufficient memory.    </para></description><throws><simpara><classname/> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1ab226ee5e8f7896cdd3b53dca9704eadd" name="load"><type>void</type><parameter name="lib_path"><paramtype>const boost::dll::fs::path &amp;</paramtype><description><para>Library file name. Can handle std::string, const char*, std::wstring, const wchar_t* or  <link linkend="boost.dll.fs.path">boost::dll::fs::path</link>. </para></description></parameter><parameter name="ec"><paramtype>boost::dll::fs::error_code &amp;</paramtype><description><para>Variable that will be set to the result of the operation. </para></description></parameter><parameter name="mode"><paramtype>load_mode::type</paramtype><default>load_mode::default_mode</default><description><para>A mode that will be used on library load. </para></description></parameter><description><para>Loads a library by specified path with a specified mode.</para><para>Note that if some library is already loaded in this instance, load will call <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a4f98671190fa5ccb035c8682ed26a140">unload()</link> and then load the new provided library.</para><para>

This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.    </para></description><throws><simpara><classname>std::bad_alloc</classname> in case of insufficient memory.</simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1afa9da0495e7ab21936d6c4c3b4bce8c5" name="load"><type>void</type><parameter name="lib_path"><paramtype>const boost::dll::fs::path &amp;</paramtype></parameter><parameter name="mode"><paramtype>load_mode::type</paramtype></parameter><parameter name="ec"><paramtype>boost::dll::fs::error_code &amp;</paramtype></parameter></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a991f75e864cc7bb1dfe43a130562ba18" name="get_variable" cv="const"><type>T &amp;</type><template>
          <template-type-parameter name="T"><purpose><para>Type of the variable </para></purpose></template-type-parameter>
        </template><parameter name="name"><paramtype>const std::string &amp;</paramtype><description><para>Name of the variable </para></description></parameter><description><para>Load a variable from the referenced library.</para><para>Unlinke <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1shared__library_1a57ca07c405c026200cf5c7799ae36170">shared_library::get</link> this function will also load scoped variables, which also includes static class members.</para><para><note><para>When mangled, MSVC will also check the type.</para>
</note>




xmlonly &lt;link linkend='boost.dll.fs.system_error'&gt;boost::dll::fs::system_error&lt;/link&gt; if symbol does not exist or if the DLL/DSO was not loaded. </para></description><returns><para>A reference to the variable of type T.</para>
</returns><throws><simpara><classname/> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a958a0864228da48a795d8a628c19dad8" name="get_function" cv="const"><type>Func &amp;</type><template>
          <template-type-parameter name="Func"><purpose><para>Type of the function, required for determining the overload </para></purpose></template-type-parameter>
        </template><parameter name="name"><paramtype>const std::string &amp;</paramtype><description><para>Name of the function. </para></description></parameter><description><para>Load a function from the referenced library.</para><para><emphasis role="bold">Example:</emphasis> </para><para><programlisting language="c++"><link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a2d7c4982300107b0b97267abb8bd33be">smart_library</link> lib("test_lib.so");
typedef int      (&amp;add_ints)(int, int);
typedef double (&amp;add_doubles)(double, double);
add_ints     f1 = lib.get_function&lt;int(int, int)&gt;         ("func_name");
add_doubles  f2 = lib.get_function&lt;double(double, double)&gt;("func_name");
</programlisting></para><para><note><para>When mangled, MSVC will also check the return type.</para>
</note>




xmlonly &lt;link linkend='boost.dll.fs.system_error'&gt;boost::dll::fs::system_error&lt;/link&gt; if symbol does not exist or if the DLL/DSO was not loaded. </para></description><returns><para>A reference to the function of type F.</para>
</returns><throws><simpara><classname/> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a50e8663ca471214987488c0c8d69b75b" name="get_mem_fn" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Class"><purpose><para>The class the function is a member of. If Class is const, the function will be assumed as taking a const this-pointer. The same applies for volatile. </para></purpose></template-type-parameter>
          <template-type-parameter name="Func"><purpose><para>Signature of the function, required for determining the overload </para></purpose></template-type-parameter>
        </template><parameter name="name"><paramtype>const std::string &amp;</paramtype><description><para>Name of the function. </para></description></parameter><description><para>Load a member-function from the referenced library.</para><para><emphasis role="bold">Example</emphasis> (import class is MyClass, which is available inside the library and the host):</para><para><programlisting language="c++"><link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a2d7c4982300107b0b97267abb8bd33be">smart_library</link> lib("test_lib.so");

typedef int      MyClass(*func)(int);
typedef int   MyClass(*func_const)(int) const;

add_ints     f1 = lib.get_mem_fn&lt;MyClass, int(int)&gt;              ("MyClass::function");
add_doubles  f2 = lib.get_mem_fn&lt;const MyClass, double(double)&gt;("MyClass::function");
</programlisting></para><para><note><para>When mangled, MSVC will also check the return type.</para>
</note>




xmlonly &lt;link linkend='boost.dll.fs.system_error'&gt;boost::dll::fs::system_error&lt;/link&gt; if symbol does not exist or if the DLL/DSO was not loaded. </para></description><returns><para>A pointer to the member-function with the signature provided</para>
</returns><throws><simpara><classname/> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a3a07b4c56bea141c6015569100ca6a65" name="get_constructor" cv="const"><type>constructor&lt; Signature &gt;</type><template>
          <template-type-parameter name="Signature"><purpose><para>Signature of the function, required for determining the overload. The return type is the class which this is the constructor of. </para></purpose></template-type-parameter>
        </template><description><para>Load a constructor from the referenced library.</para><para><emphasis role="bold">Example</emphasis> (import class is MyClass, which is available inside the library and the host):</para><para><programlisting language="c++"><link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a2d7c4982300107b0b97267abb8bd33be">smart_library</link> lib("test_lib.so");

constructor&lt;MyClass(int)    f1 = lib.get_mem_fn&lt;MyClass(int)&gt;();
</programlisting></para><para>


xmlonly &lt;link linkend='boost.dll.fs.system_error'&gt;boost::dll::fs::system_error&lt;/link&gt; if symbol does not exist or if the DLL/DSO was not loaded. </para></description><returns><para>A constructor object.</para>
</returns><throws><simpara><classname/> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a23ef5ecacabe01414b9c7c2b10f39d2a" name="get_destructor" cv="const"><type>destructor&lt; Class &gt;</type><template>
          <template-type-parameter name="Class"><purpose><para>The class whose destructor shall be loaded </para></purpose></template-type-parameter>
        </template><description><para>Load a destructor from the referenced library.</para><para><emphasis role="bold">Example</emphasis> (import class is MyClass, which is available inside the library and the host):</para><para><programlisting language="c++"><link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a2d7c4982300107b0b97267abb8bd33be">smart_library</link> lib("test_lib.so");

destructor&lt;MyClass&gt;     f1 = lib.get_mem_fn&lt;MyClass&gt;();
</programlisting></para><para>


xmlonly &lt;link linkend='boost.dll.fs.system_error'&gt;boost::dll::fs::system_error&lt;/link&gt; if symbol does not exist or if the DLL/DSO was not loaded. </para></description><returns><para>A destructor object.</para>
</returns><throws><simpara><classname/> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a6f9671ad9fb3f93293b65eafbac4577d" name="get_type_info" cv="const"><type>const std::type_info &amp;</type><template>
          <template-type-parameter name="Class"><purpose><para>The class whose typeinfo shall be loaded </para></purpose></template-type-parameter>
        </template><description><para>Load the typeinfo of the given type.</para><para><emphasis role="bold">Example</emphasis> (import class is MyClass, which is available inside the library and the host):</para><para><programlisting language="c++"><link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a2d7c4982300107b0b97267abb8bd33be">smart_library</link> lib("test_lib.so");

std::type_info &amp;ti = lib.get_Type_info&lt;MyClass&gt;();
</programlisting></para><para>


xmlonly &lt;link linkend='boost.dll.fs.system_error'&gt;boost::dll::fs::system_error&lt;/link&gt; if symbol does not exist or if the DLL/DSO was not loaded. </para></description><returns><para>A reference to a type_info object.</para>
</returns><throws><simpara><classname/> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a3b62d5d0cd3eada6c8a1bb517ba7c12f" name="add_type_alias"><type>void</type><template>
          <template-type-parameter name="Alias"/>
        </template><parameter name="name"><paramtype>const std::string &amp;</paramtype><description><para>Name of the class the alias is for.</para></description></parameter><description><para>This function can be used to add a type alias.</para><para>This is to be used, when a class shall be imported, which is not declared on the host side.</para><para>Example: <programlisting language="c++"><link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a2d7c4982300107b0b97267abb8bd33be">smart_library</link> lib("test_lib.so");

lib.add_type_alias&lt;MyAlias&gt;("MyClass"); //when using MyAlias, the library will look for MyClass

//get the destructor of MyClass
destructor&lt;MyAlias&gt; dtor = lib.get_destructor&lt;MyAlias&gt;();
</programlisting></para><para>
<important><para>If the alias-type is not large enough for the imported class, it will result in undefined behaviour. </para>
</important>
<warning><para>The alias will only be applied for the type signature, it will not replace the token in the scoped name. </para>
</warning>
</para></description></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a4f98671190fa5ccb035c8682ed26a140" name="unload" cv="noexcept"><type>void</type><description><para>Unloads a shared library. If library was loaded multiple times by different instances, the actual DLL/DSO won't be unloaded until there is at least one instance that references the DLL/DSO.</para><para>

</para></description><postconditions><para>this-&gt;<link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a768114474404dc56ef584b512dfd2b44">is_loaded()</link> returns false. </para>
</postconditions><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a768114474404dc56ef584b512dfd2b44" name="is_loaded" cv="const noexcept"><type>bool</type><description><para>Check if an library is loaded.</para><para>

</para></description><returns><para>true if a library has been loaded. </para>
</returns><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a420e60e9788bfa3b52aa3aab72ea3a5e" name="conversion-operator" cv="const noexcept" specifiers="explicit"><type>bool</type><purpose>bool() const </purpose><description><para>bool() const </para></description></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a61600573e373c540279ac3b5918dd8f1" name="has" cv="const noexcept"><type>bool</type><parameter name="symbol_name"><paramtype>const char *</paramtype><description><para>Null-terminated symbol name. Can handle std::string, char*, const char*. </para></description></parameter><description><para>Search for a given symbol on loaded library. Works for all symbols, including alias names.</para><para>


This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.    </para></description><returns><para><computeroutput>true</computeroutput> if the loaded library contains a symbol with a given name. </para>
</returns><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1ac6d3a6b6218a32a25b8f9ee1f2cc4ab2" name="has" cv="const noexcept"><type>bool</type><parameter name="symbol_name"><paramtype>const std::string &amp;</paramtype></parameter></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a033d7e1732714d83c25e8d7f2d7d5a4b" name="assign"><type><classname>smart_library</classname> &amp;</type><parameter name="lib"><paramtype>const <classname>smart_library</classname> &amp;</paramtype><description><para>A library instance to assign from. </para></description></parameter><description><para>Makes *this share the same shared object as lib. If *this is loaded, then unloads it.</para><para>


xmlonly &lt;link linkend='boost.dll.fs.system_error'&gt;boost::dll::fs::system_error&lt;/link&gt;, std::bad_alloc in case of insufficient memory.    </para></description><postconditions><para>lib.location() == this-&gt;location() </para>
</postconditions><throws><simpara><classname/> </simpara>
</throws></method>
<method id="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library_1a3bc94068bd44352758b9f1e8505084eb" name="swap" cv="noexcept"><type>void</type><parameter name="rhs"><paramtype><classname>smart_library</classname> &amp;</paramtype><description><para>Library to swap with. </para></description></parameter><description><para>Swaps two libraries. Does not invalidate existing symbols and functions loaded from libraries.</para><para>

</para></description><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></method>
</method-group>
</class><function id="doxygen.shared_library_reference.smart__library_8hpp_1a9924c849cbdcd33da5c9cfdcfdc0e261" name="operator=="><type>bool</type><parameter name="lhs"><paramtype>const <classname>smart_library</classname> &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>smart_library</classname> &amp;</paramtype></parameter><purpose>Very fast equality check that compares the actual DLL/DSO objects. Throws nothing. </purpose></function>
<function id="doxygen.shared_library_reference.smart__library_8hpp_1a776481eedb6f93b7fa73746aa4ef1e3a" name="operator!="><type>bool</type><parameter name="lhs"><paramtype>const <classname>smart_library</classname> &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>smart_library</classname> &amp;</paramtype></parameter><purpose>Very fast inequality check that compares the actual DLL/DSO objects. Throws nothing. </purpose></function>
<function id="doxygen.shared_library_reference.smart__library_8hpp_1abd7cc7722efcd2bca9a779534348e7d5" name="operator&lt;"><type>bool</type><parameter name="lhs"><paramtype>const <classname>smart_library</classname> &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>smart_library</classname> &amp;</paramtype></parameter><purpose>Compare the actual DLL/DSO objects without any guarantee to be stable between runs. Throws nothing. </purpose></function>
<function id="doxygen.shared_library_reference.smart__library_8hpp_1a8ab62190dcba5faa608f9c8a260439f9" name="swap"><type>void</type><parameter name="lhs"><paramtype><classname>smart_library</classname> &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>smart_library</classname> &amp;</paramtype></parameter><purpose>Swaps two shared libraries. Does not invalidate symbols and functions loaded from libraries. Throws nothing. </purpose></function>
<function id="doxygen.shared_library_reference.smart__library_8hpp_1aca01518fa6ec64ce2f8f56ad2a232732" name="get"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="T2"/>
        </template><parameter name="sm"><paramtype>const <classname>smart_library</classname> &amp;</paramtype><description><para>A reference to the <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library">smart_library</link> </para></description></parameter><parameter name="name"><paramtype>const std::string &amp;</paramtype><description><para>The name of the entity to import </para></description></parameter><description><para>Helper functions for overloads.</para><para>Gets either a variable, function or member-function, depending on the signature.</para><para><programlisting language="c++"><link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library">smart_library</link> sm("lib.so");
get&lt;int&gt;(sm, "space::value"); //import a variable
get&lt;void(int)&gt;(sm, "space::func"); //import a function
get&lt;some_class, void(int)&gt;(sm, "space::class_::mem_fn"); //import a member function
</programlisting></para><para>
</para></description></function>
<function id="doxygen.shared_library_reference.smart__library_8hpp_1a115b3461b3f6029ceb2b98315ab16af7" name="get"><type>std::enable_if&lt; std::is_object&lt; T &gt;::value, T &amp; &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="sm"><paramtype>const <classname>smart_library</classname> &amp;</paramtype></parameter><parameter name="name"><paramtype>const std::string &amp;</paramtype></parameter></function>
<function id="doxygen.shared_library_reference.smart__library_8hpp_1a027420dd4adc45204e51eb69b21c435a" name="get"><type>std::enable_if&lt; std::is_function&lt; T &gt;::value, T &amp; &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="sm"><paramtype>const <classname>smart_library</classname> &amp;</paramtype></parameter><parameter name="name"><paramtype>const std::string &amp;</paramtype></parameter></function>
<function id="doxygen.shared_library_reference.smart__library_8hpp_1a8e9c15aa4edf4bd334aed77f1f4c40b7" name="get"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Class"/>
          <template-type-parameter name="Signature"/>
        </template><parameter name="sm"><paramtype>const <classname>smart_library</classname> &amp;</paramtype><description><para>A reference to the <link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library">smart_library</link> </para></description></parameter><parameter name="name"><paramtype>const std::string &amp;</paramtype><description><para>The name of the entity to import </para></description></parameter><description><para>Helper functions for overloads.</para><para>Gets either a variable, function or member-function, depending on the signature.</para><para><programlisting language="c++"><link linkend="doxygen.shared_library_reference.classboost_1_1dll_1_1experimental_1_1smart__library">smart_library</link> sm("lib.so");
get&lt;int&gt;(sm, "space::value"); //import a variable
get&lt;void(int)&gt;(sm, "space::func"); //import a function
get&lt;some_class, void(int)&gt;(sm, "space::class_::mem_fn"); //import a member function
</programlisting></para><para>
</para></description></function>
</namespace>












</namespace>
</namespace>
</header>
</library-reference>