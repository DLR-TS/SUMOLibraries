<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Boost.Locale: boost::locale::util::base_converter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="section-basic.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="boost-small.png"/></td>
  <td id="projectalign">
   <div id="projectname">Boost.Locale
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classboost_1_1locale_1_1util_1_1base__converter.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classboost_1_1locale_1_1util_1_1base__converter-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">boost::locale::util::base_converter Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class represent a simple stateless converter from UCS-4 and to UCS-4 for each single code point.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="util_8hpp_source.html">boost/locale/util.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a77f96b74594000cacbbfa8e05817e2af" id="r_a77f96b74594000cacbbfa8e05817e2af"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77f96b74594000cacbbfa8e05817e2af">max_len</a> () const</td></tr>
<tr class="separator:a77f96b74594000cacbbfa8e05817e2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab914afa4fa8a3f46e3b28098d36b5bcf" id="r_ab914afa4fa8a3f46e3b28098d36b5bcf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab914afa4fa8a3f46e3b28098d36b5bcf">is_thread_safe</a> () const</td></tr>
<tr class="separator:ab914afa4fa8a3f46e3b28098d36b5bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefc4a40a1fcfb609875d4ae23769c7c" id="r_adefc4a40a1fcfb609875d4ae23769c7c"><td class="memItemLeft" align="right" valign="top"><a id="adefc4a40a1fcfb609875d4ae23769c7c" name="adefc4a40a1fcfb609875d4ae23769c7c"></a>
virtual <a class="el" href="classboost_1_1locale_1_1util_1_1base__converter.html">base_converter</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>clone</b> () const</td></tr>
<tr class="memdesc:adefc4a40a1fcfb609875d4ae23769c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a polymorphic copy of this object, usually called only if <a class="el" href="#ab914afa4fa8a3f46e3b28098d36b5bcf">is_thread_safe()</a> return false. <br /></td></tr>
<tr class="separator:adefc4a40a1fcfb609875d4ae23769c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4b2dee0f4cdbfd2840dde9aa246d56" id="r_adb4b2dee0f4cdbfd2840dde9aa246d56"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceboost_1_1locale_1_1utf.html#ab2c3f237a7e0722bb2cbf0fb5f1efc9d">utf::code_point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb4b2dee0f4cdbfd2840dde9aa246d56">to_unicode</a> (const char *&amp;begin, const char *end)</td></tr>
<tr class="separator:adb4b2dee0f4cdbfd2840dde9aa246d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6ec57bba9bb3b46d408eb8ea3a640b" id="r_a2f6ec57bba9bb3b46d408eb8ea3a640b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceboost_1_1locale_1_1utf.html#a8b1d1a5057ec103ae5e6e681e42afac0">utf::len_or_error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f6ec57bba9bb3b46d408eb8ea3a640b">from_unicode</a> (<a class="el" href="namespaceboost_1_1locale_1_1utf.html#ab2c3f237a7e0722bb2cbf0fb5f1efc9d">utf::code_point</a> u, char *begin, const char *end)</td></tr>
<tr class="separator:a2f6ec57bba9bb3b46d408eb8ea3a640b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8b4dbbaf00e961fb7b2eb1a9a1906ce4" id="r_a8b4dbbaf00e961fb7b2eb1a9a1906ce4"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceboost_1_1locale_1_1utf.html#ab2c3f237a7e0722bb2cbf0fb5f1efc9d">utf::code_point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b4dbbaf00e961fb7b2eb1a9a1906ce4">illegal</a> = utf::illegal</td></tr>
<tr class="separator:a8b4dbbaf00e961fb7b2eb1a9a1906ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826d6db5ffa24c82d39f64f718a5896e" id="r_a826d6db5ffa24c82d39f64f718a5896e"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceboost_1_1locale_1_1utf.html#ab2c3f237a7e0722bb2cbf0fb5f1efc9d">utf::code_point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a826d6db5ffa24c82d39f64f718a5896e">incomplete</a> = utf::incomplete</td></tr>
<tr class="separator:a826d6db5ffa24c82d39f64f718a5896e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represent a simple stateless converter from UCS-4 and to UCS-4 for each single code point. </p>
<p>This class is used for creation of std::codecvt facet for converting utf-16/utf-32 encoding to encoding supported by this converter</p>
<p>Please note, this converter should be fully stateless. Fully stateless means it should never assume that it is called in any specific order on the text. Even if the encoding itself seems to be stateless like windows-1255 or shift-jis, some encoders (most notably iconv) can actually compose several code-point into one or decompose them in case composite characters are found. So be very careful when implementing these converters for certain character set. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2f6ec57bba9bb3b46d408eb8ea3a640b" name="a2f6ec57bba9bb3b46d408eb8ea3a640b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6ec57bba9bb3b46d408eb8ea3a640b">&#9670;&#160;</a></span>from_unicode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceboost_1_1locale_1_1utf.html#a8b1d1a5057ec103ae5e6e681e42afac0">utf::len_or_error</a> boost::locale::util::base_converter::from_unicode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1locale_1_1utf.html#ab2c3f237a7e0722bb2cbf0fb5f1efc9d">utf::code_point</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a single code-point <em>u</em> into encoding and store it in [begin,end) range.</p>
<p>If u is invalid Unicode code-point, or it can not be mapped correctly to represented character set, <em>illegal</em> should be returned</p>
<p>If u can be converted to a sequence of bytes c1, ... , cN (1&lt;= N &lt;= <a class="el" href="#a77f96b74594000cacbbfa8e05817e2af">max_len()</a> ) then</p>
<ol type="1">
<li>If end - begin &gt;= N, c1, ... cN are written starting at begin and N is returned</li>
<li>If end - begin &lt; N, incomplete is returned, it is unspecified what would be stored in bytes in range [begin,end) </li>
</ol>

</div>
</div>
<a id="ab914afa4fa8a3f46e3b28098d36b5bcf" name="ab914afa4fa8a3f46e3b28098d36b5bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab914afa4fa8a3f46e3b28098d36b5bcf">&#9670;&#160;</a></span>is_thread_safe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool boost::locale::util::base_converter::is_thread_safe </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if calling the functions from_unicode, to_unicode, and max_len is thread safe.</p>
<p>Rule of thumb: if this class' implementation uses simple tables that are unchanged or is purely algorithmic like UTF-8 - so it does not share any mutable bit for independent to_unicode, from_unicode calls, you may set it to true, otherwise, for example if you use iconv_t descriptor or UConverter as conversion object return false, and this object will be cloned for each use. </p>

</div>
</div>
<a id="a77f96b74594000cacbbfa8e05817e2af" name="a77f96b74594000cacbbfa8e05817e2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f96b74594000cacbbfa8e05817e2af">&#9670;&#160;</a></span>max_len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int boost::locale::util::base_converter::max_len </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the maximal length that one Unicode code-point can be converted to, for example for UTF-8 it is 4, for Shift-JIS it is 2 and ISO-8859-1 is 1 </p>

</div>
</div>
<a id="adb4b2dee0f4cdbfd2840dde9aa246d56" name="adb4b2dee0f4cdbfd2840dde9aa246d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4b2dee0f4cdbfd2840dde9aa246d56">&#9670;&#160;</a></span>to_unicode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceboost_1_1locale_1_1utf.html#ab2c3f237a7e0722bb2cbf0fb5f1efc9d">utf::code_point</a> boost::locale::util::base_converter::to_unicode </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a single character starting at begin and ending at most at end to Unicode code-point.</p>
<p>if valid input sequence found in [<em>begin</em>,<em>code_point_end</em>) such as <em>begin</em> &lt; <em>code_point_end</em> &amp;&amp; <em>code_point_end</em> &lt;= <em>end</em> it is converted to its Unicode code point equivalent, <em>begin</em> is set to <em>code_point_end</em> </p>
<p>if incomplete input sequence found in [<em>begin</em>,<em>end</em>), i.e. there my be such <em>code_point_end</em> that <em>code_point_end</em> &gt; <em>end</em> and [<em>begin</em>, <em>code_point_end</em>) would be valid input sequence, then <em>incomplete</em> is returned begin stays unchanged, for example for UTF-8 conversion a *begin = 0xc2, <em>begin</em> +1 = <em>end</em> is such situation.</p>
<p>if invalid input sequence found, i.e. there is a sequence [<em>begin</em>, <em>code_point_end</em>) such as <em>code_point_end</em> &lt;= <em>end</em> that is illegal for this encoding, <em>illegal</em> is returned and begin stays unchanged. For example if *begin = 0xFF and begin &lt; end for UTF-8, then <em>illegal</em> is returned. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8b4dbbaf00e961fb7b2eb1a9a1906ce4" name="a8b4dbbaf00e961fb7b2eb1a9a1906ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4dbbaf00e961fb7b2eb1a9a1906ce4">&#9670;&#160;</a></span>illegal</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1locale_1_1utf.html#ab2c3f237a7e0722bb2cbf0fb5f1efc9d">utf::code_point</a> boost::locale::util::base_converter::illegal = utf::illegal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This value should be returned when an illegal input sequence or code-point is observed: For example if a UCS-32 code-point is in the range reserved for UTF-16 surrogates or an invalid UTF-8 sequence is found </p>

</div>
</div>
<a id="a826d6db5ffa24c82d39f64f718a5896e" name="a826d6db5ffa24c82d39f64f718a5896e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826d6db5ffa24c82d39f64f718a5896e">&#9670;&#160;</a></span>incomplete</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1locale_1_1utf.html#ab2c3f237a7e0722bb2cbf0fb5f1efc9d">utf::code_point</a> boost::locale::util::base_converter::incomplete = utf::incomplete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This value is returned in following cases: An incomplete input sequence was found or insufficient output buffer was provided so complete output could not be written. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>boost/locale/<a class="el" href="util_8hpp_source.html">util.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->

    <li class="footer">
&copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the <a href="https://www.boost.org/LICENSE_1_0.txt">Boost Software License</a>, Version 1.0.
    </li>
   </ul>
 </div>
</body>
</html>
