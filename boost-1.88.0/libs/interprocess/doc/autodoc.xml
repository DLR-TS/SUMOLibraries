<?xml version="1.0" standalone="yes"?>
<library-reference id="boost_interprocess_header_reference"><title>Boost.Interprocess Header Reference</title><header id="doxygen.boost_interprocess_header_reference.adaptive__pool_8hpp" name="boost/interprocess/allocators/adaptive_pool.hpp">
<para>Describes adaptive_pool pooled shared memory STL compatible allocator </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool" name="adaptive_pool"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
      <template-nontype-parameter name="MaxFreeBlocks"><type>std::size_t</type></template-nontype-parameter>
      <template-nontype-parameter name="OverheadPercent"><type>unsigned char</type></template-nontype-parameter>
    </template><description><para>An STL node allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc...</para><para>This node allocator shares a segregated storage between all instances of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool">adaptive_pool</link> with equal sizeof(T) placed in the same segment group. NodesPerBlock is the number of nodes allocated at once when the allocator needs runs out of nodes. MaxFreeBlocks is the maximum number of totally free blocks that the adaptive node pool will hold. The rest of the totally free blocks will be deallocated with the segment manager.</para><para>OverheadPercent is the (approximated) maximum size overhead (1-20%) of the allocator: (memory usable for nodes / total memory allocated from the segment manager) </para></description><struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1adaptive__pool_1_1rebind" name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool">adaptive_pool</link> from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool">adaptive_pool</link> </para></description><typedef id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1adaptive__pool_1_1rebind_1a8d007a5ecc0c4a7fb94d56afb8420269" name="other"><type><classname>adaptive_pool</classname>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt;</type></typedef>
</struct><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1a1b3e839ad9e4014b749b2971d853aec0" name="segment_manager"><type>implementation_defined::segment_manager</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1af0edc9485e9485f31c1db8895b959dc6" name="void_pointer"><type>segment_manager::void_pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1a263113db76a84cab373d0789819e49ad" name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1a0b2173a1d5d6d68ba52b994163146e27" name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1a39736c5d394806d439ec907c40c89a2e" name="value_type"><type>T</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1ac0c360e2164597fde42b110e0859cad2" name="reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1ad109c2e9fc584b6fd43e10e735e5acd0" name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1ae1b90f2dcc0f2d9855388b8afefb9b88" name="size_type"><type>segment_manager::size_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1a69e09ff993e2b0258954f22ecca2df7c" name="difference_type"><type>segment_manager::difference_type</type></typedef>
<method-group name="private member functions">
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1a36edeaf899e31db62512f9bb342c5427"><type><classname>adaptive_pool</classname> &amp;</type><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="SegmentManager2"/>
          <template-nontype-parameter name="N2"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F2"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP2"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>adaptive_pool</classname>&lt; T2, SegmentManager2, N2, F2, OP2 &gt; &amp;</paramtype></parameter><description><para>Not assignable from related <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool">adaptive_pool</link> </para></description></copy-assignment>
</method-group>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1a2ee3acd8f1514c5ba5d64ed71e538f2a"><parameter name="segment_mngr"><paramtype>segment_manager *</paramtype></parameter><description><para>Not assignable from other <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool">adaptive_pool</link> Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1a6a9b6e9a4f092b33f838fdb67e0f338e"><parameter name="other"><paramtype>const <classname>adaptive_pool</classname> &amp;</paramtype></parameter><description><para>Copy constructor from other <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool">adaptive_pool</link>. Increments the reference count of the associated node pool. Never throws </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1acc7d5c703d3c8f8159976529b451c5b3"><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>adaptive_pool</classname>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt; &amp;</paramtype></parameter><description><para>Copy constructor from related <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool">adaptive_pool</link>. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1a80345b9257b976d397d900c6e5d555aa"><description><para>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1aff974b028935d047f8fca3107b744279" name="get_node_pool" cv="const"><type>void *</type><description><para>Returns a pointer to the node pool. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1a25506ec9be991845fbf2214c9847f94a" name="get_segment_manager" cv="const"><type>segment_manager *</type><description><para>Returns the segment manager. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1a16d7743e8ffff05ffc6a1f301dd4b57b" name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1a13f43f55f5e038bc60d7b8a458cdd5c6" name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_pointer</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> if there is no enough memory </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1acb43bb1d50f5ee09c77e364a768772a6" name="deallocate"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1af9808dde6fde8025d8cb57575646500c" name="deallocate_free_blocks"><type>void</type><description><para>Deallocates all free blocks of the pool </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1af737111ef137a7150bf6083efb73caa5" name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1a782c2a970d51f2fe4b4c67df3059c283" name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1a6ee492e5a01f7c9ea76f27b547290753" name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1a6b0ae3ee8c39c4c0c469c35c1e96223f" name="allocation_command"><type>pointer</type><parameter name="command"><paramtype>boost::interprocess::allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1a88658c56683aa186a90422f23c3036b3" name="allocate_many"><type>void</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1ae1c8373f1a61a863853994e4eef90e17" name="allocate_many"><type>void</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1a2c7d89d2902a21b29e348472961ec84b" name="deallocate_many"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1af0075d6ee14c7458b029b798839615bb" name="allocate_one"><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1afc8adc70b7f101fbcbdd900a1bd3b72d">deallocate_one()</link>. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> if there is no enough memory </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1afc9ce1cbf2aa577f53f0c6d31b60c716" name="allocate_individual"><type>void</type><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1afc8adc70b7f101fbcbdd900a1bd3b72d">deallocate_one()</link>. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1afc8adc70b7f101fbcbdd900a1bd3b72d" name="deallocate_one"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1af0075d6ee14c7458b029b798839615bb">allocate_one()</link>. You should never use deallocate_one to deallocate memory allocated with other functions different from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1af0075d6ee14c7458b029b798839615bb">allocate_one()</link>. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1ad11676231c9d8c7abfae7478235dc473" name="deallocate_individual"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1afc8adc70b7f101fbcbdd900a1bd3b72d">deallocate_one()</link>. </para></description></method>
</method-group>
<method-group name="friend functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool_1a63777ee47c37b3f6817aa6fc57db0e0d" name="swap"><type>void</type><parameter name="alloc1"><paramtype>self_t &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>self_t &amp;</paramtype></parameter><description><para>Swaps allocators. Does not throw. If each allocator is placed in a different memory segment, the result is undefined. </para></description></method>
</method-group>
</class>





















<function id="doxygen.boost_interprocess_header_reference.adaptive__pool_8hpp_1a0c4c1e8e0fb9fe44a5b810e83f7c61b1" name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool">adaptive_pool</link> </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.adaptive__pool_8hpp_1a4b2a37d690dea3f39a9171d46249bcbb" name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool">adaptive_pool</link> </para></description></function>



























</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.allocator_8hpp" name="boost/interprocess/allocators/allocator.hpp">
<para>Describes an allocator that allocates portions of fixed size memory buffer (shared memory, mapped file...) </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator" name="allocator"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
    </template><description><para>An STL compatible allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc... </para></description><struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1allocator_1_1rebind" name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains an allocator that allocates objects of type T2 </para></description><typedef id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1allocator_1_1rebind_1a0ffadcb128f9b2db96017fa7fa16d91e" name="other"><type><classname>allocator</classname>&lt; T2, SegmentManager &gt;</type></typedef>
</struct><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1adfdc756d2f3babb68942baf31fe3565c" name="segment_manager"><type>SegmentManager</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a712cc8879e62bc12fa2d173377ed3439" name="void_pointer"><type>SegmentManager::void_pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1ae2fff68d05244d9ba01d30a0055ada2e" name="value_type"><type>T</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a395bf5c36fdcb8760f5f4614209b7694" name="pointer"><type>boost::intrusive::pointer_traits&lt; cvoid_ptr &gt;::template rebind_pointer&lt; T &gt;::type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1ac9abf404693e4a1cbe9f6bcaccb127d3" name="const_pointer"><type>boost::intrusive::pointer_traits&lt; pointer &gt;::template rebind_pointer&lt; constT &gt;::type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1af80e352fa4e19237288f56998846b149" name="reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a6aef6ae127fea0cf7633d5cfd8b92567" name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a7fc689842f760df859fbd81f2652a2ba" name="size_type"><type>segment_manager::size_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a079a05e8bcc32ac1c4a4277ea31e14a1" name="difference_type"><type>segment_manager::difference_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a311fcc1eef18279529643831506f2693" name="version"><type>boost::interprocess::version_type&lt; <classname>allocator</classname>, 2 &gt;</type></typedef>
<method-group name="public member functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1afce9a92d99367760c8c3b7ffce41a4f7" name="get_segment_manager" cv="const"><type>segment_manager *</type><description><para>Returns the segment manager. Never throws </para></description></method>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1ad2ec3e8a0ed0241a8c3a3143c4a24bf5"><parameter name="segment_mngr"><paramtype>segment_manager *</paramtype></parameter><description><para>Constructor from the segment manager. Never throws </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1aaf8de55a7119ff177dcb873679f80351"><parameter name="other"><paramtype>const <classname>allocator</classname> &amp;</paramtype></parameter><description><para>Constructor from other allocator. Never throws </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a5f88451cb14c66a6a746037900732fdc"><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>allocator</classname>&lt; T2, SegmentManager &gt; &amp;</paramtype></parameter><description><para>Constructor from related allocator. Never throws </para></description></constructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1aee830af748b2eae2aeae16cbe6739c51" name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_ptr</paramtype><default>0</default></parameter><description><para>Allocates memory for an array of count elements. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> if there is no enough memory </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a04de2ee02f9dd6188229dbb714fb6988" name="deallocate"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name=""><paramtype>size_type</paramtype></parameter><description><para>Deallocates memory previously allocated. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a22b360a283a2478383df113bf48e66db" name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1ae9050317c5b3df2fbd8e36207e18b35d" name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a2da6e04d6142375c2038888b258aa4b1" name="allocation_command"><type>pointer</type><parameter name="command"><paramtype>boost::interprocess::allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a074e2337c2e7c40d244a34751c66377f" name="allocate_many"><type>void</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1ab5b94b220c1eae36e01268196089431b" name="allocate_many"><type>void</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a60bf0819081d12f4a6076034842c7552" name="deallocate_many"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a3bda0e555d9d3b48d8dd89887683b73e" name="allocate_one"><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a2cc693e4e5ee252f64e96322c0e92f22">deallocate_one()</link>. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> if there is no enough memory </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1ab9dbe13cc09a7707b97caaadb3701bca" name="allocate_individual"><type>void</type><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a2cc693e4e5ee252f64e96322c0e92f22">deallocate_one()</link>. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a2cc693e4e5ee252f64e96322c0e92f22" name="deallocate_one"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a3bda0e555d9d3b48d8dd89887683b73e">allocate_one()</link>. You should never use deallocate_one to deallocate memory allocated with other functions different from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a3bda0e555d9d3b48d8dd89887683b73e">allocate_one()</link>. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1ac9cfe703f6b2b6b3bb36e7fba9c19071" name="deallocate_individual"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a2cc693e4e5ee252f64e96322c0e92f22">deallocate_one()</link>. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1aebbcfce51b8f6c9c81646fdb2ccd1826" name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1ac94e680830a0ed44949509a88e6a3bc2" name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method>
</method-group>
<method-group name="friend functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator_1a63777ee47c37b3f6817aa6fc57db0e0d" name="swap"><type>void</type><parameter name="alloc1"><paramtype>self_t &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>self_t &amp;</paramtype></parameter><description><para>Swap segment manager. Does not throw. If each allocator is placed in different memory segments, the result is undefined. </para></description></method>
</method-group>
</class>



















<function id="doxygen.boost_interprocess_header_reference.allocator_8hpp_1a2a2355983dad0f6297f4e882c93510b6" name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="SegmentManager"/>
        </template><parameter name="alloc1"><paramtype>const <classname>allocator</classname>&lt; T, SegmentManager &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>allocator</classname>&lt; T, SegmentManager &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of allocator </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.allocator_8hpp_1a9847664cad21c7af8e1e029cecebc79c" name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="SegmentManager"/>
        </template><parameter name="alloc1"><paramtype>const <classname>allocator</classname>&lt; T, SegmentManager &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>allocator</classname>&lt; T, SegmentManager &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of allocator </para></description></function>





























</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.cached__adaptive__pool_8hpp" name="boost/interprocess/allocators/cached_adaptive_pool.hpp">
<para>Describes cached_adaptive_pool pooled shared memory STL compatible allocator </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool" name="cached_adaptive_pool"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
      <template-nontype-parameter name="MaxFreeBlocks"><type>std::size_t</type></template-nontype-parameter>
      <template-nontype-parameter name="OverheadPercent"><type>unsigned char</type></template-nontype-parameter>
    </template><description><para>An STL node allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc...</para><para>This node allocator shares a segregated storage between all instances of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool">cached_adaptive_pool</link> with equal sizeof(T) placed in the same memory segment. But also caches some nodes privately to avoid some synchronization overhead.</para><para>NodesPerBlock is the minimum number of nodes of nodes allocated at once when the allocator needs runs out of nodes. MaxFreeBlocks is the maximum number of totally free blocks that the adaptive node pool will hold. The rest of the totally free blocks will be deallocated with the segment manager.</para><para>OverheadPercent is the (approximated) maximum size overhead (1-20%) of the allocator: (memory usable for nodes / total memory allocated from the segment manager) </para></description><struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1cached__adaptive__pool_1_1rebind" name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool">cached_adaptive_pool</link> from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool">cached_adaptive_pool</link> </para></description><typedef id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1cached__adaptive__pool_1_1rebind_1a2aec5381b1ca36500ab26215d86e2cef" name="other"><type><classname>cached_adaptive_pool</classname>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt;</type></typedef>
</struct><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a2e8b935e14ee592881bb0ec624202a21" name="segment_manager"><type>implementation_defined::segment_manager</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a3075a723f3c5459094ac3ee9159c50cf" name="void_pointer"><type>segment_manager::void_pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a2bfc629065aab72ed70ae802e226d412" name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a4893e6987e1490f4f846781f1d7418dc" name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1ad2fac459b28c02fdf8293b6c5af582cf" name="value_type"><type>T</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a4ab6cd29e61751e5f6ea5615f10d8bd6" name="reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a5100adf61faf63a0cc04264ea9cb1951" name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a475f5fe7d8d1920b2eebe78838cca252" name="size_type"><type>segment_manager::size_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1adb4104c91c49e81d4923ca2cfaf6711e" name="difference_type"><type>segment_manager::difference_type</type></typedef>
<method-group name="private member functions">
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1ae4b2816cbd35d3dd474fa7b25e0aec51"><type><classname>cached_adaptive_pool</classname> &amp;</type><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="SegmentManager2"/>
          <template-nontype-parameter name="N2"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F2"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP2"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>cached_adaptive_pool</classname>&lt; T2, SegmentManager2, N2, F2, OP2 &gt; &amp;</paramtype></parameter><description><para>Not assignable from related <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool">cached_adaptive_pool</link> </para></description></copy-assignment>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a4eca6dff7af20aee6d27bacc20cc32f0"><type><classname>cached_adaptive_pool</classname> &amp;</type><parameter name=""><paramtype>const <classname>cached_adaptive_pool</classname> &amp;</paramtype></parameter><description><para>Not assignable from other <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool">cached_adaptive_pool</link> </para></description></copy-assignment>
</method-group>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a6cfd6368bb797721021bd7b58d56c1a0"><parameter name="segment_mngr"><paramtype>segment_manager *</paramtype></parameter><description><para>Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1aaa4f6864058a24103c8d28c0421e8259"><parameter name="other"><paramtype>const <classname>cached_adaptive_pool</classname> &amp;</paramtype></parameter><description><para>Copy constructor from other <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool">cached_adaptive_pool</link>. Increments the reference count of the associated node pool. Never throws </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1ad43be0df23db4e1ffab6996c4eb7d632"><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>cached_adaptive_pool</classname>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt; &amp;</paramtype></parameter><description><para>Copy constructor from related <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool">cached_adaptive_pool</link>. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a00c735b3777fa0e440161a144a3a382d"><description><para>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a2ccb9951acddef430b5ff3f40eb6ccf1" name="get_node_pool" cv="const"><type>node_pool_t *</type><description><para>Returns a pointer to the node pool. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a232e447bd9a3ccb362f93aeae3e94dbe" name="get_segment_manager" cv="const"><type>segment_manager *</type><description><para>Returns the segment manager. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a0e8bcd26df428c5cb2449eda2b04fd4f" name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a1c23b3acabec0a7c61c68e2d0da9d647" name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_pointer</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> if there is no enough memory </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a7e105b6369d233afa6b72ff1a68088f8" name="deallocate"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1adbe8fdff53b1c34c7773ad746a0d415a" name="deallocate_free_blocks"><type>void</type><description><para>Deallocates all free blocks of the pool </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1ab5cb9a43c738bf3f92c040bf42cd9df7" name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1ae6a8dfb1dd7fd8c20f5123e2929b7683" name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a3b62e8bd1aa2a951d0d4a27d7e5804dd" name="construct"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="v"><paramtype>const_reference</paramtype></parameter><description><para>Copy construct an object. Throws if T's copy constructor throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a19ad14e9edf4ed73dd2e05847ac357bb" name="destroy"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Destroys object. Throws if object's destructor throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a89daa0332db4916721f8b49d878d0738" name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1adc2c016faa6e2871fae8495a9e844787" name="allocation_command"><type>pointer</type><parameter name="command"><paramtype>boost::interprocess::allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a08f957c3360ee314115cee5b6bf07c36" name="allocate_many"><type>void</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1ad730464c13cb28f991fa4afb5b0c65a0" name="allocate_many"><type>void</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1af61db2b4f797e586f3a5a49b2fedeb74" name="deallocate_many"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1aeca077efb12ce079025944eedf3dfc0f" name="allocate_one"><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1affbb8117d5ddc673f43b74930ff5523d">deallocate_one()</link>. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> if there is no enough memory </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1ada15e16ec1b900bde8d9a2df16e8941e" name="allocate_individual"><type>multiallocation_chain</type><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1affbb8117d5ddc673f43b74930ff5523d">deallocate_one()</link>. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1affbb8117d5ddc673f43b74930ff5523d" name="deallocate_one"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1aeca077efb12ce079025944eedf3dfc0f">allocate_one()</link>. You should never use deallocate_one to deallocate memory allocated with other functions different from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1aeca077efb12ce079025944eedf3dfc0f">allocate_one()</link>. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a5917cde250b60ce257a2705c0e3b1c9a" name="deallocate_individual"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1affbb8117d5ddc673f43b74930ff5523d">deallocate_one()</link>. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a43ad19e40136d6d8aee6bc8426e4f624" name="set_max_cached_nodes"><type>void</type><parameter name="newmax"><paramtype>size_type</paramtype></parameter><description><para>Sets the new max cached nodes value. This can provoke deallocations if "newmax" is less than current cached nodes. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1ab479782e1f2b35ed8360437a09a2b4e0" name="get_max_cached_nodes" cv="const"><type>size_type</type><description><para>Returns the max cached nodes parameter. Never throws </para></description></method>
</method-group>
<method-group name="friend functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool_1a63777ee47c37b3f6817aa6fc57db0e0d" name="swap"><type>void</type><parameter name="alloc1"><paramtype>self_t &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>self_t &amp;</paramtype></parameter><description><para>Swaps allocators. Does not throw. If each allocator is placed in a different memory segment, the result is undefined. </para></description></method>
</method-group>
</class>

















<function id="doxygen.boost_interprocess_header_reference.cached__adaptive__pool_8hpp_1a4eebc7d78782f1f44fdba5e65893af95" name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>cached_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>cached_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool">cached_adaptive_pool</link> </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.cached__adaptive__pool_8hpp_1a8538149c5beca8c76b5925eed81e4e0d" name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>cached_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>cached_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool">cached_adaptive_pool</link> </para></description></function>































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.cached__node__allocator_8hpp" name="boost/interprocess/allocators/cached_node_allocator.hpp">
<para>Describes cached_cached_node_allocator pooled shared memory STL compatible allocator </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator" name="cached_node_allocator"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
    </template><struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1cached__node__allocator_1_1rebind" name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator">cached_node_allocator</link> from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator">cached_node_allocator</link> </para></description><typedef id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1cached__node__allocator_1_1rebind_1a438818fbe824f6d39f8563a868fcf114" name="other"><type><classname>cached_node_allocator</classname>&lt; T2, SegmentManager &gt;</type></typedef>
</struct><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1adab9ee45284b9065aa529ccac37868da" name="segment_manager"><type>implementation_defined::segment_manager</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a2120ddc9deb55023e3ff42e273018202" name="void_pointer"><type>segment_manager::void_pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1ac3559275d855e3768b5cf92f272693a8" name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a76099c3b6446dc11c5d4022c97f72ef7" name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a28d7e86d4b86e6eb7c73d317a4e23bb1" name="value_type"><type>T</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1abe665d0080b38cf409f723545013401f" name="reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1afd08ebc17888a4fe66e38494fc624b53" name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1afb4ec6c58b2bdd6160e04f46ae73e0f1" name="size_type"><type>SegmentManager::size_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a580cdcf3bfc4f8be24b18c0916a113d5" name="difference_type"><type>SegmentManager::difference_type</type></typedef>
<method-group name="private member functions">
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a4183e4e6c9610222ead88c312202f8bf"><type><classname>cached_node_allocator</classname> &amp;</type><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="SegmentManager2"/>
          <template-nontype-parameter name="N2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>cached_node_allocator</classname>&lt; T2, SegmentManager2, N2 &gt; &amp;</paramtype></parameter><description><para>Not assignable from related <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator">cached_node_allocator</link> </para></description></copy-assignment>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a948b3249fccec62371f2c488bd98da57"><type><classname>cached_node_allocator</classname> &amp;</type><parameter name=""><paramtype>const <classname>cached_node_allocator</classname> &amp;</paramtype></parameter><description><para>Not assignable from other <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator">cached_node_allocator</link> </para></description></copy-assignment>
</method-group>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a6d10e2d417d394b28d0a74c7f8944c52"><parameter name="segment_mngr"><paramtype>segment_manager *</paramtype></parameter><description><para>Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a606cc696da45f1358b691e090febc7ab"><parameter name="other"><paramtype>const <classname>cached_node_allocator</classname> &amp;</paramtype></parameter><description><para>Copy constructor from other <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator">cached_node_allocator</link>. Increments the reference count of the associated node pool. Never throws </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1aaa20034b350553e6b35757e9a48cf47a"><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>cached_node_allocator</classname>&lt; T2, SegmentManager, NodesPerBlock &gt; &amp;</paramtype></parameter><description><para>Copy constructor from related <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator">cached_node_allocator</link>. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1aa468e042b99cf408636cc71c138863e0"><description><para>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a0e5a9916cd5ca40351e8a0faccc189aa" name="get_node_pool" cv="const"><type>node_pool_t *</type><description><para>Returns a pointer to the node pool. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1aca25a6b8d75d1a4bd837284659f6caa1" name="get_segment_manager" cv="const"><type>segment_manager *</type><description><para>Returns the segment manager. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a8fbf927d9775ebd87825187d84374a8f" name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1af95b84363702ceb20c5e4a28f1e635e0" name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_pointer</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> if there is no enough memory </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a9c8ed8d6c785a73276e1d33184be5278" name="deallocate"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1ab288f99a57d5f678ade9637bdbe030f8" name="deallocate_free_blocks"><type>void</type><description><para>Deallocates all free blocks of the pool </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a8e3ab778c68b6bea06a211a7b0a59a67" name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1aef28708ee6a78308a628b5675541c40c" name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a70a888654f52438b819616e589f614eb" name="construct"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="v"><paramtype>const_reference</paramtype></parameter><description><para>Default construct an object. Throws if T's default constructor throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1aaf1ca6e42e94305726cdbffbcaf9a2f6" name="destroy"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Destroys object. Throws if object's destructor throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a018ee7b20938e86b4f0c58a976ff0b40" name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a2df98f2624ae05113386fefa7bdcde54" name="allocation_command"><type>pointer</type><parameter name="command"><paramtype>boost::interprocess::allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a0d46b959115292d1bdd702cdd5278af2" name="allocate_many"><type>void</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1aaef029f3efed1c6d1c447a3294aa1961" name="allocate_many"><type>void</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1abba37f9d9ac0ccd9c93f530c653d2f05" name="deallocate_many"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a709c5765afc20c7d07da4762c3fa28d0" name="allocate_one"><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a9979ca57ae2073d0b114bd54f2e970c4">deallocate_one()</link>. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> if there is no enough memory </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1adbf99c87abf0606764f3bb52536db237" name="allocate_individual"><type>multiallocation_chain</type><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a9979ca57ae2073d0b114bd54f2e970c4">deallocate_one()</link>. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a9979ca57ae2073d0b114bd54f2e970c4" name="deallocate_one"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a709c5765afc20c7d07da4762c3fa28d0">allocate_one()</link>. You should never use deallocate_one to deallocate memory allocated with other functions different from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a709c5765afc20c7d07da4762c3fa28d0">allocate_one()</link>. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a721575bacc33c14253ae1d7c4f0c5e18" name="deallocate_individual"><type>void</type><parameter name="it"><paramtype>multiallocation_chain</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a9979ca57ae2073d0b114bd54f2e970c4">deallocate_one()</link>. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a84d92ea7515fdb54740bd7f7f4a5025f" name="set_max_cached_nodes"><type>void</type><parameter name="newmax"><paramtype>size_type</paramtype></parameter><description><para>Sets the new max cached nodes value. This can provoke deallocations if "newmax" is less than current cached nodes. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a3dd1b0e36c4f4007949b8f4bb108a746" name="get_max_cached_nodes" cv="const"><type>size_type</type><description><para>Returns the max cached nodes parameter. Never throws </para></description></method>
</method-group>
<method-group name="friend functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator_1a63777ee47c37b3f6817aa6fc57db0e0d" name="swap"><type>void</type><parameter name="alloc1"><paramtype>self_t &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>self_t &amp;</paramtype></parameter><description><para>Swaps allocators. Does not throw. If each allocator is placed in a different memory segment, the result is undefined. </para></description></method>
</method-group>
</class>















<function id="doxygen.boost_interprocess_header_reference.cached__node__allocator_8hpp_1a2c395f57a3b968012a65cf0041fb956c" name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NPC"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>cached_node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>cached_node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator">cached_node_allocator</link> </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.cached__node__allocator_8hpp_1a58a5cf77d0a0344f24a4d8860c6371e6" name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NPC"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>cached_node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>cached_node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator">cached_node_allocator</link> </para></description></function>

































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.node__allocator_8hpp" name="boost/interprocess/allocators/node_allocator.hpp">
<para>Describes node_allocator pooled shared memory STL compatible allocator </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator" name="node_allocator"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
    </template><description><para>An STL node allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc... This node allocator shares a segregated storage between all instances of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator">node_allocator</link> with equal sizeof(T) placed in the same segment group. NodesPerBlock is the number of nodes allocated at once when the allocator runs out of nodes </para></description><struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1node__allocator_1_1rebind" name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator">node_allocator</link> from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator">node_allocator</link> </para></description><typedef id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1node__allocator_1_1rebind_1a50b904f26b95571d85d54248821401c1" name="other"><type><classname>node_allocator</classname>&lt; T2, SegmentManager, NodesPerBlock &gt;</type></typedef>
</struct><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a4c4253d6305a5eff8eb5dc4b6f34938c" name="segment_manager"><type>implementation_defined::segment_manager</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1ab6ac56809b6126c475575e8dc3525f5e" name="void_pointer"><type>segment_manager::void_pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a4bd8c6b41aa4f006eed406dff4b17c80" name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1af1d441afeecc2fdf71411623210cb314" name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a803b078d521572b51738555b98439e44" name="value_type"><type>T</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1ad667010cef4b46bf365e696ce5cba746" name="reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a29330c6f85cb765f24df91587433f323" name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a85218002efbf65f166500a8405ac9723" name="size_type"><type>segment_manager::size_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1ad188b974329a2abb35155098bcd872cc" name="difference_type"><type>segment_manager::difference_type</type></typedef>
<method-group name="private member functions">
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1ac4c79b69764859ae5073a6441603aeb9"><type><classname>node_allocator</classname> &amp;</type><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="SegmentManager2"/>
          <template-nontype-parameter name="N2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>node_allocator</classname>&lt; T2, SegmentManager2, N2 &gt; &amp;</paramtype></parameter><description><para>Not assignable from related <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator">node_allocator</link> </para></description></copy-assignment>
</method-group>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a56d185f746adccb1af637a817b635b97"><parameter name="segment_mngr"><paramtype>segment_manager *</paramtype></parameter><description><para>Not assignable from other <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator">node_allocator</link> Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a47c9d7ea06e1125ea393259cf0ca250c"><parameter name="other"><paramtype>const <classname>node_allocator</classname> &amp;</paramtype></parameter><description><para>Copy constructor from other <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator">node_allocator</link>. Increments the reference count of the associated node pool. Never throws </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a0b8ac2e0f000ac92205c40a02b4e13be"><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>node_allocator</classname>&lt; T2, SegmentManager, NodesPerBlock &gt; &amp;</paramtype></parameter><description><para>Copy constructor from related <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator">node_allocator</link>. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a3f7278996cef40d3cd0a45bbcad23a43"><description><para>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a8a3c6c96516d3e5fd4549eec2de2f2c7" name="get_node_pool" cv="const"><type>void *</type><description><para>Returns a pointer to the node pool. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a7cb8d0b18eb95d586e014082d3942a6e" name="get_segment_manager" cv="const"><type>segment_manager *</type><description><para>Returns the segment manager. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a7ff881e2fb0a7413cbaa9f884f41e124" name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1aa730834357bfe3ded576c79f87bc38d8" name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_pointer</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> if there is no enough memory </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a1d745b18b5873c8e84eef01a81877416" name="deallocate"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a907074171cf50bb79e5455679041ff7f" name="deallocate_free_blocks"><type>void</type><description><para>Deallocates all free blocks of the pool </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a7b126986aebabf504d71a918a5447577" name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1af8be696bbf54948346dcc4b5ea3e2f04" name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1aca9023ab79bc93aceb3dc6496cb8c963" name="construct"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="v"><paramtype>const_reference</paramtype></parameter><description><para>Copy construct an object. Throws if T's copy constructor throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a85cbccc8db59933f53eb45932922d8b5" name="destroy"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Destroys object. Throws if object's destructor throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a86a517f05a240cd50702a230be3a593b" name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a56f82482733a72ae141a9e03203c9873" name="allocation_command"><type>pointer</type><parameter name="command"><paramtype>boost::interprocess::allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a6de85081e77a895b2cd3b5c2cd4b22f4" name="allocate_many"><type>void</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a3843fbd3fca5e1a45023ba36a8d7fa9c" name="allocate_many"><type>void</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a1bcfe522d3441fd152a962c2d91a4cf9" name="deallocate_many"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a28b197a5867e41ddeaacd0e1f4ca82cc" name="allocate_one"><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1adf58491c22dd049dc610c9d42a3d5a86">deallocate_one()</link>. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> if there is no enough memory </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a50b4449af18e9488aa3db33151eefae7" name="allocate_individual"><type>void</type><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1adf58491c22dd049dc610c9d42a3d5a86">deallocate_one()</link>. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1adf58491c22dd049dc610c9d42a3d5a86" name="deallocate_one"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a28b197a5867e41ddeaacd0e1f4ca82cc">allocate_one()</link>. You should never use deallocate_one to deallocate memory allocated with other functions different from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a28b197a5867e41ddeaacd0e1f4ca82cc">allocate_one()</link>. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1acb2c642d3d920e5e42a35ae13cd8ffb8" name="deallocate_individual"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1adf58491c22dd049dc610c9d42a3d5a86">deallocate_one()</link>. </para></description></method>
</method-group>
<method-group name="friend functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator_1a63777ee47c37b3f6817aa6fc57db0e0d" name="swap"><type>void</type><parameter name="alloc1"><paramtype>self_t &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>self_t &amp;</paramtype></parameter><description><para>Swaps allocators. Does not throw. If each allocator is placed in a different memory segment, the result is undefined. </para></description></method>
</method-group>
</class>













<function id="doxygen.boost_interprocess_header_reference.node__allocator_8hpp_1af55c8461d3deb2c1a490c433be1293ba" name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NPC"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator">node_allocator</link> </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.node__allocator_8hpp_1a6995dad28e5210991abe9fc9238fda39" name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NPC"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator">node_allocator</link> </para></description></function>



































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.private__adaptive__pool_8hpp" name="boost/interprocess/allocators/private_adaptive_pool.hpp">
<para>Describes private_adaptive_pool_base pooled shared memory STL compatible allocator </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool" name="private_adaptive_pool"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
      <template-nontype-parameter name="MaxFreeBlocks"><type>std::size_t</type></template-nontype-parameter>
      <template-nontype-parameter name="OverheadPercent"><type>unsigned char</type></template-nontype-parameter>
    </template><description><para>An STL node allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc... This allocator has its own node pool.</para><para>NodesPerBlock is the minimum number of nodes of nodes allocated at once when the allocator needs runs out of nodes. MaxFreeBlocks is the maximum number of totally free blocks that the adaptive node pool will hold. The rest of the totally free blocks will be deallocated with the segment manager.</para><para>OverheadPercent is the (approximated) maximum size overhead (1-20%) of the allocator: (memory usable for nodes / total memory allocated from the segment manager) </para></description><struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1private__adaptive__pool_1_1rebind" name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool">private_adaptive_pool</link> from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool">private_adaptive_pool</link> </para></description><typedef id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1private__adaptive__pool_1_1rebind_1a5a2862fe3cf577c4de277e890b33f679" name="other"><type><classname>private_adaptive_pool</classname>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt;</type></typedef>
</struct><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1aad85800d2fd10be94c5f8e8b74025101" name="segment_manager"><type>implementation_defined::segment_manager</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1ad7ece1642da03645fe7ba1bf9203ee1d" name="void_pointer"><type>segment_manager::void_pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a4bb7bf1d42a25b6a7a8c9603e9a953e4" name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a7facf2cbc6dd77b4df09a4187ab87845" name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1afa0ed5bf630317ddbc2c725fe3a12c27" name="value_type"><type>T</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1acbb480cc1f66f4c010a6794e79e67429" name="reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1ac91bcea2540ec9a6bc8be35add231043" name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a6c12e7c7ee48e6b9dc179291f4f40fd5" name="size_type"><type>segment_manager::size_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a9b0934188e34602e4b18655cd03f1cd1" name="difference_type"><type>segment_manager::difference_type</type></typedef>
<method-group name="private member functions">
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1afae487cb22dfc2026a7ce3abdfc9571d"><type><classname>private_adaptive_pool</classname> &amp;</type><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="SegmentManager2"/>
          <template-nontype-parameter name="N2"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F2"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP2"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>private_adaptive_pool</classname>&lt; T2, SegmentManager2, N2, F2 &gt; &amp;</paramtype></parameter><description><para>Not assignable from related <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool">private_adaptive_pool</link> </para></description></copy-assignment>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a44e7dbfd4daba137b175bd2ec0dd091d"><type><classname>private_adaptive_pool</classname> &amp;</type><parameter name=""><paramtype>const <classname>private_adaptive_pool</classname> &amp;</paramtype></parameter><description><para>Not assignable from other <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool">private_adaptive_pool</link> </para></description></copy-assignment>
</method-group>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a56907be7205fdc0e8b56b3edb012f3f2"><parameter name="segment_mngr"><paramtype>segment_manager *</paramtype></parameter><description><para>Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a0753e306cea9f54b0f5ac1c7a25fc693"><parameter name="other"><paramtype>const <classname>private_adaptive_pool</classname> &amp;</paramtype></parameter><description><para>Copy constructor from other <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool">private_adaptive_pool</link>. Increments the reference count of the associated node pool. Never throws </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a5b5a35864bec692a0aca4c88345335da"><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>private_adaptive_pool</classname>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt; &amp;</paramtype></parameter><description><para>Copy constructor from related <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool">private_adaptive_pool</link>. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a3eb4db45e8c23a9528bf04a5b416e96b"><description><para>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1aba0e033cff840fd0699254847614c518" name="get_node_pool" cv="const"><type>node_pool_t *</type><description><para>Returns a pointer to the node pool. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a6d3d869bab86e5353b05b03661bb639a" name="get_segment_manager" cv="const"><type>segment_manager *</type><description><para>Returns the segment manager. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a3e66cd79f85190cd0af11303abad1988" name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1aa4dfeac65bb4bd561f018b4bc4272cb6" name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_pointer</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> if there is no enough memory </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a6cc97a556a984f00238eeadf1c796d09" name="deallocate"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1ad5ae25ad3be7c5cfcb3d566608ac5740" name="deallocate_free_blocks"><type>void</type><description><para>Deallocates all free blocks of the pool </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1aa0a61f13c47fb64d1b8b67b917e655fc" name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1ae125fcc531767c91f4b70d559793682b" name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a5c7c51203d0a9abed37b68ae29dead66" name="construct"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="v"><paramtype>const_reference</paramtype></parameter><description><para>Copy construct an object. Throws if T's copy constructor throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a05c17f42dde5b39fa45a9a3e8873ca06" name="destroy"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Destroys object. Throws if object's destructor throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a573378d1f5153b8664eedfb11703f4fc" name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1abb7f348afa10b3b743db2544048c65bc" name="allocation_command"><type>pointer</type><parameter name="command"><paramtype>boost::interprocess::allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a7db8c6fb2f548cd5079587c88f8bd3cd" name="allocate_many"><type>void</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1aeb623ffb4b384d8702e3c638aea3033f" name="allocate_many"><type>void</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a8204dc79ce5990f3dc23299f194e9c7b" name="deallocate_many"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a56febe8f05bfe16a32cf23623ecb00c3" name="allocate_one"><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1af43d3b9898c9599dea1ca1557e1f8da6">deallocate_one()</link>. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> if there is no enough memory </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1af38974fe967fadb580a5ac7f69f745be" name="allocate_individual"><type>void</type><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1af43d3b9898c9599dea1ca1557e1f8da6">deallocate_one()</link>. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1af43d3b9898c9599dea1ca1557e1f8da6" name="deallocate_one"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a56febe8f05bfe16a32cf23623ecb00c3">allocate_one()</link>. You should never use deallocate_one to deallocate memory allocated with other functions different from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a56febe8f05bfe16a32cf23623ecb00c3">allocate_one()</link>. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a345ec1646ae3976ac565be9704bd62de" name="deallocate_individual"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1af43d3b9898c9599dea1ca1557e1f8da6">deallocate_one()</link>. </para></description></method>
</method-group>
<method-group name="friend functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool_1a63777ee47c37b3f6817aa6fc57db0e0d" name="swap"><type>void</type><parameter name="alloc1"><paramtype>self_t &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>self_t &amp;</paramtype></parameter><description><para>Swaps allocators. Does not throw. If each allocator is placed in a different memory segment, the result is undefined. </para></description></method>
</method-group>
</class>











<function id="doxygen.boost_interprocess_header_reference.private__adaptive__pool_8hpp_1ab71280923b834100361227a7dca760f0" name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>private_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>private_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool">private_adaptive_pool</link> </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.private__adaptive__pool_8hpp_1a74111b10a62b43195fd1de4fd96bfadd" name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>private_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>private_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool">private_adaptive_pool</link> </para></description></function>





































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.private__node__allocator_8hpp" name="boost/interprocess/allocators/private_node_allocator.hpp">
<para>Describes private_node_allocator_base pooled shared memory STL compatible allocator </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator" name="private_node_allocator"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
    </template><description><para>An STL node allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc... This allocator has its own node pool. NodesPerBlock is the number of nodes allocated at once when the allocator needs runs out of nodes </para></description><struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1private__node__allocator_1_1rebind" name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator">private_node_allocator</link> from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator">private_node_allocator</link> </para></description><typedef id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1private__node__allocator_1_1rebind_1a134b425427751f2f6a1282475adc3ae6" name="other"><type><classname>private_node_allocator</classname>&lt; T2, SegmentManager, NodesPerBlock &gt;</type></typedef>
</struct><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a8d1f32a9039cdf015b3a2961f1af8a29" name="segment_manager"><type>implementation_defined::segment_manager</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a6c5ee8e09114a0b2a4be253dfd1487b6" name="void_pointer"><type>segment_manager::void_pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1ae28d133b6a0a425ba6897ebfa59ae5ee" name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a8211d8cb93f84a8703c7c4f827fe0c04" name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1af8be210af6e3ec19cf48f5bfc32cb5ab" name="value_type"><type>T</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1ad49dfc3221b458f1d881cd888e106fd4" name="reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1ad6f4b7386a12de83aeb12bf32dd14bd3" name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a95bd7aa938865d220305a03bcfd963b9" name="size_type"><type>segment_manager::size_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a1a71e97f9c7eddc7f5e6dac947bd1423" name="difference_type"><type>segment_manage::difference_type</type></typedef>
<method-group name="private member functions">
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a5c6da91d00da9e62c5afe649baa15fff"><type><classname>private_node_allocator</classname> &amp;</type><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="SegmentManager2"/>
          <template-nontype-parameter name="N2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>private_node_allocator</classname>&lt; T2, SegmentManager2, N2 &gt; &amp;</paramtype></parameter><description><para>Not assignable from related <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator">private_node_allocator</link> </para></description></copy-assignment>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a14fa523b81300aa4c3404e72b28bbd45"><type><classname>private_node_allocator</classname> &amp;</type><parameter name=""><paramtype>const <classname>private_node_allocator</classname> &amp;</paramtype></parameter><description><para>Not assignable from other <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator">private_node_allocator</link> </para></description></copy-assignment>
</method-group>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a9f7d0023a9166cd756009a2ad9b363ff"><parameter name="segment_mngr"><paramtype>segment_manager *</paramtype></parameter><description><para>Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a7b5e79a910935910e810c36323bb483d"><parameter name="other"><paramtype>const <classname>private_node_allocator</classname> &amp;</paramtype></parameter><description><para>Copy constructor from other <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator">private_node_allocator</link>. Increments the reference count of the associated node pool. Never throws </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a05ff6fabe2e80dfc2bc229c00ba7d238"><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>private_node_allocator</classname>&lt; T2, SegmentManager, NodesPerBlock &gt; &amp;</paramtype></parameter><description><para>Copy constructor from related <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator">private_node_allocator</link>. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a909a7db34a2a73072187f80e460613ce"><description><para>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a923c2c1779b1ec0998bfecce6dad8d40" name="get_node_pool" cv="const"><type>node_pool_t *</type><description><para>Returns a pointer to the node pool. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a3e9b4035058a6e60661f8cfcd0e4b892" name="get_segment_manager" cv="const"><type>segment_manager *</type><description><para>Returns the segment manager. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a0bc39a3729b7120c51331e3fd6e26485" name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a1c21c614c3522dc0c9b17474a3a238d4" name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_pointer</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> if there is no enough memory </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a2d8f5cf1e99e358428ba89f15a87b3fa" name="deallocate"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1aad62c959525fa1c8d523711342211d2a" name="deallocate_free_blocks"><type>void</type><description><para>Deallocates all free blocks of the pool </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1ad1ae73cfdc1eb6a9442c703fe7f9eea8" name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a9565fcbc2b56d44aa1d64f935fd4af04" name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a3069e9cc315813531e4163a564b1181c" name="construct"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="v"><paramtype>const_reference</paramtype></parameter><description><para>Copy construct an object. Throws if T's copy constructor throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a380dd74ad20a84e4694c69ca7dedbead" name="destroy"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Destroys object. Throws if object's destructor throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a50c969eba82fc4b35ecbee43d3809e63" name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1adc2307da55baac1e02fcb975d8af147b" name="allocation_command"><type>pointer</type><parameter name="command"><paramtype>boost::interprocess::allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a83bb002d201537ba2792cab8785f36e6" name="allocate_many"><type>void</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a89fbbfee49116bb42845465e86f06987" name="allocate_many"><type>void</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a66d21182bf1f50c75b300d2809a6ba90" name="deallocate_many"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1ac15da8a1118ed1859b51101d0a6e05d7" name="allocate_one"><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a6ec722b4bc59327bed01cfc0261ff3ca">deallocate_one()</link>. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> if there is no enough memory </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a843dfee9a7c61750596cf5086113ddde" name="allocate_individual"><type>void</type><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a6ec722b4bc59327bed01cfc0261ff3ca">deallocate_one()</link>. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a6ec722b4bc59327bed01cfc0261ff3ca" name="deallocate_one"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1ac15da8a1118ed1859b51101d0a6e05d7">allocate_one()</link>. You should never use deallocate_one to deallocate memory allocated with other functions different from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1ac15da8a1118ed1859b51101d0a6e05d7">allocate_one()</link>. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a594ea1f4c7a868a0c054d76bbbd7b0ad" name="deallocate_individual"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a6ec722b4bc59327bed01cfc0261ff3ca">deallocate_one()</link>. </para></description></method>
</method-group>
<method-group name="friend functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator_1a63777ee47c37b3f6817aa6fc57db0e0d" name="swap"><type>void</type><parameter name="alloc1"><paramtype>self_t &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>self_t &amp;</paramtype></parameter><description><para>Swaps allocators. Does not throw. If each allocator is placed in a different memory segment, the result is undefined. </para></description></method>
</method-group>
</class>









<function id="doxygen.boost_interprocess_header_reference.private__node__allocator_8hpp_1a6f6fa9060b45c9ecc580e2983fdbf208" name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>private_node_allocator</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>private_node_allocator</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator">private_node_allocator</link> </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.private__node__allocator_8hpp_1a698fffb7e207a94369c959910b50a40c" name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>private_node_allocator</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>private_node_allocator</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator">private_node_allocator</link> </para></description></function>







































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.anonymous__shared__memory_8hpp" name="boost/interprocess/anonymous_shared_memory.hpp">
<para>Describes a function that creates anonymous shared memory that can be shared between forked processes </para><namespace name="boost">
<namespace name="interprocess">









<function id="doxygen.boost_interprocess_header_reference.anonymous__shared__memory_8hpp_1a79b8d3cc8666edda422f3ca0e2d93df3" name="anonymous_shared_memory"><type><classname>mapped_region</classname></type><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="address"><paramtype>void *</paramtype><default>0</default></parameter><description><para>A function that creates an anonymous shared memory segment of size "size". If "address" is passed the function will try to map the segment in that address. Otherwise the operating system will choose the mapping address. The function returns a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region">mapped_region</link> holding that segment or throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> if the function fails. </para></description></function>









































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.allocation__type_8hpp" name="boost/interprocess/containers/allocation_type.hpp">
<namespace name="boost">
<namespace name="interprocess">
<data-member id="doxygen.boost_interprocess_header_reference.allocation__type_8hpp_1a6c2c14d2f770b19816b96b75922dc804" name="allocate_new" specifiers="static"><type>const allocation_type</type></data-member>
<data-member id="doxygen.boost_interprocess_header_reference.allocation__type_8hpp_1a8e69550354ad73920671775a0c728e3f" name="expand_fwd" specifiers="static"><type>const allocation_type</type></data-member>
<data-member id="doxygen.boost_interprocess_header_reference.allocation__type_8hpp_1a4891c03815cf07b9310423b5af2a1d0f" name="expand_bwd" specifiers="static"><type>const allocation_type</type></data-member>
<data-member id="doxygen.boost_interprocess_header_reference.allocation__type_8hpp_1a24af298e68ba382fe85178d557391bc4" name="shrink_in_place" specifiers="static"><type>const allocation_type</type></data-member>
<data-member id="doxygen.boost_interprocess_header_reference.allocation__type_8hpp_1af969c1b70e06b37508b3d13d6a368af3" name="try_shrink_in_place" specifiers="static"><type>const allocation_type</type></data-member>
<data-member id="doxygen.boost_interprocess_header_reference.allocation__type_8hpp_1aa60eb8d6ded3fd19c92d0630fa7654ba" name="nothrow_allocation" specifiers="static"><type>const allocation_type</type></data-member>
<data-member id="doxygen.boost_interprocess_header_reference.allocation__type_8hpp_1a454a84b1b81b6a995fc7b49487860df7" name="zero_memory" specifiers="static"><type>const allocation_type</type></data-member>



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.containers__fwd_8hpp" name="boost/interprocess/containers/containers_fwd.hpp">
</header>
<header id="doxygen.boost_interprocess_header_reference.deque_8hpp" name="boost/interprocess/containers/deque.hpp">
<namespace name="boost">
<namespace name="interprocess">



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.flat__map_8hpp" name="boost/interprocess/containers/flat_map.hpp">
<namespace name="boost">
<namespace name="interprocess">



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.flat__set_8hpp" name="boost/interprocess/containers/flat_set.hpp">
<namespace name="boost">
<namespace name="interprocess">



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.list_8hpp" name="boost/interprocess/containers/list.hpp">
<namespace name="boost">
<namespace name="interprocess">



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.map_8hpp" name="boost/interprocess/containers/map.hpp">
<namespace name="boost">
<namespace name="interprocess">



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.pair_8hpp" name="boost/interprocess/containers/pair.hpp">
<namespace name="boost">
<namespace name="interprocess">



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.set_8hpp" name="boost/interprocess/containers/set.hpp">
<namespace name="boost">
<namespace name="interprocess">



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.slist_8hpp" name="boost/interprocess/containers/slist.hpp">
<namespace name="boost">
<namespace name="interprocess">



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.stable__vector_8hpp" name="boost/interprocess/containers/stable_vector.hpp">
<namespace name="boost">
<namespace name="interprocess">



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.string_8hpp" name="boost/interprocess/containers/string.hpp">
<namespace name="boost">
<namespace name="interprocess">



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.vector_8hpp" name="boost/interprocess/containers/vector.hpp">
<namespace name="boost">
<namespace name="interprocess">



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.version__type_8hpp" name="boost/interprocess/containers/version_type.hpp">
<namespace name="boost">
<namespace name="interprocess">



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.creation__tags_8hpp" name="boost/interprocess/creation_tags.hpp">
<namespace name="boost">
<namespace name="interprocess">
<struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1create__only__t" name="create_only_t"><description><para>Tag to indicate that the resource must be only created </para></description></struct><struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1open__copy__on__write__t" name="open_copy_on_write_t"><description><para>Tag to indicate that the resource must be only opened for reading </para></description></struct><struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1open__only__t" name="open_only_t"><description><para>Tag to indicate that the resource must be only opened </para></description></struct><struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1open__or__create__t" name="open_or_create_t"><description><para>Tag to indicate that the resource must be created. If already created, it must be opened. </para></description></struct><struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1open__read__only__t" name="open_read_only_t"><description><para>Tag to indicate that the resource must be only opened for reading </para></description></struct><struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1open__read__private__t" name="open_read_private_t"><description><para>Tag to indicate that the resource must be only opened privately for reading </para></description></struct><data-member id="doxygen.boost_interprocess_header_reference.creation__tags_8hpp_1a5c91de6ee505ba17fbc3be121968bcb4" name="create_only" specifiers="static"><type>const <classname>create_only_t</classname></type><description><para>Value to indicate that the resource must be only created </para></description></data-member>
<data-member id="doxygen.boost_interprocess_header_reference.creation__tags_8hpp_1a4a1493a736f144ab76dce1c0696c7667" name="open_only" specifiers="static"><type>const <classname>open_only_t</classname></type><description><para>Value to indicate that the resource must be only opened </para></description></data-member>
<data-member id="doxygen.boost_interprocess_header_reference.creation__tags_8hpp_1ac71932b87310788f4aee48dde205f602" name="open_read_only" specifiers="static"><type>const <classname>open_read_only_t</classname></type><description><para>Value to indicate that the resource must be only opened for reading </para></description></data-member>
<data-member id="doxygen.boost_interprocess_header_reference.creation__tags_8hpp_1a7f8c9dda85e103741ef7c88a9560cec3" name="open_or_create" specifiers="static"><type>const <classname>open_or_create_t</classname></type><description><para>Value to indicate that the resource must be created. If already created, it must be opened. </para></description></data-member>
<data-member id="doxygen.boost_interprocess_header_reference.creation__tags_8hpp_1ab60cfa8230d67126865e58e6da0667ae" name="open_copy_on_write" specifiers="static"><type>const <classname>open_copy_on_write_t</classname></type><description><para>Value to indicate that the resource must be only opened for reading </para></description></data-member>



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.errors_8hpp" name="boost/interprocess/errors.hpp">
<para>Describes the error numbering of interprocess classes </para><namespace name="boost">
<namespace name="interprocess">
<enum id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4" name="error_code_t"><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4aa2a24fa37e7c8961d0db161d18522dd1" name="no_error"><default>0</default></enumvalue><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4a927e5e6e2fd92da914e0d594f959a5f1" name="system_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4ae54a8281a5ce0775626851ab2f6a19d7" name="other_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4a39632f7c0e4efbe1898153ac40cea034" name="security_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4a43d2279b52d65459a4111e9b67b592ef" name="read_only_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4abf91124979185f8f472bac27c961d2b3" name="io_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4ab34e511b4e6583631072dace8a79a6f4" name="path_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4a4f166431d565155d3fce99cc138effa6" name="not_found_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4a27c3420aecd546834c50dd0d7511509b" name="busy_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4ace48d52832cddf9778429e74057e1f37" name="already_exists_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4afda6546885f7c0c2f6298c665a3c064a" name="not_empty_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4a8b184f950a51fda641345bd05110a89f" name="is_directory_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4a5bf2df7e5c68d6074cc5aef4bde0e505" name="out_of_space_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4a9063008c84691c1abcd4de825ad1fa8c" name="out_of_memory_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4aaec7872820dc7e4530bdf648ec64bc0b" name="out_of_resource_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4a5e336d64867dda8eedc3f94913358b86" name="lock_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4aeedb72cbe6f2076da32ede9356d01649" name="sem_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4a032233b52c60fa5417c1a6375d9b9521" name="mode_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4a4d20b5e7b1a3c7c157a10f9f0febfb37" name="size_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4aaf098a3f944ee3845d2bdd26d8574675" name="corrupted_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4a48a1f747b4e3a6fe0725bf2478bb68e9" name="not_such_file_or_directory"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4ae338bcfe34cf6b90b2f5b05b10e5f8e0" name="invalid_argument"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4a2199e6181013f046bc23de95f58f7829" name="timeout_when_locking_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4a840180270c9670d4fc752b6b71c7090a" name="timeout_when_waiting_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4a0f9477220b39a68be5356b6a5b0507a2" name="owner_dead_error"/><enumvalue id="doxygen.boost_interprocess_header_reference.errors_8hpp_1a9fa7112f059d772afd0763a5ad0edde4add27819b7da49ac4e90f7458b3b7ee8d" name="not_recoverable"/></enum>
<typedef id="doxygen.boost_interprocess_header_reference.errors_8hpp_1af0f7f7c888a1818c728c44b0e9bfc55d" name="native_error_t"><type>int</type></typedef>



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.exceptions_8hpp" name="boost/interprocess/exceptions.hpp">
<para>Describes exceptions thrown by interprocess classes </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc" name="bad_alloc"><inherit access="public">boost::interprocess::interprocess_exception</inherit><description><para>This exception is thrown when a memory request can't be fulfilled. </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc_1a76da4d018dac034f3784bc505b0f32f4"/>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc_1a3565c16d75f86febe6878490ed9aa94d" name="what" cv="const noexcept"><type>const char *</type></method>
</method-group>
</class><class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception" name="interprocess_exception"><inherit access="public">std::exception</inherit><description><para>This class is the base class of all exceptions thrown by boost::interprocess </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception_1afea3ed439bad8a3d97eb56854323a0c5" cv="noexcept"><parameter name="err"><paramtype>const char *</paramtype></parameter></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception_1a384c135ba231c9a63b6ebcb81f860cd2"><parameter name="err_info"><paramtype>const error_info &amp;</paramtype></parameter><parameter name="str"><paramtype>const char *</paramtype><default>0</default></parameter></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception_1af9d74dc8068f069476ed9cbdfaf71bb3" cv="noexcept"/>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception_1aba7702c8d64e16932ecb84b7d51a4a0f" name="what" cv="const noexcept"><type>const char *</type></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception_1a31a749259173868dea6dc9bf387e7261" name="get_native_error" cv="const noexcept"><type>native_error_t</type></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception_1a8868e3a33664e83082419c737cac6171" name="get_error_code" cv="const noexcept"><type>error_code_t</type></method>
</method-group>
</class><class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1lock__exception" name="lock_exception"><inherit access="public">boost::interprocess::interprocess_exception</inherit><description><para>This is the exception thrown by shared <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex">interprocess_mutex</link> family when a deadlock situation is detected or when using a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition">interprocess_condition</link> the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex">interprocess_mutex</link> is not locked </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1lock__exception_1a138241937ada23e0202e9c576b6115fb" cv="noexcept"><parameter name="err"><paramtype>error_code_t</paramtype><default>lock_error</default></parameter></constructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1lock__exception_1aa701345f322d9a098e92d4ded5f63efb" name="what" cv="const noexcept"><type>const char *</type></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.file__mapping_8hpp" name="boost/interprocess/file_mapping.hpp">
<para>Describes file_mapping and mapped region classes </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__mapping" name="file_mapping"><description><para>A class that wraps a file-mapping that can be used to create mapped regions from the mapped files </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__mapping_1a2af66589c58cb766769110de19de7a81" cv="noexcept"><description><para>Constructs an empty file mapping. Does not throw </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__mapping_1aeda7e9018929a3dde53b0b839115d520"><parameter name="filename"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><description><para>Opens a file mapping of file "filename", starting in offset "file_offset", and the mapping's size will be "size". The mapping can be opened for read-only "read_only" or read-write "read_write" modes. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__mapping_1a1e0211c7826ae305fc404d6d6db31075"><parameter name="filename"><paramtype>const wchar_t *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><description><para>Opens a file mapping of file "filename", starting in offset "file_offset", and the mapping's size will be "size". The mapping can be opened for read-only "read_only" or read-write "read_write" modes. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__mapping_1a6a556f4759524c08b3f122491d0f9b38" cv="noexcept"><parameter name="moved"><paramtype><classname>file_mapping</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s file mapping object to *this. After the call, "moved" does not represent any file mapping object. Does not throw </para></description></constructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__mapping_1a192d8fb8ccd0302a23413dacdadd482b" cv="noexcept"><type><classname>file_mapping</classname> &amp;</type><parameter name="moved"><paramtype><classname>file_mapping</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s file mapping to *this. After the call, "moved" does not represent any file mapping. Does not throw </para></description></copy-assignment>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__mapping_1a53d43c413cf80960104e8d19c82b9808" name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>file_mapping</classname> &amp;</paramtype></parameter><description><para>Swaps to file_mappings. Does not throw. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__mapping_1af71b9ff93d385bb52476b7acd9f3a6c0" name="get_mode" cv="const noexcept"><type>mode_t</type><description><para>Returns access mode used in the constructor </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__mapping_1a48a163c82ca3f1afd2ddf216970ee771" name="get_mapping_handle" cv="const noexcept"><type>mapping_handle_t</type><description><para>Obtains the mapping handle to be used with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region">mapped_region</link> </para></description></method>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__mapping_1aa25d2a13fbb2a8dfad9c967320983e54"><description><para>Destroys the file mapping. All mapped regions created from this are still valid. Does not throw </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__mapping_1a0eb836f416952f9cafd2c3d586688c58" name="get_name" cv="const noexcept"><type>const char *</type><description><para>Returns the name of the file used in the constructor. </para></description></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__mapping_1a5249775bc2f11892bf85e2b1d638d2a6" name="remove" specifiers="static"><type>bool</type><parameter name="filename"><paramtype>const char *</paramtype></parameter><description><para>Removes the file named "filename" even if it's been memory mapped. Returns true on success. The function might fail in some operating systems if the file is being used other processes and no deletion permission was shared. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__mapping_1a3ba15ddef9050f807b948eb942e3f9fd" name="remove" specifiers="static"><type>bool</type><parameter name="filename"><paramtype>const wchar_t *</paramtype></parameter><description><para>Removes the file named "filename" even if it's been memory mapped. Returns true on success. The function might fail in some operating systems if the file is being used other processes and no deletion permission was shared.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.flat__map__index_8hpp" name="boost/interprocess/indexes/flat_map_index.hpp">
<para>Describes index adaptor of boost::map container, to use it as name/shared memory index </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1flat__map__index" name="flat_map_index"><template>
      <template-type-parameter name="MapConfig"/>
    </template><inherit access="private">flat_map_index_aux::index_t</inherit><description><para>Index type based in flat_map. Just derives from flat_map and defines the interface needed by managed memory segments. </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1flat__map__index_1a9057dc56b2d3d4d33b2e45ca7db4451c" name="iterator"><type>base_type::iterator</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1flat__map__index_1a14f0159c8b358b1baf62aa1fe0bd38e7" name="const_iterator"><type>base_type::const_iterator</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1flat__map__index_1aa2091de3e2a0784aa8d8804c5992e393" name="value_type"><type>base_type::value_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1flat__map__index_1a00b6fab59f421fea137d26e71eff2a77" name="compare_key_type"><type>MapConfig::compare_key_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1flat__map__index_1a5b47a373be99b7d41c37262703ce9ceb" name="insert_commit_data"><type>iterator</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1flat__map__index_1a0de1008006c7fb6a487c3691894a60c7" name="index_data_t"><type>iterator</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1flat__map__index_1a8af51bdcf0355bb20baf1a069cf035a6"><parameter name="segment_mngr"><paramtype><classname>segment_manager_base</classname> *</paramtype></parameter><purpose>Constructor. Takes a pointer to the segment manager. Can throw. </purpose></constructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1flat__map__index_1ad265a0816f579d842ca9c14a31efc910" name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const compare_key_type &amp;</paramtype></parameter><parameter name=""><paramtype>insert_commit_data &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1flat__map__index_1a00d530666f67340b92dcb5b04e4853e2" name="insert_commit"><type>iterator</type><parameter name="k"><paramtype>const compare_key_type &amp;</paramtype></parameter><parameter name="context"><paramtype>void *</paramtype></parameter><parameter name=""><paramtype>index_data_t &amp;</paramtype></parameter><parameter name=""><paramtype>insert_commit_data &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1flat__map__index_1aae53c1625616d862b116a30c5b8e8791" name="find"><type>iterator</type><parameter name="k"><paramtype>const compare_key_type &amp;</paramtype></parameter></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.iset__index_8hpp" name="boost/interprocess/indexes/iset_index.hpp">
<para>Describes index adaptor of boost::intrusive::set container, to use it as name/shared memory index </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iset__index" name="iset_index"><template>
      <template-type-parameter name="MapConfig"/>
    </template><inherit access="private">iset_index_aux::index_t</inherit><description><para>Index type based in boost::intrusive::set. Just derives from boost::intrusive::set and defines the interface needed by managed memory segments*<zwj/>/ </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iset__index_1af3e0bb5303cffd63331204c187b2ad90" name="iterator"><type>index_type::iterator</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iset__index_1a1e4dbdc424c2f2a081f72ea6b2b35310" name="const_iterator"><type>index_type::const_iterator</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iset__index_1af10ff789b1ccb0a928db6126b3a6a018" name="insert_commit_data"><type>index_type::insert_commit_data</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iset__index_1a6a4132df4419f37fbe3d3d78d1775e00" name="value_type"><type>index_type::value_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iset__index_1a89b8f8376ee43eabb6171b026c7e7fd7" name="compare_key_type"><type>MapConfig::compare_key_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iset__index_1a50d9b2af1f358a587b246340aa83d0b1" name="index_data_t"><type>value_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iset__index_1a50775fb8faed5fb5b8d160dc0b199a1c"><parameter name=""><paramtype>typename MapConfig::segment_manager_base *</paramtype></parameter><description><para>Constructor. Takes a pointer to the segment manager. Can throw </para></description></constructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iset__index_1ab61ddd9fb1dd9da7e571d5f82a6f1c11" name="reserve"><type>void</type><parameter name=""><paramtype>typename MapConfig::segment_manager_base::size_type</paramtype></parameter><description><para>This reserves memory to optimize the insertion of n elements in the index </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iset__index_1a5193e3b8558dbe4b07d1da11beee1408" name="shrink_to_fit"><type>void</type><purpose>This frees all unnecessary memory. </purpose></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iset__index_1a1690ef84f3e2fdbbc32babfd941c6a93" name="find"><type>iterator</type><parameter name="key"><paramtype>const compare_key_type &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iset__index_1a6277d539cc41bb30b8f6a5821677093a" name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const compare_key_type &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iset__index_1ad218f5c271b89d77a9c0a760804716d2" name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const compare_key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iset__index_1ada1b9e214e63034b302b230b69e27171" name="insert_commit"><type>iterator</type><parameter name=""><paramtype>const compare_key_type &amp;</paramtype></parameter><parameter name=""><paramtype>void *</paramtype></parameter><parameter name="v"><paramtype>index_data_t &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.iunordered__set__index_8hpp" name="boost/interprocess/indexes/iunordered_set_index.hpp">
<para>Describes index adaptor of boost::intrusive::unordered_set container, to use it as name/shared memory index </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index" name="iunordered_set_index"><template>
      <template-type-parameter name="MapConfig"/>
    </template><inherit access="private">iunordered_set_index_aux::allocator_holder</inherit><inherit access="private">iunordered_set_index_aux::index_t</inherit><description><para>Index type based in boost::intrusive::set. Just derives from boost::intrusive::set and defines the interface needed by managed memory segments </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index_1a5fcdc6061c3ed819c4fcc0480ef2dcf8" name="iterator"><type>index_type::iterator</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index_1a001511833fab5928fb76f5d73f11f314" name="const_iterator"><type>index_type::const_iterator</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index_1ac76e337ed8bceb068f1d58e936219fbf" name="insert_commit_data"><type>index_type::insert_commit_data</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index_1ae6cee72938fb181154a7ca201d25d7dd" name="value_type"><type>index_type::value_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index_1a1bea8caa6462272d0b68b00ded86b72f" name="bucket_ptr"><type>index_type::bucket_ptr</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index_1a84ad6e5d7f23be9b9b85605cab42ef83" name="bucket_type"><type>index_type::bucket_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index_1a78cca1519168575c4aab089cc910dbad" name="bucket_traits"><type>index_type::bucket_traits</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index_1ac51995605989087eac7ae13feb9a6b30" name="size_type"><type>index_type::size_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index_1aa29630f63b7a2c6f54ac74df6a80be35" name="difference_type"><type>index_type::difference_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index_1ac7be3db9f9dc5f5b82dbea873f9db536" name="index_data_t"><type>value_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index_1a279f6ff195b326e427f9d916b18c70db"><parameter name="mngr"><paramtype><classname>segment_manager_base</classname> *</paramtype></parameter><description><para>Constructor. Takes a pointer to the segment manager. Can throw </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index_1a49b49c59853cfc1d9d9a4f983894a2e5"/>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index_1acd0113f42a8158e5bb99239049982c87" name="reserve"><type>void</type><parameter name="new_n"><paramtype>size_type</paramtype></parameter><description><para>This reserves memory to optimize the insertion of n elements in the index </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index_1aa4d03204aa9502ccc3fa66395ba0bd46" name="shrink_to_fit"><type>void</type><description><para>This tries to free unused memory previously allocated. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index_1ab5a32657da12237409b251b72a37f3d5" name="find"><type>iterator</type><parameter name="key"><paramtype>const compare_key_type &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index_1a7257f7c32ac84e978ddafc295fa1c0ff" name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const compare_key_type &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index_1a4ec1d80e576f26a655dd7e6dce68e704" name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const compare_key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index_1ae47cb91a307fae21f9f3bedf70bacb16" name="insert_commit"><type>iterator</type><parameter name=""><paramtype>const compare_key_type &amp;</paramtype></parameter><parameter name=""><paramtype>void *</paramtype></parameter><parameter name="val"><paramtype>index_data_t &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.map__index_8hpp" name="boost/interprocess/indexes/map_index.hpp">
<para>Describes index adaptor of boost::map container, to use it as name/shared memory index </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1map__index" name="map_index"><template>
      <template-type-parameter name="MapConfig"/>
    </template><description><para>Index type based in boost::interprocess::map. Just derives from boost::interprocess::map and defines the interface needed by managed memory segments </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1map__index_1a4ef9a4e51d565209db738090692d97d0" name="iterator"><type>base_type::iterator</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1map__index_1aec19d9b99fab9d24192a4760aadfb2e4" name="const_iterator"><type>base_type::const_iterator</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1map__index_1a6bad62009e57775796da69d3352d0d44" name="value_type"><type>base_type::value_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1map__index_1abef08a014280a98fd3300fe6cea30538" name="compare_key_type"><type>MapConfig::compare_key_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1map__index_1a52dbbba404b2ca06dcc749c2fa27bf1f" name="insert_commit_data"><type>iterator</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1map__index_1abc496846d692e4e413d3f881a9a7b356" name="index_data_t"><type>iterator</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1map__index_1a4679eff3401de4bb48b90fe9c042f233"><parameter name="segment_mngr"><paramtype><classname>segment_manager_base</classname> *</paramtype></parameter><description><para>Constructor. Takes a pointer to the segment manager. Can throw </para></description></constructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1map__index_1a670b4d44be84b764d17827f16b720b13" name="reserve"><type>void</type><parameter name=""><paramtype>typename segment_manager_base::size_type</paramtype></parameter><description><para>This reserves memory to optimize the insertion of n elements in the index </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1map__index_1a5194793b20e962cca0b77797506d682f" name="shrink_to_fit"><type>void</type><description><para>This tries to free previously allocate unused memory. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1map__index_1a7927d0771ce2833eb67dae4416d1a95f" name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const compare_key_type &amp;</paramtype></parameter><parameter name=""><paramtype>insert_commit_data &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1map__index_1a02e155e77cc7353efc47560b54dc5b69" name="insert_commit"><type>iterator</type><parameter name="k"><paramtype>const compare_key_type &amp;</paramtype></parameter><parameter name="context"><paramtype>void *</paramtype></parameter><parameter name="index_data"><paramtype>index_data_t &amp;</paramtype></parameter><parameter name=""><paramtype>insert_commit_data &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1map__index_1ae7d199fc28ff94f79ab8fa623189c1f6" name="find"><type>iterator</type><parameter name="k"><paramtype>const compare_key_type &amp;</paramtype></parameter></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.null__index_8hpp" name="boost/interprocess/indexes/null_index.hpp">
<para>Describes a null index adaptor, so that if we don't want to construct named objects, we can use this null index type to save resources. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__index" name="null_index"><template>
      <template-type-parameter name="MapConfig"/>
    </template><description><para>Null index type used to save compilation time when named indexes are not needed. </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__index_1ad300213ff499e6ae2173e8104bb8de65" name="iterator"><type>int *</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__index_1ac2ef4acb82663ebd91e1e6df04006db2" name="const_iterator"><type>const int *</type></typedef>
<method-group name="public member functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__index_1a60f163a71d24ceea378d9826ad5fe1a7" name="begin" cv="const"><type>const_iterator</type><description><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__index_1aa54bab9444b53b22959a4779943c3288">begin()</link> is equal to <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__index_1a1af04a2e58cd0a1fd5ff4e4c518efd44">end()</link> </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__index_1aa54bab9444b53b22959a4779943c3288" name="begin"><type>iterator</type><description><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__index_1aa54bab9444b53b22959a4779943c3288">begin()</link> is equal to <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__index_1a1af04a2e58cd0a1fd5ff4e4c518efd44">end()</link> </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__index_1a7b3f9014486ae6fb7c55a5bc8da42e4a" name="end" cv="const"><type>const_iterator</type><description><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__index_1aa54bab9444b53b22959a4779943c3288">begin()</link> is equal to <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__index_1a1af04a2e58cd0a1fd5ff4e4c518efd44">end()</link> </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__index_1a1af04a2e58cd0a1fd5ff4e4c518efd44" name="end"><type>iterator</type><description><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__index_1aa54bab9444b53b22959a4779943c3288">begin()</link> is equal to <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__index_1a1af04a2e58cd0a1fd5ff4e4c518efd44">end()</link> </para></description></method>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__index_1a760210717d0b0484fd2f862a83f271b3"><parameter name=""><paramtype><classname>segment_manager_base</classname> *</paramtype></parameter><purpose>Empty constructor. </purpose></constructor>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.interprocess__fwd_8hpp" name="boost/interprocess/interprocess_fwd.hpp">
<para>This header file forward declares the basic interprocess types:<itemizedlist>
<listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">boost::interprocess::offset_ptr</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1permissions">boost::interprocess::permissions</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region">boost::interprocess::mapped_region</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__mapping">boost::interprocess::file_mapping</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object">boost::interprocess::shared_memory_object</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory">boost::interprocess::windows_shared_memory</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__shared__memory">boost::interprocess::xsi_shared_memory</link>;</para>
</listitem></itemizedlist>
</para><para>The following synchronization mechanisms and locks:<itemizedlist>
<listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex">boost::interprocess::null_mutex</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex">boost::interprocess::interprocess_mutex</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__recursive__mutex">boost::interprocess::interprocess_recursive_mutex</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore">boost::interprocess::interprocess_semaphore</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex">boost::interprocess::named_mutex</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex">boost::interprocess::named_recursive_mutex</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__semaphore">boost::interprocess::named_semaphore</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex">boost::interprocess::interprocess_sharable_mutex</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition">boost::interprocess::interprocess_condition</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">boost::interprocess::scoped_lock</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">boost::interprocess::sharable_lock</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">boost::interprocess::upgradable_lock</link>;</para>
</listitem></itemizedlist>
</para><para>The following mutex families:<itemizedlist>
<listitem><para><link linkend="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1mutex__family">boost::interprocess::mutex_family</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1null__mutex__family">boost::interprocess::null_mutex_family</link>;</para>
</listitem></itemizedlist>
</para><para>The following allocators:<itemizedlist>
<listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator">boost::interprocess::allocator</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1node__allocator">boost::interprocess::node_allocator</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__node__allocator">boost::interprocess::private_node_allocator</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__node__allocator">boost::interprocess::cached_node_allocator</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1adaptive__pool">boost::interprocess::adaptive_pool</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1private__adaptive__pool">boost::interprocess::private_adaptive_pool</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1cached__adaptive__pool">boost::interprocess::cached_adaptive_pool</link>;</para>
</listitem></itemizedlist>
</para><para>The following allocation algorithms:<itemizedlist>
<listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1simple__seq__fit">boost::interprocess::simple_seq_fit</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit">boost::interprocess::rbtree_best_fit</link>;</para>
</listitem></itemizedlist>
</para><para>The following index types:<itemizedlist>
<listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1flat__map__index">boost::interprocess::flat_map_index</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iset__index">boost::interprocess::iset_index</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1iunordered__set__index">boost::interprocess::iunordered_set_index</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1map__index">boost::interprocess::map_index</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__index">boost::interprocess::null_index</link>;</para>
</listitem><listitem><para>boost::interprocess::unordered_map_index;</para>
</listitem></itemizedlist>
</para><para>The following managed memory types:<itemizedlist>
<listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager">boost::interprocess::segment_manager</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__external__buffer">boost::interprocess::basic_managed_external_buffer</link></para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.managed__external__buffer_8hpp_1af847c2a3013bb979840d52e42e04920c">boost::interprocess::managed_external_buffer</link></para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.managed__external__buffer_8hpp_1a44bcef480cc2f8cfca738e1fc1cfeb94">boost::interprocess::wmanaged_external_buffer</link></para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory">boost::interprocess::basic_managed_shared_memory</link></para>
</listitem><listitem><para>boost::interprocess::managed_shared_memory</para>
</listitem><listitem><para>boost::interprocess::wmanaged_shared_memory</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory">boost::interprocess::basic_managed_windows_shared_memory</link></para>
</listitem><listitem><para>boost::interprocess::managed_windows_shared_memory</para>
</listitem><listitem><para>boost::interprocess::wmanaged_windows_shared_memory</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__xsi__shared__memory">boost::interprocess::basic_managed_xsi_shared_memory</link></para>
</listitem><listitem><para>boost::interprocess::managed_xsi_shared_memory</para>
</listitem><listitem><para>boost::interprocess::wmanaged_xsi_shared_memory</para>
</listitem><listitem><para>boost::interprocess::fixed_managed_shared_memory</para>
</listitem><listitem><para>boost::interprocess::wfixed_managed_shared_memory</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__heap__memory">boost::interprocess::basic_managed_heap_memory</link></para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.managed__heap__memory_8hpp_1ad848dfe9b9f24d012e3cef54e45b0fab">boost::interprocess::managed_heap_memory</link></para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.managed__heap__memory_8hpp_1a88f79e25afba1cc358d5db50435dc58d">boost::interprocess::wmanaged_heap_memory</link></para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file">boost::interprocess::basic_managed_mapped_file</link></para>
</listitem><listitem><para>boost::interprocess::managed_mapped_file</para>
</listitem><listitem><para>boost::interprocess::wmanaged_mapped_file</para>
</listitem></itemizedlist>
</para><para>The following exception types:<itemizedlist>
<listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">boost::interprocess::interprocess_exception</link></para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1lock__exception">boost::interprocess::lock_exception</link></para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link></para>
</listitem></itemizedlist>
</para><para>The following stream types:<itemizedlist>
<listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferbuf">boost::interprocess::basic_bufferbuf</link></para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ibufferstream">boost::interprocess::basic_ibufferstream</link></para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__obufferstream">boost::interprocess::basic_obufferstream</link></para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferstream">boost::interprocess::basic_bufferstream</link></para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorbuf">boost::interprocess::basic_vectorbuf</link></para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ivectorstream">boost::interprocess::basic_ivectorstream</link></para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ovectorstream">boost::interprocess::basic_ovectorstream</link></para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorstream">boost::interprocess::basic_vectorstream</link></para>
</listitem></itemizedlist>
</para><para>The following smart pointer types:<itemizedlist>
<listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr">boost::interprocess::scoped_ptr</link></para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr">boost::interprocess::intrusive_ptr</link></para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">boost::interprocess::shared_ptr</link></para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr">boost::interprocess::weak_ptr</link></para>
</listitem></itemizedlist>
</para><para>The following interprocess communication types:<itemizedlist>
<listitem><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t">boost::interprocess::message_queue_t</link>;</para>
</listitem><listitem><para><link linkend="doxygen.boost_interprocess_header_reference.message__queue_8hpp_1a0d9116f62e6408d68a78a63dcb46c0e3">boost::interprocess::message_queue</link>; </para>
</listitem></itemizedlist>
</para></header>
<header id="doxygen.boost_interprocess_header_reference.interprocess__printers_8hpp" name="boost/interprocess/interprocess_printers.hpp">
</header>
<header id="doxygen.boost_interprocess_header_reference.message__queue_8hpp" name="boost/interprocess/ipc/message_queue.hpp">
<para>Describes an inter-process message queue. This class allows sending messages between processes and allows blocking, non-blocking and timed sending and receiving. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t" name="message_queue_t"><template>
      <template-type-parameter name="VoidPointer"/>
    </template><description><para>A class that allows sending messages between processes. </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1a88e3da2f3db1f368240874079cf7e972" name="void_pointer"><type>VoidPointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1a3b2e912fada5a1e7e0b340294147ec1d" name="char_ptr"><type>boost::intrusive::pointer_traits&lt; void_pointer &gt;::template rebind_pointer&lt; char &gt;::type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1ae696dea48947bd2386e8bff943645a7a" name="difference_type"><type>boost::intrusive::pointer_traits&lt; char_ptr &gt;::difference_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1a9f8fd173002013cce64bda3fc1dbb4a2" name="size_type"><type>boost::container::dtl::make_unsigned&lt; difference_type &gt;::type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1a923bc909ec1284759956b4c1aa354dd1"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="max_num_msg"><paramtype>size_type</paramtype></parameter><parameter name="max_msg_size"><paramtype>size_type</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a process shared message queue with name "name". For this message queue, the maximum number of messages will be "max_num_msg" and the maximum message size will be "max_msg_size". Throws on error and if the queue was previously created. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1a8c8056fd6441815c8af95884fda1d03f"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="max_num_msg"><paramtype>size_type</paramtype></parameter><parameter name="max_msg_size"><paramtype>size_type</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Opens or creates a process shared message queue with name "name". If the queue is created, the maximum number of messages will be "max_num_msg" and the maximum message size will be "max_msg_size". If queue was previously created the queue will be opened and "max_num_msg" and "max_msg_size" parameters are ignored. Throws on error. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1a59c2c2f0e3443f5198e5715b2053f80d"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a previously created process shared message queue with name "name". If the queue was not previously created or there are no free resources, throws an error. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1a27943fba3c50296be161e49a935bd3c0"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="max_num_msg"><paramtype>size_type</paramtype></parameter><parameter name="max_msg_size"><paramtype>size_type</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a process shared message queue with name "name". For this message queue, the maximum number of messages will be "max_num_msg" and the maximum message size will be "max_msg_size". Throws on error and if the queue was previously created.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1a7787e040e7b259f06903e11d5498871d"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="max_num_msg"><paramtype>size_type</paramtype></parameter><parameter name="max_msg_size"><paramtype>size_type</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Opens or creates a process shared message queue with name "name". If the queue is created, the maximum number of messages will be "max_num_msg" and the maximum message size will be "max_msg_size". If queue was previously created the queue will be opened and "max_num_msg" and "max_msg_size" parameters are ignored. Throws on error.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1a6a66c4712b6a43611bfdb4968b0593af"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Opens a previously created process shared message queue with name "name". If the queue was not previously created or there are no free resources, throws an error.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1a69677909e10b8575e85e7050655e1d90"><parameter name="max_num_msg"><paramtype>size_type</paramtype></parameter><parameter name="max_msg_size"><paramtype>size_type</paramtype></parameter><description><para>Creates a process shared message queue in anonymous memory. For this message queue, the maximum number of messages will be "max_num_msg" and the maximum message size will be "max_msg_size". Throws on error. </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1a8f2cb3ceabe32438f4695dc230f19af0"><description><para>Destroys *this and indicates that the calling process is finished using the resource. All opened message queues are still valid after destruction. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the message queue from the system use <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1abcf9f0f5365e77e32539f1b6dd10d5b8">remove()</link>. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1aeb05d832eb75ec9f4d0dd1ea2add24b7" name="send"><type>void</type><parameter name="buffer"><paramtype>const void *</paramtype></parameter><parameter name="buffer_size"><paramtype>size_type</paramtype></parameter><parameter name="priority"><paramtype>unsigned int</paramtype></parameter><description><para>Sends a message stored in buffer "buffer" with size "buffer_size" in the message queue with priority "priority". If the message queue is full the sender is blocked. Throws interprocess_error on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1abb29eed134efc6c574c08480c67bbf73" name="try_send"><type>bool</type><parameter name="buffer"><paramtype>const void *</paramtype></parameter><parameter name="buffer_size"><paramtype>size_type</paramtype></parameter><parameter name="priority"><paramtype>unsigned int</paramtype></parameter><description><para>Sends a message stored in buffer "buffer" with size "buffer_size" through the message queue with priority "priority". If the message queue is full the sender is not blocked and returns false, otherwise returns true. Throws interprocess_error on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1af1c24ffb4a167b49fb007e474fdf07dc" name="timed_send"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="buffer"><paramtype>const void *</paramtype></parameter><parameter name="buffer_size"><paramtype>size_type</paramtype></parameter><parameter name="priority"><paramtype>unsigned int</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Sends a message stored in buffer "buffer" with size "buffer_size" in the message queue with priority "priority". If the message queue is full the sender retries until time "abs_time" is reached. Returns true if the message has been successfully sent. Returns false if timeout is reached. Throws interprocess_error on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1a020363e3fcb14060d23f6e01e96f7fe7" name="receive"><type>void</type><parameter name="buffer"><paramtype>void *</paramtype></parameter><parameter name="buffer_size"><paramtype>size_type</paramtype></parameter><parameter name="recvd_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="priority"><paramtype>unsigned int &amp;</paramtype></parameter><description><para>Receives a message from the message queue. The message is stored in buffer "buffer", which has size "buffer_size". The received message has size "recvd_size" and priority "priority". If the message queue is empty the receiver is blocked. Throws interprocess_error on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1aaccbc7a2b45c892ff272ea4d345413e2" name="try_receive"><type>bool</type><parameter name="buffer"><paramtype>void *</paramtype></parameter><parameter name="buffer_size"><paramtype>size_type</paramtype></parameter><parameter name="recvd_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="priority"><paramtype>unsigned int &amp;</paramtype></parameter><description><para>Receives a message from the message queue. The message is stored in buffer "buffer", which has size "buffer_size". The received message has size "recvd_size" and priority "priority". If the message queue is empty the receiver is not blocked and returns false, otherwise returns true. Throws interprocess_error on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1a7409883ffab39ab861dd68fcd3c42adf" name="timed_receive"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="buffer"><paramtype>void *</paramtype></parameter><parameter name="buffer_size"><paramtype>size_type</paramtype></parameter><parameter name="recvd_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="priority"><paramtype>unsigned int &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Receives a message from the message queue. The message is stored in buffer "buffer", which has size "buffer_size". The received message has size "recvd_size" and priority "priority". If the message queue is empty the receiver retries until time "abs_time" is reached. Returns true if the message has been successfully sent. Returns false if timeout is reached. Throws interprocess_error on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1aab59bd34d5ad39c3ad31b2028eb3cf11" name="get_max_msg" cv="const"><type>size_type</type><description><para>Returns the maximum number of messages allowed by the queue. The message queue must be opened or created previously. Otherwise, returns 0. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1ad63c0faea6de4237bff657f6f9ee0b3f" name="get_max_msg_size" cv="const"><type>size_type</type><description><para>Returns the maximum size of message allowed by the queue. The message queue must be opened or created previously. Otherwise, returns 0. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1a149e2c88fda0f6737d925217522a17af" name="get_num_msg" cv="const"><type>size_type</type><description><para>Returns the number of messages currently stored. Never throws </para></description></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1abcf9f0f5365e77e32539f1b6dd10d5b8" name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Removes the message queue from the system. Returns false on error. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1message__queue__t_1a76810ec57f451360a978f2b0cb10774e" name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Removes the message queue from the system. Returns false on error. Never throws</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class><enum id="doxygen.boost_interprocess_header_reference.message__queue_8hpp_1a12e01c42b6b715f4be0e7d57597440c8" name="mqblock_types"><enumvalue id="doxygen.boost_interprocess_header_reference.message__queue_8hpp_1a12e01c42b6b715f4be0e7d57597440c8a67be0f5007ff99f4d4f8fd8ca0d23132" name="blocking"/><enumvalue id="doxygen.boost_interprocess_header_reference.message__queue_8hpp_1a12e01c42b6b715f4be0e7d57597440c8a443685debcf0ae6fde2849d0ef33a1a8" name="timed"/><enumvalue id="doxygen.boost_interprocess_header_reference.message__queue_8hpp_1a12e01c42b6b715f4be0e7d57597440c8a651711c1731b219a3ee7ed9047437220" name="non_blocking"/></enum>
<typedef id="doxygen.boost_interprocess_header_reference.message__queue_8hpp_1a0d9116f62e6408d68a78a63dcb46c0e3" name="message_queue"><description><para>Typedef for a default message queue to be used between processes </para></description><type><classname>message_queue_t</classname>&lt; <classname>offset_ptr</classname>&lt; void &gt; &gt;</type></typedef>



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.managed__external__buffer_8hpp" name="boost/interprocess/managed_external_buffer.hpp">
<para>Describes a named user memory allocation user class. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__external__buffer" name="basic_managed_external_buffer"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="AllocationAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><description><para>A basic user memory named object creation class. Inherits all basic functionality from basic_managed_memory_impl&lt;CharType, AllocationAlgorithm, IndexType&gt;*<zwj/>/ </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__external__buffer_1a3ce7140c79885a65d978c23726dd2078" name="size_type"><type>base_t::size_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__external__buffer_1a15fc7a4cca86a1801b101de34b688f02" cv="noexcept"><description><para>Default constructor. Does nothing. Useful in combination with move semantics </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__external__buffer_1a68db14ac1e318440b4064bbeeec43895"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="addr"><paramtype>void *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><description><para>Creates and places the segment manager. This can throw The external memory supplied by the user shall be aligned to the maximum value between <computeroutput>alignof(std::max_align_t)</computeroutput> and the strictest alignment of any over-aligned type to be built !inside that memory. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__external__buffer">basic_managed_external_buffer</link> (<link linkend="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1create__only__t">create_only_t</link>, void *addr, size_type size) { Check if alignment is correct BOOST_ASSERT((0 == (((std::size_t)addr) &amp; (AllocationAlgorithm::Alignment - size_type(1u))))); if(!base_t::create_impl(addr, size)){ throw <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link>("Could not initialize buffer in basic_managed_external_buffer constructor"); } }</para><para>!Creates and places the segment manager. This can throw !The external memory supplied by the user shall be aligned to the maximum value between !<computeroutput>alignof(std::max_align_t)</computeroutput> and the strictest alignment of any over-aligned type to be built inside that memory. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__external__buffer_1ad5b5688f356480fb017050fd1868fbb9" cv="noexcept"><parameter name="moved"><paramtype><classname>basic_managed_external_buffer</classname> &amp;&amp;</paramtype></parameter><purpose>Moves the ownership of "moved"'s managed memory to *this. Does not throw. </purpose></constructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__external__buffer_1a56f80e23a991a894063c785d4d0bbafe" cv="noexcept"><type><classname>basic_managed_external_buffer</classname> &amp;</type><parameter name="moved"><paramtype><classname>basic_managed_external_buffer</classname> &amp;&amp;</paramtype></parameter><purpose>Moves the ownership of "moved"'s managed memory to *this. Does not throw. </purpose></copy-assignment>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__external__buffer_1a73a2e1e7e683c12b0ca9ad071d365592" name="grow"><type>void</type><parameter name="extra_bytes"><paramtype>size_type</paramtype></parameter><description><para>Tries to resize internal heap memory so that we have room for more objects. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__external__buffer_1a649a1c4c28c0d82b37fd5f9a5d63f216" name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>basic_managed_external_buffer</classname> &amp;</paramtype></parameter><description><para>Swaps the ownership of the managed heap memories managed by *this and other. Never throws. </para></description></method>
</method-group>
</class><typedef id="doxygen.boost_interprocess_header_reference.managed__external__buffer_8hpp_1af847c2a3013bb979840d52e42e04920c" name="managed_external_buffer"><description><para>Typedef for a default <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__external__buffer">basic_managed_external_buffer</link> of narrow characters </para></description><type><classname>basic_managed_external_buffer</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>null_mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.managed__external__buffer_8hpp_1a44bcef480cc2f8cfca738e1fc1cfeb94" name="wmanaged_external_buffer"><description><para>Typedef for a default <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__external__buffer">basic_managed_external_buffer</link> of wide characters </para></description><type><classname>basic_managed_external_buffer</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>null_mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.managed__heap__memory_8hpp" name="boost/interprocess/managed_heap_memory.hpp">
<para>Describes a named heap memory allocation user class. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__heap__memory" name="basic_managed_heap_memory"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="AllocationAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><description><para>A basic heap memory named object creation class. Initializes the heap memory segment. Inherits all basic functionality from basic_managed_memory_impl&lt;CharType, AllocationAlgorithm, IndexType&gt;*<zwj/>/ </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__heap__memory_1a8744ca9768aff7d1587a957877737299" name="size_type"><type>base_t::size_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__heap__memory_1a5bc9eae20bee3aee52cce3253a365206" cv="noexcept"><description><para>Default constructor. Does nothing. Useful in combination with move semantics </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__heap__memory_1a10f38acf039200d62ca4b18c9b00c04f"><description><para>Destructor. Liberates the heap memory holding the managed data. Never throws. </para></description></destructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__heap__memory_1a7f61242814305f6fcc494d6ef406eff3"><parameter name="size"><paramtype>size_type</paramtype></parameter><description><para>Creates heap memory and initializes the segment manager. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__heap__memory_1a26ed9b94cd0ea689cb77823d75fb4360" cv="noexcept"><parameter name="moved"><paramtype><classname>basic_managed_heap_memory</classname> &amp;&amp;</paramtype></parameter><purpose>Moves the ownership of "moved"'s managed memory to *this. Does not throw. </purpose></constructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__heap__memory_1ab99eb263b1eb985d3c45e0e7482bfd18" cv="noexcept"><type><classname>basic_managed_heap_memory</classname> &amp;</type><parameter name="moved"><paramtype><classname>basic_managed_heap_memory</classname> &amp;&amp;</paramtype></parameter><purpose>Moves the ownership of "moved"'s managed memory to *this. Does not throw. </purpose></copy-assignment>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__heap__memory_1a4b9164f997bd7650d379a2a289bcdc27" name="grow"><type>bool</type><parameter name="extra_bytes"><paramtype>size_type</paramtype></parameter><description><para>Tries to resize internal heap memory so that we have room for more objects. WARNING: If memory is reallocated, all the objects will be binary-copied to the new buffer. To be able to use this function, all pointers constructed in this buffer must be offset pointers. Otherwise, the result is undefined. Returns true if the growth has been successful, so you will have some extra bytes to allocate new objects. If returns false, the heap allocation has failed. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__heap__memory_1a3dbc4ef4338e47365ce92a0c2672b15e" name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>basic_managed_heap_memory</classname> &amp;</paramtype></parameter><description><para>Swaps the ownership of the managed heap memories managed by *this and other. Never throws. </para></description></method>
</method-group>
</class><typedef id="doxygen.boost_interprocess_header_reference.managed__heap__memory_8hpp_1ad848dfe9b9f24d012e3cef54e45b0fab" name="managed_heap_memory"><description><para>Typedef for a default <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__heap__memory">basic_managed_heap_memory</link> of narrow characters </para></description><type><classname>basic_managed_heap_memory</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>null_mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.managed__heap__memory_8hpp_1a88f79e25afba1cc358d5db50435dc58d" name="wmanaged_heap_memory"><description><para>Typedef for a default <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__heap__memory">basic_managed_heap_memory</link> of wide characters </para></description><type><classname>basic_managed_heap_memory</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>null_mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.managed__mapped__file_8hpp" name="boost/interprocess/managed_mapped_file.hpp">
<namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file" name="basic_managed_mapped_file"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="AllocationAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><description><para>A basic mapped file named object creation class. Initializes the mapped file. Inherits all basic functionality from basic_managed_memory_impl&lt;CharType, AllocationAlgorithm, IndexType&gt; </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1a790af21785a43caf6dee1403b92f965d" name="size_type"><description><para>Unsigned integral type enough to represent the size of a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file">basic_managed_mapped_file</link>. </para></description><type>implementation_defined</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1a20f6e85e850fab43beace4f0366a0661" cv="noexcept"><description><para>Creates mapped file and creates and places the segment manager. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1ac1836fcd14dce99e9edc657020084097"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates mapped file and creates and places the segment manager. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1abb85ee0d4f32946a9f5ae4eef1f9f911"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates mapped file and creates and places the segment manager if segment was not created. If segment was created it connects to the segment. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1a585626edd85318693757a32156370e26"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created mapped file and its segment manager. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1a4bc9657a763428dab51253a19fcddd6e"><parameter name=""><paramtype><classname>open_copy_on_write_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created mapped file and its segment manager in copy_on_write mode. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1a797317c52a6fcece0b5d0ca1eb1cf8bb"><parameter name=""><paramtype><classname>open_read_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created mapped file and its segment manager in read-only mode. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1a85dba7faa899af9972bf5fe927cc9ba9"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates mapped file and creates and places the segment manager. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1a101af5e1d71156a36204384050294a86"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates mapped file and creates and places the segment manager if segment was not created. If segment was created it connects to the segment. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1aeac7e6cc5adca302cb70c7996d98128d"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created mapped file and its segment manager. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1a2450e9df6b914b05c20787e41a129727"><parameter name=""><paramtype><classname>open_copy_on_write_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created mapped file and its segment manager in copy_on_write mode. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1ad558268d3533613a53e56677680852d1"><parameter name=""><paramtype><classname>open_read_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created mapped file and its segment manager in read-only mode. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1a0090e2fb3e1d3060eb16b08e6e7d2bb3" cv="noexcept"><parameter name="moved"><paramtype><classname>basic_managed_mapped_file</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></constructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1af55af01b19b6bda7266fbeebe8a85199" cv="noexcept"><type><classname>basic_managed_mapped_file</classname> &amp;</type><parameter name="moved"><paramtype><classname>basic_managed_mapped_file</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></copy-assignment>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1a1d29c31fa0708c410bf63421955e62f3"><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1af11240748cce900f06155d1253a62975" name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>basic_managed_mapped_file</classname> &amp;</paramtype></parameter><description><para>Swaps the ownership of the managed mapped memories managed by *this and other. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1ab509822f0fd06e9be89beba80f4e0795" name="flush"><type>bool</type><description><para>Flushes cached data to file. Never throws </para></description></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1a9bfe451d8a62c2e2ee1da4129d571236" name="grow" specifiers="static"><type>bool</type><parameter name="filename"><paramtype>const char *</paramtype></parameter><parameter name="extra_bytes"><paramtype>size_type</paramtype></parameter><description><para>Tries to resize mapped file so that we have room for more objects.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file</para><para>Since the memory will be remapped after the underlying file is grown, it can't work with segments using raw pointers. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1a2ceee03407c61aabeb924db009a26e65" name="shrink_to_fit" specifiers="static"><type>bool</type><parameter name="filename"><paramtype>const char *</paramtype></parameter><description><para>Tries to resize mapped file to minimized the size of the file.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1a9110611b8cb6e4b806cbe206256ebe63" name="grow" specifiers="static"><type>bool</type><parameter name="filename"><paramtype>const wchar_t *</paramtype></parameter><parameter name="extra_bytes"><paramtype>size_type</paramtype></parameter><description><para>Tries to resize mapped file so that we have room for more objects.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file_1a9a3895e6ce438b45404fddc3adac4284" name="shrink_to_fit" specifiers="static"><type>bool</type><parameter name="filename"><paramtype>const wchar_t *</paramtype></parameter><description><para>Tries to resize mapped file to minimized the size of the file.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class><typedef id="doxygen.boost_interprocess_header_reference.managed__mapped__file_8hpp_1a0d4da159703df101158c50948bb69156" name="managed_mapped_file"><description><para>Typedef for a default <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file">basic_managed_mapped_file</link> of narrow characters </para></description><type><classname>basic_managed_mapped_file</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.managed__mapped__file_8hpp_1af03e245176329886c6d448d5146b6f90" name="wmanaged_mapped_file"><description><para>Typedef for a default <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__mapped__file">basic_managed_mapped_file</link> of wide characters </para></description><type><classname>basic_managed_mapped_file</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.managed__shared__memory_8hpp" name="boost/interprocess/managed_shared_memory.hpp">
<namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory" name="basic_managed_shared_memory"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="AllocationAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><description><para>A basic shared memory named object creation class. Initializes the shared memory segment. Inherits all basic functionality from basic_managed_memory_impl&lt;CharType, AllocationAlgorithm, IndexType&gt;*<zwj/>/ </para></description><method-group name="public member functions">
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1a12f9bdf4b79c70e01c2df09a5a94eaf4"><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1ab06e47452dfa8c745913b90e39b41100"><description><para>Default constructor. Does nothing. Useful in combination with move semantics </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1aab0d49fcefb76d9f459824ac9f43ad72"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates shared memory and creates and places the segment manager. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1afa3ed045443a89b562f781c8c1634e1f"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates shared memory and creates and places the segment manager if segment was not created. If segment was created it connects to the segment. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1a57266afee1ad53f7f0c455d1ef67aa16"><parameter name=""><paramtype><classname>open_copy_on_write_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. in copy_on_write mode. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1adc3af63ac8448339cf081448cd5a026a"><parameter name=""><paramtype><classname>open_read_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. in read-only mode. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1a9ea08c9c14fa8eaa1b6eaf39acb72af0"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1a915e4d2ab92acfd4f8d1ed40889891ee"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates shared memory and creates and places the segment manager. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1ae02ce4fe5256784206b7952cd38a899c"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates shared memory and creates and places the segment manager if segment was not created. If segment was created it connects to the segment. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1ad0f6e1c9d1b19fa9837332ee0d49bf7f"><parameter name=""><paramtype><classname>open_copy_on_write_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. in copy_on_write mode. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1abecf1426f5d0e15faf6d1852d93f2d35"><parameter name=""><paramtype><classname>open_read_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. in read-only mode. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1a351ec16987a5851e60efa5daf076ab22"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1a051f9c14941723398625b765e00d698c"><parameter name="moved"><paramtype><classname>basic_managed_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></constructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1a7cfb836b90c4de35e06a2bd8d063ef7d"><type><classname>basic_managed_shared_memory</classname> &amp;</type><parameter name="moved"><paramtype><classname>basic_managed_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></copy-assignment>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1a67df3f38d7081cefb5e575e3bbc91684" name="swap"><type>void</type><parameter name="other"><paramtype><classname>basic_managed_shared_memory</classname> &amp;</paramtype></parameter><description><para>Swaps the ownership of the managed shared memories managed by *this and other. Never throws. </para></description></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1ad3e0b6c7819b3327ec1e7534f545da3d" name="grow" specifiers="static"><type>bool</type><parameter name="shmname"><paramtype>const char *</paramtype></parameter><parameter name="extra_bytes"><paramtype>size_type</paramtype></parameter><description><para>Tries to resize the managed shared memory object so that we have room for more objects.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file</para><para>Since the memory will be remapped after the underlying shared memory is grown, it can't work with segments using raw pointers. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1a1d425955e206ad6b4c1e7db5228382e3" name="shrink_to_fit" specifiers="static"><type>bool</type><parameter name="shmname"><paramtype>const char *</paramtype></parameter><description><para>Tries to resize the managed shared memory to minimized the size of the file.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1a9bdac3127328a5cf49b7a96e43522cd5" name="grow" specifiers="static"><type>bool</type><parameter name="shmname"><paramtype>const wchar_t *</paramtype></parameter><parameter name="extra_bytes"><paramtype>size_type</paramtype></parameter><description><para>Tries to resize the managed shared memory object so that we have room for more objects.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory_1a3a407c4e736d7caf8389a736e13b5110" name="shrink_to_fit" specifiers="static"><type>bool</type><parameter name="shmname"><paramtype>const wchar_t *</paramtype></parameter><description><para>Tries to resize the managed shared memory to minimized the size of the file.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class><typedef id="doxygen.boost_interprocess_header_reference.managed__shared__memory_8hpp_1a49fc68e77e17ab77d91f1005c99023d9" name="managed_shared_memory"><description><para>Typedef for a default <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory">basic_managed_shared_memory</link> of narrow characters </para></description><type><classname>basic_managed_shared_memory</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.managed__shared__memory_8hpp_1a4295f5c3e394b5c2473f94b637e72cec" name="wmanaged_shared_memory"><description><para>Typedef for a default <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory">basic_managed_shared_memory</link> of wide characters </para></description><type><classname>basic_managed_shared_memory</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.managed__shared__memory_8hpp_1a00c26692ef234a4f0fcfd331cf57ad2c" name="fixed_managed_shared_memory"><description><para>Typedef for a default <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory">basic_managed_shared_memory</link> of narrow characters to be placed in a fixed address </para></description><type><classname>basic_managed_shared_memory</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname>, void * &gt;,<classname>iset_index</classname> &gt;</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.managed__shared__memory_8hpp_1ae5933d2665a1d5262a2d5e82af719484" name="wfixed_managed_shared_memory"><description><para>Typedef for a default <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory">basic_managed_shared_memory</link> of narrow characters to be placed in a fixed address </para></description><type><classname>basic_managed_shared_memory</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname>, void * &gt;,<classname>iset_index</classname> &gt;</type></typedef>



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.managed__windows__shared__memory_8hpp" name="boost/interprocess/managed_windows_shared_memory.hpp">
<namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory" name="basic_managed_windows_shared_memory"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="AllocationAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><description><para>A basic managed windows shared memory creation class. Initializes the shared memory segment. Inherits all basic functionality from basic_managed_memory_impl&lt;CharType, AllocationAlgorithm, IndexType&gt; Unlike <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory">basic_managed_shared_memory</link>, it has no kernel persistence and the shared memory is destroyed when all processes destroy all their <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory">windows_shared_memory</link> objects and mapped regions for the same shared memory or the processes end/crash.</para><para>Warning: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory">basic_managed_windows_shared_memory</link> and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__shared__memory">basic_managed_shared_memory</link> can't communicate between them. </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory_1a2e65ce2c361fb2c424fbb92bfe6b84b4" name="size_type"><type>base_t::size_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory_1a3f96eafc51b12e32b1fb3f2588d4b43e" cv="noexcept"><description><para>Default constructor. Does nothing. Useful in combination with move semantics </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory_1aa035f2c1e8b020d36be9272f27918235"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates shared memory and creates and places the segment manager. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory_1af91418492c65a7d397825cc951ce8f16"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates shared memory and creates and places the segment manager if segment was not created. If segment was created it connects to the segment. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory_1a8f12e15c9284db69a891d85102b126c9"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory_1a0d09c0f923f37947b4c6cfe32e7765bc"><parameter name=""><paramtype><classname>open_copy_on_write_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager in copy_on_write mode. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory_1acf9150a14ab3f51e7e7e6049e7937be4"><parameter name=""><paramtype><classname>open_read_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager in read-only mode. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory_1a77cb2c971b165091edfbe7c779b68f65"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates shared memory and creates and places the segment manager if segment was not created. If segment was created it connects to the segment. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory_1aa24ccc6db70b832694663fead73f2248"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory_1afbcf4b2238f7845b085350495196d5fc"><parameter name=""><paramtype><classname>open_copy_on_write_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager in copy_on_write mode. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory_1a72ea26d485a9cfb94385abf4a73fba08"><parameter name=""><paramtype><classname>open_read_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager in read-only mode. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory_1aa73ddbbed344e678806309e4284d4829" cv="noexcept"><parameter name="moved"><paramtype><classname>basic_managed_windows_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></constructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory_1a5d845c5662e7f615b171dcd0f1181e20" cv="noexcept"><type><classname>basic_managed_windows_shared_memory</classname> &amp;</type><parameter name="moved"><paramtype><classname>basic_managed_windows_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></copy-assignment>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory_1aab772f59ff0bca13926dbe7f357a6edd"><description><para>Destroys *this and indicates that the calling process is finished using the resource. All mapped regions are still valid after destruction. When all mapped regions and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory">basic_managed_windows_shared_memory</link> objects referring the shared memory are destroyed, the operating system will destroy the shared memory. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory_1ae8d5f9dcf849a0c774db22af1a45f60c" name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>basic_managed_windows_shared_memory</classname> &amp;</paramtype></parameter><description><para>Swaps the ownership of the managed mapped memories managed by *this and other. Never throws. </para></description></method>
</method-group>
</class><typedef id="doxygen.boost_interprocess_header_reference.managed__windows__shared__memory_8hpp_1a2bac2a81da906e3c32623022c3a5b1aa" name="managed_windows_shared_memory"><description><para>Typedef for a default <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory">basic_managed_windows_shared_memory</link> of narrow characters </para></description><type><classname>basic_managed_windows_shared_memory</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.managed__windows__shared__memory_8hpp_1a44077de0663d8c7d1c99d80deb0bbb8d" name="wmanaged_windows_shared_memory"><description><para>Typedef for a default <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__windows__shared__memory">basic_managed_windows_shared_memory</link> of wide characters </para></description><type><classname>basic_managed_windows_shared_memory</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.managed__xsi__shared__memory_8hpp" name="boost/interprocess/managed_xsi_shared_memory.hpp">
<namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__xsi__shared__memory" name="basic_managed_xsi_shared_memory"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="AllocationAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><description><para>A basic X/Open System Interface (XSI) shared memory named object creation class. Initializes the shared memory segment. Inherits all basic functionality from basic_managed_memory_impl&lt;CharType, AllocationAlgorithm, IndexType&gt; </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__xsi__shared__memory_1a41dd6f3c41e0827eb9278512050a1b98" name="size_type"><type>base_t::size_type</type></typedef>
<method-group name="public member functions">
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__xsi__shared__memory_1a0a5aa3f31f9e49e1733e7c6368f6d2f3"><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__xsi__shared__memory_1aa515ecb1c73a9764079691ff35bf05a0">remove()</link>. </para></description></destructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__xsi__shared__memory_1a5a64bfbf02792bc61f9e97f0338b4d40" cv="noexcept"><description><para>Default constructor. Does nothing. Useful in combination with move semantics </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__xsi__shared__memory_1a315b54e5e1aac7f30934d40cee4e3042"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="key"><paramtype>const <classname>xsi_key</classname> &amp;</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates shared memory and creates and places the segment manager. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__xsi__shared__memory_1a3a9b2d0d93a47f47470ddd7e093192ac"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="key"><paramtype>const <classname>xsi_key</classname> &amp;</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates shared memory and creates and places the segment manager if segment was not created. If segment was created it connects to the segment. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__xsi__shared__memory_1a31ff869447c0df9a97ac46406465b7e0"><parameter name=""><paramtype><classname>open_read_only_t</classname></paramtype></parameter><parameter name="key"><paramtype>const <classname>xsi_key</classname> &amp;</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. in read-only mode. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__xsi__shared__memory_1a21f4621e7c24f6189b18919d0221f58f"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="key"><paramtype>const <classname>xsi_key</classname> &amp;</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. This can throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__xsi__shared__memory_1af0b35a45bfbf3721f263de7170ec2452" cv="noexcept"><parameter name="moved"><paramtype><classname>basic_managed_xsi_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></constructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__xsi__shared__memory_1a8e5c94ff6db42511bb80b169e8545e33" cv="noexcept"><type><classname>basic_managed_xsi_shared_memory</classname> &amp;</type><parameter name="moved"><paramtype><classname>basic_managed_xsi_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></copy-assignment>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__xsi__shared__memory_1ad72ece26950104cf3fb37cb2f31982d9" name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>basic_managed_xsi_shared_memory</classname> &amp;</paramtype></parameter><description><para>Swaps the ownership of the managed shared memories managed by *this and other. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__xsi__shared__memory_1adb31ef005eb6b76b3a011b561f1cf786" name="get_shmid" cv="const noexcept"><type>int</type></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__xsi__shared__memory_1aa515ecb1c73a9764079691ff35bf05a0" name="remove" specifiers="static"><type>bool</type><parameter name="shmid"><paramtype>int</paramtype></parameter><description><para>Erases a XSI shared memory object identified by shmid from the system. Returns false on error. Never throws </para></description></method>
</method-group>
</class><typedef id="doxygen.boost_interprocess_header_reference.managed__xsi__shared__memory_8hpp_1a9411fb9c80c0ffa2186b96d7234b6e6e" name="managed_xsi_shared_memory"><description><para>Typedef for a default <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__xsi__shared__memory">basic_managed_xsi_shared_memory</link> of narrow characters </para></description><type><classname>basic_managed_xsi_shared_memory</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.managed__xsi__shared__memory_8hpp_1a5b8298df50ded2181996a6e85b89d0b5" name="wmanaged_xsi_shared_memory"><description><para>Typedef for a default <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__managed__xsi__shared__memory">basic_managed_xsi_shared_memory</link> of wide characters </para></description><type><classname>basic_managed_xsi_shared_memory</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.mapped__region_8hpp" name="boost/interprocess/mapped_region.hpp">
<para>Describes mapped region class </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region" name="mapped_region"><description><para>The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region">mapped_region</link> class represents a portion or region created from a memory_mappable object.</para><para>The OS can map a region bigger than the requested one, as region must be multiple of the page size, but <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region">mapped_region</link> will always refer to the region specified by the user. </para></description><enum id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1ac06a91187a899ed7a7a1644a5b9d8b86" name="advice_types"><enumvalue id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1ac06a91187a899ed7a7a1644a5b9d8b86a296712d72abf56c98248b38a58629099" name="advice_normal"><description><para>Specifies that the application has no advice to give on its behavior with respect to the region. It is the default characteristic if no advice is given for a range of memory. </para></description></enumvalue><enumvalue id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1ac06a91187a899ed7a7a1644a5b9d8b86a401ad311ef9cafa14409715fdec42cec" name="advice_sequential"><description><para>Specifies that the application expects to access the region sequentially from lower addresses to higher addresses. The implementation can lower the priority of preceding pages within the region once a page have been accessed. </para></description></enumvalue><enumvalue id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1ac06a91187a899ed7a7a1644a5b9d8b86a3bdf22026ae990577767e9f525a2b7dd" name="advice_random"><description><para>Specifies that the application expects to access the region in a random order, and prefetching is likely not advantageous. </para></description></enumvalue><enumvalue id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1ac06a91187a899ed7a7a1644a5b9d8b86a6e54b53202012bae81f4eada46270af1" name="advice_willneed"><description><para>Specifies that the application expects to access the region in the near future. The implementation can prefetch pages of the region. </para></description></enumvalue><enumvalue id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1ac06a91187a899ed7a7a1644a5b9d8b86af374ef68eb2294bce8394fb6a58f9d29" name="advice_dontneed"><description><para>Specifies that the application expects that it will not access the region in the near future. The implementation can unload pages within the range to save system resources. </para></description></enumvalue><description><para>This enum specifies region usage behaviors that an application can specify to the mapped region implementation. </para></description></enum>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1aac2794754a315afa857f2504d903c14b"><template>
          <template-type-parameter name="MemoryMappable"/>
        </template><parameter name="mapping"><paramtype>const MemoryMappable &amp;</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="offset"><paramtype>offset_t</paramtype><default>0</default></parameter><parameter name="size"><paramtype>std::size_t</paramtype><default>0</default></parameter><parameter name="address"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="map_options"><paramtype>map_options_t</paramtype><default>default_map_options</default></parameter><description><para>Creates a mapping region of the mapped memory "mapping", starting in offset "offset", and the mapping's size will be "size". The mapping can be opened for read only, read-write or copy-on-write.</para><para>If an address is specified, both the offset and the address must be multiples of the page size.</para><para>The map is created using "default_map_options". This flag is OS dependant and it should not be changed unless the user needs to specify special options.</para><para>In Windows systems "map_options" is a DWORD value passed as "dwDesiredAccess" to "MapViewOfFileEx". If "default_map_options" is passed it's initialized to zero. "map_options" is XORed with FILE_MAP_[COPY|READ|WRITE].</para><para>In UNIX systems and POSIX mappings "map_options" is an int value passed as "flags" to "mmap". If "default_map_options" is specified it's initialized to MAP_NOSYNC if that option exists and to zero otherwise. "map_options" XORed with MAP_PRIVATE or MAP_SHARED.</para><para>In UNIX systems and XSI mappings "map_options" is an int value passed as "shmflg" to "shmat". If "default_map_options" is specified it's initialized to zero. "map_options" is XORed with SHM_RDONLY if needed.</para><para>The OS could allocate more pages than size/page_size(), but <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1aaf0baea459554c319cbf729e217ce280">get_address()</link> will always return the address passed in this function (if not null) and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1a4d03788dcdbbe659eb2c92cb731097b0">get_size()</link> will return the specified size. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1a8a077657043be42295f35e9a232ca975" cv="noexcept"><description><para>Default constructor. Address will be 0 (nullptr). Size will be 0. Does not throw </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1a770edda2502227399ece3b43e86d46cc" cv="noexcept"><parameter name="other"><paramtype><classname>mapped_region</classname> &amp;&amp;</paramtype></parameter><description><para>Move constructor. *this will be constructed taking ownership of "other"'s region and "other" will be left in default constructor state. </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1af1c9923f11f0c266c1c7af43db121b47"><description><para>Destroys the mapped region. Does not throw </para></description></destructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1a1f51ef7970883ab4f4bcca53a6e38aab" cv="noexcept"><type><classname>mapped_region</classname> &amp;</type><parameter name="other"><paramtype><classname>mapped_region</classname> &amp;&amp;</paramtype></parameter><description><para>Move assignment. If *this owns a memory mapped region, it will be destroyed and it will take ownership of "other"'s memory mapped region. </para></description></copy-assignment>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1a2332241806276bb0035385494dfe70de" name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>mapped_region</classname> &amp;</paramtype></parameter><description><para>Swaps the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region">mapped_region</link> with another mapped region </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1a4d03788dcdbbe659eb2c92cb731097b0" name="get_size" cv="const noexcept"><type>std::size_t</type><purpose>Returns the size of the mapping. Never throws. </purpose></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1aaf0baea459554c319cbf729e217ce280" name="get_address" cv="const noexcept"><type>void *</type><description><para>Returns the base address of the mapping. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1a459e5dbedf1c3d2cd9e183a74619bfa4" name="get_mode" cv="const noexcept"><type>mode_t</type><description><para>Returns the mode of the mapping used to construct the mapped region. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1aab10d5ff2e5a9f47a62b55090ccc984f" name="flush"><type>bool</type><parameter name="mapping_offset"><paramtype>std::size_t</paramtype><default>0</default></parameter><parameter name="numbytes"><paramtype>std::size_t</paramtype><default>0</default></parameter><parameter name="async"><paramtype>bool</paramtype><default>true</default></parameter><description><para>Flushes to the disk a byte range within the mapped memory. If 'async' is true, the function will return before flushing operation is completed If 'async' is false, function will return once data has been written into the underlying device (i.e., in mapped files OS cached information is written to disk). Never throws. Returns false if operation could not be performed. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1a295d1b2c97755a74de2d49059d9da544" name="shrink_by"><type>bool</type><parameter name="bytes"><paramtype>std::size_t</paramtype></parameter><parameter name="from_back"><paramtype>bool</paramtype><default>true</default></parameter><description><para>Shrinks current mapped region. If after shrinking there is no longer need for a previously mapped memory page, accessing that page can trigger a segmentation fault. Depending on the OS, this operation might fail (XSI shared memory), it can decommit storage and free a portion of the virtual address space (e.g.POSIX) or this function can release some physical memory without freeing any virtual address space(Windows). Returns true on success. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1ad721b43b75349de6bbf1fff384706ff2" name="advise"><type>bool</type><parameter name="advise"><paramtype>advice_types</paramtype></parameter><description><para>Advises the implementation on the expected behavior of the application with respect to the data in the region. The implementation may use this information to optimize handling of the region data. This function has no effect on the semantics of access to memory in the region, although it may affect the performance of access. If the advise type is not known to the implementation, the function returns false. True otherwise. </para></description></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1mapped__region_1aafe23f123fbb55ee52c7e4f826f51452" name="get_page_size" cv="noexcept" specifiers="static"><type>std::size_t</type><description><para>Returns the size of the page. This size is the minimum memory that will be used by the system when mapping a memory mappable source and will restrict the address and the offset to map. </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.rbtree__best__fit_8hpp" name="boost/interprocess/mem_algo/rbtree_best_fit.hpp">
<para>Describes a best-fit algorithm based in an intrusive red-black tree used to allocate objects in shared memory. This class is intended as a base class for single segment and multi-segment implementations. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit" name="rbtree_best_fit"><template>
      <template-type-parameter name="MutexFamily"/>
      <template-type-parameter name="VoidPointer"/>
      <template-nontype-parameter name="MemAlignment"><type>std::size_t</type></template-nontype-parameter>
    </template><description><para>This class implements an algorithm that stores the free nodes in a red-black tree to have logarithmic search/insert times. </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1ac95e2f51119e929e0d70dd1234f58169" name="mutex_family"><purpose>Shared mutex family used for the rest of the Interprocess framework. </purpose><type>MutexFamily</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1a8c267d9d901cea8706f0247141157bba" name="void_pointer"><purpose>Pointer type to be used with the rest of the Interprocess framework. </purpose><type>VoidPointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1a4780902dee380f71781ac774f50ba145" name="multiallocation_chain"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1aecc96ba775d4d8643de134535d7abbf1" name="difference_type"><type>boost::intrusive::pointer_traits&lt; char_ptr &gt;::difference_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1a591b82b08a4b904c362d37c6a37fa439" name="size_type"><type>boost::container::dtl::make_unsigned&lt; difference_type &gt;::type</type></typedef>
<data-member id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1ac20e18713ea6b0aa144108f9f8ee3650" name="PayloadPerAllocation" specifiers="static"><type>const size_type</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1a169fdeeb90eb349dc98a86b96164b230"><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="extra_hdr_bytes"><paramtype>size_type</paramtype></parameter><description><para>Constructor. "size" is the total size of the managed memory segment, "extra_hdr_bytes" indicates the extra bytes beginning in the sizeof(rbtree_best_fit) offset that the allocator should not use at all. </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1abf80e440bd6955a9259ce9d359eae4fc"><purpose>Destructor. </purpose></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1af2b8957eb90c8a891f43b159cf87c246" name="allocate"><type>void *</type><parameter name="nbytes"><paramtype>size_type</paramtype></parameter><description><para>Allocates bytes, returns 0 if there is not more memory. Returned memory is aligned to Alignment bytes. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1a80dae2508733e291ba9f6747c190d83c" name="deallocate"><type>void</type><parameter name="addr"><paramtype>void *</paramtype></parameter><purpose>Deallocates previously allocated bytes. </purpose></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1a91d5575348eb0acf7234c7a69c4b79cc" name="get_size" cv="const"><type>size_type</type><purpose>Returns the size of the memory segment. </purpose></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1a5862e2e88c2277a86b20d2441df99bc4" name="get_free_memory" cv="const"><type>size_type</type><purpose>Returns the number of free bytes of the segment. </purpose></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1a59e20e4fc79cb1c9c549a6237ad18abc" name="zero_free_memory"><type>void</type><description><para>Initializes to zero all the memory that's not in use. This function is normally used for security reasons. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1aebfba195f413f54a6ee907344613a0f2" name="grow"><type>void</type><parameter name="extra_size"><paramtype>size_type</paramtype></parameter><description><para>Increases managed memory in extra_size bytes more </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1a1a37ef364899e98b7520b125d27a04e8" name="shrink_to_fit"><type>void</type><purpose>Decreases managed memory as much as possible. </purpose></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1a47dfda91bd69963009f5e557db063184" name="all_memory_deallocated"><type>bool</type><purpose>Returns true if all allocated memory has been deallocated. </purpose></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1aea36f952d3106f51f9694f454f9c96ed" name="check_sanity"><type>bool</type><description><para>Makes an internal sanity check and returns true if success </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1a3bc059116b5dc3636f5dd956b3699553" name="size" cv="const"><type>size_type</type><parameter name="ptr"><paramtype>const void *</paramtype></parameter><purpose>Returns the size of the buffer previously allocated pointed by ptr. </purpose></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1a28d48105c94ee852d291209e55949131" name="allocate_aligned"><type>void *</type><parameter name="nbytes"><paramtype>size_type</paramtype></parameter><parameter name="alignment"><paramtype>size_type</paramtype></parameter><description><para>Allocates aligned bytes, returns 0 if there is not more memory. Alignment must be power of 2 </para></description></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1rbtree__best__fit_1aa6573d2d29aebc5ef100a45930fe1aed" name="get_min_size" specifiers="static"><type>size_type</type><parameter name="extra_hdr_bytes"><paramtype>size_type</paramtype></parameter><purpose>Obtains the minimum size needed by the algorithm. </purpose></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.simple__seq__fit_8hpp" name="boost/interprocess/mem_algo/simple_seq_fit.hpp">
<para>Describes sequential fit algorithm used to allocate objects in shared memory. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1simple__seq__fit" name="simple_seq_fit"><template>
      <template-type-parameter name="MutexFamily"/>
      <template-type-parameter name="VoidPointer"/>
    </template><description><para>This class implements the simple sequential fit algorithm with a simply linked list of free buffers. </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1simple__seq__fit_1ac8753be77808deb2e3216deba1a10c59" name="size_type"><type>base_t::size_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1simple__seq__fit_1ab77ff5b2373262dca37a2eef3bda120a"><parameter name="segment_size"><paramtype>size_type</paramtype></parameter><parameter name="extra_hdr_bytes"><paramtype>size_type</paramtype></parameter><description><para>Constructor. "size" is the total size of the managed memory segment, "extra_hdr_bytes" indicates the extra bytes beginning in the sizeof(simple_seq_fit) offset that the allocator should not use at all.*<zwj/>/ </para></description></constructor>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.offset__ptr_8hpp" name="boost/interprocess/offset_ptr.hpp">
<para>Describes a smart pointer that stores the offset between this pointer and target pointee, called offset_ptr. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr" name="offset_ptr"><template>
      <template-type-parameter name="PointedType"><purpose><para>The type of the pointee. </para></purpose></template-type-parameter>
      <template-type-parameter name="DifferenceType"><purpose><para>A signed integer type that can represent the arithmetic operations on the pointer </para></purpose></template-type-parameter>
      <template-type-parameter name="OffsetType"><purpose><para>An unsigned integer type that can represent the distance between two pointers reinterpret_cast-ed as unsigned integers. This type should be at least of the same size of std::uintptr_t. In some systems it's possible to communicate between 32 and 64 bit processes using 64 bit offsets. </para></purpose></template-type-parameter>
      <template-nontype-parameter name="OffsetAlignment"><type>std::size_t</type><purpose><para>Alignment of the OffsetType stored inside. In some systems might be necessary to align it to 64 bits in order to communicate 32 and 64 bit processes using 64 bit offsets.</para></purpose></template-nontype-parameter>
    </template><description><para>A smart pointer that stores the offset between the pointer and the object it points to. This allows special properties, since the pointer is independent from the address of the pointee, if the pointer and the pointee are still separated by the same offset. This feature converts <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">offset_ptr</link> in a smart pointer that can be placed in shared memory and memory mapped files mapped at different addresses in every process.</para><para>
b&gt;Note: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">offset_ptr</link> uses implementation defined properties, present in most platforms, for performance reasons:<itemizedlist>
<listitem><para>Assumes that OffsetType representation of nullptr is (OffsetType)zero.</para>
</listitem><listitem><para>Assumes that incrementing a OffsetType obtained from a pointer is equivalent to incrementing the pointer and then converting it back to OffsetType. </para>
</listitem></itemizedlist>
</para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1abc9a7c2853c121309c33bfbf36fbb87a" name="element_type"><type>PointedType</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1a5bb54b11b9cacb3826c4f02e48423c81" name="pointer"><type>PointedType *</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1ab9d2c86f7da2025f7e945559bd93a950" name="reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1aee0a9e2e50ebcfa18a61de2368c4e6bb" name="value_type"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1afe913dd3e00f993b8066e2f87414a9a3" name="difference_type"><type>DifferenceType</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1a13ba4120b9eb2f3aca82c3960539b93c" name="iterator_category"><type>std::random_access_iterator_tag</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1a51a83e04e111254d6665bfb763237bcb" name="offset_type"><type>OffsetType</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1a9749a8bdf100034bb4750d38bbaf5da6" name="rebind"><description><para>Compatibility with pointer_traits </para></description><type><classname>offset_ptr</classname>&lt; U, DifferenceType, OffsetType, OffsetAlignment &gt;</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1ab34ae7e6027112173fa5f54d4b8e7037" cv="noexcept"><description><para>Default constructor (null pointer). Never throws. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1ae12a483fddd8eaa35167e9c5ad2083c1" cv="noexcept"><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><description><para>Constructor from nullptr. Never throws. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1adb6f8d7ea5749c0dc9b1c66bcb181732" cv="noexcept"><template>
          <template-type-parameter name="T"/>
        </template><parameter name="ptr"><paramtype>T *</paramtype></parameter><description><para>Constructor from raw pointer. Only takes part in overload resolution if T* is convertible to PointedType* Never throws. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1ae7559fd69782a717c0093b1eb74abe59" cv="noexcept"><parameter name="ptr"><paramtype>const <classname>offset_ptr</classname> &amp;</paramtype></parameter><description><para>Constructor from other <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">offset_ptr</link>. Never throws. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1a4409dc4cc63fbb5d71d92b219cdcf3e4" cv="noexcept"><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="ptr"><paramtype>const <classname>offset_ptr</classname>&lt; T2, DifferenceType, OffsetType, OffsetAlignment &gt; &amp;</paramtype></parameter><description><para>Constructor from other <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">offset_ptr</link>. Only takes part in overload resolution if T2* is convertible to PointedType*. Never throws. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1af4154b1f8ad527bc86b7b48ab29b06c7" cv="noexcept"><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="P2"/>
          <template-type-parameter name="O2"/>
          <template-nontype-parameter name="A2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="r"><paramtype>const <classname>offset_ptr</classname>&lt; T2, P2, O2, A2 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Emulates static_cast operator. Never throws. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1a9f92aeacb8fd9e26b3c862f995460046" cv="noexcept"><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="P2"/>
          <template-type-parameter name="O2"/>
          <template-nontype-parameter name="A2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="r"><paramtype>const <classname>offset_ptr</classname>&lt; T2, P2, O2, A2 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Emulates const_cast operator. Never throws. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1a32af9eb53e76c33a56442fa76e1f6866" cv="noexcept"><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="P2"/>
          <template-type-parameter name="O2"/>
          <template-nontype-parameter name="A2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="r"><paramtype>const <classname>offset_ptr</classname>&lt; T2, P2, O2, A2 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Emulates dynamic_cast operator. Never throws. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1ab2685bb21889b35631e4c970f16508da" cv="noexcept"><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="P2"/>
          <template-type-parameter name="O2"/>
          <template-nontype-parameter name="A2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="r"><paramtype>const <classname>offset_ptr</classname>&lt; T2, P2, O2, A2 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Emulates reinterpret_cast operator. Never throws. </para></description></constructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1ad94dd2687c38de0dfcd10561d9909d1b" name="get" cv="const noexcept"><type>pointer</type><description><para>Obtains raw pointer from offset. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1abb56066c2cec5ad587e3a52bed62f6c7" name="get_offset" cv="const noexcept"><type>offset_type</type></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1afc9b40ea7877bb831d98a7af40ae5c05" name="operator-&gt;" cv="const noexcept"><type>pointer</type><description><para>Pointer-like -&gt; operator. It can return 0 pointer. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1aab4cf5362bdd13dc5297f8b8bf04ca2c" name="operator*" cv="const noexcept"><type>reference</type><description><para>Dereferencing operator, if it is a null <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">offset_ptr</link> behavior is undefined. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1ac1c69586c71ee8ce46d0513e386e6dc2" name="operator[]" cv="const noexcept"><type>reference</type><parameter name="idx"><paramtype>difference_type</paramtype></parameter><description><para>Indexing operator. Never throws. </para></description></method>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1ab6c597d8651de8d34e839fa7773c2e40" cv="noexcept"><type><classname>offset_ptr</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="ptr"><paramtype>T *</paramtype></parameter><description><para>Assignment from raw pointer. Only takes part in overload resolution if T* is convertible to PointedType* Never throws. </para></description></copy-assignment>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1ab0ccf11dd4a71f98d653023905b65a5d" cv="noexcept"><type><classname>offset_ptr</classname> &amp;</type><parameter name="ptr"><paramtype>const <classname>offset_ptr</classname> &amp;</paramtype></parameter><description><para>Assignment from other <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">offset_ptr</link>. Never throws. </para></description></copy-assignment>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1a8870f81678bde10cd0fbe29631ac318a" cv="noexcept"><type><classname>offset_ptr</classname> &amp;</type><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><description><para>Assignment from nullptr. Never throws. </para></description></copy-assignment>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1a2716139b15791a7b2a6054598976a327" cv="noexcept"><type><classname>offset_ptr</classname> &amp;</type><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="ptr"><paramtype>const <classname>offset_ptr</classname>&lt; T2, DifferenceType, OffsetType, OffsetAlignment &gt; &amp;</paramtype></parameter><description><para>Assignment from related <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">offset_ptr</link>. Only takes part in overload resolution if T2* is convertible to PointedType* Never throws. </para></description></copy-assignment>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1ac4ce34677414e1b6f7e6617fd4e7fd11" name="operator+=" cv="noexcept"><type><classname>offset_ptr</classname> &amp;</type><parameter name="offset"><paramtype>difference_type</paramtype></parameter><description><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">offset_ptr</link> += difference_type. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1aa4efa59c2ee2109e7a0b0661779faf6c" name="operator-=" cv="noexcept"><type><classname>offset_ptr</classname> &amp;</type><parameter name="offset"><paramtype>difference_type</paramtype></parameter><description><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">offset_ptr</link> -= difference_type. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1a3e1063a438c3bca7b7825a636dbb4c5a" name="operator++" cv="noexcept"><type><classname>offset_ptr</classname> &amp;</type><parameter name=""><paramtype>void</paramtype></parameter><description><para>++<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">offset_ptr</link>. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1ada1687269397c838b5c774342b6364ba" name="operator++" cv="noexcept"><type><classname>offset_ptr</classname></type><parameter name=""><paramtype>int</paramtype></parameter><description><para>offset_ptr++. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1a5b2d121328594ef48fd581a35bdc3c45" name="operator--" cv="noexcept"><type><classname>offset_ptr</classname> &amp;</type><parameter name=""><paramtype>void</paramtype></parameter><description><para>–<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">offset_ptr</link>. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1ad6f5bff5180164b2a2f781dfd4d8f61d" name="operator--" cv="noexcept"><type><classname>offset_ptr</classname></type><parameter name=""><paramtype>int</paramtype></parameter><description><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">offset_ptr</link>–. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1a26bc0c260e9023c97de6e6e4ba13ac42" name="conversion-operator" cv="const noexcept" specifiers="explicit"><type>bool</type><description><para>safe bool conversion operator. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1a9ceec210ca236ff27b9c7b940886cb04" name="operator!" cv="const noexcept"><type>bool</type><description><para>Not operator. Not needed in theory, but improves portability. Never throws </para></description></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1a45c57bf4497fd36ff9835f7e72a5699c" name="pointer_to" cv="noexcept" specifiers="static"><type><classname>offset_ptr</classname></type><parameter name="r"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Compatibility with pointer_traits </para></description></method>
</method-group>
<method-group name="friend functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1a0d301becc4bbad56e35de406d388d3de" name="operator+" cv="noexcept"><type><classname>offset_ptr</classname></type><parameter name="diff"><paramtype>difference_type</paramtype></parameter><parameter name="right"><paramtype><classname>offset_ptr</classname></paramtype></parameter><description><para>difference_type + <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">offset_ptr</link> operation </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1ad2d1eaef02a54e6d8c7b36268bb55b98" name="operator+" cv="noexcept"><type><classname>offset_ptr</classname></type><parameter name="left"><paramtype><classname>offset_ptr</classname></paramtype></parameter><parameter name="diff"><paramtype>difference_type</paramtype></parameter><description><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">offset_ptr</link> + difference_type operation </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1ad49058ebe7afe61ce598da1f991c782f" name="operator-" cv="noexcept"><type><classname>offset_ptr</classname></type><parameter name="left"><paramtype><classname>offset_ptr</classname></paramtype></parameter><parameter name="diff"><paramtype>difference_type</paramtype></parameter><description><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">offset_ptr</link> - diff operation </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1a43b9a4a1e49d118e91222018b16fd362" name="operator-" cv="noexcept"><type><classname>offset_ptr</classname></type><parameter name="diff"><paramtype>difference_type</paramtype></parameter><parameter name="right"><paramtype><classname>offset_ptr</classname></paramtype></parameter><description><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">offset_ptr</link> - diff operation </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1a452f048c5a6c38f7fb71aff30ab4c10c" name="operator-" cv="noexcept"><type>difference_type</type><parameter name="pt"><paramtype>const <classname>offset_ptr</classname> &amp;</paramtype></parameter><parameter name="pt2"><paramtype>const <classname>offset_ptr</classname> &amp;</paramtype></parameter><description><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">offset_ptr</link> - <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr">offset_ptr</link> operation </para></description></method>
</method-group>
<method-group name="private member functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1a7b53dcc06e69d65c56eb91faea2b5a48" name="assign" cv="noexcept"><type>void</type><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="ptr"><paramtype>const <classname>offset_ptr</classname>&lt; T2, DifferenceType, OffsetType, OffsetAlignment &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1offset__ptr_1afba2dcc1699274b73f64b99820ef5111" name="assign" cv="noexcept"><type>void</type><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="ptr"><paramtype>const <classname>offset_ptr</classname>&lt; T2, DifferenceType, OffsetType, OffsetAlignment &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method>
</method-group>
</class>


<function id="doxygen.boost_interprocess_header_reference.offset__ptr_8hpp_1ae7c20c7880cff81e435a5d59c162b8f0" name="operator&lt;&lt;"><type>std::basic_ostream&lt; E, T &gt; &amp;</type><template>
          <template-type-parameter name="E"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="W"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
          <template-nontype-parameter name="Z"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; E, T &gt; &amp;</paramtype></parameter><parameter name="p"><paramtype><classname>offset_ptr</classname>&lt; W, X, Y, Z &gt; const &amp;</paramtype></parameter><description><para>operator&lt;&lt; for offset ptr </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.offset__ptr_8hpp_1a829125e4d75854a2444815c7561e4cfe" name="operator&gt;&gt;"><type>std::basic_istream&lt; E, T &gt; &amp;</type><template>
          <template-type-parameter name="E"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="W"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
          <template-nontype-parameter name="Z"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="is"><paramtype>std::basic_istream&lt; E, T &gt; &amp;</paramtype></parameter><parameter name="p"><paramtype><classname>offset_ptr</classname>&lt; W, X, Y, Z &gt; &amp;</paramtype></parameter><description><para>operator&gt;&gt; for offset ptr </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.offset__ptr_8hpp_1a3b468cecf9b517a549215a52df2fee2b" name="static_pointer_cast"><type><classname>boost::interprocess::offset_ptr</classname>&lt; T1, P1, O1, A1 &gt;</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="P1"/>
          <template-type-parameter name="O1"/>
          <template-nontype-parameter name="A1"><type>std::size_t</type></template-nontype-parameter>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="P2"/>
          <template-type-parameter name="O2"/>
          <template-nontype-parameter name="A2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="r"><paramtype>const <classname>boost::interprocess::offset_ptr</classname>&lt; T2, P2, O2, A2 &gt; &amp;</paramtype></parameter><purpose>Simulation of static_cast between pointers. Never throws. </purpose></function>
<function id="doxygen.boost_interprocess_header_reference.offset__ptr_8hpp_1ac99255e21e8bf8653a30420ebaa35298" name="const_pointer_cast"><type><classname>boost::interprocess::offset_ptr</classname>&lt; T1, P1, O1, A1 &gt;</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="P1"/>
          <template-type-parameter name="O1"/>
          <template-nontype-parameter name="A1"><type>std::size_t</type></template-nontype-parameter>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="P2"/>
          <template-type-parameter name="O2"/>
          <template-nontype-parameter name="A2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="r"><paramtype>const <classname>boost::interprocess::offset_ptr</classname>&lt; T2, P2, O2, A2 &gt; &amp;</paramtype></parameter><purpose>Simulation of const_cast between pointers. Never throws. </purpose></function>
<function id="doxygen.boost_interprocess_header_reference.offset__ptr_8hpp_1a5125c5a6174c3312a4a09fa2e22fb51b" name="dynamic_pointer_cast"><type><classname>boost::interprocess::offset_ptr</classname>&lt; T1, P1, O1, A1 &gt;</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="P1"/>
          <template-type-parameter name="O1"/>
          <template-nontype-parameter name="A1"><type>std::size_t</type></template-nontype-parameter>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="P2"/>
          <template-type-parameter name="O2"/>
          <template-nontype-parameter name="A2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="r"><paramtype>const <classname>boost::interprocess::offset_ptr</classname>&lt; T2, P2, O2, A2 &gt; &amp;</paramtype></parameter><purpose>Simulation of dynamic_cast between pointers. Never throws. </purpose></function>
<function id="doxygen.boost_interprocess_header_reference.offset__ptr_8hpp_1aa1cca83410d97b1bc631022ca11846f0" name="reinterpret_pointer_cast"><type><classname>boost::interprocess::offset_ptr</classname>&lt; T1, P1, O1, A1 &gt;</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="P1"/>
          <template-type-parameter name="O1"/>
          <template-nontype-parameter name="A1"><type>std::size_t</type></template-nontype-parameter>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="P2"/>
          <template-type-parameter name="O2"/>
          <template-nontype-parameter name="A2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="r"><paramtype>const <classname>boost::interprocess::offset_ptr</classname>&lt; T2, P2, O2, A2 &gt; &amp;</paramtype></parameter><purpose>Simulation of reinterpret_cast between pointers. Never throws. </purpose></function>










































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.permissions_8hpp" name="boost/interprocess/permissions.hpp">
<para>Describes permissions class </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1permissions" name="permissions"><description><para>The permissions class represents permissions to be set to shared memory or files, that can be constructed form usual permission representations: a SECURITY_ATTRIBUTES pointer in windows or ORed rwx chmod integer in UNIX. </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1permissions_1ac900a7480946e477fcc4320fe02d92ef" cv="noexcept"><parameter name="type"><paramtype>os_permissions_type</paramtype></parameter><description><para>Constructs a permissions object from a user provided os-dependent permissions. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1permissions_1a628628253d023ec679594256418e0574" cv="noexcept"><description><para>Constructs a default permissions object: A null security attributes pointer for windows or 0644 for UNIX. </para></description></constructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1permissions_1a8b43c50551dbafbf143b2956641a5e67" name="set_default" cv="noexcept"><type>void</type><description><para>Sets permissions to default values: A null security attributes pointer for windows or 0644 for UNIX. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1permissions_1a96e019dc95f6b8c0bfe7884fbb6f5884" name="set_unrestricted" cv="noexcept"><type>void</type><description><para>Sets permissions to unrestricted access: A null DACL for windows or 0666 for UNIX. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1permissions_1ad9335350139d20686859c7f2d286f64a" name="set_permissions" cv="noexcept"><type>void</type><parameter name="perm"><paramtype>os_permissions_type</paramtype></parameter><description><para>Sets permissions from a user provided os-dependent permissions. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1permissions_1a3d5713925ae4f7bae936ff4fea4f05b8" name="get_permissions" cv="const noexcept"><type>os_permissions_type</type><description><para>Returns stored os-dependent permissions </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.segment__manager_8hpp" name="boost/interprocess/segment_manager.hpp">
<para>Describes the object placed in a memory segment that provides named object allocation capabilities for single-segment and multi-segment allocations. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager" name="segment_manager"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="MemoryAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><inherit access="public">boost::interprocess::segment_manager_base&lt; MemoryAlgorithm &gt;</inherit><description><para>This object is placed in the beginning of memory segment and implements the allocation (named or anonymous) of portions of the segment. This object contains two indexes that maintain an association between a name and a portion of the segment.</para><para>The first index contains the mappings for normal named objects using the char type specified in the template parameter.</para><para>The second index contains the association for unique instances. The key will be the const char * returned from type_info.name() function for the unique type to be constructed.</para><para>segment_manager&lt;CharType, MemoryAlgorithm, IndexType&gt; inherits publicly from segment_manager_base&lt;MemoryAlgorithm&gt; and inherits from it many public functions related to anonymous object and raw memory allocation. See <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base">segment_manager_base</link> reference to know about those functions. </para></description><struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1segment__manager_1_1allocator" name="allocator"><template>
      <template-type-parameter name="T"/>
    </template><description><para>This is the default allocator to allocate types T from this managed segment </para></description><typedef id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1segment__manager_1_1allocator_1ade3f79b28fe5950a666d1774cdf8e8c9" name="type"><type><classname>boost::interprocess::allocator</classname>&lt; T, <classname>segment_manager</classname> &gt;</type></typedef>
</struct><struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1segment__manager_1_1deleter" name="deleter"><template>
      <template-type-parameter name="T"/>
    </template><description><para>This is the default deleter to delete types T from this managed segment. </para></description><typedef id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1segment__manager_1_1deleter_1a5f741c852ee29147d6570dc20bcfd411" name="type"><type><classname>boost::interprocess::deleter</classname>&lt; T, <classname>segment_manager</classname> &gt;</type></typedef>
</struct><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a3460b141b7c656e1a532626484ef3322" name="memory_algorithm"><type>MemoryAlgorithm</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a2b262239566e3ff6d3b0b2deb59be4c6" name="void_pointer"><type>segment_manager_base_t::void_pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a09e737db0e8d5a8af0aeb4406753ee53" name="size_type"><type>segment_manager_base_t::size_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a99523e24b538fce73e1fb3fd40e1e80a" name="difference_type"><type>segment_manager_base_t::difference_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1ac881465f4f424dd342a5989a101a5e00" name="char_type"><type>CharType</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a96e92822a623b274a0e40c54482dc3d0" name="segment_manager_base_type"><type><classname>segment_manager_base</classname>&lt; MemoryAlgorithm &gt;</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a3744b96fc05435cf283f2fe11c1bbe35" name="mutex_family"><type>segment_manager_base_t::mutex_family</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a08767d9d01b5f1cc350fbb30d77f1175" name="const_named_iterator"><type>transform_iterator&lt; typename named_index_t::const_iterator, named_transform &gt;</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1ac2528e7b44ea79ca83c85bf8bd2893a5" name="const_unique_iterator"><type>transform_iterator&lt; typename unique_index_t::const_iterator, unique_transform &gt;</type></typedef>
<data-member id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1af1d6a5140b160b639eb3639c4b180ea3" name="PayloadPerAllocation" specifiers="static"><type>const size_type</type></data-member>
<data-member id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a11b4cf51e6d9fdaaf21b2e171b2b0076" name="MemAlignment" specifiers="static"><type>const size_type</type></data-member>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1ac1db9ec3077e42ab162dca27d02e6f8f" specifiers="explicit"><parameter name="segment_size"><paramtype>size_type</paramtype></parameter><description><para>Constructor of the segment manager "size" is the size of the memory segment where the segment manager is being constructed. Can throw </para></description></constructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1ae7e2eaa05b23cd1a54d6180eac8bbc9c" name="find"><type>std::pair&lt; T *, size_type &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><description><para>Tries to find a previous named/unique allocation. Returns the address and the object count. On failure the first member of the returned pair is 0. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a59bc9a8e01381edcf4f1774775f9a814" name="find_no_lock"><type>std::pair&lt; T *, size_type &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><description><para>Tries to find a previous named/unique allocation. Returns the address and the object count. On failure the first member of the returned pair is 0. This search is not mutex-protected! Use it only inside <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1aea023093311c13a024b74dc0e1004717">atomic_func()</link> calls, where the internal mutex is guaranteed to be locked. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a11341d9da688d58d4f3b293ebe6f3f24" name="construct"><type>construct_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><description><para>Returns throwing "construct" proxy object </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a30cabfc06666b05719e0e1fd978b0aad" name="find_or_construct"><type>construct_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><description><para>Returns throwing "search or construct" proxy object </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a93840b0886c4645725997a7787641253" name="construct"><type>construct_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><parameter name=""><paramtype>const std::nothrow_t &amp;</paramtype></parameter><description><para>Returns no throwing "construct" proxy object </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1acd29e53db3d979d7623cd35389c254a4" name="find_or_construct"><type>construct_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><parameter name=""><paramtype>const std::nothrow_t &amp;</paramtype></parameter><description><para>Returns no throwing "search or construct" proxy object </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1ad8bfa4da6270902c60101c6fab7b4d38" name="construct_it"><type>construct_iter_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><purpose>Returns throwing "construct from iterators" proxy object. </purpose></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a213d4db0dab7f5a057cd165048208964" name="find_or_construct_it"><type>construct_iter_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><description><para>Returns throwing "search or construct from iterators" proxy object </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a28bacd8eb11c26cbece2af45d2fa877b" name="construct_it"><type>construct_iter_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><parameter name=""><paramtype>const std::nothrow_t &amp;</paramtype></parameter><description><para>Returns no throwing "construct from iterators" proxy object </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1ae040ec58a46f2f6d0f2f3010879be6d2" name="find_or_construct_it"><type>construct_iter_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><parameter name=""><paramtype>const std::nothrow_t &amp;</paramtype></parameter><description><para>Returns no throwing "search or construct from iterators" proxy object </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1aea023093311c13a024b74dc0e1004717" name="atomic_func"><type>void</type><template>
          <template-type-parameter name="Func"/>
        </template><parameter name="f"><paramtype>Func &amp;</paramtype></parameter><description><para>Calls object function blocking recursive <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex">interprocess_mutex</link> and guarantees that no new named_alloc or destroy will be executed by any process while executing the object function call </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a0e57472f9b09b0ec63a2897937e8985e" name="try_atomic_func"><type>bool</type><template>
          <template-type-parameter name="Func"/>
        </template><parameter name="f"><paramtype>Func &amp;</paramtype></parameter><description><para>Tries to calls a functor guaranteeing that no new construction, search or destruction will be executed by any process while executing the object function call. If the atomic function can't be immediatelly executed because the internal mutex is already locked, returns false. If the functor throws, this function throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a36baaa2036bcf1aff18353b2efa32cf3" name="destroy"><type>bool</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><description><para>Destroys a previously created named/unique instance. Returns false if the object was not present. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1aaa0ef03830801edf30ed286de5382030" name="destroy_ptr"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="p"><paramtype>const T *</paramtype></parameter><description><para>Destroys an anonymous, unique or named object using its address </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a7d1753626fd543f1d1d3ec05810002b0" name="reserve_named_objects"><type>void</type><parameter name="num"><paramtype>size_type</paramtype></parameter><description><para>Preallocates needed index resources to optimize the creation of "num" named objects in the managed memory segment. Can throw <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> if there is no enough memory. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a0a37c56d1c6906f3b17b94ca3c02e0dd" name="reserve_unique_objects"><type>void</type><parameter name="num"><paramtype>size_type</paramtype></parameter><description><para>Preallocates needed index resources to optimize the creation of "num" unique objects in the managed memory segment. Can throw <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> if there is no enough memory. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a8cb3d1bd29718bc72fd0fb64b733c443" name="shrink_to_fit_indexes"><type>void</type><description><para>Calls shrink_to_fit in both named and unique object indexes to try to free unused memory from those indexes. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a3388538cc7e21ad9a35179f43a155293" name="get_num_named_objects"><type>size_type</type><description><para>Returns the number of named objects stored in the segment. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a8420f879075a52709217ff6abbc8ff0e" name="get_num_unique_objects"><type>size_type</type><description><para>Returns the number of unique objects stored in the segment. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1af95a6a1b4fda6dd74d1aba3ad4fb4f87" name="named_begin" cv="const"><type>const_named_iterator</type><description><para>Returns a constant iterator to the beginning of the information about the named allocations performed in this segment manager </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a964a094c4963d887391227de302ac8f5" name="named_end" cv="const"><type>const_named_iterator</type><description><para>Returns a constant iterator to the end of the information about the named allocations performed in this segment manager </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1ac3ac08ac5a970dfc67b0ece1510c8f64" name="unique_begin" cv="const"><type>const_unique_iterator</type><description><para>Returns a constant iterator to the beginning of the information about the unique allocations performed in this segment manager </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1af403b77c24739de3483adcce9ae0807c" name="unique_end" cv="const"><type>const_unique_iterator</type><description><para>Returns a constant iterator to the end of the information about the unique allocations performed in this segment manager </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a1c4110f1bf86a3bdb4e34268236d25c7" name="get_allocator"><type><classname>allocator</classname>&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><description><para>Returns an instance of the default allocator for type T initialized that allocates memory from this segment manager. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a9c34a82485fe5c495dc5c39f86deda3e" name="get_deleter"><type><classname>deleter</classname>&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><description><para>Returns an instance of the default deleter for type T that will delete an object constructed in this segment manager. </para></description></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a719fb1e273492a169805fcb85af10435" name="get_instance_name" specifiers="static"><type>const CharType *</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="ptr"><paramtype>const T *</paramtype></parameter><description><para>Returns the name of an object created with construct/find_or_construct functions. Does not throw </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a3f27b54b988281ee45e23e279e319cb9" name="get_instance_length" specifiers="static"><type>size_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="ptr"><paramtype>const T *</paramtype></parameter><description><para>Returns the length of an object created with construct/find_or_construct functions. Does not throw. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a82260b42080de676db3f696835221d96" name="get_instance_type" specifiers="static"><type>instance_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="ptr"><paramtype>const T *</paramtype></parameter><description><para>Returns is the the name of an object created with construct/find_or_construct functions. Does not throw </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager_1a7984f40196484b6b6f09a0c4ad085c7a" name="get_min_size" specifiers="static"><type>size_type</type><description><para>Obtains the minimum size needed by the segment manager </para></description></method>
</method-group>
</class><class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base" name="segment_manager_base"><template>
      <template-type-parameter name="MemoryAlgorithm"/>
    </template><inherit access="private">MemoryAlgorithm</inherit><description><para>This object is the public base class of segment manager. This class only depends on the memory allocation algorithm and implements all the allocation features not related to named or unique objects.</para><para>Storing a reference to <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager">segment_manager</link> forces the holder class to be dependent on index types and character types. When such dependence is not desirable and only anonymous and raw allocations are needed, <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base">segment_manager_base</link> is the correct answer. </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1a6e67246a0cc96a67d0c6a904b4ec0aff" name="segment_manager_base_type"><type><classname>segment_manager_base</classname>&lt; MemoryAlgorithm &gt;</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1a869e6bae5c676dbbac0503e41e18a6c5" name="void_pointer"><type>MemoryAlgorithm::void_pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1af7d88abde9835ca9dc0d0a0d584c13d7" name="mutex_family"><type>MemoryAlgorithm::mutex_family</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1a8d9e989db4663a51eda7d416b1686127" name="memory_algorithm"><type>MemoryAlgorithm</type></typedef>
<data-member id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1ac33d3e9e7c8b915df755484b2287e70d" name="MemAlignment" specifiers="static"><type>const std::size_t</type></data-member>
<data-member id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1af35480e8152da4ade86d12828917b446" name="PayloadPerAllocation" specifiers="static"><type>const size_type</type><description><para>This constant indicates the payload size associated with each allocation of the memory algorithm </para></description></data-member>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1ab283b9f4fc35704a0b8600e43696bf7d"><parameter name="sz"><paramtype>size_type</paramtype></parameter><parameter name="reserved_bytes"><paramtype>size_type</paramtype></parameter><description><para>Constructor of the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base">segment_manager_base</link></para><para>"size" is the size of the memory segment where the basic segment manager is being constructed.</para><para>"reserved_bytes" is the number of bytes after the end of the memory algorithm object itself that the memory algorithm will exclude from dynamic allocation</para><para>Can throw </para></description></constructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1a22d60be6b8859272080c80b6d2897344" name="get_size" cv="const"><type>size_type</type><description><para>Returns the size of the memory segment </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1ae463417eb7a3d95066e7d01a03286cee" name="get_free_memory" cv="const"><type>size_type</type><description><para>Returns the number of free bytes of the memory segment </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1ad8f5c83e8bb194d0729d6fbf22459fdb" name="allocate"><type>void *</type><parameter name="nbytes"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype>const std::nothrow_t &amp;</paramtype></parameter><description><para>Allocates nbytes bytes. This function is only used in single-segment management. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1acfc03169a2db9561946cd6a4d1d725f4" name="get_memory_algorithm"><type>MemoryAlgorithm &amp;</type><description><para>Returns a reference to the internal memory algorithm. This function is useful for custom memory algorithms that need additional configuration options after construction. Never throws. This function should be only used by advanced users. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1a03827b0f019cc1c7eba54d74351075e5" name="get_memory_algorithm" cv="const"><type>const MemoryAlgorithm &amp;</type><description><para>Returns a const reference to the internal memory algorithm. This function is useful for custom memory algorithms that need additional configuration options after construction. Never throws. This function should be only used by advanced users. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1a019ff2632b995e10e28830ed10ec8690" name="allocate"><type>void *</type><parameter name="nbytes"><paramtype>size_type</paramtype></parameter><description><para>Allocates nbytes bytes. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">boost::interprocess::bad_alloc</link> on failure </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1a901fc38f1f4f694303b631fc6b2cf95c" name="allocate_aligned"><type>void *</type><parameter name="nbytes"><paramtype>size_type</paramtype></parameter><parameter name="alignment"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype>const std::nothrow_t &amp;</paramtype></parameter><description><para>Allocates nbytes bytes. This function is only used in single-segment management. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1a2623b91c23ae731b507ed3789dcd6242" name="allocate_aligned"><type>void *</type><parameter name="nbytes"><paramtype>size_type</paramtype></parameter><parameter name="alignment"><paramtype>size_type</paramtype></parameter><description><para>Allocates nbytes bytes. This function is only used in single-segment management. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1bad__alloc">bad_alloc</link> when fails </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1aa1651ba36307dff5c45b86797f0ed5ef" name="deallocate"><type>void</type><parameter name="addr"><paramtype>void *</paramtype></parameter><description><para>Deallocates the bytes allocated with allocate/allocate_many() pointed by addr </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1a65f59c2f555934f9921ae5dd900cb13e" name="grow"><type>void</type><parameter name="extra_size"><paramtype>size_type</paramtype></parameter><description><para>Increases managed memory in extra_size bytes more. This only works with single-segment management. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1a55f7c9a9a5e935d773b87e4c20cce668" name="shrink_to_fit"><type>void</type><description><para>Decreases managed memory to the minimum. This only works with single-segment management. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1a277551ce586a7289b072e7ca92ebc4b5" name="all_memory_deallocated"><type>bool</type><description><para>Returns the result of "all_memory_deallocated()" function of the used memory algorithm </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1ab14c63d038b82b8bba976f2421adece5" name="check_sanity"><type>bool</type><description><para>Returns the result of "check_sanity()" function of the used memory algorithm </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1ae176b27f4da64bf5caeb802fae45c1a9" name="zero_free_memory"><type>void</type><description><para>Writes to zero free memory (memory not yet allocated) of the memory algorithm </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1a24a3905658cd0250c7959be6be69b4bb" name="size" cv="const"><type>size_type</type><parameter name="ptr"><paramtype>const void *</paramtype></parameter><purpose>Returns the size of the buffer previously allocated pointed by ptr. </purpose></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1segment__manager__base_1af4054e49520b755f981b14c69a6f0393" name="get_min_size" specifiers="static"><type>size_type</type><parameter name="size"><paramtype>size_type</paramtype></parameter><description><para>Obtains the minimum size needed by the segment manager </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.shared__memory__object_8hpp" name="boost/interprocess/shared_memory_object.hpp">
<para>Describes a shared memory object management class. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object" name="shared_memory_object"><description><para>A class that wraps a shared memory mapping that can be used to create mapped regions from the mapped files </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1a9763fa8498e45cb818f517e25b9ff16f" cv="noexcept"><purpose>Default constructor. Represents an empty <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object">shared_memory_object</link>. </purpose></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1a81b51c7e2c8e72297c0f9cf630107257"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a shared memory object with name "name" and mode "mode", with the access mode "mode" If the file previously exists, throws an error.*<zwj/>/ </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1a79dc1fc0f894bd560365cac4c1ea439f"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Tries to create a shared memory object with name "name" and mode "mode", with the access mode "mode". If the file previously exists, it tries to open it with mode "mode". Otherwise throws an error. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1ae29dd1dee2b132ef94dcf51d4184c0a6"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><description><para>Tries to open a shared memory object with name "name", with the access mode "mode". If the file does not previously exist, it throws an error. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1a748ede69ee25d46142e24e88bb1637be"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a shared memory object with name "name" and mode "mode", with the access mode "mode" If the file previously exists, throws an error.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1a062d409edddb76859dae82801c1fcc23"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Tries to create a shared memory object with name "name" and mode "mode", with the access mode "mode". If the file previously exists, it tries to open it with mode "mode". Otherwise throws an error.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1a5aaf4759cbb6e9da14954d4e92d63cb7"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><description><para>Tries to open a shared memory object with name "name", with the access mode "mode". If the file does not previously exist, it throws an error.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1ac2f20f51fa9485af752e478a61bcb8c5" cv="noexcept"><parameter name="moved"><paramtype><classname>shared_memory_object</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s shared memory object to *this. After the call, "moved" does not represent any shared memory object. Does not throw </para></description></constructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1a446b294ca1b47ecd82bf63853929e6f2" cv="noexcept"><type><classname>shared_memory_object</classname> &amp;</type><parameter name="moved"><paramtype><classname>shared_memory_object</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s shared memory to *this. After the call, "moved" does not represent any shared memory. Does not throw </para></description></copy-assignment>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1af4ac71154cfbbd63bcd00a8ca7e4398c" name="swap" cv="noexcept"><type>void</type><parameter name="moved"><paramtype><classname>shared_memory_object</classname> &amp;</paramtype></parameter><purpose>Swaps the shared_memory_objects. Does not throw. </purpose></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1aa01a1a9fd5c2d9664d10e521f7c3f708" name="truncate"><type>void</type><parameter name="length"><paramtype>offset_t</paramtype></parameter><purpose>Sets the size of the shared memory mapping. </purpose></method>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1a7d4c13a364bd76a949820f3637bb9bcf"><description><para>Destroys *this and indicates that the calling process is finished using the resource. All mapped regions are still valid after destruction. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1ae766c32ef5fe470f3567c3f40ca2b7bd">remove()</link>. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1abd132da20b04aa0dd444b71058565eb0" name="get_name" cv="const noexcept"><type>const char *</type><purpose>Returns the name of the shared memory object. </purpose></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1a8a598eb441194906c649cf2fe180f71b" name="get_size" cv="const noexcept"><type>bool</type><parameter name="size"><paramtype>offset_t &amp;</paramtype></parameter><description><para>Returns true if the size of the shared memory object can be obtained and writes the size in the passed reference </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1af39c53fed9c46b9312c0c359f790d6f3" name="get_mode" cv="const noexcept"><type>mode_t</type><purpose>Returns access mode. </purpose></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1a4f5ba6f862daab93bd20d47aa124fc1d" name="get_mapping_handle" cv="const noexcept"><type>mapping_handle_t</type><purpose>Returns mapping handle. Never throws. </purpose></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1ae766c32ef5fe470f3567c3f40ca2b7bd" name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a shared memory object from the system. Returns false on error. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object_1ad5c254e7100cd361ca93db77dde32134" name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Erases a shared memory object from the system. Returns false on error. Never throws</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.deleter_8hpp" name="boost/interprocess/smart_ptr/deleter.hpp">
<para>Describes the functor to delete objects from the segment. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1deleter" name="deleter"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
    </template><description><para>A deleter that uses the segment manager's destroy_ptr function to destroy the passed pointer resource.</para><para>This deleter is used </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1deleter_1a0c13f6eaeed116bbf5f0729afe84183f" name="pointer"><type>boost::intrusive::pointer_traits&lt; typenameSegmentManager::void_pointer &gt;::template rebind_pointer&lt; T &gt;::type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1deleter_1a9a0317cd82921816a78b65c06328ea29" cv="noexcept"><parameter name="pmngr"><paramtype>segment_manager_pointer</paramtype></parameter></constructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1deleter_1a7edda5d6e38734793883e5e75158da8d" name="operator()"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.enable__shared__from__this_8hpp" name="boost/interprocess/smart_ptr/enable_shared_from_this.hpp">
<para>Describes an utility to form a shared pointer from this </para><namespace name="boost">
<namespace name="interprocess">



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.intrusive__ptr_8hpp" name="boost/interprocess/smart_ptr/intrusive_ptr.hpp">
<para>Describes an intrusive ownership pointer. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr" name="intrusive_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="VoidPointer"/>
    </template><description><para>The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr">intrusive_ptr</link> class template stores a pointer to an object with an embedded reference count. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr">intrusive_ptr</link> is parameterized on T (the type of the object pointed to) and VoidPointer(a void pointer type
that defines the type of pointer that intrusive_ptr will store). intrusive_ptr&lt;T, void &lt;em&gt;&gt; defines a class with a T member whereas <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr">intrusive_ptr</link>&lt;T, offset_ptr&lt;void&gt; &gt; defines a class with a offset_ptr&lt;T&gt; member. Relies on unqualified calls to:</para><para>void intrusive_ptr_add_ref(T * p) BOOST_NOEXCEPT; void intrusive_ptr_release(T * p) BOOST_NOEXCEPT;</para><para>with (p != 0)</para><para>The object is responsible for destroying itself. </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1a6c8c4b397971951b0d9defce0cad7bc8" name="pointer"><purpose>Provides the type of the internal stored pointer. </purpose><type>boost::intrusive::pointer_traits&lt; VoidPointer &gt;::template rebind_pointer&lt; T &gt;::type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1a6323896a5b9a7643aa7fc4959189b9e4" name="element_type"><purpose>Provides the type of the stored pointer. </purpose><type>T</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1a3b062402a4f97267f3d5f6d02572d1da" cv="noexcept"><description><para>Constructor. Initializes internal pointer to 0. Does not throw </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1a9d8a78cba6f87c3479c9d046832201f6" cv="noexcept"><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="add_ref"><paramtype>bool</paramtype><default>true</default></parameter><description><para>Constructor. Copies pointer and if "p" is not zero and "add_ref" is true calls intrusive_ptr_add_ref(to_raw_pointer(p)). Does not throw </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1a641487a6128954bc6852987e731a0383" cv="noexcept"><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname> const &amp;</paramtype></parameter><description><para>Copy constructor. Copies the internal pointer and if "p" is not zero calls intrusive_ptr_add_ref(to_raw_pointer(p)). Does not throw </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1a3dd69761f4ec2a6fa5558152cd7424c6" cv="noexcept"><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname> &amp;&amp;</paramtype></parameter><purpose>Move constructor. Moves the internal pointer. Does not throw. </purpose></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1aaa3f512bbda87d40b0ce835fc2bf1548" cv="noexcept"><template>
          <template-type-parameter name="U"/>
        </template><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname>&lt; U, VP &gt; const &amp;</paramtype></parameter><description><para>Constructor from related. Copies the internal pointer and if "p" is not zero calls intrusive_ptr_add_ref(to_raw_pointer(p)). Does not throw </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1a3ed6cfcd094205ffe569472d8bae51f3"><purpose>Destructor. Calls <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1ac1ffa4a3578eb390ee36368687052d28">reset()</link>. Does not throw. </purpose></destructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1a5ac3ec09d78dc56855b1d4656d5ca95c" cv="noexcept"><type><classname>intrusive_ptr</classname> &amp;</type><parameter name="rhs"><paramtype>BOOST_COPY_ASSIGN_REF(<classname>intrusive_ptr</classname>)</paramtype></parameter><description><para>Assignment operator. Equivalent to intrusive_ptr(r).swap(*this). Does not throw </para></description></copy-assignment>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1ac84d23bf38a020c1d44611f52a2f1976" cv="noexcept"><type><classname>intrusive_ptr</classname> &amp;</type><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname> &amp;&amp;</paramtype></parameter><description><para>Move Assignment operator Does not throw </para></description></copy-assignment>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1a2502f5c7f5e962b4b7005b29b76f7cf2" cv="noexcept"><type><classname>intrusive_ptr</classname> &amp;</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname>&lt; U, VP &gt; const &amp;</paramtype></parameter><description><para>Assignment from related. Equivalent to intrusive_ptr(r).swap(*this). Does not throw </para></description></copy-assignment>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1a5476c22b7af008da57d744e8a52e1d32" cv="noexcept"><type><classname>intrusive_ptr</classname> &amp;</type><parameter name="rhs"><paramtype>pointer</paramtype></parameter><description><para>Assignment from pointer. Equivalent to intrusive_ptr(r).swap(*this). Does not throw </para></description></copy-assignment>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1ac1ffa4a3578eb390ee36368687052d28" name="reset" cv="noexcept"><type>void</type><description><para>Release internal pointer and set it to 0. If internal pointer is not 0, calls intrusive_ptr_release(to_raw_pointer(m_ptr)). Does not throw </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1aac625d6cbb898c0b754f13f49fc0961e" name="get" cv="noexcept"><type>pointer &amp;</type><description><para>Returns a reference to the internal pointer. Does not throw </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1a35ad6abe1a924602938f6c02a94a72a8" name="get" cv="const noexcept"><type>const pointer &amp;</type><description><para>Returns a reference to the internal pointer. Does not throw </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1a191709e971e939833998ee754329b025" name="operator*" cv="const noexcept"><type>T &amp;</type><description><para>Returns *get(). Does not throw </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1adeb444405c954b83524b181a8b8ef957" name="operator-&gt;" cv="const noexcept"><type>const pointer &amp;</type><description><para>Returns *get(). Does not throw </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1a506ca35c6bbaeb90616b2b72f63f1a53" name="operator-&gt;" cv="noexcept"><type>pointer &amp;</type><description><para>Returns <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1aac625d6cbb898c0b754f13f49fc0961e">get()</link>. Does not throw </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1a6cbd046b6639ba32b21ab78b82cfb1a2" name="conversion-operator" cv="const noexcept"><type>unspecified_bool_type</type><description><para>Conversion to boolean. Does not throw </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1a4e1db57f5eedfbf20bf400bd1f293f67" name="operator!" cv="const noexcept"><type>bool</type><description><para>Not operator. Does not throw </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1intrusive__ptr_1a9122b4d287f62a0a22a425189b37af28" name="swap" cv="noexcept"><type>void</type><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname> &amp;</paramtype></parameter><description><para>Exchanges the contents of the two smart pointers. Does not throw </para></description></method>
</method-group>
</class>








































<function id="doxygen.boost_interprocess_header_reference.intrusive__ptr_8hpp_1ad07d21c7071ac564f4a3b29a3128c871" name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>intrusive_ptr</classname>&lt; U, VP &gt; const &amp;</paramtype></parameter><description><para>Returns a.get() == b.get(). Does not throw </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.intrusive__ptr_8hpp_1ac934dca3be14d5928459b25a363d0652" name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>intrusive_ptr</classname>&lt; U, VP &gt; const &amp;</paramtype></parameter><description><para>Returns a.get() != b.get(). Does not throw </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.intrusive__ptr_8hpp_1abb9b07310c516a36724c567fadf33c92" name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype>const typename <classname>intrusive_ptr</classname>&lt; T, VP &gt;::pointer &amp;</paramtype></parameter><description><para>Returns a.get() == b. Does not throw </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.intrusive__ptr_8hpp_1a6be2ec26ca38811300d632345f00479c" name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype>const typename <classname>intrusive_ptr</classname>&lt; T, VP &gt;::pointer &amp;</paramtype></parameter><description><para>Returns a.get() != b. Does not throw </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.intrusive__ptr_8hpp_1abacd035a797432eebeb509ca30e51d15" name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype>const typename <classname>intrusive_ptr</classname>&lt; T, VP &gt;::pointer &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><description><para>Returns a == b.get(). Does not throw </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.intrusive__ptr_8hpp_1a525ceb9d26eb037eda6a4d1d6fd09b7b" name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype>const typename <classname>intrusive_ptr</classname>&lt; T, VP &gt;::pointer &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><description><para>Returns a != b.get(). Does not throw </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.intrusive__ptr_8hpp_1adf9757b5de1f742f1b432d269b7a956b" name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><description><para>Returns a.get() &lt; b.get(). Does not throw </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.intrusive__ptr_8hpp_1a8b5a5706d97a8fa356fa600874693eb1" name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="lhs"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; &amp;</paramtype></parameter><description><para>Exchanges the contents of the two intrusive_ptrs. Does not throw </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.intrusive__ptr_8hpp_1a25ac60837d33fe1922fe0914514a52aa" name="operator&lt;&lt;"><type>std::basic_ostream&lt; E, T &gt; &amp;</type><template>
          <template-type-parameter name="E"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; E, T &gt; &amp;</paramtype></parameter><parameter name="p"><paramtype><classname>intrusive_ptr</classname>&lt; Y, VP &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.boost_interprocess_header_reference.intrusive__ptr_8hpp_1abf3e3e6d4d2614e0366e5fa11d4b46f9" name="to_raw_pointer"><type><classname>boost::interprocess::intrusive_ptr</classname>&lt; T, VP &gt;::pointer</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="p"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt;</paramtype></parameter><description><para>Returns p.get(). Does not throw </para></description></function>
</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.scoped__ptr_8hpp" name="boost/interprocess/smart_ptr/scoped_ptr.hpp">
<para>Describes the smart pointer scoped_ptr </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr" name="scoped_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Deleter"/>
    </template><inherit access="private">Deleter</inherit><description><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr">scoped_ptr</link> stores a pointer to a dynamically allocated object. The object pointed to is guaranteed to be deleted, either on destruction of the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr">scoped_ptr</link>, or via an explicit reset. The user can avoid this deletion using <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr_1a69bca053c76181953eecd94552503761">release()</link>. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr">scoped_ptr</link> is parameterized on T (the type of the object pointed to) and Deleter (the functor to be executed to delete the internal pointer). The internal pointer will be of the same pointer type as typename Deleter::pointer type (that is, if typename Deleter::pointer is offset_ptr&lt;void&gt;, the internal pointer will be offset_ptr&lt;T&gt;). </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr_1a3399a4f4341bb973038bb31c43efa555" name="element_type"><type>T</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr_1ad76cc889b77bddaf17b6c2687e00d228" name="deleter_type"><type>Deleter</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr_1aeb3b20cd6af89b0eab7f682c526dc7c3" name="pointer"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr_1abf886823d3dc83760e43d5c91e72beb2" name="unspecified_bool_type"><type>pointer this_type::*</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr_1a5cc26fe9e64610731d1b30d3dd1aa093" specifiers="explicit"><parameter name="p"><paramtype>const pointer &amp;</paramtype><default>0</default></parameter><parameter name="d"><paramtype>const Deleter &amp;</paramtype><default>Deleter()</default></parameter><description><para>Constructs a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr">scoped_ptr</link>, storing a copy of p(which can be 0) and d. Does not throw. </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr_1a3766d806afca9ac314e6c3facd5b14fe"><description><para>If the stored pointer is not 0, destroys the object pointed to by the stored pointer. calling the operator() of the stored deleter. Never throws </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr_1a4e2056cd1c26c60d26fb84363d1f3973" name="reset"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype><default>0</default></parameter><description><para>Deletes the object pointed to by the stored pointer and then stores a copy of p. Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr_1af942c55d15aebe4f3ccb44eb564780f1" name="reset"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="d"><paramtype>const Deleter &amp;</paramtype></parameter><description><para>Deletes the object pointed to by the stored pointer and then stores a copy of p and a copy of d. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr_1a69bca053c76181953eecd94552503761" name="release" cv="noexcept"><type>pointer</type><description><para>Assigns internal pointer as 0 and returns previous pointer. This will avoid deletion on destructor </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr_1a46d79dc3052124ec94cc240384e90bb7" name="operator*" cv="const noexcept"><type>reference</type><description><para>Returns a reference to the object pointed to by the stored pointer. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr_1a07e7d822d8171f30b930883ec0a14e3e" name="operator-&gt;" cv="noexcept"><type>pointer &amp;</type><description><para>Returns the internal stored pointer. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr_1a417f0f198dfce5e09134ac07f3d0cf6b" name="operator-&gt;" cv="const noexcept"><type>const pointer &amp;</type><description><para>Returns the internal stored pointer. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr_1aa86900e99fec50fa8b4527f677fca417" name="get" cv="noexcept"><type>pointer &amp;</type><description><para>Returns the stored pointer. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr_1ac03b9b6d36e625d34e18d785eec29c12" name="get" cv="const noexcept"><type>const pointer &amp;</type><description><para>Returns the stored pointer. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr_1a3e742af91d57ff5ce19bbe931de1f647" name="conversion-operator" cv="const noexcept"><type>unspecified_bool_type</type><description><para>Conversion to bool Never throws </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr_1a187153721919e3555e3c240e67d00b8c" name="operator!" cv="const noexcept"><type>bool</type><description><para>Returns true if the stored pointer is 0. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr_1abb31f34e1a71719458892359ce7b6da2" name="swap" cv="noexcept"><type>void</type><parameter name="b"><paramtype><classname>scoped_ptr</classname> &amp;</paramtype></parameter><description><para>Exchanges the internal pointer and deleter with other <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr">scoped_ptr</link> Never throws. </para></description></method>
</method-group>
</class>






































<function id="doxygen.boost_interprocess_header_reference.scoped__ptr_8hpp_1a843672aca6a894605303494cb8b1dfc0" name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name="a"><paramtype><classname>scoped_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>scoped_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><description><para>Exchanges the internal pointer and deleter with other <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__ptr">scoped_ptr</link> Never throws. </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.scoped__ptr_8hpp_1a8f199a204f447c7ba3456a5f2d43924d" name="to_raw_pointer"><type><classname>scoped_ptr</classname>&lt; T, D &gt;::pointer</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name="p"><paramtype><classname>scoped_ptr</classname>&lt; T, D &gt; const &amp;</paramtype></parameter><description><para>Returns a copy of the stored pointer Never throws </para></description></function>










</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.shared__ptr_8hpp" name="boost/interprocess/smart_ptr/shared_ptr.hpp">
<para>Describes the smart pointer shared_ptr </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1enable__shared__from__this" name="enable_shared_from_this"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="A"/>
      <template-type-parameter name="D"/>
    </template><description><para>This class is used as a base class that allows a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> to the current object to be obtained from within a member function. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1enable__shared__from__this">enable_shared_from_this</link> defines two member functions called shared_from_this that return a shared_ptr&lt;T&gt; and shared_ptr&lt;T const&gt;, depending on constness, to this. </para></description><method-group name="public member functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1enable__shared__from__this_1a344da34a562058fb5ed5095c1eaa9198" name="shared_from_this"><type><classname>shared_ptr</classname>&lt; T, A, D &gt;</type></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1enable__shared__from__this_1ab0017cb1564dc3417e1e92d8f6721537" name="shared_from_this" cv="const"><type><classname>shared_ptr</classname>&lt; T const, A, D &gt;</type></method>
</method-group>
</class><struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1managed__shared__ptr" name="managed_shared_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="ManagedMemory"/>
    </template><description><para>Returns the type of a shared pointer of type T with the allocator <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator">boost::interprocess::allocator</link> allocator and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1deleter">boost::interprocess::deleter</link> deleter that can be constructed in the given managed segment type. </para></description><typedef id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1managed__shared__ptr_1a2f383130e8306ae3f772749506da0be8" name="void_allocator"><type>ManagedMemory::template <classname>allocator</classname>&lt; void &gt;::type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1managed__shared__ptr_1a9d9d27bcea10b48d997334430dc0a1fe" name="deleter"><type>ManagedMemory::template deleter&lt; T &gt;::type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1managed__shared__ptr_1adc5de94702264bb7a8cd64595daa7040" name="type"><type><classname>shared_ptr</classname>&lt; T, void_allocator, deleter &gt;</type></typedef>
</struct><class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr" name="shared_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="VoidAllocator"/>
      <template-type-parameter name="Deleter"/>
    </template><description><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> stores a pointer to a dynamically allocated object. The object pointed to is guaranteed to be deleted when the last <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> pointing to it is destroyed or reset.</para><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> is parameterized on T (the type of the object pointed to), VoidAllocator (the void allocator to be used to allocate the auxiliary data) and Deleter (the deleter whose operator() will be used to delete the object.</para><para>The internal pointer will be of the same pointer type as typename VoidAllocator::pointer type (that is, if typename VoidAllocator::pointer is offset_ptr&lt;void&gt;, the internal pointer will be offset_ptr&lt;T&gt;).</para><para>Because the implementation uses reference counting, cycles of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> instances will not be reclaimed. For example, if main() holds a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> to A, which directly or indirectly holds a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> back to A, A's use count will be 2. Destruction of the original <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> will leave A dangling with a use count of 1. Use <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr">weak_ptr</link> to "break cycles." </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a601c0b8fbb9af425bea1d73f3f7e0a35" name="element_type"><type>T</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a88b208143e81817f52a98a482c4a8e02" name="value_type"><type>T</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a6461b2607cae8cf84b803af4db6d28dc" name="void_ptr"><type>boost::container::allocator_traits&lt; VoidAllocator &gt;::pointer</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1ae9c938b12bc709b1e97f28c53ef3e611" name="pointer"><type>boost::intrusive::pointer_traits&lt; void_ptr &gt;::template rebind_pointer&lt; T &gt;::type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a67bb07cfe6aa479c7a10d29e832fc6c6" name="reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a1cc5f09d6eaa53da3fd8e0f4280a1a2c" name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1aca0318eec0900fa638c0108198871eb5" name="const_deleter_pointer"><type>boost::intrusive::pointer_traits&lt; void_ptr &gt;::template rebind_pointer&lt; constDeleter &gt;::type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1ae03e4dd983290c721867e3b944f543f3" name="const_allocator_pointer"><type>boost::intrusive::pointer_traits&lt; void_ptr &gt;::template rebind_pointer&lt; constVoidAllocator &gt;::type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a9150799938dd3f9dc224fe054763e8ee"><description><para>Constructs an empty <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link>. Use_count() == 0 &amp;&amp; <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1afd7aa3cbdadd00f7e21f011438a4275a">get()</link>== 0. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a7532cfda8a6045e6587297c19edae53c" specifiers="explicit"><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="a"><paramtype>const VoidAllocator &amp;</paramtype><default>VoidAllocator()</default></parameter><parameter name="d"><paramtype>const Deleter &amp;</paramtype><default>Deleter()</default></parameter><description><para>Constructs a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> that owns the pointer p. Auxiliary data will be allocated with a copy of a and the object will be deleted with a copy of d. Requirements: Deleter and A's copy constructor must not throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a264ca317d2ad4d6088542c6e9abce6f5"><parameter name="r"><paramtype>const <classname>shared_ptr</classname> &amp;</paramtype></parameter><description><para>Copy constructs a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link>. If r is empty, constructs an empty <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link>. Otherwise, constructs a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> that shares ownership with r. Never throws. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a56fffd7611b004859f4c6b0cae9dd2ca"><parameter name="other"><paramtype>const <classname>shared_ptr</classname> &amp;</paramtype></parameter><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Constructs a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> that shares ownership with other and stores p. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1afd7aa3cbdadd00f7e21f011438a4275a">get()</link> == p &amp;&amp; <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a8b5bf27c04529a61f95485c1a22f43b2">use_count()</link> == r.use_count(). Throws: nothing. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a75f6d677baaf2fd33869fafe6ffa878e"><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; Y, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><description><para>If r is empty, constructs an empty <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link>. Otherwise, constructs a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> that shares ownership with r. Never throws. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a2625cb1ddf4044f85edd00dcc9c94b8f" specifiers="explicit"><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>weak_ptr</classname>&lt; Y, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><description><para>Constructs a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> that shares ownership with r and stores a copy of the pointer stored in r. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a582f4eb88535f4d4a29adc4c90d9e994" specifiers="explicit"><parameter name="other"><paramtype><classname>shared_ptr</classname> &amp;&amp;</paramtype></parameter><description><para>Move-Constructs a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> that takes ownership of other resource and other is put in default-constructed state. Throws: nothing. </para></description></constructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1af7dc2decc7eda869ee42975fb258be35"><type><classname>shared_ptr</classname> &amp;</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; Y, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><description><para>Equivalent to shared_ptr(r).swap(*this). Never throws </para></description></copy-assignment>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a6d6ca5630fc2df1e7ea804cf64037b06"><type><classname>shared_ptr</classname> &amp;</type><parameter name="r"><paramtype>BOOST_COPY_ASSIGN_REF(<classname>shared_ptr</classname>)</paramtype></parameter><description><para>Equivalent to shared_ptr(r).swap(*this). Never throws </para></description></copy-assignment>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a5872b285424dbfd70651d9f404f3d932"><type><classname>shared_ptr</classname> &amp;</type><parameter name="other"><paramtype><classname>shared_ptr</classname> &amp;&amp;</paramtype></parameter><description><para>Move-assignment. Equivalent to shared_ptr(other).swap(*this). Never throws </para></description></copy-assignment>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a1e1ddcf08cc644fb9bafbb1ec7f5e67d" name="reset"><type>void</type><description><para>This is equivalent to: this_type().swap(*this); </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a94180a982830fbe620450271a750014e" name="reset"><type>void</type><template>
          <template-type-parameter name="Pointer"/>
        </template><parameter name="p"><paramtype>const Pointer &amp;</paramtype></parameter><parameter name="a"><paramtype>const VoidAllocator &amp;</paramtype><default>VoidAllocator()</default></parameter><parameter name="d"><paramtype>const Deleter &amp;</paramtype><default>Deleter()</default></parameter><description><para>This is equivalent to: this_type(p, a, d).swap(*this); </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a430f25700cdc9ed88f04c2e881e49538" name="reset"><type>void</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; Y, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a3b5f5988f515f610054a95b0d3b33b28" name="operator*" cv="const"><type>reference</type><description><para>Returns a reference to the pointed type </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a92cda07048c91eb44a002269d6304e6c" name="operator-&gt;" cv="const"><type>pointer</type><description><para>Returns the pointer pointing to the owned object </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1afd7aa3cbdadd00f7e21f011438a4275a" name="get" cv="const"><type>pointer</type><description><para>Returns the pointer pointing to the owned object </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1aa608eca8c322bd678ebc365bedd214b2" name="operator!" cv="const"><type>bool</type><description><para>Not operator. Returns true if this-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1afd7aa3cbdadd00f7e21f011438a4275a">get()</link> != 0, false otherwise </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1ab90d9b6271161c6a72b7ec07668b0b5e" name="unique" cv="const"><type>bool</type><description><para>Returns <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a8b5bf27c04529a61f95485c1a22f43b2">use_count()</link> == 1. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1ab90d9b6271161c6a72b7ec07668b0b5e">unique()</link> might be faster than <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a8b5bf27c04529a61f95485c1a22f43b2">use_count()</link> </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a8b5bf27c04529a61f95485c1a22f43b2" name="use_count" cv="const"><type>long</type><description><para>Returns the number of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> objects, *this included, that share ownership with *this, or an unspecified nonnegative value when *this is empty. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a8b5bf27c04529a61f95485c1a22f43b2">use_count()</link> is not necessarily efficient. Use only for debugging and testing purposes, not for production code. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr_1a5a304307f05056f1c60a89aed533bff6" name="swap"><type>void</type><parameter name="other"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; &amp;</paramtype></parameter><description><para>Exchanges the contents of the two smart pointers. </para></description></method>
</method-group>
</class>



























<function id="doxygen.boost_interprocess_header_reference.shared__ptr_8hpp_1a607325de4b91b768445b582af26e22de" name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="VoidAllocator2"/>
          <template-type-parameter name="Deleter2"/>
        </template><parameter name="a"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>shared_ptr</classname>&lt; U, VoidAllocator2, Deleter2 &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.boost_interprocess_header_reference.shared__ptr_8hpp_1a284cc47107231d33e16144752969a55e" name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="VoidAllocator2"/>
          <template-type-parameter name="Deleter2"/>
        </template><parameter name="a"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>shared_ptr</classname>&lt; U, VoidAllocator2, Deleter2 &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.boost_interprocess_header_reference.shared__ptr_8hpp_1a7a4a1efe7e6fa8335f3c683904869360" name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="VoidAllocator2"/>
          <template-type-parameter name="Deleter2"/>
        </template><parameter name="a"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>shared_ptr</classname>&lt; U, VoidAllocator2, Deleter2 &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.boost_interprocess_header_reference.shared__ptr_8hpp_1a869d2625c947d5dc8ef4216ae962332b" name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
        </template><parameter name="a"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; &amp;</paramtype></parameter></function>
<function id="doxygen.boost_interprocess_header_reference.shared__ptr_8hpp_1a99f3a884f291359136a2b4f8597ce352" name="static_pointer_cast"><type><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
          <template-type-parameter name="U"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; U, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.boost_interprocess_header_reference.shared__ptr_8hpp_1a3cf3aa35088e652879bcc7d7460e0954" name="const_pointer_cast"><type><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
          <template-type-parameter name="U"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; U, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.boost_interprocess_header_reference.shared__ptr_8hpp_1a2f7e8d531a67d77ef3f013f4dc5bfe0f" name="dynamic_pointer_cast"><type><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
          <template-type-parameter name="U"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; U, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.boost_interprocess_header_reference.shared__ptr_8hpp_1ad937107d3b464b64c85545c2edf3ceab" name="to_raw_pointer"><type>T *</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
        </template><parameter name="p"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.boost_interprocess_header_reference.shared__ptr_8hpp_1a16dfb344441e91bc7e412b70d500c3f5" name="operator&lt;&lt;"><type>std::basic_ostream&lt; E, T &gt; &amp;</type><template>
          <template-type-parameter name="E"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; E, T &gt; &amp;</paramtype></parameter><parameter name="p"><paramtype><classname>shared_ptr</classname>&lt; Y, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.boost_interprocess_header_reference.shared__ptr_8hpp_1a946d9135de9f10bec397e4972c3160ac" name="make_managed_shared_ptr"><type><classname>managed_shared_ptr</classname>&lt; T, ManagedMemory &gt;::type</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="ManagedMemory"/>
        </template><parameter name="constructed_object"><paramtype>T *</paramtype></parameter><parameter name="managed_memory"><paramtype>ManagedMemory &amp;</paramtype></parameter><description><para>Returns an instance of a shared pointer constructed with the default allocator and deleter from a pointer of type T that has been allocated in the passed managed segment </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.shared__ptr_8hpp_1a4bf0491e19d1da36ef55e7a00ba2b8a3" name="make_managed_shared_ptr"><type><classname>managed_shared_ptr</classname>&lt; T, ManagedMemory &gt;::type</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="ManagedMemory"/>
        </template><parameter name="constructed_object"><paramtype>T *</paramtype></parameter><parameter name="managed_memory"><paramtype>ManagedMemory &amp;</paramtype></parameter><parameter name=""><paramtype>const std::nothrow_t &amp;</paramtype></parameter><description><para>Returns an instance of a shared pointer constructed with the default allocator and deleter from a pointer of type T that has been allocated in the passed managed segment. Does not throw, return null shared pointer in error. </para></description></function>












</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.unique__ptr_8hpp" name="boost/interprocess/smart_ptr/unique_ptr.hpp">
<para>This header provides utilities to define a unique_ptr that plays nicely with managed segments. </para><namespace name="boost">
<namespace name="interprocess">
<struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1managed__unique__ptr" name="managed_unique_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="ManagedMemory"/>
    </template><description><para>Returns the type of a unique pointer of type T with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1deleter">boost::interprocess::deleter</link> deleter that can be constructed in the given managed segment type. </para></description><typedef id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1managed__unique__ptr_1ae704ecdfe322d4834a2c86e9153fc590" name="type"><type>boost::movelib::unique_ptr&lt; T, typename ManagedMemory::template <classname>deleter</classname>&lt; T &gt;::type &gt;</type></typedef>
</struct>


























<function id="doxygen.boost_interprocess_header_reference.unique__ptr_8hpp_1a754f4149b2f08b6e2a50327bb6083585" name="make_managed_unique_ptr"><type><classname>managed_unique_ptr</classname>&lt; T, ManagedMemory &gt;::type</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="ManagedMemory"/>
        </template><parameter name="constructed_object"><paramtype>T *</paramtype></parameter><parameter name="managed_memory"><paramtype>ManagedMemory &amp;</paramtype></parameter><description><para>Returns an instance of a unique pointer constructed with boost::interproces::deleter from a pointer of type T that has been allocated in the passed managed segment </para></description></function>























</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.weak__ptr_8hpp" name="boost/interprocess/smart_ptr/weak_ptr.hpp">
<para>Describes the smart pointer weak_ptr. </para><namespace name="boost">
<namespace name="interprocess">
<struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1managed__weak__ptr" name="managed_weak_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="ManagedMemory"/>
    </template><description><para>Returns the type of a weak pointer of type T with the allocator <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1allocator">boost::interprocess::allocator</link> allocator and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1deleter">boost::interprocess::deleter</link> deleter that can be constructed in the given managed segment type. </para></description><typedef id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1managed__weak__ptr_1a18f990b5cb62e83ce28f46997bbc6ff0" name="type"><type><classname>weak_ptr</classname>&lt; T, typename ManagedMemory::template <classname>allocator</classname>&lt; void &gt;::type, typename ManagedMemory::template <classname>deleter</classname>&lt; T &gt;::type &gt;</type></typedef>
</struct><class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr" name="weak_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="VoidAllocator"/>
      <template-type-parameter name="Deleter"/>
    </template><description><para>The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr">weak_ptr</link> class template stores a "weak reference" to an object that's already managed by a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link>. To access the object, a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr">weak_ptr</link> can be converted to a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> using the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> constructor or the member function lock. When the last <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> to the object goes away and the object is deleted, the attempt to obtain a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> from the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr">weak_ptr</link> instances that refer to the deleted object will fail: the constructor will throw an exception of type bad_weak_ptr, and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1a6584724f3e78adb3d3fe89d731a1aeb0">weak_ptr::lock</link> will return an empty <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link>.</para><para>Every <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr">weak_ptr</link> meets the CopyConstructible and Assignable requirements of the C++ Standard Library, and so can be used in standard library containers. Comparison operators are supplied so that <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr">weak_ptr</link> works with the standard library's associative containers.</para><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr">weak_ptr</link> operations never throw exceptions.</para><para>The class template is parameterized on T, the type of the object pointed to. </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1af5753ba11f1fad192b446c65abf85bdc" name="element_type"><type>T</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1ace27a9a041f7c8de280bb554f3253bd7" name="value_type"><type>T</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1aeddbfcb8b7ba2174d61c59c5846bf607"><description><para>Effects: Constructs an empty <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr">weak_ptr</link>. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1ab3b67d0064b8f84fd596725e3fdaef76">use_count()</link> == 0. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1a2a57ae8bb7ee21073a4ed68fa2b785b9"><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>weak_ptr</classname>&lt; Y, A, D &gt; const &amp;</paramtype></parameter><description><para>Effects: If r is empty, constructs an empty <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr">weak_ptr</link>; otherwise, constructs a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr">weak_ptr</link> that shares ownership with r as if by storing a copy of the pointer stored in r.</para><para>Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1ab3b67d0064b8f84fd596725e3fdaef76">use_count()</link> == r.use_count().</para><para>Throws: nothing. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1ac697619bd89e549edc52eb126d542d2a"><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; Y, A, D &gt; const &amp;</paramtype></parameter><description><para>Effects: If r is empty, constructs an empty <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr">weak_ptr</link>; otherwise, constructs a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr">weak_ptr</link> that shares ownership with r as if by storing a copy of the pointer stored in r.</para><para>Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1ab3b67d0064b8f84fd596725e3fdaef76">use_count()</link> == r.use_count().</para><para>Throws: nothing. </para></description></constructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1a4a6c7843b08df6798cdb12caaadfd40c"><type><classname>weak_ptr</classname> &amp;</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>weak_ptr</classname>&lt; Y, A, D &gt; const &amp;</paramtype></parameter><description><para>Effects: Equivalent to weak_ptr(r).swap(*this).</para><para>Throws: nothing.</para><para>Notes: The implementation is free to meet the effects (and the implied guarantees) via different means, without creating a temporary. </para></description></copy-assignment>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1a803100d9fd06863337e7e69dfdd9bf6b"><type><classname>weak_ptr</classname> &amp;</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; Y, A, D &gt; const &amp;</paramtype></parameter><description><para>Effects: Equivalent to weak_ptr(r).swap(*this).</para><para>Throws: nothing.</para><para>Notes: The implementation is free to meet the effects (and the implied guarantees) via different means, without creating a temporary. </para></description></copy-assignment>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1a6584724f3e78adb3d3fe89d731a1aeb0" name="lock" cv="const"><type><classname>shared_ptr</classname>&lt; T, A, D &gt;</type><description><para>Returns: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1ac614508482f1e41a2531b85dfe45322c">expired()</link>? shared_ptr&lt;T&gt;(): shared_ptr&lt;T&gt;(*this).</para><para>Throws: nothing. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1ab3b67d0064b8f84fd596725e3fdaef76" name="use_count" cv="const"><type>long</type><description><para>Returns: 0 if *this is empty; otherwise, the number of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__ptr">shared_ptr</link> objects that share ownership with *this.</para><para>Throws: nothing.</para><para>Notes: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1ab3b67d0064b8f84fd596725e3fdaef76">use_count()</link> is not necessarily efficient. Use only for debugging and testing purposes, not for production code. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1ac614508482f1e41a2531b85dfe45322c" name="expired" cv="const"><type>bool</type><description><para>Returns: Returns: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1ab3b67d0064b8f84fd596725e3fdaef76">use_count()</link> == 0.</para><para>Throws: nothing.</para><para>Notes: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1ac614508482f1e41a2531b85dfe45322c">expired()</link> may be faster than <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1ab3b67d0064b8f84fd596725e3fdaef76">use_count()</link>. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1a634c9f74dab02e859a69a0ad0af7c3b6" name="reset"><type>void</type><description><para>Effects: Equivalent to: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1aeddbfcb8b7ba2174d61c59c5846bf607">weak_ptr()</link>.swap(*this). </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1weak__ptr_1a35e72aedd9c51af676f545be9182db9d" name="swap"><type>void</type><parameter name="other"><paramtype>this_type &amp;</paramtype></parameter><description><para>Effects: Exchanges the contents of the two smart pointers.</para><para>Throws: nothing. </para></description></method>
</method-group>
</class>























<function id="doxygen.boost_interprocess_header_reference.weak__ptr_8hpp_1a457905ec65abf3b6d03bd0ddaa087403" name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
          <template-type-parameter name="D"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="D2"/>
        </template><parameter name="a"><paramtype><classname>weak_ptr</classname>&lt; T, A, D &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>weak_ptr</classname>&lt; U, A2, D2 &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.boost_interprocess_header_reference.weak__ptr_8hpp_1ae799e74e178ffc961c6ac70411941493" name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
          <template-type-parameter name="D"/>
        </template><parameter name="a"><paramtype><classname>weak_ptr</classname>&lt; T, A, D &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>weak_ptr</classname>&lt; T, A, D &gt; &amp;</paramtype></parameter></function>
<function id="doxygen.boost_interprocess_header_reference.weak__ptr_8hpp_1a60fce6fe96124b684d113a427273e57d" name="make_managed_weak_ptr"><type><classname>managed_weak_ptr</classname>&lt; T, ManagedMemory &gt;::type</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="ManagedMemory"/>
        </template><parameter name="constructed_object"><paramtype>T *</paramtype></parameter><parameter name="managed_memory"><paramtype>ManagedMemory &amp;</paramtype></parameter><description><para>Returns an instance of a weak pointer constructed with the default allocator and deleter from a pointer of type T that has been allocated in the passed managed segment </para></description></function>
























</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.bufferstream_8hpp" name="boost/interprocess/streams/bufferstream.hpp">
<para>This file defines basic_bufferbuf, basic_ibufferstream, basic_obufferstream, and basic_bufferstream classes. These classes represent streamsbufs and streams whose sources or destinations are fixed size character buffers. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferbuf" name="basic_bufferbuf"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="CharTraits"/>
    </template><inherit access="public">std::basic_streambuf&lt; CharT, CharTraits &gt;</inherit><description><para>A streambuf class that controls the transmission of elements to and from a basic_xbufferstream. The elements are transmitted from a to a fixed size buffer </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferbuf_1afa15c8af27752e6f8bd9fc26c60f8187" name="char_type"><type>CharT</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferbuf_1a146da8ad2697f7eef3d1dccf82468990" name="int_type"><type>CharTraits::int_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferbuf_1ad17d9ba049f70d29b54dfa7e830622d4" name="pos_type"><type>CharTraits::pos_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferbuf_1a793f6a115ad094b41bfdd1b7729e546a" name="off_type"><type>CharTraits::off_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferbuf_1a7421ef4d6b121d950144b6bcc7ac761e" name="traits_type"><type>CharTraits</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferbuf_1a42a35b8504a88ed188e287e00c8b1424" name="basic_streambuf_t"><type>std::basic_streambuf&lt; char_type, traits_type &gt;</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferbuf_1a56763359069e10e1239f34f41fa79cc6" specifiers="explicit"><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Does not throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferbuf_1abeccd71ba33c1ae96301f160c9500b71" specifiers="explicit"><parameter name="buf"><paramtype>CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Assigns formatting buffer. Does not throw. </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferbuf_1ad5c3890fbeee951da3cb09b5bf7a8ef7" specifiers="virtual"/>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferbuf_1a69975ff7b4e2d821cac5940f7ae8ca2d" name="buffer" cv="const"><type>std::pair&lt; CharT *, std::size_t &gt;</type><description><para>Returns the pointer and size of the internal buffer. Does not throw. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferbuf_1a24cdf1393de3f4872791eb9f94119a0c" name="buffer"><type>void</type><parameter name="buf"><paramtype>CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><description><para>Sets the underlying buffer to a new value Does not throw. </para></description></method>
</method-group>
</class><class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferstream" name="basic_bufferstream"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="CharTraits"/>
    </template><inherit access="public">std::basic_iostream&lt; CharT, CharTraits &gt;</inherit><description><para>A basic_iostream class that uses a fixed size character buffer as its formatting buffer. </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferstream_1aad97a13d8d45199bb955454e3e928a4f" name="char_type"><type>std::basic_ios&lt; CharT, CharTraits &gt;::char_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferstream_1a80bc10fce9d9d38d01d90e2cdba88242" name="int_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::int_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferstream_1aa9a1237c022ee5b418c014d3d75b8b9e" name="pos_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::pos_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferstream_1a3b8472ce9d68c9e3cda253000c7eca2d" name="off_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::off_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferstream_1a5579bd5b29d76e083e0aefd5eadd5147" name="traits_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::traits_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferstream_1a01cf81240906015916d000ccd5dc601d"><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Does not throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferstream_1ac030345636c78720bdeea8301f099676"><parameter name="buf"><paramtype>CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Assigns formatting buffer. Does not throw. </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferstream_1a496369f97e85858bac0f34310b2f4434"/>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferstream_1aeb814f976a3ff5ab090ef7de1001f8c4" name="rdbuf" cv="const"><type><classname>basic_bufferbuf</classname>&lt; CharT, CharTraits &gt; *</type><description><para>Returns the address of the stored stream buffer. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferstream_1a816d55305b9c580917c9d9b3e9f45356" name="buffer" cv="const"><type>std::pair&lt; CharT *, std::size_t &gt;</type><description><para>Returns the pointer and size of the internal buffer. Does not throw. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__bufferstream_1a5074b97c8406764d4c4b778ac62da02c" name="buffer"><type>void</type><parameter name="buf"><paramtype>CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><description><para>Sets the underlying buffer to a new value. Resets stream position. Does not throw. </para></description></method>
</method-group>
</class><class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ibufferstream" name="basic_ibufferstream"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="CharTraits"/>
    </template><inherit access="public">std::basic_istream&lt; CharT, CharTraits &gt;</inherit><description><para>A basic_istream class that uses a fixed size character buffer as its formatting buffer. </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ibufferstream_1a279d26348afb85e7bac6baabc10d2274" name="char_type"><type>std::basic_ios&lt; CharT, CharTraits &gt;::char_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ibufferstream_1aedce8e7236f5ade066c866f9ef23a1c5" name="int_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::int_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ibufferstream_1ad4036835ce89f9e0914397bf5b9667d0" name="pos_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::pos_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ibufferstream_1afddd1353d84e76c0cdc6e191ab41e169" name="off_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::off_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ibufferstream_1a2c25c0349d914715f252961ecea3ebbc" name="traits_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::traits_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ibufferstream_1a773cbb0f79a5f25ff736d0bce5673c25"><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in</default></parameter><description><para>Constructor. Does not throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ibufferstream_1ab9431545460e2bf455452d5ae3878a51"><parameter name="buf"><paramtype>const CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in</default></parameter><description><para>Constructor. Assigns formatting buffer. Does not throw. </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ibufferstream_1ab9584683993da5a28260053cdcc04e90"/>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ibufferstream_1a46ba2e5eed9507a685846568d411ead1" name="rdbuf" cv="const"><type><classname>basic_bufferbuf</classname>&lt; CharT, CharTraits &gt; *</type><description><para>Returns the address of the stored stream buffer. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ibufferstream_1a7f8004834bbb99dfb496a12d22dfea1d" name="buffer" cv="const"><type>std::pair&lt; const CharT *, std::size_t &gt;</type><description><para>Returns the pointer and size of the internal buffer. Does not throw. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ibufferstream_1afe7842fcba3355f7ce38808c344ad263" name="buffer"><type>void</type><parameter name="buf"><paramtype>const CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><description><para>Sets the underlying buffer to a new value. Resets stream position. Does not throw. </para></description></method>
</method-group>
</class><class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__obufferstream" name="basic_obufferstream"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="CharTraits"/>
    </template><inherit access="public">std::basic_ostream&lt; CharT, CharTraits &gt;</inherit><description><para>A basic_ostream class that uses a fixed size character buffer as its formatting buffer. </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__obufferstream_1ac61aca68caac463d931469e5b12cb718" name="char_type"><type>std::basic_ios&lt; CharT, CharTraits &gt;::char_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__obufferstream_1a7a1a873e818779a8866bd8d1838dd806" name="int_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::int_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__obufferstream_1a9b9e2153af4199d599d1712b1ca3d145" name="pos_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::pos_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__obufferstream_1a478515e8d53202df146a15f472912d87" name="off_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::off_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__obufferstream_1a8007a265aa0fe82f73cccd5b41ea59a6" name="traits_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::traits_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__obufferstream_1a173961e14d376ea3da8e7cf378c0f9bc"><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::out</default></parameter><description><para>Constructor. Does not throw. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__obufferstream_1a3fd1e8247fb6916f9c328d2eef02b9a7"><parameter name="buf"><paramtype>CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::out</default></parameter><description><para>Constructor. Assigns formatting buffer. Does not throw. </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__obufferstream_1a5eb553566c56f81d161a1c5e394f7884"/>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__obufferstream_1ae5ee76d955b6e429768cb7a5fbafa12e" name="rdbuf" cv="const"><type><classname>basic_bufferbuf</classname>&lt; CharT, CharTraits &gt; *</type><description><para>Returns the address of the stored stream buffer. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__obufferstream_1a90940a3ee609ec6cf4faa486a199fdac" name="buffer" cv="const"><type>std::pair&lt; CharT *, std::size_t &gt;</type><description><para>Returns the pointer and size of the internal buffer. Does not throw. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__obufferstream_1a4c00d9619b88889b518be7eabecac8ad" name="buffer"><type>void</type><parameter name="buf"><paramtype>CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><description><para>Sets the underlying buffer to a new value. Resets stream position. Does not throw. </para></description></method>
</method-group>
</class><typedef id="doxygen.boost_interprocess_header_reference.bufferstream_8hpp_1ab37579b2c04cd0959c63f88e92ee03e5" name="bufferbuf"><type><classname>basic_bufferbuf</classname>&lt; char &gt;</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.bufferstream_8hpp_1a5a8ba5aa66a5047ec30e7cd2bda5c6fb" name="bufferstream"><type><classname>basic_bufferstream</classname>&lt; char &gt;</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.bufferstream_8hpp_1acda31db7778cdb95eea18d511d93f2d7" name="ibufferstream"><type><classname>basic_ibufferstream</classname>&lt; char &gt;</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.bufferstream_8hpp_1ad68227a65cd4139d76fe04e2eed52270" name="obufferstream"><type><classname>basic_obufferstream</classname>&lt; char &gt;</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.bufferstream_8hpp_1ae80e4b0788941008db00c0029fd94de6" name="wbufferbuf"><type><classname>basic_bufferbuf</classname>&lt; wchar_t &gt;</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.bufferstream_8hpp_1af92d54c26f2586661cd9684faa3cba27" name="wbufferstream"><type><classname>basic_bufferstream</classname>&lt; wchar_t &gt;</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.bufferstream_8hpp_1ae9f950cc159def46a4720333b377e46e" name="wibufferstream"><type><classname>basic_ibufferstream</classname>&lt; wchar_t &gt;</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.bufferstream_8hpp_1a9cb3ecd708e474b36593e750254937bd" name="wobufferstream"><type><classname>basic_obufferstream</classname>&lt; wchar_t &gt;</type></typedef>



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.vectorstream_8hpp" name="boost/interprocess/streams/vectorstream.hpp">
<para>This file defines basic_vectorbuf, basic_ivectorstream, basic_ovectorstream, and basic_vectorstreamclasses. These classes represent streamsbufs and streams whose sources or destinations are STL-like vectors that can be swapped with external vectors to avoid unnecessary allocations/copies. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ivectorstream" name="basic_ivectorstream"><template>
      <template-type-parameter name="CharVector"/>
      <template-type-parameter name="CharTraits"/>
    </template><inherit access="public">std::basic_istream&lt; CharVector::value_type, CharTraits &gt;</inherit><description><para>A basic_istream class that holds a character vector specified by CharVector template parameter as its formatting buffer. The vector must have contiguous storage, like std::vector, boost::interprocess::vector or boost::interprocess::basic_string </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ivectorstream_1a239553abfece12f0d47c5b85fd764afb" name="vector_type"><type>CharVector</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ivectorstream_1a65ccb2aa008c93ffbb56d876c2d5e169" name="char_type"><type>std::basic_ios&lt; typenameCharVector::value_type, CharTraits &gt;::char_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ivectorstream_1aef487d02d803da688c6ffe526a053b62" name="int_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::int_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ivectorstream_1a02cc9356847b9252a6d26cde28578621" name="pos_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::pos_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ivectorstream_1af1191022a7ade35363d45c531c09d95f" name="off_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::off_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ivectorstream_1a36e4abc4a4e2dd392ab3a003ac96a4a6" name="traits_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::traits_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ivectorstream_1a49c326602de9a3459969042cbcce21c6"><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in</default></parameter><description><para>Constructor. Throws if vector_type default constructor throws. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ivectorstream_1a06fa8ab3856d98ac304da5f4abfbba07"><template>
          <template-type-parameter name="VectorParameter"/>
        </template><parameter name="param"><paramtype>const VectorParameter &amp;</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in</default></parameter><description><para>Constructor. Throws if vector_type(const VectorParameter &amp;param) throws. </para></description></constructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ivectorstream_1a31ac361a8108e6f87426205cdd4fa3b5" name="rdbuf" cv="const"><type><classname>basic_vectorbuf</classname>&lt; CharVector, CharTraits &gt; *</type><description><para>Returns the address of the stored stream buffer. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ivectorstream_1a92e6aabc2f88c9d029ac080ac73ca68d" name="swap_vector"><type>void</type><parameter name="vect"><paramtype>vector_type &amp;</paramtype></parameter><description><para>Swaps the underlying vector with the passed vector. This function resets the read position in the stream. Does not throw. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ivectorstream_1a2c5676966d073f407340d0dcb88814a3" name="vector" cv="const"><type>const vector_type &amp;</type><description><para>Returns a const reference to the internal vector. Does not throw. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ivectorstream_1a57abadfdde6e681e9d88c6534f0f8610" name="reserve"><type>void</type><parameter name="size"><paramtype>typename vector_type::size_type</paramtype></parameter><description><para>Calls <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ivectorstream_1a57abadfdde6e681e9d88c6534f0f8610">reserve()</link> method of the internal vector. Resets the stream to the first position. Throws if the internals vector's reserve throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ivectorstream_1a01913eb1ed4fc9d8d77fec04e3d4856d" name="clear"><type>void</type><description><para>Calls <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ivectorstream_1a01913eb1ed4fc9d8d77fec04e3d4856d">clear()</link> method of the internal vector. Resets the stream to the first position. </para></description></method>
</method-group>
</class><class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ovectorstream" name="basic_ovectorstream"><template>
      <template-type-parameter name="CharVector"/>
      <template-type-parameter name="CharTraits"/>
    </template><inherit access="public">std::basic_ostream&lt; CharVector::value_type, CharTraits &gt;</inherit><description><para>A basic_ostream class that holds a character vector specified by CharVector template parameter as its formatting buffer. The vector must have contiguous storage, like std::vector, boost::interprocess::vector or boost::interprocess::basic_string </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ovectorstream_1a63e96125400dd8272e1189101c92b93f" name="vector_type"><type>CharVector</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ovectorstream_1a1f54b032a5adf82f40966f4cbf76591f" name="char_type"><type>std::basic_ios&lt; typenameCharVector::value_type, CharTraits &gt;::char_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ovectorstream_1a7ddd0f0b00871e1a9d55d09704d919bc" name="int_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::int_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ovectorstream_1aa40c1a16d32eca25e2925cc8fe566f0b" name="pos_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::pos_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ovectorstream_1a519217ab41cdf86976eaebe994e9cfca" name="off_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::off_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ovectorstream_1a4cd4d2e4f6da2a0d931438e74247b725" name="traits_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::traits_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ovectorstream_1a929dbc22234d8c69a788e1df819dd625"><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::out</default></parameter><description><para>Constructor. Throws if vector_type default constructor throws. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ovectorstream_1a57df68fe9fa08e2efd3f24a2511df8fd"><template>
          <template-type-parameter name="VectorParameter"/>
        </template><parameter name="param"><paramtype>const VectorParameter &amp;</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::out</default></parameter><description><para>Constructor. Throws if vector_type(const VectorParameter &amp;param) throws. </para></description></constructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ovectorstream_1ab349aa74673192baa228914da34a453f" name="rdbuf" cv="const"><type><classname>basic_vectorbuf</classname>&lt; CharVector, CharTraits &gt; *</type><description><para>Returns the address of the stored stream buffer. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ovectorstream_1a424f3d26398163eaed550635e9219c21" name="swap_vector"><type>void</type><parameter name="vect"><paramtype>vector_type &amp;</paramtype></parameter><description><para>Swaps the underlying vector with the passed vector. This function resets the write position in the stream. Does not throw. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ovectorstream_1a63fe834402688f59d679d8e4d4b006d3" name="vector" cv="const"><type>const vector_type &amp;</type><description><para>Returns a const reference to the internal vector. Does not throw. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ovectorstream_1a66d3e3f39eab5924c1eeb3efdf4e30e8" name="reserve"><type>void</type><parameter name="size"><paramtype>typename vector_type::size_type</paramtype></parameter><description><para>Calls <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ovectorstream_1a66d3e3f39eab5924c1eeb3efdf4e30e8">reserve()</link> method of the internal vector. Resets the stream to the first position. Throws if the internals vector's reserve throws. </para></description></method>
</method-group>
</class><class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorbuf" name="basic_vectorbuf"><template>
      <template-type-parameter name="CharVector"/>
      <template-type-parameter name="CharTraits"/>
    </template><inherit access="public">std::basic_streambuf&lt; CharVector::value_type, CharTraits &gt;</inherit><description><para>A streambuf class that controls the transmission of elements to and from a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ivectorstream">basic_ivectorstream</link>, <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__ovectorstream">basic_ovectorstream</link> or <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorstream">basic_vectorstream</link>. It holds a character vector specified by CharVector template parameter as its formatting buffer. The vector must have contiguous storage, like std::vector, boost::interprocess::vector or boost::interprocess::basic_string </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorbuf_1a024bb1dc7946d6f45b6d49755b2f7028" name="vector_type"><type>CharVector</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorbuf_1a5325e0fc6f4609ae57c02c58b5fab9c9" name="char_type"><type>CharVector::value_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorbuf_1a527c7d6d2ca0d034f20788b7ed532ee0" name="int_type"><type>CharTraits::int_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorbuf_1abe31d471e9d35f3349deeded74ff2fe2" name="pos_type"><type>CharTraits::pos_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorbuf_1aac2a0faa52697b6427be63f3ca057df7" name="off_type"><type>CharTraits::off_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorbuf_1ad16aaf156ffa922f16d318cd36f16a2f" name="traits_type"><type>CharTraits</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorbuf_1a7cfc325b6aac7fa1e2c5e1ee8b221f0b" specifiers="explicit"><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Throws if vector_type default constructor throws. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorbuf_1a109da8e875159d1a1e1f8888a632a26b" specifiers="explicit"><template>
          <template-type-parameter name="VectorParameter"/>
        </template><parameter name="param"><paramtype>const VectorParameter &amp;</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Throws if vector_type(const VectorParameter &amp;param) throws. </para></description></constructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorbuf_1a26908e41573af50a3bca8deaaab34bb9" name="swap_vector"><type>void</type><parameter name="vect"><paramtype>vector_type &amp;</paramtype></parameter><description><para>Swaps the underlying vector with the passed vector. This function resets the read/write position in the stream. Does not throw. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorbuf_1a1ae0154ea77a16e590c0560f68b9032a" name="vector" cv="const"><type>const vector_type &amp;</type><description><para>Returns a const reference to the internal vector. Does not throw. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorbuf_1a8be437c9bcac1ad3880cef5f802b25eb" name="reserve"><type>void</type><parameter name="size"><paramtype>typename vector_type::size_type</paramtype></parameter><description><para>Preallocates memory from the internal vector. Resets the stream to the first position. Throws if the internals vector's memory allocation throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorbuf_1a9f622d672f18cee7b8e74bf20c76d48f" name="clear"><type>void</type><description><para>Calls <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorbuf_1a9f622d672f18cee7b8e74bf20c76d48f">clear()</link> method of the internal vector. Resets the stream to the first position. </para></description></method>
</method-group>
</class><class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorstream" name="basic_vectorstream"><template>
      <template-type-parameter name="CharVector"/>
      <template-type-parameter name="CharTraits"/>
    </template><inherit access="public">std::basic_iostream&lt; CharVector::value_type, CharTraits &gt;</inherit><description><para>A basic_iostream class that holds a character vector specified by CharVector template parameter as its formatting buffer. The vector must have contiguous storage, like std::vector, boost::interprocess::vector or boost::interprocess::basic_string </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorstream_1a986e8b0d4979cf782cad3f5d760e212a" name="vector_type"><type>CharVector</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorstream_1a008be025861b7c269ada9084b250ba22" name="char_type"><type>std::basic_ios&lt; typenameCharVector::value_type, CharTraits &gt;::char_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorstream_1a08164c8bda3eb264dcc886adac74d967" name="int_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::int_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorstream_1ad7b306daa84816941a5460630bc24318" name="pos_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::pos_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorstream_1ae00138536d02e113eb5be78c8e879172" name="off_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::off_type</type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorstream_1aa2757efe95f28155dbcc0bb9435d99ad" name="traits_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::traits_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorstream_1a27e9ab170508d087cf9ac0ec85a0a6e4"><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Throws if vector_type default constructor throws. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorstream_1a70ba3ad4d49a1cefbcd1b18309e4a879"><template>
          <template-type-parameter name="VectorParameter"/>
        </template><parameter name="param"><paramtype>const VectorParameter &amp;</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Throws if vector_type(const VectorParameter &amp;param) throws. </para></description></constructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorstream_1a315dcffa225d7bd0e50a0292f21f9c47" name="rdbuf" cv="const"><type><classname>basic_vectorbuf</classname>&lt; CharVector, CharTraits &gt; *</type></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorstream_1a5c7f7eb019a129de09556e5fd924db6c" name="swap_vector"><type>void</type><parameter name="vect"><paramtype>vector_type &amp;</paramtype></parameter><description><para>Swaps the underlying vector with the passed vector. This function resets the read/write position in the stream. Does not throw. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorstream_1a80ce0d8c64b7e0f7fdd2b09e7380c64d" name="vector" cv="const"><type>const vector_type &amp;</type><description><para>Returns a const reference to the internal vector. Does not throw. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorstream_1ae7457b17a3c82d1404418e86035416e7" name="reserve"><type>void</type><parameter name="size"><paramtype>typename vector_type::size_type</paramtype></parameter><description><para>Calls <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorstream_1ae7457b17a3c82d1404418e86035416e7">reserve()</link> method of the internal vector. Resets the stream to the first position. Throws if the internals vector's reserve throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorstream_1ade39ce926842330eb0de681360277083" name="clear"><type>void</type><description><para>Calls <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1basic__vectorstream_1ade39ce926842330eb0de681360277083">clear()</link> method of the internal vector. Resets the stream to the first position. </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.cv__status_8hpp" name="boost/interprocess/sync/cv_status.hpp">
<namespace name="boost">
<namespace name="interprocess">
<enum id="doxygen.boost_interprocess_header_reference.cv__status_8hpp_1ab8b8d84b7ea2d2b72450e1144a21c0fc" name="cv_status"><enumvalue id="doxygen.boost_interprocess_header_reference.cv__status_8hpp_1ab8b8d84b7ea2d2b72450e1144a21c0fca70d61392e69e95a8c7f9603306634cbd" name="no_timeout"/><enumvalue id="doxygen.boost_interprocess_header_reference.cv__status_8hpp_1ab8b8d84b7ea2d2b72450e1144a21c0fca90272dda245ae1fb3cf197e91a8689dc" name="timeout"/></enum>



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.file__lock_8hpp" name="boost/interprocess/sync/file_lock.hpp">
<para>Describes a class that wraps file locking capabilities. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock" name="file_lock"><description><para>A file lock, is a mutual exclusion utility similar to a mutex using a file. A file lock has sharable and exclusive locking capabilities and can be used with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> classes. A file lock can't guarantee synchronization between threads of the same process so just use file locks to synchronize threads from different processes. </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1a2d7bc116603676749ec9b54f88d6377f" cv="noexcept"><description><para>Constructs an empty file mapping. Does not throw </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1adfabfb38b63d9a49c715654766e29609"><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a file lock. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> if the file does not exist or there are no operating system resources. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1a2f227f89306acfc09b64ccdbc29cb3cf"><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Opens a file lock. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> if the file does not exist or there are no operating system resources.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1a85671a1f6ed3ff31585649f1c1d70daf" cv="noexcept"><parameter name="moved"><paramtype><classname>file_lock</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s file mapping object to *this. After the call, "moved" does not represent any file mapping object. Does not throw </para></description></constructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1a5f95c28133e5b5db0773a3366e0d39d0" cv="noexcept"><type><classname>file_lock</classname> &amp;</type><parameter name="moved"><paramtype><classname>file_lock</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s file mapping to *this. After the call, "moved" does not represent any file mapping. Does not throw </para></description></copy-assignment>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1a12f7ac4e5151281b937dc95df2a1af33"><purpose>Closes a file lock. Does not throw. </purpose></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1af62a63603f16aaa484d43bd1654c9cb7" name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>file_lock</classname> &amp;</paramtype></parameter><description><para>Swaps two file_locks. Does not throw. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1aed7c17b66fd26ba505b9b6eeb680ddf1" name="lock"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain exclusive ownership of the mutex, and if another thread has exclusive, or sharable ownership of the mutex, it waits until it can obtain the ownership. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1a2c15c43072c92a89cfb6339241effe93" name="try_lock"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex without waiting. If no other thread has exclusive, or sharable ownership of the mutex this succeeds. Returns: If it can acquire exclusive ownership immediately returns true. If it has to wait, returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1a94235c95ab47c1561096f4726da5aa73" name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex waiting if necessary until no other thread has exclusive, or sharable ownership of the mutex or abs_time is reached. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1a462fdae065ee93e952e112b17ce27756" name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1aaba12f4923439cb047768a6d1e73eecb" name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1a2672913a254aad2b44e8232757b90f02" name="unlock"><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The calling thread releases the exclusive ownership of the mutex. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1afb87ed5639b06e1517c0bc15a1f2f07f" name="lock_sharable"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain sharable ownership of the mutex, and if another thread has exclusive ownership of the mutex, waits until it can obtain the ownership. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that owns a mutex object calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1a43c9cf41d63f8ae21e8b2c9f21ff0bb3" name="lock_shared"><type>void</type><description><para>Same as <computeroutput>lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1ad1f8183defe5442a2bff3fefa0104b55" name="try_lock_sharable"><type>bool</type><description><para>Effects: The calling thread tries to acquire sharable ownership of the mutex without waiting. If no other thread has exclusive ownership of the mutex this succeeds. Returns: If it can acquire sharable ownership immediately returns true. If it has to wait, returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1a094fb5aa626a9b45b2f4bbb1fb835d2b" name="try_lock_shared"><type>bool</type><description><para>Same as <computeroutput>try_lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1a759afc0b0ba35019cf30f4699d154873" name="timed_lock_sharable"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Effects: The calling thread tries to acquire sharable ownership of the mutex waiting if necessary until no other thread has exclusive ownership of the mutex or abs_time is reached. Returns: If acquires sharable ownership, returns true. Otherwise returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1aafa53077663605af3fc8b77cfaefa685" name="try_lock_shared_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1af432ff2721d89ed28e9ca05fcd45a8a6" name="try_lock_shared_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1a7cc41e8b3d4c71761d2ae7eb314e5a7f" name="unlock_sharable"><type>void</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The calling thread releases the sharable ownership of the mutex. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1file__lock_1a2c9887c3342b7ca8790d1cb0e5f39ee7" name="unlock_shared"><type>void</type><description><para>Same as <computeroutput>unlock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.interprocess__condition_8hpp" name="boost/interprocess/sync/interprocess_condition.hpp">
<para>Describes process-shared variables interprocess_condition class </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition" name="interprocess_condition"><description><para>This class is a condition variable that can be placed in shared memory or memory mapped files. Destroys the object of type std::condition_variable_any</para><para>Unlike std::condition_variable in C++11, it is NOT safe to invoke the destructor if all threads have been only notified. It is required that they have exited their respective wait functions. </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition_1a7fc15a5ebe3774056ef5f2dbfde0b83f"><purpose>Constructs a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition">interprocess_condition</link>. On error throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link>. </purpose></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition_1a3ac151debf9a6a30bd1b3e20128c0b8d"><description><para>Destroys *this liberating system resources. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition_1af36201a87a4b312f16a902613a152966" name="notify_one"><type>void</type><description><para>If there is a thread waiting on *this, change that thread's state to ready. Otherwise there is no effect. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition_1a625140964384f21f4f44248b0702dc8c" name="notify_all"><type>void</type><description><para>Change the state of all threads waiting on *this to ready. If there are no waiting threads, <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition_1a625140964384f21f4f44248b0702dc8c">notify_all()</link> has no effect. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition_1a3f9ef691d26ffebc1e19cc820f683068" name="wait"><type>void</type><template>
          <template-type-parameter name="L"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><description><para>Releases the lock on the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex">interprocess_mutex</link> object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition_1af36201a87a4b312f16a902613a152966">notify_one()</link> or this-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition_1a625140964384f21f4f44248b0702dc8c">notify_all()</link>, and then reacquires the lock. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition_1a0ca99e056250293e2f0cf69f3bb9b9d7" name="wait"><type>void</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) wait(lock) </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition_1aa65a9ea5020329dbf4f8d44a88ae300e" name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Releases the lock on the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex">interprocess_mutex</link> object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition_1af36201a87a4b312f16a902613a152966">notify_one()</link> or this-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition_1a625140964384f21f4f44248b0702dc8c">notify_all()</link>, or until time abs_time is reached, and then reacquires the lock. Returns: false if time abs_time is reached, otherwise true. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition_1ab0d9bbdd4aa7af2aa0137341c7f14a21" name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) { if (!timed_wait(lock, abs_time)) return pred(); } return true; </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition_1a50e8e156fd5e7d56cb4706a89dcd94c1" name="wait_until"><type>cv_status</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition_1a1a1ce83bed2cb45006f26d5a511d0c4a" name="wait_until"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition_1a271d6365b7e651309ea99fba9dd16d80" name="wait_for"><type>cv_status</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Duration"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface and uses relative timeouts. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition_1acd762fb53a969ceddef7a2f769b8cc0b" name="wait_for"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Duration"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface and uses relative timeouts </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.interprocess__condition__any_8hpp" name="boost/interprocess/sync/interprocess_condition_any.hpp">
<para>Describes process-shared variables interprocess_condition_any class </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any" name="interprocess_condition_any"><description><para>This class is a condition variable that can be placed in shared memory or memory mapped files.</para><para>The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any">interprocess_condition_any</link> class is a generalization of <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition">interprocess_condition</link>. Whereas <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition">interprocess_condition</link> works only on Locks with mutex_type == <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex">interprocess_mutex</link> <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any">interprocess_condition_any</link> can operate on any user-defined lock that meets the BasicLockable requirements (lock()/unlock() member functions).</para><para>Unlike std::condition_variable_any in C++11, it is NOT safe to invoke the destructor if all threads have been only notified. It is required that they have exited their respective wait functions. </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any_1a59d7c32c0d1899816dc8c9d43cdb6cc8"><purpose>Constructs a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any">interprocess_condition_any</link>. On error throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link>. </purpose></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any_1aa01d0dfc25737fec265608e189513da4"><description><para>Destroys *this liberating system resources. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any_1aa7dc7b5ccc8e982303956909d90a2002" name="notify_one"><type>void</type><description><para>If there is a thread waiting on *this, change that thread's state to ready. Otherwise there is no effect. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any_1ad37bcdfd1d9c6f00a4242cdb06a030d7" name="notify_all"><type>void</type><description><para>Change the state of all threads waiting on *this to ready. If there are no waiting threads, <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any_1ad37bcdfd1d9c6f00a4242cdb06a030d7">notify_all()</link> has no effect. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any_1a636ff42d2571e6b40c7185545623ed8e" name="wait"><type>void</type><template>
          <template-type-parameter name="L"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><description><para>Releases the lock on the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex">interprocess_mutex</link> object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any_1aa7dc7b5ccc8e982303956909d90a2002">notify_one()</link> or this-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any_1ad37bcdfd1d9c6f00a4242cdb06a030d7">notify_all()</link>, and then reacquires the lock. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any_1acdbaa2b48d3c69378188c94352517b48" name="wait"><type>void</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) wait(lock) </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any_1af4494cd3bcff07d03333c1d66c2cf19c" name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Releases the lock on the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex">interprocess_mutex</link> object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any_1aa7dc7b5ccc8e982303956909d90a2002">notify_one()</link> or this-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any_1ad37bcdfd1d9c6f00a4242cdb06a030d7">notify_all()</link>, or until time abs_time is reached, and then reacquires the lock. Returns: false if time abs_time is reached, otherwise true. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any_1a2015a61f29a5a07d81990c1dd1a5d7fc" name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) { if (!timed_wait(lock, abs_time)) return pred(); } return true; </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any_1acc7c1fd6f72723c98d638ad17bda6f47" name="wait_until"><type>cv_status</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any_1ad74ee9f71b80814b2c726a60c00d6ce9" name="wait_until"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any_1a73a3ab9c5e1b891e38dd4cc1247263bb" name="wait_for"><type>cv_status</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Duration"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface and uses relative timeouts. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__condition__any_1a41def1b6664b2367c9975a74f45a0f16" name="wait_for"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Duration"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface and uses relative timeouts </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.interprocess__mutex_8hpp" name="boost/interprocess/sync/interprocess_mutex.hpp">
<para>Describes a mutex class that can be placed in memory shared by several processes. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex" name="interprocess_mutex"><description><para>Wraps a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex">interprocess_mutex</link> that can be placed in shared memory and can be shared between processes. Allows timed lock tries </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex_1a50e3041f981f54d4cabe795db460732c"><description><para>Constructor. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex_1afdcacfd1bc430dc808bc431c36329f45"><description><para>Destructor. If any process uses the mutex after the destructor is called the result is undefined. Does not throw. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex_1ae767b22a33329ee2bad50486e43b8f74" name="lock"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain ownership of the mutex, and if another thread has ownership of the mutex, it waits until it can obtain the ownership. If a thread takes ownership of the mutex the mutex must be unlocked by the same mutex. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex_1af28ab0194789cc89d033d4cbb3962835" name="try_lock"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain ownership of the mutex, and if another thread has ownership of the mutex returns immediately. Returns: If the thread acquires ownership of the mutex, returns true, if the another thread has ownership of the mutex, returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex_1ae63e76cbaa61fbc42f0d78189bedf648" name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread will try to obtain exclusive ownership of the mutex if it can do so in until the specified time is reached. If the mutex supports recursive locking, the mutex must be unlocked the same number of times it is locked. Returns: If the thread acquires ownership of the mutex, returns true, if the timeout expires returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex_1afcf1093665b457c652f6e5ed27919dd8" name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex_1a49a981ddc4dd9158452376084beb05ba" name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex_1a14fa23cb158c88c564a038e21fccbe6e" name="unlock"><type>void</type><description><para>Effects: The calling thread releases the exclusive ownership of the mutex. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.interprocess__recursive__mutex_8hpp" name="boost/interprocess/sync/interprocess_recursive_mutex.hpp">
<para>Describes interprocess_recursive_mutex and shared_recursive_try_mutex classes </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__recursive__mutex" name="interprocess_recursive_mutex"><description><para>Wraps a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex">interprocess_mutex</link> that can be placed in shared memory and can be shared between processes. Allows several locking calls by the same process. Allows timed lock tries </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__recursive__mutex_1a404d12deab37f96d91dd5731108f92e8"><description><para>Constructor. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__recursive__mutex_1a167637d44bf2adc54bf6e739c937876a"><description><para>Destructor. If any process uses the mutex after the destructor is called the result is undefined. Does not throw. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__recursive__mutex_1af4b16acaf49305d56499836f0474e0cb" name="lock"><type>void</type><description><para>Effects: The calling thread tries to obtain ownership of the mutex, and if another thread has ownership of the mutex, it waits until it can obtain the ownership. If a thread takes ownership of the mutex the mutex must be unlocked by the same mutex. The mutex must be unlocked the same number of times it is locked. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program shall not deadlock if the thread that has ownership calls this function. <sbr/>
 </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__recursive__mutex_1a0e885f0c11ea9c032a504bf0bc23b760" name="try_lock"><type>bool</type><description><para>Tries to lock the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex">interprocess_mutex</link>, returns false when <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex">interprocess_mutex</link> is already locked, returns true when success. The mutex must be unlocked the same number of times it is locked. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> if a severe error is found</para><para>Note: A program shall not deadlock if the thread that has ownership calls this function. <sbr/>
 </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__recursive__mutex_1a997fed3dd67abdc24e45cbb86cebd796" name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Tries to lock the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex">interprocess_mutex</link>, if <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex">interprocess_mutex</link> can't be locked before abs_time time, returns false. The mutex must be unlocked the same number of times it is locked. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> if a severe error is found</para><para>Note: A program shall not deadlock if the thread that has ownership calls this function. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__recursive__mutex_1a275b00e3a8366bf2538bb2b779820b29" name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__recursive__mutex_1a1487d8ba99e5825dd67e9d64ee34a153" name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__recursive__mutex_1a90e3898f5893d07ecd17ccfa9fcfd009" name="unlock"><type>void</type><description><para>Effects: The calling thread releases the exclusive ownership of the mutex. If the mutex supports recursive locking, the mutex must be unlocked the same number of times it is locked. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.interprocess__semaphore_8hpp" name="boost/interprocess/sync/interprocess_semaphore.hpp">
<para>Describes a interprocess_semaphore class for inter-process synchronization </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore" name="interprocess_semaphore"><description><para>Wraps a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore">interprocess_semaphore</link> that can be placed in shared memory and can be shared between processes. Allows timed lock tries </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore_1abb2784b7acb836b8fa7cc91aef955e66"><parameter name="initialCount"><paramtype>unsigned int</paramtype></parameter><description><para>Creates a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore">interprocess_semaphore</link> with the given initial count. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> if there is an error.*<zwj/>/ </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore_1a06904cf015f5ec4428eeaa47aa21e0da"><description><para>Destroys the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore">interprocess_semaphore</link>. Does not throw </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore_1ac9e41816ea0117fd56ac7b474a0cd392" name="post"><type>void</type><description><para>Increments the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore">interprocess_semaphore</link> count. If there are processes/threads blocked waiting for the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore">interprocess_semaphore</link>, then one of these processes will return successfully from its wait function. If there is an error an <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> exception is thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore_1a6cb7263bbfc2056d6fead41bf70778d3" name="wait"><type>void</type><description><para>Decrements the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore">interprocess_semaphore</link>. If the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore">interprocess_semaphore</link> value is not greater than zero, then the calling process/thread blocks until it can decrement the counter. If there is an error an <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> exception is thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore_1ad0154d7b1a825492a9853a5dc025a5ea" name="try_wait"><type>bool</type><description><para>Decrements the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore">interprocess_semaphore</link> if the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore">interprocess_semaphore</link>'s value is greater than zero and returns true. If the value is not greater than zero returns false. If there is an error an <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> exception is thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore_1a7c22ce98f0730ea6c544386d91d7a66f" name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Decrements the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore">interprocess_semaphore</link> if the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore">interprocess_semaphore</link>'s value is greater than zero and returns true. Otherwise, waits for the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore">interprocess_semaphore</link> to the posted or the timeout expires. If the timeout expires, the function returns false. If the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__semaphore">interprocess_semaphore</link> is posted the function returns true. If there is an error throws sem_exception </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.interprocess__sharable__mutex_8hpp" name="boost/interprocess/sync/interprocess_sharable_mutex.hpp">
<para>Describes interprocess_sharable_mutex class </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex" name="interprocess_sharable_mutex"><description><para>Wraps a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex">interprocess_sharable_mutex</link> that can be placed in shared memory and can be shared between processes. Allows timed lock tries </para></description><method-group name="private member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1a37ba6c52b8cf540f78774774a45a24e8"><parameter name=""><paramtype>const <classname>interprocess_sharable_mutex</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1abada41a268faa18585ca7454b54265df"><type><classname>interprocess_sharable_mutex</classname> &amp;</type><parameter name=""><paramtype>const <classname>interprocess_sharable_mutex</classname> &amp;</paramtype></parameter></copy-assignment>
</method-group>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1a0bff5914894f95f2b0e36aa109a7a4ca"><description><para>Constructs the sharable lock. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1a4b141db1ddb7f3ad419ff3617e1d83d2"><description><para>Destroys the sharable lock. Does not throw. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1a7b787d2a8e53595092675b5f7ff556b9" name="lock"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain exclusive ownership of the mutex, and if another thread has exclusive or sharable ownership of the mutex, it waits until it can obtain the ownership. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1afb6e0cd42815dc8e7acca6ef4a463a2b" name="try_lock"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex without waiting. If no other thread has exclusive or sharable ownership of the mutex this succeeds. Returns: If it can acquire exclusive ownership immediately returns true. If it has to wait, returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1af75c327a20315be90d083acc24995daa" name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex waiting if necessary until no other thread has exclusive or sharable ownership of the mutex or abs_time is reached. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1a611f8b670a425f756ebafc6b6c2ecaa3" name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1a80ffab305a5cd782d8a038dffa5a8ecb" name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1a090c6a6e2c0aad20a5cf4498ad09f29b" name="unlock"><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The calling thread releases the exclusive ownership of the mutex. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1af470ea701b2836184061ab2ec33fe970" name="lock_sharable"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain sharable ownership of the mutex, and if another thread has exclusive ownership of the mutex, waits until it can obtain the ownership. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1a0efc41c58375dfc264753a0f2f3770ea" name="lock_shared"><type>void</type><description><para>Same as <computeroutput>lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1ad8f406c2cfedc21b65c48d95a45bcde8" name="try_lock_sharable"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire sharable ownership of the mutex without waiting. If no other thread has exclusive ownership of the mutex this succeeds. Returns: If it can acquire sharable ownership immediately returns true. If it has to wait, returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1a7bf9c1867b6f131976141b91cb4155ee" name="try_lock_shared"><type>bool</type><description><para>Same as <computeroutput>try_lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1a2b43782ab76a07d1a2478056fd8642eb" name="timed_lock_sharable"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire sharable ownership of the mutex waiting if necessary until no other thread has exclusive ownership of the mutex or abs_time is reached. Returns: If acquires sharable ownership, returns true. Otherwise returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1a0be16aabed633a5961f63ad659de0ee2" name="try_lock_shared_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1a0f90eb8eebaa406c96e84f02d5fd8897" name="try_lock_shared_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1a914601a6c8b968fa7fe84302074ff534" name="unlock_sharable"><type>void</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The calling thread releases the sharable ownership of the mutex. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__sharable__mutex_1ada8d0252c72b3259345db9fb987bbc57" name="unlock_shared"><type>void</type><description><para>Same as <computeroutput>unlock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.interprocess__upgradable__mutex_8hpp" name="boost/interprocess/sync/interprocess_upgradable_mutex.hpp">
<para>Describes interprocess_upgradable_mutex class </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex" name="interprocess_upgradable_mutex"><description><para>Wraps a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex">interprocess_upgradable_mutex</link> that can be placed in shared memory and can be shared between processes. Allows timed lock tries </para></description><method-group name="private member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a885d8ecbc107157025b2856dfed08e0c"><parameter name=""><paramtype>const <classname>interprocess_upgradable_mutex</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a202ce07434ebacefd5a40afa61b84fe5"><type><classname>interprocess_upgradable_mutex</classname> &amp;</type><parameter name=""><paramtype>const <classname>interprocess_upgradable_mutex</classname> &amp;</paramtype></parameter></copy-assignment>
</method-group>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a39d073ae396b8b8efa04a71194f770c9"><description><para>Constructs the upgradable lock. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1ac47727f934963f2206678da283bf02e4"><description><para>Destroys the upgradable lock. Does not throw. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1ab40ab6a85ee8dfda8c139162e699def9" name="lock"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain exclusive ownership of the mutex, and if another thread has exclusive, sharable or upgradable ownership of the mutex, it waits until it can obtain the ownership. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a8e261ce73f2b4886d71f5651c30adff9" name="try_lock"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex without waiting. If no other thread has exclusive, sharable or upgradable ownership of the mutex this succeeds. Returns: If it can acquire exclusive ownership immediately returns true. If it has to wait, returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a62e9b7f1a18e25ca0aaea8a05c4b3a0e" name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex waiting if necessary until no other thread has exclusive, sharable or upgradable ownership of the mutex or abs_time is reached. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a75ea19b7f6534873408e7ecc44c40979" name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a0bacea6bec92819d432a3bb64fa04d12" name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1aca8fb892abbf3e35962ea78d04397449" name="unlock"><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The calling thread releases the exclusive ownership of the mutex. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1ac3da361313759c8ae65298725aaf28d5" name="lock_sharable"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain sharable ownership of the mutex, and if another thread has exclusive ownership of the mutex, waits until it can obtain the ownership. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a4df502137e0ace52db28231ddfd99ee6" name="lock_shared"><type>void</type><description><para>Same as <computeroutput>lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a5c1f83e5611cb9ee3c512d1529bb3cff" name="try_lock_sharable"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire sharable ownership of the mutex without waiting. If no other thread has exclusive ownership of the mutex this succeeds. Returns: If it can acquire sharable ownership immediately returns true. If it has to wait, returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a59d7845fba8ec97455c042b70f66b00c" name="try_lock_shared"><type>bool</type><description><para>Same as <computeroutput>try_lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1ac11b7740a93c0e020cae98ca4525390d" name="timed_lock_sharable"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire sharable ownership of the mutex waiting if necessary until no other thread has exclusive ownership of the mutex or abs_time is reached. Returns: If acquires sharable ownership, returns true. Otherwise returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1ada6a2ec9cf1d82dc08e5202d49af23fc" name="try_lock_shared_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a8482ae6806493d24205118bb92763dab" name="try_lock_shared_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a4636f9468174105e8967fbb4c41cbba0" name="unlock_sharable"><type>void</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The calling thread releases the sharable ownership of the mutex. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1ad1457724ec1e97ffaeb06c43c92d6f78" name="unlock_shared"><type>void</type><description><para>Same as <computeroutput>unlock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a18bb3b72c3120da7c7adb02bdd4afef6" name="lock_upgradable"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain upgradable ownership of the mutex, and if another thread has exclusive or upgradable ownership of the mutex, waits until it can obtain the ownership. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a38eea9f55de08c2601f03f30c83928d9" name="try_lock_upgradable"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire upgradable ownership of the mutex without waiting. If no other thread has exclusive or upgradable ownership of the mutex this succeeds. Returns: If it can acquire upgradable ownership immediately returns true. If it has to wait, returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1ac684889281ab2bda5578ca2945bcd08f" name="timed_lock_upgradable"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire upgradable ownership of the mutex waiting if necessary until no other thread has exclusive or upgradable ownership of the mutex or abs_time is reached. Returns: If acquires upgradable ownership, returns true. Otherwise returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a60e4820486d79d16a12d2f53a48147f9" name="unlock_upgradable"><type>void</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The calling thread releases the upgradable ownership of the mutex. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1ab1d8d787fc44424661f7331fdd837ce4" name="unlock_and_lock_upgradable"><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The thread atomically releases exclusive ownership and acquires upgradable ownership. This operation is non-blocking. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1ac55f9d3458b33411c5a3f34a6c22e193" name="unlock_and_lock_sharable"><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The thread atomically releases exclusive ownership and acquires sharable ownership. This operation is non-blocking. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a62f23146f9c45307dccf50b36c3cbc98" name="unlock_upgradable_and_lock_sharable"><type>void</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and acquires sharable ownership. This operation is non-blocking. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1ab9af1e5652dd46ca21ae22619060e148" name="unlock_upgradable_and_lock"><type>void</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and acquires exclusive ownership. This operation will block until all threads with sharable ownership release their sharable lock. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a9c5b4d06a391a6a27609258ced9f4125" name="try_unlock_upgradable_and_lock"><type>bool</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and tries to acquire exclusive ownership. This operation will fail if there are threads with sharable ownership, but it will maintain upgradable ownership. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a4775c450bf503cf27371ad32f872a471" name="timed_unlock_upgradable_and_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and tries to acquire exclusive ownership, waiting if necessary until abs_time. This operation will fail if there are threads with sharable ownership or timeout reaches, but it will maintain upgradable ownership. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. *<zwj/>/ </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1ac395c0239e962961d7448dfdd9976b5a" name="try_unlock_sharable_and_lock"><type>bool</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The thread atomically releases sharable ownership and tries to acquire exclusive ownership. This operation will fail if there are threads with sharable or upgradable ownership, but it will maintain sharable ownership. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__upgradable__mutex_1a4ccc15c9054b4e414a6cadf081eb52a5" name="try_unlock_sharable_and_lock_upgradable"><type>bool</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The thread atomically releases sharable ownership and tries to acquire upgradable ownership. This operation will fail if there are threads with sharable or upgradable ownership, but it will maintain sharable ownership. Returns: If acquires upgradable ownership, returns true. Otherwise returns false. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.lock__options_8hpp" name="boost/interprocess/sync/lock_options.hpp">
<para>Describes the lock options with associated with interprocess_mutex lock constructors. </para><namespace name="boost">
<namespace name="interprocess">
<struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1accept__ownership__type" name="accept_ownership_type"><purpose>Type to indicate to a mutex lock constructor that the mutex is already locked. </purpose></struct><struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1defer__lock__type" name="defer_lock_type"><purpose>Type to indicate to a mutex lock constructor that must not lock the mutex. </purpose></struct><struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1try__to__lock__type" name="try_to_lock_type"><purpose>Type to indicate to a mutex lock constructor that must try to lock the mutex. </purpose></struct><data-member id="doxygen.boost_interprocess_header_reference.lock__options_8hpp_1a3a57da080894431f8788f9e9ed866f5a" name="defer_lock" specifiers="static"><type>const <classname>defer_lock_type</classname></type><description><para>An object indicating that the locking must be deferred. </para></description></data-member>
<data-member id="doxygen.boost_interprocess_header_reference.lock__options_8hpp_1a6469dc17982125a3eee42ddbbc09e26d" name="try_to_lock" specifiers="static"><type>const <classname>try_to_lock_type</classname></type><description><para>An object indicating that a try_lock() operation must be executed. </para></description></data-member>
<data-member id="doxygen.boost_interprocess_header_reference.lock__options_8hpp_1a3c6af5c4d96b7ce12e46b5717e4a8a63" name="accept_ownership" specifiers="static"><type>const <classname>accept_ownership_type</classname></type><description><para>An object indicating that the ownership of lockable object must be accepted by the new owner. </para></description></data-member>



















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.mutex__family_8hpp" name="boost/interprocess/sync/mutex_family.hpp">
<para>Describes a shared interprocess_mutex family fit algorithm used to allocate objects in shared memory. </para><namespace name="boost">
<namespace name="interprocess">
<struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1mutex__family" name="mutex_family"><description><para>Describes <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex">interprocess_mutex</link> family to use with Interprocess framework based on boost::interprocess synchronization objects. </para></description><typedef id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1mutex__family_1ac5420782a6717594b13a8338bb7fd2e4" name="mutex_type"><type><classname>boost::interprocess::interprocess_mutex</classname></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1mutex__family_1ae4d1768f8441bf9269b27ae43e952148" name="recursive_mutex_type"><type><classname>boost::interprocess::interprocess_recursive_mutex</classname></type></typedef>
</struct><struct id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1null__mutex__family" name="null_mutex_family"><description><para>Describes <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__mutex">interprocess_mutex</link> family to use with Interprocess frameworks based on null operation synchronization objects. </para></description><typedef id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1null__mutex__family_1ab68d53467362417f54b81b41b134b30c" name="mutex_type"><type><classname>boost::interprocess::null_mutex</classname></type></typedef>
<typedef id="doxygen.boost_interprocess_header_reference.structboost_1_1interprocess_1_1null__mutex__family_1a8b4a382574946fb303f3f29e18554f76" name="recursive_mutex_type"><type><classname>boost::interprocess::null_mutex</classname></type></typedef>
</struct>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.named__condition_8hpp" name="boost/interprocess/sync/named_condition.hpp">
<para>Describes a named condition class for inter-process synchronization </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition" name="named_condition"><description><para>A global condition variable that can be created by name. This condition variable is designed to work with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex">named_mutex</link> and can't be placed in shared memory or memory mapped files. </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a4101a5e6469dd571a9e73161b05d5973"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a global condition with a name. If the condition can't be created throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1aac3c7ed98f56441c1074b6d386e0ba95"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Opens or creates a global condition with a name. If the condition is created, this call is equivalent to named_condition(create_only_t, ... ) If the condition is already created, this call is equivalent named_condition(open_only_t, ... ) Does not throw </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1af103fe3e0afddfb17f144270ca6d8897"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global condition with a name if that condition is previously created. If it is not previously created this function throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link>. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a3a19cc30a4d03ceb8e3842008820cdcf"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Opens a global condition with a name if that condition is previously created. If it is not previously created this function throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link>. Creates a global condition with a name. If the condition can't be created throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link></para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a82a9af1252dcea4200175542511bf000"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Opens or creates a global condition with a name. If the condition is created, this call is equivalent to named_condition(create_only_t, ... ) If the condition is already created, this call is equivalent named_condition(open_only_t, ... ) Does not throw</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a80637f91cfb753fae0820e939a47dc82"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Opens a global condition with a name if that condition is previously created. If it is not previously created this function throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link>.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1ad78388db4d8b3f8548c9dadc59bb7e40"><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a3daa97bf857279e0d531f162fb44407a">remove()</link>. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a268e039ee1e0d2112751d6ecef1c48a9" name="notify_one"><type>void</type><description><para>If there is a thread waiting on <emphasis>this, change that thread's state to ready. Otherwise there is no effect.</emphasis><zwj/>/ </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a1eb56b18cf062faca443a4180236a033" name="notify_all"><type>void</type><description><para>Change the state of all threads waiting on *this to ready. If there are no waiting threads, <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a1eb56b18cf062faca443a4180236a033">notify_all()</link> has no effect. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a8e05f4757f262aacb8a2d77554ff379c" name="wait"><type>void</type><template>
          <template-type-parameter name="L"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><description><para>Releases the lock on the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex">named_mutex</link> object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a268e039ee1e0d2112751d6ecef1c48a9">notify_one()</link> or this-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a1eb56b18cf062faca443a4180236a033">notify_all()</link>, and then reacquires the lock. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a1c32e5291d2038bfdd5ad822776bd2cf" name="wait"><type>void</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) wait(lock) </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1ad4bd59d733c455672d9d8af4d2b74cee" name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Releases the lock on the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex">named_mutex</link> object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a268e039ee1e0d2112751d6ecef1c48a9">notify_one()</link> or this-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a1eb56b18cf062faca443a4180236a033">notify_all()</link>, or until time abs_time is reached, and then reacquires the lock. Returns: false if time abs_time is reached, otherwise true. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a462e56777286aaf4d79648e07a7c975b" name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) { if (!timed_wait(lock, abs_time)) return pred(); } return true; </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a67c267fbb39b6df44c488f31f8dd65b7" name="wait_until"><type>cv_status</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1af05bf6486877da93e0aac48da2542623" name="wait_until"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1ab3ef57ae164d3cebc499210a19d72886" name="wait_for"><type>cv_status</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Duration"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface and uses relative timeouts. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a8e54c509c896f200a082f665e07a2acc" name="wait_for"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Duration"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface and uses relative timeouts </para></description></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a3daa97bf857279e0d531f162fb44407a" name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named condition from the system. Returns false on error. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition_1a3a088ce9bde2322e945fd0ce313eef19" name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Erases a named condition from the system. Returns false on error. Never throws.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.named__condition__any_8hpp" name="boost/interprocess/sync/named_condition_any.hpp">
<para>Describes a named condition class for inter-process synchronization </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any" name="named_condition_any"><description><para>A global condition variable that can be created by name. This condition variable is designed to work with <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex">named_mutex</link> and can't be placed in shared memory or memory mapped files. </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a04b22e93d1a5a6fb5fcaa68a413a8af4"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a global condition with a name. If the condition can't be created throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a85b83c93b85993f0d0f1c4b24508119a"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Opens or creates a global condition with a name. If the condition is created, this call is equivalent to named_condition_any(create_only_t, ... ) If the condition is already created, this call is equivalent named_condition_any(open_only_t, ... ) Does not throw </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a07c296b15b42f3afa7d837b6e9a6f999"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global condition with a name if that condition is previously created. If it is not previously created this function throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link>. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1aa46c807d89e38f6aca8a0f11f13ba3b9"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a global condition with a name. If the condition can't be created throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link></para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a01a3dc872c8f004b6e20839a8a4b208d"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Opens or creates a global condition with a name. If the condition is created, this call is equivalent to named_condition_any(create_only_t, ... ) If the condition is already created, this call is equivalent named_condition_any(open_only_t, ... ) Does not throw</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a63277d048aa9a7cf3b51520fdb5c20c3"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Opens a global condition with a name if that condition is previously created. If it is not previously created this function throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link>.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1aeef622d628d9ff306f7fa363419837cd"><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a529228301f4dbed175776a0077f75cef">remove()</link>. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a98548661146e8cdbd1b34aa49ad75420" name="notify_one"><type>void</type><description><para>If there is a thread waiting on <emphasis>this, change that thread's state to ready. Otherwise there is no effect.</emphasis><zwj/>/ </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a62389241c00b7970285d52a71ebc8b95" name="notify_all"><type>void</type><description><para>Change the state of all threads waiting on *this to ready. If there are no waiting threads, <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a62389241c00b7970285d52a71ebc8b95">notify_all()</link> has no effect. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a3b87ed5ff8189fe97be2c35ca4550172" name="wait"><type>void</type><template>
          <template-type-parameter name="L"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><description><para>Releases the lock on the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex">named_mutex</link> object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a98548661146e8cdbd1b34aa49ad75420">notify_one()</link> or this-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a62389241c00b7970285d52a71ebc8b95">notify_all()</link>, and then reacquires the lock. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a85176d354318aee4070e8acac85d33d8" name="wait"><type>void</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) wait(lock) </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1ae4de0870828880c9e1f946fcb11af594" name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Releases the lock on the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex">named_mutex</link> object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a98548661146e8cdbd1b34aa49ad75420">notify_one()</link> or this-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a62389241c00b7970285d52a71ebc8b95">notify_all()</link>, or until time abs_time is reached, and then reacquires the lock. Returns: false if time abs_time is reached, otherwise true. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a9ddfbd9454b2d5983982884f749e1f4f" name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) { if (!timed_wait(lock, abs_time)) return pred(); } return true; </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1ae347e580b921bc555162c812c48c49ac" name="wait_until"><type>cv_status</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a0754e3079bda657dca34ad97df60595b" name="wait_until"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a346a38e073c3103fa5a2bec32f5ae94f" name="wait_for"><type>cv_status</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Duration"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface and uses relative timeouts. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a22f938e399417ed25858608ced8f280e" name="wait_for"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Duration"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface and uses relative timeouts </para></description></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a529228301f4dbed175776a0077f75cef" name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named condition from the system. Returns false on error. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__condition__any_1a57cdac6346d4ba882453d8f0592775eb" name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Erases a named condition from the system. Returns false on error. Never throws.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.named__mutex_8hpp" name="boost/interprocess/sync/named_mutex.hpp">
<para>Describes a named mutex class for inter-process synchronization </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex" name="named_mutex"><description><para>A mutex with a global name, so it can be found from different processes. This mutex can't be placed in shared memory, and each process should have it's own <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex">named_mutex</link>. </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex_1aa349dfb8317ed2f38211e4492f9b105a"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a global mutex with a name. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex_1addef062ead3bc044bc60ab9de12a2add"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Opens or creates a global mutex with a name. If the mutex is created, this call is equivalent to named_mutex(create_only_t, ... ) If the mutex is already created, this call is equivalent named_mutex(open_only_t, ... ) Does not throw </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex_1a0faba990ef7864c0c84640dd629dba80"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global mutex with a name if that mutex is previously created. If it is not previously created this function throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link>. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex_1a31d8726d96f2557daf18b08411511d11"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a global mutex with a name. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex_1a91d9a09100684fdb3a7f98b9cd1324d9"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Opens or creates a global mutex with a name. If the mutex is created, this call is equivalent to named_mutex(create_only_t, ... ) If the mutex is already created, this call is equivalent named_mutex(open_only_t, ... ) Does not throw</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex_1af06e8fdc888923e10bb08ecdb93590e6"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Opens a global mutex with a name if that mutex is previously created. If it is not previously created this function throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link>.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex_1a0a80cd3771db97192d040a0d4a223508"><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex_1ad9f58e1440cff141067e4dd4b94638aa">remove()</link>. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex_1a239dafee923c3a6e909c46805eed46b0" name="unlock"><type>void</type><description><para>Unlocks a previously locked mutex. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex_1a650543385847060b2b5dc9f21fea24e3" name="lock"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Locks the mutex, sleeps when the mutex is already locked. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> if a severe error is found</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex_1ad24662e5bcb6e2fa56129302be7576c6" name="try_lock"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Tries to lock the mutex, returns false when the mutex is already locked, returns true when success. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> if a severe error is found</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex_1aba0a6043da6aa217c7d01653eb6358c7" name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Tries to lock the the mutex until time abs_time, Returns false when timeout expires, returns true when locks. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> if a severe error is found</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex_1a9ab8cf074058ab99e1c4f61e860bf9f5" name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex_1af3ed6e2bb0846e809c75d3325d170edc" name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex_1ad9f58e1440cff141067e4dd4b94638aa" name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named mutex from the system. Returns false on error. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__mutex_1a569bacd4b463f96399485d807e5508cc" name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Erases a named mutex from the system. Returns false on error. Never throws.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.named__recursive__mutex_8hpp" name="boost/interprocess/sync/named_recursive_mutex.hpp">
<para>Describes a named named_recursive_mutex class for inter-process synchronization </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex" name="named_recursive_mutex"><description><para>A recursive mutex with a global name, so it can be found from different processes. This mutex can't be placed in shared memory, and each process should have it's own <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex">named_recursive_mutex</link>. </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex_1a66e7ab70c7426afc4c7f05d17dc4320c"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a global recursive_mutex with a name. If the recursive_mutex can't be created throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex_1ac8e32a0c34a881d9aaa242db702b3fed"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Opens or creates a global recursive_mutex with a name. If the recursive_mutex is created, this call is equivalent to named_recursive_mutex(create_only_t, ... ) If the recursive_mutex is already created, this call is equivalent named_recursive_mutex(open_only_t, ... ) Does not throw </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex_1aba421883a6ae14ff071d93339a13bafb"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global recursive_mutex with a name if that recursive_mutex is previously created. If it is not previously created this function throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link>. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex_1ac2b9c5ae42a455691d0b647870b43800"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a global recursive_mutex with a name. If the recursive_mutex can't be created throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link></para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex_1ae8db381634a59ec27a91511a428a3678"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Opens or creates a global recursive_mutex with a name. If the recursive_mutex is created, this call is equivalent to named_recursive_mutex(create_only_t, ... ) If the recursive_mutex is already created, this call is equivalent named_recursive_mutex(open_only_t, ... ) Does not throw</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex_1a8f5bfd209b8062e14110704da180a904"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Opens a global recursive_mutex with a name if that recursive_mutex is previously created. If it is not previously created this function throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link>.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex_1aeeec7a142ea97d2914d7808334d8fb76"><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex_1a7715fdfa43e01f507d85e749ce1b30cf">remove()</link>. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex_1ac7424e86aa3f5165c2ba3df1b0ae2f8a" name="unlock"><type>void</type><description><para>Unlocks a previously locked <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex">named_recursive_mutex</link>. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex_1a79b70c1895c45051368d46a6dd03acdd" name="lock"><type>void</type><description><para>Locks <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex">named_recursive_mutex</link>, sleeps when <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex">named_recursive_mutex</link> is already locked. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> if a severe error is found.</para><para>Note: A program shall not deadlock if the thread that has ownership calls this function. <sbr/>
 </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex_1a1fe7193005a31a15705f2a9b58f8b90c" name="try_lock"><type>bool</type><description><para>Tries to lock the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex">named_recursive_mutex</link>, returns false when <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex">named_recursive_mutex</link> is already locked, returns true when success. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> if a severe error is found.</para><para>Note: A program shall not deadlock if the thread that has ownership calls this function. <sbr/>
 </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex_1ae4e22f6b4dcb41536cb893e88245f838" name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Tries to lock the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex">named_recursive_mutex</link> until time abs_time, Returns false when timeout expires, returns true when locks. Throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> if a severe error is found</para><para>Note: A program shall not deadlock if the thread that has ownership calls this function. <sbr/>
 </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex_1a6d10bf2295754c2a0cfce803a27b6c5e" name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex_1a2c053159d3b04c2007a459ea3a2c0af7" name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex_1a7715fdfa43e01f507d85e749ce1b30cf" name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named recursive mutex from the system </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__recursive__mutex_1a61f09623a51f0dc07661e343fc8e5afd" name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Erases a named recursive mutex from the system</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.named__semaphore_8hpp" name="boost/interprocess/sync/named_semaphore.hpp">
<para>Describes a named semaphore class for inter-process synchronization </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__semaphore" name="named_semaphore"><description><para>A semaphore with a global name, so it can be found from different processes. Allows several resource sharing patterns and efficient acknowledgment mechanisms. </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__semaphore_1a314a2620302db2ac5a7fef313d99a428"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="initialCount"><paramtype>unsigned int</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a global semaphore with a name, and an initial count. If the semaphore can't be created throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__semaphore_1a0a2d211438010609a7d1b718a7e9c1e2"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="initialCount"><paramtype>unsigned int</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Opens or creates a global semaphore with a name, and an initial count. If the semaphore is created, this call is equivalent to named_semaphore(create_only_t, ...) If the semaphore is already created, this call is equivalent to named_semaphore(open_only_t, ... ) and initialCount is ignored. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__semaphore_1a8f06d2b06e5646fa3efd31168d670778"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global semaphore with a name if that semaphore is previously. created. If it is not previously created this function throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link>. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__semaphore_1a65ebbbf1150948f6b29d5b79843762ac"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="initialCount"><paramtype>unsigned int</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a global semaphore with a name, and an initial count. If the semaphore can't be created throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link></para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__semaphore_1a3f9e9aee747581f1de5040352294f277"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="initialCount"><paramtype>unsigned int</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Opens or creates a global semaphore with a name, and an initial count. If the semaphore is created, this call is equivalent to named_semaphore(create_only_t, ...) If the semaphore is already created, this call is equivalent to named_semaphore(open_only_t, ... ) and initialCount is ignored.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__semaphore_1afe6d5ee3c39b0ac98f472ffe0b7b40f7"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Opens a global semaphore with a name if that semaphore is previously. created. If it is not previously created this function throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link>.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__semaphore_1a3d71d0de8f7658db6ea3a4cb4b5a9f4c"><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__semaphore_1a2e503b85b95c983b4afbc5aee505d431">remove()</link>. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__semaphore_1a73d59bad56b6ce241bdf241bd01cb024" name="post"><type>void</type><description><para>Increments the semaphore count. If there are processes/threads blocked waiting for the semaphore, then one of these processes will return successfully from its wait function. If there is an error an <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> exception is thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__semaphore_1aaac7af90e4d626b2336cadfddcc13976" name="wait"><type>void</type><description><para>Decrements the semaphore. If the semaphore value is not greater than zero, then the calling process/thread blocks until it can decrement the counter. If there is an error an <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> exception is thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__semaphore_1a014f00a63b79b4b0b2bbbff39540234d" name="try_wait"><type>bool</type><description><para>Decrements the semaphore if the semaphore's value is greater than zero and returns true. If the value is not greater than zero returns false. If there is an error an <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> exception is thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__semaphore_1ab8ee3a578f4af6a91cead2fdac23c243" name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Decrements the semaphore if the semaphore's value is greater than zero and returns true. Otherwise, waits for the semaphore to the posted or the timeout expires. If the timeout expires, the function returns false. If the semaphore is posted the function returns true. If there is an error throws sem_exception </para></description></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__semaphore_1a2e503b85b95c983b4afbc5aee505d431" name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named semaphore from the system. Returns false on error. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__semaphore_1a3be1b31ed69a2ba778290ad047230f85" name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Erases a named semaphore from the system. Returns false on error. Never throws.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.named__sharable__mutex_8hpp" name="boost/interprocess/sync/named_sharable_mutex.hpp">
<para>Describes a named sharable mutex class for inter-process synchronization </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex" name="named_sharable_mutex"><description><para>A sharable mutex with a global name, so it can be found from different processes. This mutex can't be placed in shared memory, and each process should have it's own named sharable mutex. </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1abf93f71d8c77c1817b88d3dffa56c320"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a global sharable mutex with a name. If the sharable mutex can't be created throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1ad508d06db75da55ba513dd583ea22d07"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Opens or creates a global sharable mutex with a name. If the sharable mutex is created, this call is equivalent to named_sharable_mutex(create_only_t, ...) If the sharable mutex is already created, this call is equivalent to named_sharable_mutex(open_only_t, ... ). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1afac980d5bbff26eea69df08b1d8a958e"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global sharable mutex with a name if that sharable mutex is previously. created. If it is not previously created this function throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link>. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1a971c3d97e19035e8f1c5acc6cc554f06"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a global sharable mutex with a name. If the sharable mutex can't be created throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link></para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1a4d44c624f7f05db15ba79483d7870e24"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Opens or creates a global sharable mutex with a name. If the sharable mutex is created, this call is equivalent to named_sharable_mutex(create_only_t, ...) If the sharable mutex is already created, this call is equivalent to named_sharable_mutex(open_only_t, ... ).</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1a5dcf4828e82b052516cbb8422fd980d8"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Opens a global sharable mutex with a name if that sharable mutex is previously. created. If it is not previously created this function throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link>.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1ab73673f72d2f947052653f8354e0a119"><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1a037051bc7fe01395629f7aaf38f947a2">remove()</link>. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1ac79dfa17d13690af715c19e93d93f7eb" name="lock"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain exclusive ownership of the mutex, and if another thread has exclusive or sharable ownership of the mutex, it waits until it can obtain the ownership. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1a2cea049a3f46081d174ff951b9bc430f" name="try_lock"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex without waiting. If no other thread has exclusive or sharable ownership of the mutex this succeeds. Returns: If it can acquire exclusive ownership immediately returns true. If it has to wait, returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1a77916b3663f86a2a71165917863e375c" name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex waiting if necessary until no other thread has exclusive, or sharable ownership of the mutex or abs_time is reached. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1abcb9d2afaa0bcfca23d52f86f4f7f46f" name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1a954506b5e8dfd446fb247a5f72802c4b" name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1a9e54928f1ca8e82a08eef49ca685b938" name="unlock"><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The calling thread releases the exclusive ownership of the mutex. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1a275d23e26a58004eb16ae912d4f9c41d" name="lock_sharable"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain sharable ownership of the mutex, and if another thread has exclusive ownership of the mutex, waits until it can obtain the ownership. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1a1194dbc0b41fa703c005fbd8266b0b6b" name="lock_shared"><type>void</type><description><para>Same as <computeroutput>lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1a185b4020c0d535ba5e0433bc912f7262" name="try_lock_sharable"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire sharable ownership of the mutex without waiting. If no other thread has exclusive ownership of the mutex this succeeds. Returns: If it can acquire sharable ownership immediately returns true. If it has to wait, returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1aa254afc7a492288d04c1593e336dc357" name="try_lock_shared"><type>bool</type><description><para>Same as <computeroutput>try_lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1adefed13f6989018a7aeae6be6387d948" name="timed_lock_sharable"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire sharable ownership of the mutex waiting if necessary until no other thread has exclusive ownership of the mutex or abs_time is reached. Returns: If acquires sharable ownership, returns true. Otherwise returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1a95f16856c2a8c1cf3b366e6f9a6f6022" name="try_lock_shared_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1a8521635e7075c0186dc561521b9d7edc" name="try_lock_shared_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1a2e12cceca592f74759ff5e3b345f402b" name="unlock_sharable"><type>void</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The calling thread releases the sharable ownership of the mutex. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1af0a2a2018748c472b8e2276d8db2bffd" name="unlock_shared"><type>void</type><description><para>Same as <computeroutput>unlock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1a037051bc7fe01395629f7aaf38f947a2" name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named sharable mutex from the system. Returns false on error. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__sharable__mutex_1a6741be5620bff8b21c6c4faf91db1c0c" name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Erases a named sharable mutex from the system. Returns false on error. Never throws. </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.named__upgradable__mutex_8hpp" name="boost/interprocess/sync/named_upgradable_mutex.hpp">
<para>Describes a named upgradable mutex class for inter-process synchronization </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex" name="named_upgradable_mutex"><description><para>A upgradable mutex with a global name, so it can be found from different processes. This mutex can't be placed in shared memory, and each process should have it's own named upgradable mutex. </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a1d24c1e78e50cbaa1cdaf19aeb1d91b7"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a global upgradable mutex with a name. If the upgradable mutex can't be created throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a310c8864d033807774255981f0e11c1b"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Opens or creates a global upgradable mutex with a name. If the upgradable mutex is created, this call is equivalent to named_upgradable_mutex(create_only_t, ...) If the upgradable mutex is already created, this call is equivalent to named_upgradable_mutex(open_only_t, ... ). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a67de612b74556a05a9575191d4650084"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global upgradable mutex with a name if that upgradable mutex is previously. created. If it is not previously created this function throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link>. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a69c5b243f02904ca5b7c7609ad1929f2"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a global upgradable mutex with a name. If the upgradable mutex can't be created throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link></para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a51f09b0e5b3e41d7922fd5d9bc6bb599"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Opens or creates a global upgradable mutex with a name. If the upgradable mutex is created, this call is equivalent to named_upgradable_mutex(create_only_t, ...) If the upgradable mutex is already created, this call is equivalent to named_upgradable_mutex(open_only_t, ... ).</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a0efb992b0a294279b803ae1541043368"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Opens a global upgradable mutex with a name if that upgradable mutex is previously. created. If it is not previously created this function throws <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link>.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a39f5c48baf61d63f6b948cf6e1023efd"><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a456798c7661db6b7f6886272a1facfc3">remove()</link>. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a5f2aa9a0b6e724fc3142b035ff6b0d9d" name="lock"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain exclusive ownership of the mutex, and if another thread has exclusive, sharable or upgradable ownership of the mutex, it waits until it can obtain the ownership. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a880e2971e25aa42e37b2fa2934912d49" name="try_lock"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex without waiting. If no other thread has exclusive, sharable or upgradable ownership of the mutex this succeeds. Returns: If it can acquire exclusive ownership immediately returns true. If it has to wait, returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a8b5fa1141d1275fc549fdbf0b654fca8" name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex waiting if necessary until no other thread has exclusive, sharable or upgradable ownership of the mutex or abs_time is reached. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a13713f0c7f12a9345e5402069891dc4b" name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a82d28fbf90ecfec56e8207800be1a1aa" name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a710024ce3cf8c4350a078bc042071a7c" name="unlock"><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The calling thread releases the exclusive ownership of the mutex. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a3b49b700c52b4e87b1352b4ac4f8dc64" name="lock_sharable"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain sharable ownership of the mutex, and if another thread has exclusive ownership of the mutex, waits until it can obtain the ownership. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a906592ce9f0329de12e3967282602dab" name="lock_shared"><type>void</type><description><para>Same as <computeroutput>lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1ae5f52c82ab6b40855f472eb6a7979cbd" name="try_lock_sharable"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire sharable ownership of the mutex without waiting. If no other thread has exclusive ownership of the mutex this succeeds. Returns: If it can acquire sharable ownership immediately returns true. If it has to wait, returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a8a02215a4c3ba296d03ea0c89b17c7f8" name="try_lock_shared"><type>bool</type><description><para>Same as <computeroutput>try_lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a3b212b21b1657359ead214b4921ae0c6" name="timed_lock_sharable"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire sharable ownership of the mutex waiting if necessary until no other thread has exclusive ownership of the mutex or abs_time is reached. Returns: If acquires sharable ownership, returns true. Otherwise returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a03a44f218ea975b5cbc446e899f5db76" name="try_lock_shared_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1ab25bb38c7ce4e3bc42d0a4d0d3a76aa9" name="try_lock_shared_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a807943e1e351fb34455566a491fc2d7b" name="unlock_sharable"><type>void</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The calling thread releases the sharable ownership of the mutex. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a53fc11a1fd2b9bc8c2d616010b783915" name="unlock_shared"><type>void</type><description><para>Same as <computeroutput>unlock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a979a7631a1b929b226fa34f66aed700e" name="lock_upgradable"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain upgradable ownership of the mutex, and if another thread has exclusive or upgradable ownership of the mutex, waits until it can obtain the ownership. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a1370107e2edbad9f43573deb0afea7cf" name="try_lock_upgradable"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire upgradable ownership of the mutex without waiting. If no other thread has exclusive or upgradable ownership of the mutex this succeeds. Returns: If it can acquire upgradable ownership immediately returns true. If it has to wait, returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a6795f3e273bc4a36ef2d29a9f8e279a9" name="timed_lock_upgradable"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire upgradable ownership of the mutex waiting if necessary until no other thread has exclusive or upgradable ownership of the mutex or abs_time is reached. Returns: If acquires upgradable ownership, returns true. Otherwise returns false. Throws: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1ac071f31cc25b1105c55de6712cf41f05" name="unlock_upgradable"><type>void</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The calling thread releases the upgradable ownership of the mutex. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a7671ff80f906f16230071274a9014e64" name="unlock_and_lock_upgradable"><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The thread atomically releases exclusive ownership and acquires upgradable ownership. This operation is non-blocking. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1afa9723fac9282ae528f253bfc9d941e2" name="unlock_and_lock_sharable"><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The thread atomically releases exclusive ownership and acquires sharable ownership. This operation is non-blocking. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1aebd501eb2fb555dc0d15a065bdfb648b" name="unlock_upgradable_and_lock_sharable"><type>void</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and acquires sharable ownership. This operation is non-blocking. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a667b7055929686740b3d7b4438ff2a1a" name="unlock_upgradable_and_lock"><type>void</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and acquires exclusive ownership. This operation will block until all threads with sharable ownership release it. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a1cbbb3f7953dd869fd6910491e14e171" name="try_unlock_upgradable_and_lock"><type>bool</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and tries to acquire exclusive ownership. This operation will fail if there are threads with sharable ownership, but it will maintain upgradable ownership. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a02dd27765c6f093f4e944ecc4fa6e184" name="timed_unlock_upgradable_and_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and tries to acquire exclusive ownership, waiting if necessary until abs_time. This operation will fail if there are threads with sharable ownership or timeout reaches, but it will maintain upgradable ownership. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1ad4c5dc21ce777911cd8c198cc2e88b5e" name="try_unlock_sharable_and_lock"><type>bool</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The thread atomically releases sharable ownership and tries to acquire exclusive ownership. This operation will fail if there are threads with sharable or upgradable ownership, but it will maintain sharable ownership. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a9bc6b8840d6fab414c36252acc21e30e" name="try_unlock_sharable_and_lock_upgradable"><type>bool</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The thread atomically releases sharable ownership and tries to acquire upgradable ownership. This operation will fail if there are threads with sharable or upgradable ownership, but it will maintain sharable ownership. Returns: If acquires upgradable ownership, returns true. Otherwise returns false. Throws: An exception derived from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1interprocess__exception">interprocess_exception</link> on error. </para></description></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a456798c7661db6b7f6886272a1facfc3" name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named upgradable mutex from the system. Returns false on error. Never throws. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1named__upgradable__mutex_1a140258d4fe4ca8588a9d606a399dfbe9" name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Erases a named upgradable mutex from the system. Returns false on error. Never throws.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.null__mutex_8hpp" name="boost/interprocess/sync/null_mutex.hpp">
<para>Describes null_mutex classes </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex" name="null_mutex"><description><para>Implements a mutex that simulates a mutex without doing any operation and simulates a successful operation. </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a89aa465ae3c91c20ef9cdf3eded08e92" cv="noexcept"><description><para>Constructor. Empty. </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a7b03b708bbeb316a300a36da69d9a1c5"><description><para>Destructor. Empty. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a33e4f2e8bc26c8968462356fb184d671" name="lock"><type>void</type><purpose>Simulates a mutex <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a33e4f2e8bc26c8968462356fb184d671">lock()</link> operation. Empty function. </purpose></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1adfabbb452b623ba44c2ebca317e4b714" name="try_lock"><type>bool</type><description><para>Simulates a mutex <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1adfabbb452b623ba44c2ebca317e4b714">try_lock()</link> operation. Equivalent to "return true;" </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a3955ebdb81976707a755d411b0924347" name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name=""><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Simulates a mutex <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a3955ebdb81976707a755d411b0924347">timed_lock()</link> operation. Equivalent to "return true;" </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a478902b38b28bf6c88ddc083f8cf09c8" name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name=""><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a85e679aa082a604efd95f79b372e1333" name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name=""><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a4c884813de8b96d19ad9e6314f556725" name="unlock"><type>void</type><description><para>Simulates a mutex <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a4c884813de8b96d19ad9e6314f556725">unlock()</link> operation. Empty function. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1ad133f07766e77abffcdb009d87e9dacb" name="lock_sharable"><type>void</type><description><para>Simulates a mutex <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1ad133f07766e77abffcdb009d87e9dacb">lock_sharable()</link> operation. Empty function. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a4c1bf0cdcf97f6d57ab9988417465a3f" name="lock_shared"><type>void</type><description><para>Same as <computeroutput>lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a48e8b5bd3f528a3dc7790e3a151202d9" name="try_lock_sharable"><type>bool</type><description><para>Simulates a mutex <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a48e8b5bd3f528a3dc7790e3a151202d9">try_lock_sharable()</link> operation. Equivalent to "return true;" </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a1de5848ec05aefc4d5dfec9a040820f5" name="try_lock_shared"><type>bool</type><description><para>Same as <computeroutput>try_lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a39336fba529371c7b9d01f7c0488e9c4" name="timed_lock_sharable"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name=""><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Simulates a mutex <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a39336fba529371c7b9d01f7c0488e9c4">timed_lock_sharable()</link> operation. Equivalent to "return true;" </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a8cf71f83414d420f0a18647776a6a697" name="unlock_sharable"><type>void</type><description><para>Simulates a mutex <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a8cf71f83414d420f0a18647776a6a697">unlock_sharable()</link> operation. Empty function. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a7e48a2bb033fd7628ed372f0fdd2a70e" name="unlock_shared"><type>void</type><description><para>Same as <computeroutput>unlock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a589c30f79c77404078afd1ff622864f8" name="lock_upgradable"><type>void</type><description><para>Simulates a mutex <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a589c30f79c77404078afd1ff622864f8">lock_upgradable()</link> operation. Empty function. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a07882510548d012d6f25a6a4886dc544" name="try_lock_upgradable"><type>bool</type><description><para>Simulates a mutex <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a07882510548d012d6f25a6a4886dc544">try_lock_upgradable()</link> operation. Equivalent to "return true;" </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1aa8bbc0695c0797efb4b2aa046caed55f" name="timed_lock_upgradable"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name=""><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Simulates a mutex <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1aa8bbc0695c0797efb4b2aa046caed55f">timed_lock_upgradable()</link> operation. Equivalent to "return true;" </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1aa5d832cdad13bebc26bac8d08a66ac7b" name="unlock_upgradable"><type>void</type><description><para>Simulates a mutex <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1aa5d832cdad13bebc26bac8d08a66ac7b">unlock_upgradable()</link> operation. Empty function. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a6c3f44d7ce3a7851a9cdf028e7783a04" name="unlock_and_lock_upgradable"><type>void</type><description><para>Simulates <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a6c3f44d7ce3a7851a9cdf028e7783a04">unlock_and_lock_upgradable()</link>. Empty function. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a7f55e798c8b680a2d91b6e3b56301435" name="unlock_and_lock_sharable"><type>void</type><description><para>Simulates <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a7f55e798c8b680a2d91b6e3b56301435">unlock_and_lock_sharable()</link>. Empty function. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1aefbc69b16d380edaa63719d73d34ad6b" name="unlock_upgradable_and_lock_sharable"><type>void</type><description><para>Simulates <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1aefbc69b16d380edaa63719d73d34ad6b">unlock_upgradable_and_lock_sharable()</link>. Empty function. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a034d2c49f31cfd8dd748bfb585621c9d" name="unlock_upgradable_and_lock"><type>void</type><description><para>Simulates <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a034d2c49f31cfd8dd748bfb585621c9d">unlock_upgradable_and_lock()</link>. Empty function. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a2e20f0c752e40f96953c4939f87aacb2" name="try_unlock_upgradable_and_lock"><type>bool</type><description><para>Simulates <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a2e20f0c752e40f96953c4939f87aacb2">try_unlock_upgradable_and_lock()</link>. Equivalent to "return true;" </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1aa5c3a419b93dddb81e2c2fad249ac040" name="timed_unlock_upgradable_and_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name=""><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Simulates <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1aa5c3a419b93dddb81e2c2fad249ac040">timed_unlock_upgradable_and_lock()</link>. Equivalent to "return true;" </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a81fd610cac0dae80dfe07847ba65bae1" name="try_unlock_sharable_and_lock"><type>bool</type><description><para>Simulates <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a81fd610cac0dae80dfe07847ba65bae1">try_unlock_sharable_and_lock()</link>. Equivalent to "return true;" </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a6146d7ca5040e1d15bae4941ede479cb" name="try_unlock_sharable_and_lock_upgradable"><type>bool</type><description><para>Simulates <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1null__mutex_1a6146d7ca5040e1d15bae4941ede479cb">try_unlock_sharable_and_lock_upgradable()</link>. Equivalent to "return true;" </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.scoped__lock_8hpp" name="boost/interprocess/sync/scoped_lock.hpp">
<para>Describes the scoped_lock class. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock" name="scoped_lock"><template>
      <template-type-parameter name="Mutex"/>
    </template><description><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> is meant to carry out the tasks for locking, unlocking, try-locking and timed-locking (recursive or not) for the Mutex. The Mutex need not supply all of this functionality. If the client of scoped_lock&lt;Mutex&gt; does not use functionality which the Mutex does not supply, no harm is done. Mutex ownership transfer is supported through the syntax of move semantics. Ownership transfer is allowed both by construction and assignment. The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> does not support copy semantics. A compile time error results if copy construction or copy assignment is attempted. Mutex ownership can also be moved from an <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link> and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> via constructor. In this role, <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> shares the same functionality as a write_lock. </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1aa2a646139667239a04a5798edf0313c9" name="mutex_type"><type>Mutex</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1aee816a4be359f8dd3ac6dbf1a0cb68d2" cv="noexcept"><description><para>Effects: Default constructs a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link>. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> == false and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> == 0. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a9a026e48b87795491ee6df539e213c83" specifiers="explicit"><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><description><para>Effects: m.lock(). Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> == true and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> == &amp;m. Notes: The constructor will take ownership of the mutex. If another thread already owns the mutex, this thread will block until the mutex is released. Whether or not this constructor handles recursive locking depends upon the mutex. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a4ed8c30faeae19f60b7050e9917238cc"><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><classname>defer_lock_type</classname></paramtype></parameter><description><para>Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> == false, and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> == &amp;m. Notes: The constructor will not take ownership of the mutex. There is no effect required on the referenced mutex. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a47051dbdf4ffdc5c4beaf98e7a83bf0d"><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><classname>accept_ownership_type</classname></paramtype></parameter><description><para>Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> == true, and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> == &amp;m. Notes: The constructor will suppose that the mutex is already locked. There is no effect required on the referenced mutex. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a6149fa1f8a668b17e2db09e22af111a8"><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><classname>try_to_lock_type</classname></paramtype></parameter><description><para>Effects: m.try_lock(). Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> == &amp;m. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> == the return value of the m.try_lock() executed within the constructor. Notes: The constructor will take ownership of the mutex if it can do so without waiting. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support try_lock, this constructor will fail at compile time if instantiated, but otherwise have no effect. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1affcdc1a7815195ec5cab136754f5264b"><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Effects: m.timed_lock(abs_time). Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> == &amp;m. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> == the return value of the m.timed_lock(abs_time) executed within the constructor. Notes: The constructor will take ownership of the mutex if it can do it until abs_time is reached. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support try_lock, this constructor will fail at compile time if instantiated, but otherwise have no effect. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a06d57957b67c00e7d35b6605cccf8cc0" cv="noexcept"><parameter name="scop"><paramtype><classname>scoped_lock</classname> &amp;&amp;</paramtype></parameter><description><para>Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> == the value scop.mutex() had before the constructor executes. s1.mutex() == 0. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> == the value of scop.owns() before the constructor executes. scop.owns(). Notes: If the scop <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> owns the mutex, ownership is moved to thisscoped_lock with no blocking. If the scop <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> does not own the mutex, then neither will this <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link>. Only a moved <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link>'s will match this signature. An non-moved <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> can be moved with the expression: "boost::move(lock);". This constructor does not alter the state of the mutex, only potentially who owns it. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ade26ec80defd4d968d199b15ad15e979" specifiers="explicit"><template>
          <template-type-parameter name="T"/>
        </template><parameter name="upgr"><paramtype><classname>upgradable_lock</classname>&lt; T &gt; &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>Effects: If upgr.owns() then calls unlock_upgradable_and_lock() on the referenced mutex. upgr.release() is called. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> == the value upgr.mutex() had before the construction. upgr.mutex() == 0. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> == upgr.owns() before the construction. upgr.owns() == false after the construction. Notes: If upgr is locked, this constructor will lock this <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> while unlocking upgr. If upgr is unlocked, then this <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> will be unlocked as well. Only a moved <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link>'s will match this signature. An non-moved <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link> can be moved with the expression: "boost::move(lock);" This constructor may block if other threads hold a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> on this mutex (<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link>'s can share ownership with an <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link>). </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a7ab15ac0ca04abf17dd10d782d53d7b4"><template>
          <template-type-parameter name="T"/>
        </template><parameter name="upgr"><paramtype><classname>upgradable_lock</classname>&lt; T &gt; &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>try_to_lock_type</classname></paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>Effects: If upgr.owns() then calls try_unlock_upgradable_and_lock() on the referenced mutex: a)if try_unlock_upgradable_and_lock() returns true then <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> obtains the value from upgr.release() and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> is set to true. b)if try_unlock_upgradable_and_lock() returns false then upgr is unaffected and this <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> construction as the same effects as a default construction. c)Else upgr.owns() is false. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> obtains the value from upgr.release() and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> is set to false Notes: This construction will not block. It will try to obtain mutex ownership from upgr immediately, while changing the lock type from a "read lock" to a "write lock". If the "read lock" isn't held in the first place, the mutex merely changes type to an unlocked "write lock". If the "read lock" is held, then mutex transfer occurs only if it can do so in a non-blocking manner. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a8aac8210bae7ca7c61539c7d31bdb01c"><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="upgr"><paramtype><classname>upgradable_lock</classname>&lt; T &gt; &amp;&amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>Effects: If upgr.owns() then calls timed_unlock_upgradable_and_lock(abs_time) on the referenced mutex: a)if timed_unlock_upgradable_and_lock(abs_time) returns true then <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> obtains the value from upgr.release() and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> is set to true. b)if timed_unlock_upgradable_and_lock(abs_time) returns false then upgr is unaffected and this <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> construction as the same effects as a default construction. c)Else upgr.owns() is false. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> obtains the value from upgr.release() and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> is set to false Notes: This construction will not block. It will try to obtain mutex ownership from upgr immediately, while changing the lock type from a "read lock" to a "write lock". If the "read lock" isn't held in the first place, the mutex merely changes type to an unlocked "write lock". If the "read lock" is held, then mutex transfer occurs only if it can do so in a non-blocking manner. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad188d9e6136c3fd9cd97033f3771b0fa"><template>
          <template-type-parameter name="T"/>
        </template><parameter name="shar"><paramtype><classname>sharable_lock</classname>&lt; T &gt; &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>try_to_lock_type</classname></paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>Effects: If shar.owns() then calls try_unlock_sharable_and_lock() on the referenced mutex. a)if try_unlock_sharable_and_lock() returns true then <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> obtains the value from shar.release() and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> is set to true. b)if try_unlock_sharable_and_lock() returns false then shar is unaffected and this <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> construction has the same effects as a default construction. c)Else shar.owns() is false. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> obtains the value from shar.release() and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> is set to false Notes: This construction will not block. It will try to obtain mutex ownership from shar immediately, while changing the lock type from a "read lock" to a "write lock". If the "read lock" isn't held in the first place, the mutex merely changes type to an unlocked "write lock". If the "read lock" is held, then mutex transfer occurs only if it can do so in a non-blocking manner. </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad8084319f3f5584df6832db82a044c5b"><description><para>Effects: if (<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link>) mp_mutex-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a95226de39521b0dfbfdf5f6913f1ac30">unlock()</link>. Notes: The destructor behavior ensures that the mutex lock is not leaked.*<zwj/>/ </para></description></destructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ab7ba1ab407a85af9893c214f851a8fa9"><type><classname>scoped_lock</classname> &amp;</type><parameter name="scop"><paramtype><classname>scoped_lock</classname> &amp;&amp;</paramtype></parameter><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> before the call, then <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a95226de39521b0dfbfdf5f6913f1ac30">unlock()</link> is called on <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link>. *this gets the state of scop and scop gets set to a default constructed state. Notes: With a recursive mutex it is possible that both this and scop own the same mutex before the assignment. In this case, this will own the mutex after the assignment (and scop will not), but the mutex's lock count will be decremented by one. </para></description></copy-assignment>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a62b75774a9f359053592e0cf5ac84360" name="lock"><type>void</type><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> == 0 or if already locked, throws a lock_exception() exception. Calls <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a62b75774a9f359053592e0cf5ac84360">lock()</link> on the referenced mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> == true. Notes: The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> changes from a state of not owning the mutex, to owning the mutex, blocking if necessary. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a6375c2ecbbcf3881ee858b85c65f1fd3" name="try_lock"><type>bool</type><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> == 0 or if already locked, throws a lock_exception() exception. Calls <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a6375c2ecbbcf3881ee858b85c65f1fd3">try_lock()</link> on the referenced mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> == the value returned from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link>-&gt;<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a6375c2ecbbcf3881ee858b85c65f1fd3">try_lock()</link>. Notes: The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> changes from a state of not owning the mutex, to owning the mutex, but only if blocking was not required. If the mutex_type does not support <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a6375c2ecbbcf3881ee858b85c65f1fd3">try_lock()</link>, this function will fail at compile time if instantiated, but otherwise have no effect.*<zwj/>/ </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a6e37625230e5ec4d47376f69aa535af1" name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> == 0 or if already locked, throws a lock_exception() exception. Calls timed_lock(abs_time) on the referenced mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> == the value returned from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link>-&gt; timed_lock(abs_time). Notes: The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership by the specified time. If the mutex_type does not support timed_lock (), this function will fail at compile time if instantiated, but otherwise have no effect.*<zwj/>/ </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a1412165b782e1d12db4f721c5a50acbe" name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> == 0 or if already locked, throws a lock_exception() exception. Calls try_lock_until(abs_time) on the referenced mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> == the value returned from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link>-&gt; timed_lock(abs_time). Notes: The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership by the specified time. If the mutex_type does not support timed_lock (), this function will fail at compile time if instantiated, but otherwise have no effect.*<zwj/>/ </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1aff137f659ad1a7bd7cffa43fca39fda2" name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> == 0 or if already locked, throws a lock_exception() exception. Calls try_lock_until(abs_time) on the referenced mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> == the value returned from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link>-&gt; timed_lock(abs_time). Notes: The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership by the specified time. If the mutex_type does not support timed_lock (), this function will fail at compile time if instantiated, but otherwise have no effect.*<zwj/>/ </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a95226de39521b0dfbfdf5f6913f1ac30" name="unlock"><type>void</type><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> == 0 or if not locked, throws a lock_exception() exception. Calls <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a95226de39521b0dfbfdf5f6913f1ac30">unlock()</link> on the referenced mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> == false. Notes: The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> changes from a state of owning the mutex, to not owning the mutex.*<zwj/>/ </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2" name="owns" cv="const noexcept"><type>bool</type><description><para>Effects: Returns true if this <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> has acquired the referenced mutex. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ae541a361d9a1bb495e3df173f3d73365" name="conversion-operator" cv="const noexcept"><type>unspecified_bool_type</type><description><para>Conversion to bool. Returns <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link>. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1" name="mutex" cv="const noexcept"><type>mutex_type *</type><description><para>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a2b9a3f897a0f35eba20a0481dfd2a6c6" name="release" cv="noexcept"><type>mutex_type *</type><description><para>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1add4cef7e824de9f2d243b6864d967cc1">mutex()</link> == 0 and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1ad449978166ee8a5b75bd90eadf26aaf2">owns()</link> == false. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock_1a699bba79ce251c921b885d2aea9751c0" name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>scoped_lock</classname>&lt; mutex_type &gt; &amp;</paramtype></parameter><description><para>Effects: Swaps state with moved lock. Throws: Nothing. </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.sharable__lock_8hpp" name="boost/interprocess/sync/sharable_lock.hpp">
<para>Describes the upgradable_lock class that serves to acquire the upgradable lock of a mutex. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock" name="sharable_lock"><template>
      <template-type-parameter name="SharableMutex"/>
    </template><description><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> is meant to carry out the tasks for sharable-locking (such as read-locking), unlocking, try-sharable-locking and timed-sharable-locking (recursive or not) for the Mutex. The Mutex need not supply all of this functionality. If the client of sharable_lock&lt;Mutex&gt; does not use functionality which the Mutex does not supply, no harm is done. Mutex ownership can be shared among sharable_locks, and a single <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link>. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> does not support copy semantics. But <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> supports ownership transfer from an <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link>, <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link> and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> via transfer_lock syntax.*<zwj/>/ </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a728821d59799c353e338ff60a0fa513f" name="mutex_type"><type>SharableMutex</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a237576e8391ac22dbc1b2e5a37f346fe" cv="noexcept"><description><para>Effects: Default constructs a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link>. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link> == false and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link> == 0. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1ab5198b571a280c8ceca5761549b18ffb" specifiers="explicit"><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><description><para>Effects: m.lock_sharable(). Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link> == true and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link> == &amp;m. Notes: The constructor will take sharable-ownership of the mutex. If another thread already owns the mutex with exclusive ownership (<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link>), this thread will block until the mutex is released. If another thread owns the mutex with sharable or upgradable ownership, then no blocking will occur. Whether or not this constructor handles recursive locking depends upon the mutex. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1ae735dd26d9e767451cb004be96caf38f"><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><classname>defer_lock_type</classname></paramtype></parameter><description><para>Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link> == false, and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link> == &amp;m. Notes: The constructor will not take ownership of the mutex. There is no effect required on the referenced mutex. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a2b998c2aecf4acce80fc5c41a956b967"><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><classname>accept_ownership_type</classname></paramtype></parameter><description><para>Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link> == true, and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link> == &amp;m. Notes: The constructor will suppose that the mutex is already sharable locked. There is no effect required on the referenced mutex. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a3924951519e70b0e7a4ff7abb5e1af84"><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><classname>try_to_lock_type</classname></paramtype></parameter><description><para>Effects: m.try_lock_sharable() Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link> == &amp;m. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link> == the return value of the m.try_lock_sharable() executed within the constructor. Notes: The constructor will take sharable-ownership of the mutex if it can do so without waiting. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support try_lock_sharable, this constructor will fail at compile time if instantiated, but otherwise have no effect. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a8064b7d609ed93c825a1f4cb8f49f48a"><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Effects: m.timed_lock_sharable(abs_time) Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link> == &amp;m. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link> == the return value of the m.timed_lock_sharable() executed within the constructor. Notes: The constructor will take sharable-ownership of the mutex if it can do so within the time specified. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support timed_lock_sharable, this constructor will fail at compile time if instantiated, but otherwise have no effect. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a87bff05320d6d3ae1243ce7f83670352" cv="noexcept"><parameter name="upgr"><paramtype><classname>sharable_lock</classname>&lt; mutex_type &gt; &amp;&amp;</paramtype></parameter><description><para>Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link> == upgr.mutex(). <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link> == the value of upgr.owns() before the construction. upgr.owns() == false after the construction. Notes: If the upgr <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> owns the mutex, ownership is moved to this <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> with no blocking. If the upgr <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> does not own the mutex, then neither will this <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link>. Only a moved <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link>'s will match this signature. An non-moved <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> can be moved with the expression: "boost::move(lock);". This constructor does not alter the state of the mutex, only potentially who owns it. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1ab8d30fa5d897dda39b09b8feb22ab458"><template>
          <template-type-parameter name="T"/>
        </template><parameter name="upgr"><paramtype><classname>upgradable_lock</classname>&lt; T &gt; &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>Effects: If upgr.owns() then calls unlock_upgradable_and_lock_sharable() on the referenced mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link> == the value upgr.mutex() had before the construction. upgr.mutex() == 0 <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link> == the value of upgr.owns() before construction. upgr.owns() == false after the construction. Notes: If upgr is locked, this constructor will lock this <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> while unlocking upgr. Only a moved <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link>'s will match this signature. An non-moved <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link> can be moved with the expression: "boost::move(lock);".*<zwj/>/ </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a9b302f68c1de38e1991543294e7c9bba"><template>
          <template-type-parameter name="T"/>
        </template><parameter name="scop"><paramtype><classname>scoped_lock</classname>&lt; T &gt; &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>Effects: If scop.owns() then calls unlock_and_lock_sharable() on the referenced mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link> == the value scop.mutex() had before the construction. scop.mutex() == 0 <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link> == scop.owns() before the constructor. After the construction, scop.owns() == false. Notes: If scop is locked, this constructor will transfer the exclusive ownership to a sharable-ownership of this <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link>. Only a moved <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link>'s will match this signature. An non-moved <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> can be moved with the expression: "boost::move(lock);". </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1aed174e0384b9406cb2ee36fbafba4ae6"><description><para>Effects: if (<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link>) mp_mutex-&gt;unlock_sharable(). Notes: The destructor behavior ensures that the mutex lock is not leaked. </para></description></destructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a6c026d1b44051bcbdcecb75e2607b2d1"><type><classname>sharable_lock</classname> &amp;</type><parameter name="upgr"><paramtype><classname>sharable_lock</classname>&lt; mutex_type &gt; &amp;&amp;</paramtype></parameter><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link> before the call, then unlock_sharable() is called on <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link>. *this gets the state of upgr and upgr gets set to a default constructed state. Notes: With a recursive mutex it is possible that both this and upgr own the mutex before the assignment. In this case, this will own the mutex after the assignment (and upgr will not), but the mutex's lock count will be decremented by one. </para></description></copy-assignment>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a889849e989d974119f7e32c0a34d5e58" name="lock"><type>void</type><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link> == 0 or already locked, throws a lock_exception() exception. Calls lock_sharable() on the referenced mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link> == true. Notes: The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> changes from a state of not owning the mutex, to owning the mutex, blocking if necessary. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0c0f3ec1ac664871fe947227c33d0689" name="try_lock"><type>bool</type><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link> == 0 or already locked, throws a lock_exception() exception. Calls try_lock_sharable() on the referenced mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link> == the value returned from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link>-&gt;try_lock_sharable(). Notes: The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> changes from a state of not owning the mutex, to owning the mutex, but only if blocking was not required. If the mutex_type does not support try_lock_sharable(), this function will fail at compile time if instantiated, but otherwise have no effect. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0eed8e37a1726aa6e650ebb82a4cd853" name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link> == 0 or already locked, throws a lock_exception() exception. Calls timed_lock_sharable(abs_time) on the referenced mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link> == the value returned from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link>-&gt;timed_lock_sharable(elps_time). Notes: The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership within the specified time interval. If the mutex_type does not support timed_lock_sharable(), this function will fail at compile time if instantiated, but otherwise have no effect. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1af1159fbe05b14d5a86c70cfa2ed6f5ab" name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link> == 0 or already locked, throws a lock_exception() exception. Calls try_lock_shared_until(abs_time) on the referenced mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link> == the value returned from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link>-&gt;timed_lock_sharable(elps_time). Notes: The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership within the specified time interval. If the mutex_type does not support timed_lock_sharable(), this function will fail at compile time if instantiated, but otherwise have no effect.</para><para>Note: Similar to timed_lock, but with a std-like interface </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1ab6cd67415616b16cf58315ab2566ef4b" name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link> == 0 or already locked, throws a lock_exception() exception. Calls try_lock_shared_until(abs_time) on the referenced mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link> == the value returned from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link>-&gt;timed_lock_sharable(elps_time). Notes: The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership within the specified time interval. If the mutex_type does not support timed_lock_sharable(), this function will fail at compile time if instantiated, but otherwise have no effect.</para><para>Note: Similar to timed_lock, but with a std-like interface </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1aa6ccd7f0b48ef607cad1820b1dd4d7b1" name="unlock"><type>void</type><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link> == 0 or not locked, throws a lock_exception() exception. Calls unlock_sharable() on the referenced mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link> == false. Notes: The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> changes from a state of owning the mutex, to not owning the mutex. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4" name="owns" cv="const noexcept"><type>bool</type><description><para>Effects: Returns true if this <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> has acquired the referenced mutex. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a46aef11ba6ed3f0e9bfe3a088a55bd03" name="conversion-operator" cv="const noexcept"><type>unspecified_bool_type</type><description><para>Conversion to bool. Returns <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link>. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c" name="mutex" cv="const noexcept"><type>mutex_type *</type><description><para>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a45dcd0922363ddea9b75b1ded6f55642" name="release" cv="noexcept"><type>mutex_type *</type><description><para>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a13e5565ea2a14b199fb4d8629251b99c">mutex()</link> == 0 and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1a0e734921b811aaee92166f32d268d4b4">owns()</link> == false. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock_1ad4a8f96d0a727b5ab9160bde407258f6" name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>sharable_lock</classname>&lt; mutex_type &gt; &amp;</paramtype></parameter><description><para>Effects: Swaps state with moved lock. Throws: Nothing. </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.upgradable__lock_8hpp" name="boost/interprocess/sync/upgradable_lock.hpp">
<para>Describes the upgradable_lock class that serves to acquire the upgradable lock of a mutex. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock" name="upgradable_lock"><template>
      <template-type-parameter name="UpgradableMutex"/>
    </template><description><para><link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link> is meant to carry out the tasks for read-locking, unlocking, try-read-locking and timed-read-locking (recursive or not) for the Mutex. Additionally the <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link> can transfer ownership to a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> using transfer_lock syntax. The Mutex need not supply all of the functionality. If the client of upgradable_lock&lt;Mutex&gt; does not use functionality which the Mutex does not supply, no harm is done. Mutex ownership can be shared among read_locks, and a single <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link>. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link> does not support copy semantics. However <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link> supports ownership transfer from a upgradable_locks or scoped_locks via transfer_lock syntax. </para></description><typedef id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a5638084b21b53bcff1ff1760b36c6382" name="mutex_type"><type>UpgradableMutex</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a68d8dac1f766e68900da742246e3a8c1" cv="noexcept"><description><para>Effects: Default constructs a <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link>. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a4f37ab2685ab5ac3fb1c1e947370569e">owns()</link> == false and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af40cf6338af4d39e5e49d1ec888adb36">mutex()</link> == 0. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a49fa914ef053f83c947044fa88ab8697" specifiers="explicit"><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a40b2c3d5a0a9fd771fe07ae504387da1"><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><classname>defer_lock_type</classname></paramtype></parameter><description><para>Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a4f37ab2685ab5ac3fb1c1e947370569e">owns()</link> == false, and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af40cf6338af4d39e5e49d1ec888adb36">mutex()</link> == &amp;m. Notes: The constructor will not take ownership of the mutex. There is no effect required on the referenced mutex. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1ac188f1f038d567b04180d92af60c5ef9"><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><classname>accept_ownership_type</classname></paramtype></parameter><description><para>Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a4f37ab2685ab5ac3fb1c1e947370569e">owns()</link> == true, and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af40cf6338af4d39e5e49d1ec888adb36">mutex()</link> == &amp;m. Notes: The constructor will suppose that the mutex is already upgradable locked. There is no effect required on the referenced mutex. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1aa7b6f931e2a5cf4e6a6fdda8357d671a"><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><classname>try_to_lock_type</classname></paramtype></parameter><description><para>Effects: m.try_lock_upgradable(). Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af40cf6338af4d39e5e49d1ec888adb36">mutex()</link> == &amp;m. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a4f37ab2685ab5ac3fb1c1e947370569e">owns()</link> == the return value of the m.try_lock_upgradable() executed within the constructor. Notes: The constructor will take upgradable-ownership of the mutex if it can do so without waiting. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support try_lock_upgradable, this constructor will fail at compile time if instantiated, but otherwise have no effect. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1abc2a52295316a2eba52ec23b89cdef28"><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Effects: m.timed_lock_upgradable(abs_time) Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af40cf6338af4d39e5e49d1ec888adb36">mutex()</link> == &amp;m. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a4f37ab2685ab5ac3fb1c1e947370569e">owns()</link> == the return value of the m.timed_lock_upgradable() executed within the constructor. Notes: The constructor will take upgradable-ownership of the mutex if it can do so within the time specified. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support timed_lock_upgradable, this constructor will fail at compile time if instantiated, but otherwise have no effect. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1aee55a7076287ca703d041495b64da3df" cv="noexcept"><parameter name="upgr"><paramtype><classname>upgradable_lock</classname>&lt; mutex_type &gt; &amp;&amp;</paramtype></parameter><description><para>Effects: No effects on the underlying mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af40cf6338af4d39e5e49d1ec888adb36">mutex()</link> == the value upgr.mutex() had before the construction. upgr.mutex() == 0. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a4f37ab2685ab5ac3fb1c1e947370569e">owns()</link> == upgr.owns() before the construction. upgr.owns() == false. Notes: If upgr is locked, this constructor will lock this <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link> while unlocking upgr. If upgr is unlocked, then this <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link> will be unlocked as well. Only a moved <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link>'s will match this signature. An non-moved <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link> can be moved with the expression: "boost::move(lock);". This constructor does not alter the state of the mutex, only potentially who owns it. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1affe366f9e12737f528ffff2eef38f7bb"><template>
          <template-type-parameter name="T"/>
        </template><parameter name="scop"><paramtype><classname>scoped_lock</classname>&lt; T &gt; &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>Effects: If scop.owns(), m_.unlock_and_lock_upgradable(). Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af40cf6338af4d39e5e49d1ec888adb36">mutex()</link> == the value scop.mutex() had before the construction. scop.mutex() == 0. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a4f37ab2685ab5ac3fb1c1e947370569e">owns()</link> == scop.owns() before the constructor. After the construction, scop.owns() == false. Notes: If scop is locked, this constructor will transfer the exclusive-ownership to an upgradable-ownership of this <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link>. Only a moved <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link>'s will match this signature. An non-moved <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> can be moved with the expression: "boost::move(lock);". </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a49edf1be241f182290c1a7eb8419ed59"><template>
          <template-type-parameter name="T"/>
        </template><parameter name="shar"><paramtype><classname>sharable_lock</classname>&lt; T &gt; &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>try_to_lock_type</classname></paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>Effects: If shar.owns() then calls try_unlock_sharable_and_lock_upgradable() on the referenced mutex. a)if try_unlock_sharable_and_lock_upgradable() returns true then <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af40cf6338af4d39e5e49d1ec888adb36">mutex()</link> obtains the value from shar.release() and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a4f37ab2685ab5ac3fb1c1e947370569e">owns()</link> is set to true. b)if try_unlock_sharable_and_lock_upgradable() returns false then shar is unaffected and this <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link> construction has the same effects as a default construction. c)Else shar.owns() is false. <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af40cf6338af4d39e5e49d1ec888adb36">mutex()</link> obtains the value from shar.release() and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a4f37ab2685ab5ac3fb1c1e947370569e">owns()</link> is set to false. Notes: This construction will not block. It will try to obtain mutex ownership from shar immediately, while changing the lock type from a "read lock" to an "upgradable lock". If the "read lock" isn't held in the first place, the mutex merely changes type to an unlocked "upgradable lock". If the "read lock" is held, then mutex transfer occurs only if it can do so in a non-blocking manner. </para></description></constructor>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a78db6b83c240c5c723948b71415b9139"><description><para>Effects: if (<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a4f37ab2685ab5ac3fb1c1e947370569e">owns()</link>) m_-&gt;unlock_upgradable(). Notes: The destructor behavior ensures that the mutex lock is not leaked. </para></description></destructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a57a84a215dd842070e1ca8968125475b"><type><classname>upgradable_lock</classname> &amp;</type><parameter name="upgr"><paramtype><classname>upgradable_lock</classname> &amp;&amp;</paramtype></parameter><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a4f37ab2685ab5ac3fb1c1e947370569e">owns()</link>, then unlock_upgradable() is called on <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af40cf6338af4d39e5e49d1ec888adb36">mutex()</link>. *this gets the state of upgr and upgr gets set to a default constructed state. Notes: With a recursive mutex it is possible that both this and upgr own the mutex before the assignment. In this case, this will own the mutex after the assignment (and upgr will not), but the mutex's upgradable lock count will be decremented by one. </para></description></copy-assignment>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a61ee4bc4a23cd960e478a86c1424f30e" name="lock"><type>void</type><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af40cf6338af4d39e5e49d1ec888adb36">mutex()</link> == 0 or if already locked, throws a lock_exception() exception. Calls lock_upgradable() on the referenced mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a4f37ab2685ab5ac3fb1c1e947370569e">owns()</link> == true. Notes: The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1sharable__lock">sharable_lock</link> changes from a state of not owning the mutex, to owning the mutex, blocking if necessary. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a11a01e6076b245f7ed76174ec3589d27" name="try_lock"><type>bool</type><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af40cf6338af4d39e5e49d1ec888adb36">mutex()</link> == 0 or if already locked, throws a lock_exception() exception. Calls try_lock_upgradable() on the referenced mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a4f37ab2685ab5ac3fb1c1e947370569e">owns()</link> == the value returned from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af40cf6338af4d39e5e49d1ec888adb36">mutex()</link>-&gt;try_lock_upgradable(). Notes: The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link> changes from a state of not owning the mutex, to owning the mutex, but only if blocking was not required. If the mutex_type does not support try_lock_upgradable(), this function will fail at compile time if instantiated, but otherwise have no effect. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af8c802df78488052baee3d25dd594d4f" name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af40cf6338af4d39e5e49d1ec888adb36">mutex()</link> == 0 or if already locked, throws a lock_exception() exception. Calls timed_lock_upgradable(abs_time) on the referenced mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a4f37ab2685ab5ac3fb1c1e947370569e">owns()</link> == the value returned from <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af40cf6338af4d39e5e49d1ec888adb36">mutex()</link>-&gt;timed_lock_upgradable(abs_time). Notes: The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link> changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership within the specified time. If the mutex_type does not support timed_lock_upgradable(abs_time), this function will fail at compile time if instantiated, but otherwise have no effect. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a395b2447a0df20c51e31bda350b2a6b9" name="unlock"><type>void</type><description><para>Effects: If <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af40cf6338af4d39e5e49d1ec888adb36">mutex()</link> == 0 or if not locked, throws a lock_exception() exception. Calls unlock_upgradable() on the referenced mutex. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a4f37ab2685ab5ac3fb1c1e947370569e">owns()</link> == false. Notes: The <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock">upgradable_lock</link> changes from a state of owning the mutex, to not owning the mutex. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a4f37ab2685ab5ac3fb1c1e947370569e" name="owns" cv="const noexcept"><type>bool</type><description><para>Effects: Returns true if this <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1scoped__lock">scoped_lock</link> has acquired the referenced mutex. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a823dd0c2b6f5c0320cb4d26b0b3085b7" name="conversion-operator" cv="const noexcept"><type>unspecified_bool_type</type><description><para>Conversion to bool. Returns <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a4f37ab2685ab5ac3fb1c1e947370569e">owns()</link>. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af40cf6338af4d39e5e49d1ec888adb36" name="mutex" cv="const noexcept"><type>mutex_type *</type><description><para>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a84ca78763a83e337b9011fcd762e3156" name="release" cv="noexcept"><type>mutex_type *</type><description><para>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. Postconditions: <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1af40cf6338af4d39e5e49d1ec888adb36">mutex()</link> == 0 and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1a4f37ab2685ab5ac3fb1c1e947370569e">owns()</link> == false. </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1upgradable__lock_1ac859b4e52df2cfa46512e10e171b315a" name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>upgradable_lock</classname>&lt; mutex_type &gt; &amp;</paramtype></parameter><description><para>Effects: Swaps state with moved lock. Throws: Nothing. </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.timed__utils_8hpp" name="boost/interprocess/timed_utils.hpp">
<para>Describes some simple time-related utilities that can be used to call synchronization primitive and ipc methods that required waiting until the resource is signalled or a timeout expires.</para><para>These utilities are provided for those users that want to avoid dependence on std::chrono or boost::chrono or boost::date_time and just want to implement simple portable waits. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1usduration" name="usduration"><description><para>Describes a simple duration type with microsecond resolution that can be used with the ustime time-point utility to call timed functions of Boost.Interprocess' synchronization classes that expect a duration type (wait_for, lock_for...) </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1usduration_1a0e11c21fb15d7a88bebc89fd0148fcd0" specifiers="explicit"><parameter name="microsecs"><paramtype>boost::uint64_t</paramtype><default>0u</default></parameter><description><para>Constructs a duration type that stores microseconds from the passed count </para></description></constructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1usduration_1aa88e0fda6e5c5ac7b22cf7361d1f9185" name="get_microsecs" cv="const"><type>boost::uint64_t</type><description><para>Returns the stored microsecond count </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1usduration_1a30350902efe45b715220e4fc21df4fb1" name="operator&lt;" cv="const"><type>bool</type><parameter name="other"><paramtype>const <classname>usduration</classname> &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1usduration_1a0e81dc09b533b8342afd5eec7279a5a9" name="operator&gt;" cv="const"><type>bool</type><parameter name="other"><paramtype>const <classname>usduration</classname> &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1usduration_1a9d8c5a9d28df104a981c56f92335945a" name="operator&lt;=" cv="const"><type>bool</type><parameter name="other"><paramtype>const <classname>usduration</classname> &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1usduration_1ae4e171c6ab4f97446aa60ae941859473" name="operator&gt;=" cv="const"><type>bool</type><parameter name="other"><paramtype>const <classname>usduration</classname> &amp;</paramtype></parameter></method>
</method-group>
</class><class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1ustime" name="ustime"><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1ustime_1a5f9c600183aa4b56a07bb978ce4197f2" specifiers="explicit"><parameter name="microsecs"><paramtype>boost::uint64_t</paramtype><default>0u</default></parameter><description><para>Constructs a time point that is "microsecs" duration away from the epoch of the system </para></description></constructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1ustime_1adc9890ba9706a08406fc4151112d60ff" name="operator+="><type><classname>ustime</classname> &amp;</type><parameter name="other"><paramtype>const <classname>usduration</classname> &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1ustime_1a2b68dad0fd7335e2a40e60645ad21024" name="operator+"><type><classname>ustime</classname></type><parameter name="other"><paramtype>const <classname>usduration</classname> &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1ustime_1abf87daaf6656cfba138c98a677a8bb0b" name="operator-="><type><classname>ustime</classname> &amp;</type><parameter name="other"><paramtype>const <classname>usduration</classname> &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1ustime_1a73f4e7ab68254239d41d4f413492c018" name="operator-"><type><classname>ustime</classname></type><parameter name="other"><paramtype>const <classname>usduration</classname> &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1ustime_1a649f13727e743defe2bab28328695532" name="operator&lt;" cv="const"><type>bool</type><parameter name="other"><paramtype>const <classname>ustime</classname> &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1ustime_1a4f463d4ba98950fb93bb938ffb6d7683" name="operator&gt;" cv="const"><type>bool</type><parameter name="other"><paramtype>const <classname>ustime</classname> &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1ustime_1a2049b8c5fa3e1b04ac02c605f34f2990" name="operator&lt;=" cv="const"><type>bool</type><parameter name="other"><paramtype>const <classname>ustime</classname> &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1ustime_1a9a8ab7cd756fcf9565d09ec65c8b1b44" name="operator&gt;=" cv="const"><type>bool</type><parameter name="other"><paramtype>const <classname>ustime</classname> &amp;</paramtype></parameter></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1ustime_1a54ae7b1ef8b5f78c589b1336af5f50db" name="get_microsecs" cv="const"><type>boost::uint64_t</type><description><para>Returns the stored count that represents microseconds from epoch </para></description></method>
</method-group>
</class><function id="doxygen.boost_interprocess_header_reference.timed__utils_8hpp_1a825a05961e2967ba9bba6b7661ff3f69" name="usduration_from_seconds"><type><classname>usduration</classname></type><parameter name="sec"><paramtype>boost::uint64_t</paramtype></parameter><description><para>Utility that returns a duration from a seconds count </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.timed__utils_8hpp_1a06edd79728c966c14ac4abddc0263587" name="usduration_from_milliseconds"><type><classname>usduration</classname></type><parameter name="millisec"><paramtype>boost::uint64_t</paramtype></parameter><description><para>Utility that returns a duration from a milliseconds count </para></description></function>
<function id="doxygen.boost_interprocess_header_reference.timed__utils_8hpp_1ad95c2d04534cc54be077083b838c3b94" name="ustime_delay_milliseconds"><type><classname>ustime</classname></type><parameter name="msecs"><paramtype>unsigned</paramtype></parameter><description><para>Utility that returns a time_point in the future that is "msecs" milliseconds in the future from now. </para></description></function>
















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.windows__shared__memory_8hpp" name="boost/interprocess/windows_shared_memory.hpp">
<para>Describes a class representing a native windows shared memory. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory" name="windows_shared_memory"><description><para>A class that wraps the native Windows shared memory that is implemented as a file mapping of the paging file. Unlike <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object">shared_memory_object</link>, <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory">windows_shared_memory</link> has no kernel persistence and the shared memory is destroyed when all processes destroy all their <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory">windows_shared_memory</link> objects and mapped regions for the same shared memory or the processes end/crash.</para><para>Warning: Windows native shared memory and interprocess portable shared memory (<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object">boost::interprocess::shared_memory_object</link>) can't communicate between them. </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory_1af5e01ae200f08ffe828f1fa49f31ec64" cv="noexcept"><description><para>Default constructor. Represents an empty <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory">windows_shared_memory</link>. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory_1a50695bb2f355028e484301342faf8a1a"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a new native shared memory with name "name" and at least size "size", with the access mode "mode". If the file previously exists, throws an error. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory_1aa05443f64ee7ce0d2774013fe75a8af1"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Tries to create a shared memory object with name "name" and at least size "size", with the access mode "mode". If the file previously exists, it tries to open it with mode "mode". Otherwise throws an error. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory_1a6668d22453d8426365a0886d4b627feb"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><description><para>Tries to open a shared memory object with name "name", with the access mode "mode". If the file does not previously exist, it throws an error. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory_1aac96ab7083a6ca5b540f6066d1ec8862"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a new native shared memory with name "name" and at least size "size", with the access mode "mode". If the file previously exists, throws an error. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory_1a8ce131bf2d4c18d16dd9365bb6312c27"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Tries to create a shared memory object with name "name" and at least size "size", with the access mode "mode". If the file previously exists, it tries to open it with mode "mode". Otherwise throws an error. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory_1ad8ab81d3b8ca0c5ec67d06c4176310a1"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><description><para>Tries to open a shared memory object with name "name", with the access mode "mode". If the file does not previously exist, it throws an error. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory_1a86db1e6a3250ace7a6ab9e73e3ca1cf3" cv="noexcept"><parameter name="moved"><paramtype><classname>windows_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s shared memory object to *this. After the call, "moved" does not represent any shared memory object. Does not throw </para></description></constructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory_1a6d39933560e06341cacced7424b77285" cv="noexcept"><type><classname>windows_shared_memory</classname> &amp;</type><parameter name="moved"><paramtype><classname>windows_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s shared memory to *this. After the call, "moved" does not represent any shared memory. Does not throw </para></description></copy-assignment>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory_1aa7ad22b388b43111f568e53e4fa087e2" name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>windows_shared_memory</classname> &amp;</paramtype></parameter><purpose>Swaps to shared_memory_objects. Does not throw. </purpose></method>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory_1a714ba5d80797fa1e0a6e7996cc7fd862"><description><para>Destroys *this. All mapped regions are still valid after destruction. When all mapped regions and <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory">windows_shared_memory</link> objects referring the shared memory are destroyed, the operating system will destroy the shared memory. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory_1aeec47abdfd3d16876f28b792575bf0bc" name="get_name" cv="const noexcept"><type>const char *</type><purpose>Returns the name of the shared memory. </purpose></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory_1a9e00d6d3010e1875f6198f9095d958aa" name="get_mode" cv="const noexcept"><type>mode_t</type><purpose>Returns access mode. </purpose></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory_1aff2846f1eead90a099ba70c3575ab3dc" name="get_mapping_handle" cv="const noexcept"><type>mapping_handle_t</type><purpose>Returns the mapping handle. Never throws. </purpose></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1windows__shared__memory_1a684469aef1d956665ab2ec30ff4571cf" name="get_size" cv="const noexcept"><type>offset_t</type><description><para>Returns the size of the windows shared memory. It will be a 4K rounded size of the "size" passed in the constructor. </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.xsi__key_8hpp" name="boost/interprocess/xsi_key.hpp">
<para>Describes a class representing a xsi key type. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__key" name="xsi_key"><description><para>A class that wraps XSI (System V) key_t type. This type calculates key_t from path and id using ftok, sets key to a specified value, or sets key to IPC_PRIVATE using the default constructor. </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__key_1a62b1e8bf53eed7107e1e922fb572accc"><description><para>Default constructor. Represents a private <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__key">xsi_key</link>. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__key_1a3f517ca8acf20e830c3708a9e2133703" specifiers="explicit"><parameter name="key"><paramtype>key_t</paramtype></parameter><purpose>Creates a new XSI key using a specified value. Constructor is explicit to avoid ambiguity with shmid. </purpose></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__key_1aea3c3b128b9cc0d7a9ae7783e47f72bb"><parameter name="path"><paramtype>const char *</paramtype></parameter><parameter name="id"><paramtype>boost::uint8_t</paramtype></parameter><description><para>Creates a new XSI shared memory with a key obtained from a call to ftok (with path "path" and id "id"), of size "size" and permissions "perm". If the shared memory previously exists, throws an error. </para></description></constructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__key_1a79fdd5ebca2373a070ee45b0544a0388" name="get_key" cv="const"><type>key_t</type><purpose>Returns the internal key_t value. </purpose></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
<header id="doxygen.boost_interprocess_header_reference.xsi__shared__memory_8hpp" name="boost/interprocess/xsi_shared_memory.hpp">
<para>Describes a class representing a native xsi shared memory. </para><namespace name="boost">
<namespace name="interprocess">
<class id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__shared__memory" name="xsi_shared_memory"><description><para>A class that wraps XSI (System V) shared memory. Unlike <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object">shared_memory_object</link>, <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__shared__memory">xsi_shared_memory</link> needs a valid <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__key">xsi_key</link> to identify a shared memory object.</para><para>Warning: XSI shared memory and interprocess portable shared memory (<link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1shared__memory__object">boost::interprocess::shared_memory_object</link>) can't communicate between them. </para></description><method-group name="public member functions">
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__shared__memory_1aee4894f6322796d9049c6686bbc91b0f" cv="noexcept"><description><para>Default constructor. Represents an empty <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__shared__memory">xsi_shared_memory</link>. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__shared__memory_1a020afdc8c65a57122a229b40b8563527"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="shmid"><paramtype>int</paramtype></parameter><description><para>Initializes *this with a shmid previously obtained (possibly from another process) This lower-level initializer allows shared memory mapping without having a key. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__shared__memory_1a6eb8685a5d5306dff3893403afaa5dbf"><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="key"><paramtype>const <classname>xsi_key</classname> &amp;</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Creates a new XSI shared memory from 'key', with size "size" and permissions "perm". If the shared memory previously exists, throws an error. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__shared__memory_1a946a5952b97aceb9227d53752ceccf08"><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="key"><paramtype>const <classname>xsi_key</classname> &amp;</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default>permissions()</default></parameter><description><para>Opens an existing shared memory with identifier 'key' or creates a new XSI shared memory from identifier 'key', with size "size" and permissions "perm". </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__shared__memory_1a5bf77927a0691290f8bc50f81115a32a"><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="key"><paramtype>const <classname>xsi_key</classname> &amp;</paramtype></parameter><description><para>Tries to open a XSI shared memory with identifier 'key' If the shared memory does not previously exist, it throws an error. </para></description></constructor>
<constructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__shared__memory_1a8b08ecc9581ea0c5ae012d4830e4d4ea" cv="noexcept"><parameter name="moved"><paramtype><classname>xsi_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s shared memory object to *this. After the call, "moved" does not represent any shared memory object. Does not throw </para></description></constructor>
<copy-assignment id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__shared__memory_1abf4ba6b7a4161f7ce3e5e04eb64d6239" cv="noexcept"><type><classname>xsi_shared_memory</classname> &amp;</type><parameter name="moved"><paramtype><classname>xsi_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s shared memory to *this. After the call, "moved" does not represent any shared memory. Does not throw </para></description></copy-assignment>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__shared__memory_1ad547f60f533940c34be33e189a226b84" name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>xsi_shared_memory</classname> &amp;</paramtype></parameter><purpose>Swaps two xsi_shared_memorys. Does not throw. </purpose></method>
<destructor id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__shared__memory_1a44eec5d743e111f5576045a469070994"><description><para>Destroys *this. The shared memory won't be destroyed, just this connection to it. Use <link linkend="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__shared__memory_1ae0cb9dd154d601a5b4324260aacf52f7">remove()</link> to destroy the shared memory. </para></description></destructor>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__shared__memory_1ab7dcc911007de5d64280f9487399d707" name="get_shmid" cv="const noexcept"><type>int</type><description><para>Returns the shared memory ID that identifies the shared memory </para></description></method>
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__shared__memory_1a6acec4a840218c0486c7a369bb575fa0" name="get_mapping_handle" cv="const noexcept"><type>mapping_handle_t</type><description><para>Returns the mapping handle. Never throws </para></description></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_interprocess_header_reference.classboost_1_1interprocess_1_1xsi__shared__memory_1ae0cb9dd154d601a5b4324260aacf52f7" name="remove" specifiers="static"><type>bool</type><parameter name="shmid"><paramtype>int</paramtype></parameter><description><para>Erases the XSI shared memory object identified by shmid from the system. Returns false on error. Never throws </para></description></method>
</method-group>
</class>


















































</namespace>
</namespace>
</header>
</library-reference>