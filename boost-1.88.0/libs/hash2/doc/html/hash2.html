<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<meta name="author" content="Peter Dimov">
<title>Hash2: An Extensible Hashing Framework</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge, pre.rouge .w {
  color: #24292f;
  background-color: #f6f8fa;
}
pre.rouge .k, pre.rouge .kd, pre.rouge .kn, pre.rouge .kp, pre.rouge .kr, pre.rouge .kt, pre.rouge .kv {
  color: #cf222e;
}
pre.rouge .gr {
  color: #f6f8fa;
}
pre.rouge .gd {
  color: #82071e;
  background-color: #ffebe9;
}
pre.rouge .nb {
  color: #953800;
}
pre.rouge .nc {
  color: #953800;
}
pre.rouge .no {
  color: #953800;
}
pre.rouge .nn {
  color: #953800;
}
pre.rouge .sr {
  color: #116329;
}
pre.rouge .na {
  color: #116329;
}
pre.rouge .nt {
  color: #116329;
}
pre.rouge .gi {
  color: #116329;
  background-color: #dafbe1;
}
pre.rouge .ges {
  font-weight: bold;
  font-style: italic;
}
pre.rouge .kc {
  color: #0550ae;
}
pre.rouge .l, pre.rouge .ld, pre.rouge .m, pre.rouge .mb, pre.rouge .mf, pre.rouge .mh, pre.rouge .mi, pre.rouge .il, pre.rouge .mo, pre.rouge .mx {
  color: #0550ae;
}
pre.rouge .sb {
  color: #0550ae;
}
pre.rouge .bp {
  color: #0550ae;
}
pre.rouge .ne {
  color: #0550ae;
}
pre.rouge .nl {
  color: #0550ae;
}
pre.rouge .py {
  color: #0550ae;
}
pre.rouge .nv, pre.rouge .vc, pre.rouge .vg, pre.rouge .vi, pre.rouge .vm {
  color: #0550ae;
}
pre.rouge .o, pre.rouge .ow {
  color: #0550ae;
}
pre.rouge .gh {
  color: #0550ae;
  font-weight: bold;
}
pre.rouge .gu {
  color: #0550ae;
  font-weight: bold;
}
pre.rouge .s, pre.rouge .sa, pre.rouge .sc, pre.rouge .dl, pre.rouge .sd, pre.rouge .s2, pre.rouge .se, pre.rouge .sh, pre.rouge .sx, pre.rouge .s1, pre.rouge .ss {
  color: #0a3069;
}
pre.rouge .nd {
  color: #8250df;
}
pre.rouge .nf, pre.rouge .fm {
  color: #8250df;
}
pre.rouge .err {
  color: #f6f8fa;
  background-color: #82071e;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cm, pre.rouge .cp, pre.rouge .cpf, pre.rouge .c1, pre.rouge .cs {
  color: #6e7781;
}
pre.rouge .gl {
  color: #6e7781;
}
pre.rouge .gt {
  color: #6e7781;
}
pre.rouge .ni {
  color: #24292f;
}
pre.rouge .si {
  color: #24292f;
}
pre.rouge .ge {
  color: #24292f;
  font-style: italic;
}
pre.rouge .gs {
  color: #24292f;
  font-weight: bold;
}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Hash2: An Extensible Hashing Framework</h1>
<div class="details">
<span id="author" class="author">Peter Dimov</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#overview">Overview</a></li>
<li><a href="#hashing_bytes">Hashing Byte Sequences</a>
<ul class="sectlevel2">
<li><a href="#hashing_bytes_hash_algorithm_requirements">Hash Algorithm Requirements</a>
<ul class="sectlevel3">
<li><a href="#hashing_bytes_result_type">result_type</a></li>
<li><a href="#hashing_bytes_block_size">block_size</a></li>
<li><a href="#hashing_bytes_default_constructor">Default Constructor</a></li>
<li><a href="#hashing_bytes_constructor_taking_an_integer_seed">Constructor Taking an Integer Seed</a></li>
<li><a href="#hashing_bytes_constructor_taking_a_byte_sequence_seed">Constructor Taking a Byte Sequence Seed</a></li>
<li><a href="#hashing_bytes_copy_constructor_copy_assignment">Copy Constructor, Copy Assignment</a></li>
<li><a href="#hashing_bytes_update">update</a></li>
<li><a href="#hashing_bytes_result">result</a></li>
</ul>
</li>
<li><a href="#hashing_bytes_compile_time_hashing">Compile Time Hashing</a></li>
<li><a href="#hashing_bytes_provided_hash_algorithms">Provided Hash Algorithms</a>
<ul class="sectlevel3">
<li><a href="#hashing_bytes_fnv_1a">FNV-1a</a></li>
<li><a href="#hashing_bytes_xxhash">xxHash</a></li>
<li><a href="#hashing_bytes_siphash">SipHash</a></li>
<li><a href="#hashing_bytes_md5">MD5</a></li>
<li><a href="#hashing_bytes_sha_1">SHA-1</a></li>
<li><a href="#hashing_bytes_sha_2">SHA-2</a></li>
<li><a href="#hashing_bytes_sha_3">SHA-3</a></li>
<li><a href="#hashing_bytes_ripemd_160_ripemd_128">RIPEMD-160, RIPEMD-128</a></li>
<li><a href="#hashing_bytes_hmac">HMAC</a></li>
</ul>
</li>
<li><a href="#hashing_bytes_choosing_a_hash_algorithm">Choosing a Hash Algorithm</a></li>
</ul>
</li>
<li><a href="#hashing_objects">Hashing C&#43;&#43; Objects</a>
<ul class="sectlevel2">
<li><a href="#hashing_objects_contiguously_hashable_types">Contiguously Hashable Types</a></li>
<li><a href="#hashing_objects_integral_types">Integral Types</a></li>
<li><a href="#hashing_objects_floating_point_types">Floating Point Types</a></li>
<li><a href="#hashing_objects_enumeration_types">Enumeration Types</a></li>
<li><a href="#hashing_objects_pointers">Pointers</a></li>
<li><a href="#hashing_objects_arrays">Arrays</a></li>
<li><a href="#hashing_objects_ranges">Ranges</a></li>
<li><a href="#hashing_objects_tuples">Tuples</a></li>
<li><a href="#hashing_objects_described_classes">Described Classes</a></li>
<li><a href="#hashing_objects_user_defined_types">User Defined Types</a></li>
</ul>
</li>
<li><a href="#examples">Usage Examples</a>
<ul class="sectlevel2">
<li><a href="#example_use_with_unordered_containers">Use with Unordered Containers</a></li>
<li><a href="#example_md5sum">md5sum</a></li>
<li><a href="#example_hash2sum">hash2sum</a></li>
<li><a href="#example_compile_time_hashing">Compile Time Hashing</a></li>
<li><a href="#example_result_extension">Result Extension</a></li>
</ul>
</li>
<li><a href="#implementation">Implementation Features</a>
<ul class="sectlevel2">
<li><a href="#implementation_supported_compilers">Supported Compilers</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a>
<ul class="sectlevel2">
<li><a href="#ref_hash_algorithms">Hash Algorithms</a>
<ul class="sectlevel3">
<li><a href="#ref_fnv1a">&lt;boost/hash2/fnv1a.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_fnv1a_fnv1a_32">fnv1a_32</a></li>
<li><a href="#ref_fnv1a_fnv1a_64">fnv1a_64</a></li>
</ul>
</li>
<li><a href="#ref_xxhash">&lt;boost/hash2/xxhash.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_xxhash_xxhash_32">xxhash_32</a></li>
<li><a href="#ref_xxhash_xxhash_64">xxhash_64</a></li>
</ul>
</li>
<li><a href="#ref_siphash">&lt;boost/hash2/siphash.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_siphash_siphash_32">siphash_32</a></li>
<li><a href="#ref_siphash_siphash_64">siphash_64</a></li>
</ul>
</li>
<li><a href="#ref_hmac">&lt;boost/hash2/hmac.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_hmac_hmac">hmac</a></li>
</ul>
</li>
<li><a href="#ref_md5">&lt;boost/hash2/md5.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_md5_md5_128">md5_128</a></li>
</ul>
</li>
<li><a href="#ref_sha1">&lt;boost/hash2/sha1.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_sha1_sha1_160">sha1_160</a></li>
</ul>
</li>
<li><a href="#ref_sha2">&lt;boost/hash2/sha2.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_sha2_sha2_256">sha2_256</a></li>
<li><a href="#ref_sha2_sha2_224">sha2_224</a></li>
<li><a href="#ref_sha2_sha2_512">sha2_512</a></li>
<li><a href="#ref_sha2_sha2_384">sha2_384</a></li>
<li><a href="#ref_sha2_sha2_512_224">sha2_512_224</a></li>
<li><a href="#ref_sha2_sha2_512_256">sha2_512_256</a></li>
</ul>
</li>
<li><a href="#ref_sha3">&lt;boost/hash2/sha3.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_sha3_sha3_256">sha3_256</a></li>
<li><a href="#ref_sha3_sha3_224">sha3_224</a></li>
<li><a href="#ref_sha3_sha3_512">sha3_512</a></li>
<li><a href="#ref_sha3_sha3_384">sha3_384</a></li>
<li><a href="#ref_sha3_shake_128">shake_128</a></li>
<li><a href="#ref_sha3_shake_256">shake_256</a></li>
</ul>
</li>
<li><a href="#ref_ripemd">&lt;boost/hash2/ripemd.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_ripemd_ripemd_160">ripemd_160</a></li>
<li><a href="#ref_ripemd_ripemd_128">ripemd_128</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ref_utilities_and_traits">Utilities and Traits</a>
<ul class="sectlevel3">
<li><a href="#ref_digest">&lt;boost/hash2/digest.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_digest_digest">digest</a></li>
</ul>
</li>
<li><a href="#ref_endian">&lt;boost/hash2/endian.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_endian_endian">endian</a></li>
</ul>
</li>
<li><a href="#ref_flavor">&lt;boost/hash2/flavor.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_flavor_default_flavor">default_flavor</a></li>
<li><a href="#ref_flavor_little_endian_flavor">little_endian_flavor</a></li>
<li><a href="#ref_flavor_big_endian_flavor">big_endian_flavor</a></li>
</ul>
</li>
<li><a href="#ref_get_integral_result">&lt;boost/hash2/get_integral_result.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_get_integral_result_get_integral_result">get_integral_result</a></li>
</ul>
</li>
<li><a href="#ref_is_trivially_equality_comparable">&lt;boost/hash2/is_trivially_equality_comparable.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_is_trivially_equality_comparable_is_trivially_equality_comparable">is_trivially_equality_comparable</a></li>
</ul>
</li>
<li><a href="#ref_is_endian_independent">&lt;boost/hash2/is_endian_independent.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_is_endian_independent_is_endian_independent">is_endian_independent</a></li>
</ul>
</li>
<li><a href="#ref_is_contiguously_hashable">&lt;boost/hash2/is_contiguously_hashable.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_is_contiguously_hashable_is_contiguously_hashable">is_contiguously_hashable</a></li>
</ul>
</li>
<li><a href="#ref_has_constant_size">&lt;boost/hash2/has_constant_size.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_has_constant_size_has_constant_size">has_constant_size</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ref_hashing_cpp_objects">Hashing C&#43;&#43; Objects</a>
<ul class="sectlevel3">
<li><a href="#ref_hash_append_fwd">&lt;boost/hash2/hash_append_fwd.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_hash_append_fwd_synopsis">Synopsis</a></li>
<li><a href="#ref_hash_append_fwd_examples">Examples</a></li>
</ul>
</li>
<li><a href="#ref_hash_append">&lt;boost/hash2/hash_append.hpp&gt;</a>
<ul class="sectlevel4">
<li><a href="#ref_hash_append_hash_append">hash_append</a></li>
<li><a href="#ref_hash_append_hash_append_range">hash_append_range</a></li>
<li><a href="#ref_hash_append_hash_append_size">hash_append_size</a></li>
<li><a href="#ref_hash_append_hash_append_range_and_size">hash_append_range_and_size</a></li>
<li><a href="#ref_hash_append_hash_append_unordered_range">hash_append_unordered_range</a></li>
<li><a href="#ref_hash_append_hash_append_tag">hash_append_tag</a></li>
<li><a href="#ref_hash_append_hash_append_provider">hash_append_provider</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#copyright">Copyright and License</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="overview"><a class="anchor" href="#overview"></a>Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This library implements an extensible framework for implementing
hashing algorithms that can support user-defined types. Its structure
is largely based on the paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3980.html">"Types don&#8217;t know #"</a>
by Howard Hinnant, Vinnie Falco and John Bytheway.</p>
</div>
<div class="paragraph">
<p>The key feature of the design is the clean separation between the <em>hash
algorithm</em>, which takes an untyped stream of bytes (a <em>message</em>) and produces
a hash value (a <em>message digest</em>), and the <code>hash_append</code> function, which takes
a type and is responsible for turning the value of this type into a
sequence of bytes and feeding them to a <em>hash algorithm</em>.</p>
</div>
<div class="paragraph">
<p>This allows hashing support for user-defined types to be written once,
and then automatically being usable with any hash algorithms, even such
that weren&#8217;t yet available at the time the type was defined.</p>
</div>
<div class="paragraph">
<p>The following popular hashing algorithms are provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">FNV-1a</a></p>
</li>
<li>
<p><a href="https://cyan4973.github.io/xxHash/">xxHash</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/SipHash">SipHash</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc1321">MD5</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc3174">SHA-1</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc6234">SHA-2</a></p>
</li>
<li>
<p><a href="https://csrc.nist.gov/pubs/fips/202/final">SHA-3</a></p>
</li>
<li>
<p><a href="https://homes.esat.kuleuven.be/%7Ebosselae/ripemd160.html">RIPEMD-160, RIPEMD-128</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc2104">HMAC</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>but it&#8217;s also possible for users to write their own; as long as the
hash algorithm conforms to the concept, <code>hash_append</code> will work with it,
and so will all user-defined types that support <code>hash_append</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hashing_bytes"><a class="anchor" href="#hashing_bytes"></a>Hashing Byte Sequences</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This library addresses two major use cases: hashing an untyped sequence
of bytes, and hashing C&#43;&#43; objects.</p>
</div>
<div class="paragraph">
<p>Untyped byte sequences (also called <em>messages</em>) are hashed by passing
them to a <em>hash algorithm</em>, which then produces a hash value (or a
<em>message digest</em>).</p>
</div>
<div class="paragraph">
<p>The same <em>hash algorithm</em>, when passed the same <em>message</em>, will always
produce the same <em>digest</em>. (Published algorithms provide <em>message</em> and
corresponding <em>digest</em> pairs, called <em>test vectors</em>, to enable
verification of independent implementations.)</p>
</div>
<div class="paragraph">
<p>(To hash a C&#43;&#43; object, it&#8217;s first converted (serialized) to a sequence
of bytes, then passed to a <em>hash algorithm</em>.)</p>
</div>
<div class="sect2">
<h3 id="hashing_bytes_hash_algorithm_requirements"><a class="anchor" href="#hashing_bytes_hash_algorithm_requirements"></a>Hash Algorithm Requirements</h3>
<div class="paragraph">
<p>A <em>hash algorithm</em> must have the following structure, and meet the
following minimum requirements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">HashAlgorithm</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="cm">/*integral or array-like*/</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span> <span class="c1">// optional</span>

    <span class="n">HashAlgorithm</span><span class="p">();</span>
    <span class="k">explicit</span> <span class="n">HashAlgorithm</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span>
    <span class="n">HashAlgorithm</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">seed</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="n">HashAlgorithm</span><span class="p">(</span> <span class="n">HashAlgorithm</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">r</span> <span class="p">);</span>
    <span class="n">HashAlgorithm</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">HashAlgorithm</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">r</span> <span class="p">);</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="n">result_type</span> <span class="n">result</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="hashing_bytes_result_type"><a class="anchor" href="#hashing_bytes_result_type"></a>result_type</h4>
<div class="paragraph">
<p>The nested type <code>result_type</code> is the type of the produced hash value. It
can be an unsigned integer type (that is not <code>bool</code>), typically
<code>std::uint32_t</code> or <code>std::uint64_t</code>, or a <code>std::array</code>-like type with a
value type of <code>unsigned char</code>.</p>
</div>
<div class="paragraph">
<p>Normally, non-cryptographic hash functions have an integer <code>result_type</code>,
and cryptographic hash functions have an array-like <code>result_type</code>, but
that&#8217;s not required.</p>
</div>
<div class="paragraph">
<p>The provided utility function <code>get_integral_result</code> can be used to obtain
an integer hash value from any valid <code>result_type</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="hashing_bytes_block_size"><a class="anchor" href="#hashing_bytes_block_size"></a>block_size</h4>
<div class="paragraph">
<p>Cryptographic hash functions provide a <code>block_size</code> value, which is their
block size (e.g. 64 for MD5, 128 for SHA2-512) and is required in order
to implement the corresponding <a href="https://en.wikipedia.org/wiki/HMAC">HMAC</a>.</p>
</div>
<div class="paragraph">
<p><code>block_size</code> is an optional requirement.</p>
</div>
</div>
<div class="sect3">
<h4 id="hashing_bytes_default_constructor"><a class="anchor" href="#hashing_bytes_default_constructor"></a>Default Constructor</h4>
<div class="paragraph">
<p>All <em>hash algorithms</em> must be default constructible. The default
constructor initializes the internal state of the hash algorithm to its
initial values, as published in its specification.</p>
</div>
<div class="paragraph">
<p>For example, the default constructor of <code>md5_128</code> corresponds to calling
the function <code>MD5_Init</code> of the reference implementation.</p>
</div>
</div>
<div class="sect3">
<h4 id="hashing_bytes_constructor_taking_an_integer_seed"><a class="anchor" href="#hashing_bytes_constructor_taking_an_integer_seed"></a>Constructor Taking an Integer Seed</h4>
<div class="paragraph">
<p>All <em>hash algorithms</em> must be constructible from a value of type
<code>std::uint64_t</code>, which serves as a seed.</p>
</div>
<div class="paragraph">
<p>Using a seed value of 0 is equivalent to default construction.</p>
</div>
<div class="paragraph">
<p>Distinct seed values cause the internal state to be initialized differently,
and therefore, instances of the hash algorithm initialized by different seeds
produce different hash values when passed the same message.</p>
</div>
<div class="paragraph">
<p>Seeding using random (unobservable from the outside) values is useful for
preventing <a href="https://en.wikipedia.org/wiki/Collision_attack#Hash_flooding">hash flooding attacks</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="hashing_bytes_constructor_taking_a_byte_sequence_seed"><a class="anchor" href="#hashing_bytes_constructor_taking_a_byte_sequence_seed"></a>Constructor Taking a Byte Sequence Seed</h4>
<div class="paragraph">
<p>All <em>hash algorithms</em> can be constructed from a seed sequence of
<code>unsigned char</code> values (this makes all hash algorithms
<a href="https://en.wikipedia.org/wiki/Keyed_hash_function">keyed hash functions</a>.)</p>
</div>
<div class="paragraph">
<p>A null sequence (one with length 0) produces a default-constructed instance.</p>
</div>
<div class="paragraph">
<p>Different seed sequences produce differently initialized instances.</p>
</div>
<div class="paragraph">
<p>While this requirement makes all hash algorithms usable as MACs
(<a href="https://en.wikipedia.org/wiki/Message_authentication_code">Message Authentication Codes</a>),
you should as a general rule prefer an established MAC algorithm, such as
<a href="https://en.wikipedia.org/wiki/HMAC">HMAC</a>. (A HMAC implementation is provided.)</p>
</div>
</div>
<div class="sect3">
<h4 id="hashing_bytes_copy_constructor_copy_assignment"><a class="anchor" href="#hashing_bytes_copy_constructor_copy_assignment"></a>Copy Constructor, Copy Assignment</h4>
<div class="paragraph">
<p>Hash algorithms are copy constructible and copy assignable, providing the
usual guarantees for these operations. That is, a copy is equivalent to the
original.</p>
</div>
</div>
<div class="sect3">
<h4 id="hashing_bytes_update"><a class="anchor" href="#hashing_bytes_update"></a>update</h4>
<div class="paragraph">
<p>The function <code>update</code> is the mechanism by which the input message is provided
to the hash algorithm.</p>
</div>
<div class="paragraph">
<p>Calling <code>update</code> several times is equivalent to calling it once with the
concatenated byte sequences from the individual calls. That is, the input
message may be provided in parts, and the way it&#8217;s split into parts does
not matter and does not affect the final hash value.</p>
</div>
<div class="paragraph">
<p>Given</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">Hash</span> <span class="n">hash</span><span class="p">;</span> <span class="c1">// some hash algorithm</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">message</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span> <span class="c1">// some input message</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>the following <code>update</code> call</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hash</span><span class="p">.</span><span class="n">update</span><span class="p">(</span> <span class="n">message</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hash</span><span class="p">.</span><span class="n">update</span><span class="p">(</span> <span class="n">message</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
<span class="n">hash</span><span class="p">.</span><span class="n">update</span><span class="p">(</span> <span class="n">message</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>and to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="n">hash</span><span class="p">.</span><span class="n">update</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span> <span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="hashing_bytes_result"><a class="anchor" href="#hashing_bytes_result"></a>result</h4>
<div class="paragraph">
<p>After the entire input message has been provided via calls to <code>update</code>, the
final hash value can be obtained by calling <code>result</code>.</p>
</div>
<div class="paragraph">
<p>The call to <code>result</code> finalizes the internal state, by padding the message as
per the concrete algorithm specification, by optionally incorporating the
length of the message into the state, and by performing finalization
operations on the state, again as specified by the concrete algorithm.</p>
</div>
<div class="paragraph">
<p>A final hash value is then obtained by transforming the internal state, and
returned.</p>
</div>
<div class="paragraph">
<p>Note that <code>result</code> is non-const, because it changes the internal state. It&#8217;s
allowed for <code>result</code> to be called more than once; subsequent calls perform
the state finalization again and as a result produce a pseudorandom sequence
of <code>result_type</code> values. This can be used to effectively extend the output of
the hash function. For example, a 256 bit result can be obtained from a hash
algorithm whose <code>result_type</code> is 64 bit, by calling <code>result</code> four times.</p>
</div>
<div class="paragraph">
<p>As a toy example, <em>not intended for production use</em>, this is how one could
write a random number generator on top of the FNV-1a implementation provided
by the library:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="nf">random</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_64</span> <span class="n">hash</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">hash</span><span class="p">.</span><span class="n">result</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hashing_bytes_compile_time_hashing"><a class="anchor" href="#hashing_bytes_compile_time_hashing"></a>Compile Time Hashing</h3>
<div class="paragraph">
<p>Under C&#43;&#43;14, it&#8217;s possible to invoke some hash algorithms at compile time.
These algorithms provide the following interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">HashAlgorithm</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="cm">/*integral or array-like*/</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">;</span> <span class="c1">// optional</span>

    <span class="k">constexpr</span> <span class="n">HashAlgorithm</span><span class="p">();</span>
    <span class="k">explicit</span> <span class="k">constexpr</span> <span class="n">HashAlgorithm</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span>
    <span class="n">HashAlgorithm</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">seed</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="n">HashAlgorithm</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">seed</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="k">constexpr</span> <span class="n">HashAlgorithm</span><span class="p">(</span> <span class="n">HashAlgorithm</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">r</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="n">HashAlgorithm</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">HashAlgorithm</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">r</span> <span class="p">);</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="k">constexpr</span> <span class="n">result_type</span> <span class="n">result</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Apart from the added <code>constexpr</code> qualifiers, the only difference is that
the byte seed constructor and <code>update</code> have a second overload that takes
<code>unsigned char const*</code> instead of <code>void const*</code>.
(Pointers to <code>void</code> cannot be used in <code>constexpr</code> functions before C&#43;&#43;26.)</p>
</div>
</div>
<div class="sect2">
<h3 id="hashing_bytes_provided_hash_algorithms"><a class="anchor" href="#hashing_bytes_provided_hash_algorithms"></a>Provided Hash Algorithms</h3>
<div class="sect3">
<h4 id="hashing_bytes_fnv_1a"><a class="anchor" href="#hashing_bytes_fnv_1a"></a>FNV-1a</h4>
<div class="paragraph">
<p>The <a href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">Fowler-Noll-Vo hash function</a>
is provided as a representative of the class of hash functions that process
their input one byte at a time. The 32 or 64 bit state is updated for each
input character <code>ch</code> by using the operation <code>state = (state ^ ch) * fnv_prime</code>.</p>
</div>
<div class="paragraph">
<p>FNV-1a is non-cryptographic, relatively weak compared to state of the art
hash functions (although good for its class), but fast when the input strings
are short.</p>
</div>
</div>
<div class="sect3">
<h4 id="hashing_bytes_xxhash"><a class="anchor" href="#hashing_bytes_xxhash"></a>xxHash</h4>
<div class="paragraph">
<p><a href="https://xxhash.com/">xxHash</a> is a fast non-cryptographic hashing algorithm by Yann Collet.</p>
</div>
<div class="paragraph">
<p>Its speed (~5GB/s for <code>xxhash_32</code>, ~10GB/s for <code>xxhash_64</code> on a Xeon E5-2683 v4 @ 2.10GHz)
makes it well suited for quick generation of file or data integrity checksums.</p>
</div>
</div>
<div class="sect3">
<h4 id="hashing_bytes_siphash"><a class="anchor" href="#hashing_bytes_siphash"></a>SipHash</h4>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/SipHash">SipHash</a> by Jean-Philippe Aumasson and Daniel J. Bernstein
(<a href="https://eprint.iacr.org/2012/351">paper</a>) has been designed to thwart
<a href="https://en.wikipedia.org/wiki/Collision_attack#Hash_flooding">hash flooding attacks</a> against hash tables that receive
external untrusted input (e.g. HTTP message headers, or JSON objects.)</p>
</div>
<div class="paragraph">
<p>It&#8217;s not a cryptographic hash function (even though its design is similar to one),
because it does not provide collision resistance when the initial seed is known.</p>
</div>
<div class="paragraph">
<p>It is, however, a cryptographically strong keyed hash function (or a pseudorandom function, PRF).
If the initial seed is unknown to the attacker, it&#8217;s computationally difficult to engineer a collision, or to recover the seed by observing the output.</p>
</div>
<div class="paragraph">
<p>SipHash has been adopted as the de-facto standard hash function for hash tables that can be exposed to external input,
and is used in Python, Perl, Ruby, Rust, and other languages.</p>
</div>
<div class="paragraph">
<p>SipHash is the recommended hash function for hash tables exposed to external input. As a best practice, it should be seeded with a random value that varies per connection, and not a fixed one per process.</p>
</div>
</div>
<div class="sect3">
<h4 id="hashing_bytes_md5"><a class="anchor" href="#hashing_bytes_md5"></a>MD5</h4>
<div class="paragraph">
<p>Designed in 1991 by Ron Rivest, <a href="https://en.wikipedia.org/wiki/MD5">MD5</a> used
to be the best known and the most widely used <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">cryptographic hash function</a>,
but has been broken and is no longer considered cryptographic for any purposes.
It produces a 128 bit digest.</p>
</div>
<div class="paragraph">
<p>MD5 should no longer be used in new code when cryptographic strength is required, except when implementing an existing
specification or protocol that calls for its use.</p>
</div>
<div class="paragraph">
<p>Prefer SHA2-512/256 (or SHA2-256 in 32 bit code) instead.</p>
</div>
<div class="paragraph">
<p>If you require a digest of exactly 128 bits, use RIPEMD-128 instead.
Do note that 128 bit digests are no longer considered cryptographic, because attacks with a complexity of 2<sup>64</sup> are within the capabilities of well-funded attackers.</p>
</div>
</div>
<div class="sect3">
<h4 id="hashing_bytes_sha_1"><a class="anchor" href="#hashing_bytes_sha_1"></a>SHA-1</h4>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a> is a cryptographic hash function that was designed by NSA and
<a href="https://csrc.nist.gov/pubs/fips/180-1/final">published</a> in 1995 by <a href="https://en.wikipedia.org/wiki/NIST">NIST</a>
as a <a href="https://en.wikipedia.org/wiki/Federal_Information_Processing_Standard">Federal Information Processing Standard</a> (FIPS).
It produces a 160 bit digest.</p>
</div>
<div class="paragraph">
<p>SHA-1 is now considered insecure against a well-funded attacker, and should no
longer be used in new code. Prefer SHA2-512/256, SHA2-256 in 32 bit code, or, if
you require a digest of exactly 160 bits, RIPEMD-160 instead.</p>
</div>
</div>
<div class="sect3">
<h4 id="hashing_bytes_sha_2"><a class="anchor" href="#hashing_bytes_sha_2"></a>SHA-2</h4>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/SHA-2">SHA-2</a> is a family of cryptographic hash functions, also designed by NSA,
<a href="https://csrc.nist.gov/pubs/fips/180-2/upd1/final">initially published</a> by NIST in 2002,
and <a href="https://csrc.nist.gov/pubs/fips/180-4/upd1/final">updated</a> in 2015.
It includes SHA2-224, SHA2-256, SHA2-384, SHA2-512, SHA2-512/224, and SHA2-512/256, each producing a digest with the corresponding bit length.</p>
</div>
<div class="paragraph">
<p>Of these, SHA2-256 and SHA2-512 are the basis ones, and the rest are variants with the digest truncated.</p>
</div>
<div class="paragraph">
<p>The SHA-2 functions haven&#8217;t been broken and are in wide use, despite the existence of a newer standard (SHA-3).</p>
</div>
<div class="paragraph">
<p>SHA2-256 and its truncated variant SHA2-224 use 32 bit operations and therefore do not lose performance on a 32 bit platform.</p>
</div>
<div class="paragraph">
<p>SHA2-512 and its truncated variants SHA2-384, SHA2-512/224, and SHA2-512/256 use 64 bit operations and are approximately 1.5 times as fast
as SHA2-256 on a 64 bit platform, but twice as slow in 32 bit code.</p>
</div>
<div class="paragraph">
<p>On 64 bit platforms, SHA2-512/256 and SHA2-512/224 should be preferred over SHA2-256 and SHA2-224 not just because of speed, but because
they are resistant to length extension attacks as they don&#8217;t expose all of the bits of their internal state in the final digest.</p>
</div>
</div>
<div class="sect3">
<h4 id="hashing_bytes_sha_3"><a class="anchor" href="#hashing_bytes_sha_3"></a>SHA-3</h4>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/SHA-3">SHA-3</a> is the most recent addition to the Secure Hash Algorithm standards, published in 2015
as <a href="https://csrc.nist.gov/pubs/fips/202/final">FIPS 202</a>.</p>
</div>
<div class="paragraph">
<p>SHA-3 includes 6 algorithms: SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, and SHAKE256.</p>
</div>
<div class="paragraph">
<p>The SHA3 functions output a fixed-sized digest while SHAKE128 and SHAKE256 are approved extendable-output functions, also known as XOFs. XOFs permit generation
of an arbitrarily long message digest in a defined manner.</p>
</div>
<div class="paragraph">
<p>Unlike SHA-2, SHA3-224 is not a truncated version of the SHA3-256 algorithm. Instead, all SHA-3 algorithms create their digests by truncating the
lower portion of the 1600-bit state permuted by the Keccak algorithm. The XOFs return their digests incrementally as fixed-sized blocks, using the truncation specified
in Algorithm 8, step 8 of FIPS 202.</p>
</div>
<div class="paragraph">
<p>SHA-3 uses 64 bit operations for all of the algorithms in the family.</p>
</div>
</div>
<div class="sect3">
<h4 id="hashing_bytes_ripemd_160_ripemd_128"><a class="anchor" href="#hashing_bytes_ripemd_160_ripemd_128"></a>RIPEMD-160, RIPEMD-128</h4>
<div class="paragraph">
<p>Designed in 1996, <a href="https://en.wikipedia.org/wiki/RIPEMD">RIPEMD-160</a> is a cryptographic hash function that was less well known than MD5 and SHA-1,
but that has recently become popular because of its use in Bitcoin and other cryptocurrencies.</p>
</div>
<div class="paragraph">
<p>Even though it hasn&#8217;t been broken, there&#8217;s no reason to prefer its use in new code over SHA-2.</p>
</div>
<div class="paragraph">
<p>RIPEMD-128 is a truncated variant of RIPEMD-160. (Do note that 128 bit digests are no longer considered cryptographic, because attacks with a complexity of 2<sup>64</sup> are within the capabilities of well-funded attackers.)</p>
</div>
</div>
<div class="sect3">
<h4 id="hashing_bytes_hmac"><a class="anchor" href="#hashing_bytes_hmac"></a>HMAC</h4>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/HMAC">HMAC</a> (Hash-based Message Authentication Code) is an algorithm for deriving
a <em>message authentication code</em> by using a cryptographic hash function. It&#8217;s described in <a href="https://datatracker.ietf.org/doc/html/rfc2104">RFC 2104</a>.</p>
</div>
<div class="paragraph">
<p>A message authentication code differs from a digest by the fact that it depends on both the contents of the message
and on a secret <em>key</em>; in contrast, a message digest only depends on the contents of the message.</p>
</div>
<div class="paragraph">
<p>Even though all hash algorithms provided by the library can be used to produce message authentication codes,
by means of seeding the hash algorithm initially with a secret key by calling the constructor taking a byte
sequence, hash algorithms have usually not been designed to be used in this manner, and such use hasn&#8217;t been
cryptographically analyzed and vetted. (SipHash is an exception; it has specifically been designed as a MAC.)</p>
</div>
<div class="paragraph">
<p>The HMAC algorithm is provided in the form of a class template <code>hmac&lt;H&gt;</code> that adapts a cryptographic hash
algorithm <code>H</code>. <code>hmac&lt;H&gt;</code> satisfies the requirements of a cryptographic hash algorithm.</p>
</div>
<div class="paragraph">
<p>Convenience aliases of common HMAC instantiations are provided. For example, the <code>md5.hpp</code> header defining
<code>md5_128</code> also defines <code>hmac_md5_128</code> as an alias to <code>hmac&lt;md5_128&gt;</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hashing_bytes_choosing_a_hash_algorithm"><a class="anchor" href="#hashing_bytes_choosing_a_hash_algorithm"></a>Choosing a Hash Algorithm</h3>
<div class="paragraph">
<p>If your use case requires cryptographic strength, use SHA2-512/256 (or SHA2-256 in 32 bit code) for digests, and the corresponding HMAC for message authentication codes.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Digests of fewer than 256 bits in length are no longer recommended when cryptographic security is required or desired.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For computing file or content checksums, when speed is of the essence and externally induced collisions aren&#8217;t a concern, use xxHash-64.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
xxHash-32 will be faster in 32 bit code, but since it only produces a 32 bit result, collisions will become an issue when the number of items reaches tens of thousands, which is usually unacceptable.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For a large number of items (many millions), 64 bits may not be enough; in that case, use either MD5, or xxHash-64, <a href="#example_result_extension">extended to 128 bits</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Even though MD5 is no longer cryptographically secure, it can still be used when cryptographic strength is not a requirement.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For hash tables, use SipHash by default, <a href="#example_use_with_unordered_containers">with a random (unpredictable from the outside) seed</a> that varies per connection or per container. Avoid using a fixed processwide seed. Never use SipHash without a seed.</p>
</div>
<div class="paragraph">
<p>For hash tables with very short keys (3-4-5 bytes), unexposed to external input, you can use FNV-1a, although the default hash function of e.g. <code>boost::unordered_flat_map</code> will typically perform better.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hashing_objects"><a class="anchor" href="#hashing_objects"></a>Hashing C&#43;&#43; Objects</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The traditional approach to hashing C&#43;&#43; objects is to make
them responsible for providing a hash value. The standard,
for instance, follows this by making it the responsibility
of each type <code>T</code> to implement a specialization of <code>std::hash&lt;T&gt;</code>,
which when invoked with a value returns its <code>size_t</code> hash.</p>
</div>
<div class="paragraph">
<p>This, of course, means that the specific hash algorithm varies
per type and is, in the general case, completely opaque.</p>
</div>
<div class="paragraph">
<p>This library takes a different approach; the hash algorithm
is known and chosen by the user. A C&#43;&#43; object is hashed by
first being converted to a sequence of bytes representing its
value (a <em>message</em>) which is then passed to the hash algorithm.</p>
</div>
<div class="paragraph">
<p>The conversion must obey the following requirements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Equal objects must produce the same message;</p>
</li>
<li>
<p>Different objects should produce different messages;</p>
</li>
<li>
<p>An object should always produce a non-empty message.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first two requirements follow directly from the hash value
requirements, whereas the third one is a bit more subtle and
is intended to prevent things like the distinct sequences
<code>[[1], [], []]</code> and <code>[[], [1], []]</code> producing the same message.
(This is similar to the requirement that all C&#43;&#43; objects have
<code>sizeof</code> that is not zero, including empty ones.)</p>
</div>
<div class="paragraph">
<p>In this library, the conversion is performed by the function
<code>hash_append</code>. It&#8217;s declared as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span> <span class="o">=</span> <span class="n">default_flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">hash_append</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>and the effect of invoking <code>hash_append(h, f, v)</code> is to call
<code>h.update(p, n)</code> one or more times (but never zero times.) The
combined result of these calls forms the message corresponding
to <code>v</code>.</p>
</div>
<div class="paragraph">
<p><code>hash_append</code> handles natively the following types <code>T</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Integral types (signed and unsigned integers, character types, <code>bool</code>);</p>
</li>
<li>
<p>Floating point types (<code>float</code> and <code>double</code>);</p>
</li>
<li>
<p>Enumeration types;</p>
</li>
<li>
<p>Pointer types (object and function, but not pointer to member types);</p>
</li>
<li>
<p>C arrays;</p>
</li>
<li>
<p>Containers and ranges (types that provide <code>begin()</code> and <code>end()</code>);</p>
</li>
<li>
<p>Unordered containers and ranges;</p>
</li>
<li>
<p>Constant size containers (<code>std::array</code>, <code>boost::array</code>);</p>
</li>
<li>
<p>Tuple-like types (<code>std::pair</code>, <code>std::tuple</code>);</p>
</li>
<li>
<p>Described classes (using Boost.Describe).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>User-defined types that aren&#8217;t in the above categories can provide
support for <code>hash_append</code> by declaring an overload of the <code>tag_invoke</code>
function with the appropriate parameters.</p>
</div>
<div class="paragraph">
<p>The second argument to <code>hash_append</code>, the <em>flavor</em>, is used to control
the serialization process in cases where more than one behavior is
possible and desirable. It currently contains the following members:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>static constexpr endian byte_order; // native, little, or big</code></p>
</li>
<li>
<p><code>using size_type = std::uint32_t; // or std::uint64_t</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>byte_order</code> member of the flavor affects how scalar C&#43;&#43; objects
are serialized into bytes. For example, the <code>uint32_t</code> integer <code>0x01020304</code>
can be serialized into <code>{ 0x01, 0x02, 0x03, 0x04 }</code> when <code>byte_order</code> is
<code>endian::big</code>, and into <code>{ 0x04, 0x03, 0x02, 0x01 }</code> when <code>byte_order</code>
is <code>endian::little</code>.</p>
</div>
<div class="paragraph">
<p>The value <code>endian::native</code> means to use the byte order of the current
platform. This typically results in higher performance, because it allows
<code>hash_append</code> to pass the underlying object bytes directly to the hash
algorithm, without any processing.</p>
</div>
<div class="paragraph">
<p>The <code>size_type</code> member type of the flavor affects how container and range
sizes (typically of type <code>size_t</code>) are serialized. Since the size of
<code>size_t</code> in bytes can vary, serializing the type directly results in
different hash values when the code is compiled for 64 bit or for 32 bit.
Using a fixed width type avoids this.</p>
</div>
<div class="paragraph">
<p>There are three predefined flavors, defined in <code>boost/hash2/flavor.hpp</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">default_flavor</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">byte_order</span> <span class="o">=</span> <span class="n">endian</span><span class="o">::</span><span class="n">native</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">little_endian_flavor</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">byte_order</span> <span class="o">=</span> <span class="n">endian</span><span class="o">::</span><span class="n">little</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">big_endian_flavor</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">byte_order</span> <span class="o">=</span> <span class="n">endian</span><span class="o">::</span><span class="n">big</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The default one is used when <code>hash_append</code> is invoked without passing
a flavor: <code>hash_append(h, {}, v);</code>. It results in higher performance,
but the hash values are endianness dependent.</p>
</div>
<div class="sect2">
<h3 id="hashing_objects_contiguously_hashable_types"><a class="anchor" href="#hashing_objects_contiguously_hashable_types"></a>Contiguously Hashable Types</h3>
<div class="paragraph">
<p>The first thing <code>hash_append(h, f, v)</code> does is to check whether the type is <em>contiguously hashable</em> under the requested byte order, by testing <code>is_contiguously_hashable&lt;T, Flavor::byte_order&gt;::value</code>.
When that&#8217;s <code>true</code>, it invokes <code>h.update(&amp;v, sizeof(v))</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="hashing_objects_integral_types"><a class="anchor" href="#hashing_objects_integral_types"></a>Integral Types</h3>
<div class="paragraph">
<p>When <code>T</code> is an integral type (<code>bool</code>, a signed or unsigned integer type like <code>int</code> or <code>unsigned long</code>, or a character type like <code>char8_t</code> or <code>char32_t</code>),
<code>v</code> converted into its byte representation (an array of <code>unsigned char</code> and a size of <code>sizeof(T)</code>) under the requested byte order.</p>
</div>
<div class="paragraph">
<p><code>hash_append</code> then calls <code>h.update(p, n)</code>, where <code>p</code> is the address of this representation, and <code>n</code> is its size.</p>
</div>
<div class="paragraph">
<p>For example, the value <code>0x01020304</code> of type <code>std::uint32_t</code>, when <code>Flavor::byte_order</code> is <code>endian::little</code>, is converted into the array <code>{ 0x04, 0x03, 0x02, 0x01 }</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">v1</span> <span class="o">=</span> <span class="mh">0x01020304</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h1</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">little_endian_flavor</span><span class="p">(),</span> <span class="n">v1</span> <span class="p">);</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h2</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">v2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x01</span> <span class="p">};</span>
    <span class="n">h2</span><span class="p">.</span><span class="n">update</span><span class="p">(</span> <span class="n">v2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span> <span class="n">h1</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="o">==</span> <span class="n">h2</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hashing_objects_floating_point_types"><a class="anchor" href="#hashing_objects_floating_point_types"></a>Floating Point Types</h3>
<div class="paragraph">
<p>When <code>T</code> is a floating point type (only <code>float</code> and <code>double</code> are supported at the moment),
<code>v</code> is converted into an unsigned integer type of the same size using the equivalent of <code>std::bit_cast</code>, then <code>hash_append</code> is invoked with that converted value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">v1</span> <span class="o">=</span> <span class="mf">3.14</span><span class="n">f</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h1</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v1</span> <span class="p">);</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h2</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">v2</span> <span class="o">=</span> <span class="mh">0x4048f5c3</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h2</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v2</span> <span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span> <span class="n">h1</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="o">==</span> <span class="n">h2</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, there&#8217;s a subtlety here. The requirements for a hash function <code>H</code> say that if <code>x == y</code>, then <code>H(x) == H(y)</code>. But <code>+0.0 == -0.0</code>, even though the bit representations of these two values differ.</p>
</div>
<div class="paragraph">
<p>So, in order to meet the requirement, if <code>v</code> is negative zero, it&#8217;s first replaced with a positive zero of the same type, before <code>bit_cast</code> to an integer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h1</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h1</span><span class="p">,</span> <span class="p">{},</span> <span class="o">+</span><span class="mf">0.0</span> <span class="p">);</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h2</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h2</span><span class="p">,</span> <span class="p">{},</span> <span class="o">-</span><span class="mf">0.0</span> <span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span> <span class="n">h1</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="o">==</span> <span class="n">h2</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hashing_objects_enumeration_types"><a class="anchor" href="#hashing_objects_enumeration_types"></a>Enumeration Types</h3>
<div class="paragraph">
<p>When <code>T</code> is an enumeration type, <code>v</code> is converted to the underlying type of <code>T</code>, then the converted value is passed to <code>hash_append</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">enum</span> <span class="n">E</span><span class="o">:</span> <span class="kt">int</span>
<span class="p">{</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="mi">123</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h1</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h1</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v1</span> <span class="p">);</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">v2</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h2</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v2</span> <span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span> <span class="n">h1</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="o">==</span> <span class="n">h2</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hashing_objects_pointers"><a class="anchor" href="#hashing_objects_pointers"></a>Pointers</h3>
<div class="paragraph">
<p>When <code>T</code> is a pointer type, it&#8217;s converted to <code>std::uintptr_t</code> using <code>reinterpret_cast</code>, and the converted value is passed to <code>hash_append</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">int</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h1</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h1</span><span class="p">,</span> <span class="p">{},</span> <span class="o">&amp;</span><span class="n">x1</span> <span class="p">);</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h2</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h2</span><span class="p">,</span> <span class="p">{},</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x1</span><span class="p">)</span> <span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span> <span class="n">h1</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="o">==</span> <span class="n">h2</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hashing_objects_arrays"><a class="anchor" href="#hashing_objects_arrays"></a>Arrays</h3>
<div class="paragraph">
<p>When <code>T</code> is an array type <code>U[N]</code>, the elements of <code>v</code> are passed to <code>hash_append</code> in sequence.</p>
</div>
<div class="paragraph">
<p>This is accomplished by calling <code>hash_append_range(h, f, v + 0, v + N)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">v1</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h1</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v1</span> <span class="p">);</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h2</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append_range</span><span class="p">(</span> <span class="n">h2</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v1</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v1</span> <span class="o">+</span> <span class="mi">4</span> <span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span> <span class="n">h1</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="o">==</span> <span class="n">h2</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h3</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h3</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h3</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h3</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h3</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span> <span class="n">h1</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="o">==</span> <span class="n">h3</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hashing_objects_ranges"><a class="anchor" href="#hashing_objects_ranges"></a>Ranges</h3>
<div class="paragraph">
<p>When <code>T</code> is a <em>range</em> (<code>boost::container_hash::is_range&lt;T&gt;::value</code> is <code>true</code>), its elements are passed to <code>hash_append</code> as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When <code>T</code> is an <em>unordered range</em> (<code>boost::container_hash::is_unordered_range&lt;T&gt;::value</code> is <code>true</code>), <code>hash_append</code> invokes <code>hash_append_unordered_range(h, f, v.begin(), v.end())</code>.
<code>hash_append_unordered_range</code> derives a hash value from the range elements in such a way so that their order doesn&#8217;t affect the hash value.</p>
</li>
<li>
<p>When <code>T</code> is a <em>contiguous range</em> (<code>boost::container_hash::is_contiguous_range&lt;T&gt;::value</code> is <code>true</code>), <code>hash_append</code> first invokes <code>hash_append_range(h, f, v.data(), v.data() + v.size())</code>,
then, if <code>has_constant_size&lt;T&gt;::value</code> is <code>false</code>, it invokes <code>hash_append_size(h, f, v.size())</code>.</p>
</li>
<li>
<p>Otherwise, <code>hash_append</code> first invokes <code>hash_append_range(h, f, v.begin(), v.end())</code>,
then, if <code>has_constant_size&lt;T&gt;::value</code> is <code>false</code>, it invokes <code>hash_append_size(h, f, m)</code>, where <code>m</code> is <code>std::distance(v.begin(), v.end())</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As a special case, in order to meet the requirement that a call to <code>hash_append</code> must always result in at least one call to <code>Hash::update</code>, for ranges of constant size 0, <code>hash_append(h, f, '\x00')</code> is called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h1</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v1</span> <span class="p">);</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h2</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h2</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v2</span> <span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span> <span class="n">h1</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="o">==</span> <span class="n">h2</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h3</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append_range</span><span class="p">(</span> <span class="n">h3</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v1</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">v1</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">v1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append_size</span><span class="p">(</span> <span class="n">h3</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span> <span class="n">h1</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="o">==</span> <span class="n">h3</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h4</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append_range</span><span class="p">(</span> <span class="n">h4</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v2</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append_size</span><span class="p">(</span> <span class="n">h4</span><span class="p">,</span> <span class="p">{},</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">v2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v2</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span> <span class="n">h2</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="o">==</span> <span class="n">h4</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hashing_objects_tuples"><a class="anchor" href="#hashing_objects_tuples"></a>Tuples</h3>
<div class="paragraph">
<p>When <code>T</code> is a tuple (<code>boost::container_hash::is_tuple_like&lt;T&gt;::value</code> is <code>true</code>), its elements as obtained by <code>get&lt;I&gt;(v)</code> for <code>I</code> in <code>[0, std::tuple_size&lt;T&gt;::value)</code> are passed to <code>hash_append</code>, in sequence.</p>
</div>
<div class="paragraph">
<p>As a special case, in order to meet the requirement that a call to <code>hash_append</code> must always result in at least one call to <code>Hash::update</code>, for tuples of size 0, <code>hash_append(h, f, '\x00')</code> is called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h1</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v1</span> <span class="p">);</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h2</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h2</span><span class="p">,</span> <span class="p">{},</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h2</span><span class="p">,</span> <span class="p">{},</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h2</span><span class="p">,</span> <span class="p">{},</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span> <span class="n">h1</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="o">==</span> <span class="n">h2</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hashing_objects_described_classes"><a class="anchor" href="#hashing_objects_described_classes"></a>Described Classes</h3>
<div class="paragraph">
<p>When <code>T</code> is a <em>described class</em> (<code>boost::container_hash::is_described_class&lt;T&gt;::value</code> is <code>true</code>), Boost.Describe primitives are used to enumerate its bases and members, and then,
for each base class subobject <code>b</code> of <code>v</code>, <code>hash_append(h, f, b)</code> is called, then for each member subobject <code>m</code> of <code>v</code>, <code>hash_append(h, f, m)</code> is called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">X</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">BOOST_DESCRIBE_STRUCT</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="n">a</span><span class="p">))</span>

<span class="k">struct</span> <span class="nc">Y</span><span class="o">:</span> <span class="k">public</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">BOOST_DESCRIBE_STRUCT</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="p">(</span><span class="n">b</span><span class="p">))</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h1</span><span class="p">;</span>
    <span class="n">X</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">},</span> <span class="mi">2</span> <span class="p">};</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h1</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v1</span> <span class="p">);</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_32</span> <span class="n">h2</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h2</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v1</span><span class="p">.</span><span class="n">a</span> <span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h2</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v1</span><span class="p">.</span><span class="n">b</span> <span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span> <span class="n">h1</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="o">==</span> <span class="n">h2</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As a special case, in order to meet the requirement that a call to <code>hash_append</code> must always result in at least one call to <code>Hash::update</code>, for classes without any bases or members, <code>hash_append(h, f, '\x00')</code> is called.</p>
</div>
</div>
<div class="sect2">
<h3 id="hashing_objects_user_defined_types"><a class="anchor" href="#hashing_objects_user_defined_types"></a>User Defined Types</h3>
<div class="paragraph">
<p>When <code>T</code> is a user defined type that does not fall into one of the above categories, it needs to provide its own hashing support, by defining an appropriate <code>tag_invoke</code> overload.</p>
</div>
<div class="paragraph">
<p>This <code>tag_invoke</code> overload needs to have the following form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Provider</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">tag_invoke</span><span class="p">(</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append_tag</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Provider</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">pr</span><span class="p">,</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">X</span> <span class="k">const</span><span class="o">*</span> <span class="n">v</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>X</code> is the user-defined type.</p>
</div>
<div class="paragraph">
<p>It can be defined as a separate free function in the namespace of <code>X</code>, but the recommended approach is to define it as an inline <code>friend</code> in the definition of <code>X</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/hash_append_fwd.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
<span class="nl">private:</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>

    <span class="c1">// not part of the salient state</span>
    <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">c</span><span class="p">;</span>

<span class="nl">public:</span>

    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">X</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x1</span><span class="p">,</span> <span class="n">X</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x2</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">x1</span><span class="p">.</span><span class="n">a</span> <span class="o">==</span> <span class="n">x2</span><span class="p">.</span><span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">x1</span><span class="p">.</span><span class="n">b</span> <span class="o">==</span> <span class="n">x2</span><span class="p">.</span><span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Provider</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span><span class="p">&gt;</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">tag_invoke</span><span class="p">(</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append_tag</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Provider</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span>
        <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">X</span> <span class="k">const</span><span class="o">*</span> <span class="n">v</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">);</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This overload needs to meet the three requirements for a hash function. In practice, this means that the definitions of equality (<code>operator==</code>) and hashing (<code>tag_invoke</code>) must agree on what members need to be included.</p>
</div>
<div class="paragraph">
<p>In the example above, the member <code>c</code> is not part of the object state, so it&#8217;s neither compared in <code>operator==</code>, nor included in the object <em>message</em> in <code>tag_invoke</code>.</p>
</div>
<div class="paragraph">
<p>The particular implementation of <code>tag_invoke</code> is type-specific. In general, it needs to include all salient parts of the object&#8217;s value in the resultant <em>message</em>, but the exact way to do so is type-dependent.</p>
</div>
<div class="paragraph">
<p>As another example, here&#8217;s how one might implement <code>tag_invoke</code> for an "inline string" type (a string that stores its characters, up to some maximum count, in the type itself):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/hash_append_fwd.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Str</span>
<span class="p">{</span>
<span class="nl">private:</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">size_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span> <span class="n">N</span> <span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>

<span class="k">public</span><span class="o">:</span>

    <span class="k">friend</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">Str</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x1</span><span class="p">,</span> <span class="n">Str</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x2</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">x1</span><span class="p">.</span><span class="n">size_</span> <span class="o">==</span> <span class="n">x2</span><span class="p">.</span><span class="n">size_</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">equal</span><span class="p">(</span> <span class="n">x1</span><span class="p">.</span><span class="n">data_</span><span class="p">,</span> <span class="n">x1</span><span class="p">.</span><span class="n">data_</span> <span class="o">+</span> <span class="n">x1</span><span class="p">.</span><span class="n">size_</span><span class="p">,</span> <span class="n">x2</span><span class="p">.</span><span class="n">data_</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Provider</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span><span class="p">&gt;</span>
    <span class="k">friend</span> <span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">tag_invoke</span><span class="p">(</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append_tag</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Provider</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span>
        <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Str</span> <span class="k">const</span><span class="o">*</span> <span class="n">v</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append_range_and_size</span><span class="p">(</span> <span class="n">h</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">data_</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">data_</span> <span class="o">+</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">size_</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This example is illustrative; in practice, the above type will likely provide <code>begin()</code>, <code>end()</code>, <code>data()</code>, and <code>size()</code> member functions, which will make it a <em>contiguous range</em> and the built-in support will do the right thing.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>Provider</code> argument of <code>tag_invoke</code> that we&#8217;ve ignored receives an object of type <code>hash_append_provider</code>.
This object contains static member functions that are copies of the functions declared in <code>&lt;boost/hash2/hash_append_fwd.hpp&gt;</code>.
This allows <code>tag_invoke</code> overloads to be written without the need to include <code>&lt;boost/hash2/hash_append_fwd.hpp&gt;</code>, such that the header is not dependent on anything from Hash2.</p>
</div>
<div class="paragraph">
<p>For example, this is how we can alternatively declare the user-defined type <code>X</code> above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
<span class="nl">private:</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>

    <span class="c1">// not part of the salient state</span>
    <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">c</span><span class="p">;</span>

<span class="nl">public:</span>

    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">X</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x1</span><span class="p">,</span> <span class="n">X</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x2</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">x1</span><span class="p">.</span><span class="n">a</span> <span class="o">==</span> <span class="n">x2</span><span class="p">.</span><span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">x1</span><span class="p">.</span><span class="n">b</span> <span class="o">==</span> <span class="n">x2</span><span class="p">.</span><span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Provider</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span><span class="p">&gt;</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">tag_invoke</span><span class="p">(</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append_tag</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Provider</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">pr</span><span class="p">,</span>
        <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">X</span> <span class="k">const</span><span class="o">*</span> <span class="n">v</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pr</span><span class="p">.</span><span class="n">hash_append</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">);</span>
        <span class="n">pr</span><span class="p">.</span><span class="n">hash_append</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="examples"><a class="anchor" href="#examples"></a>Usage Examples</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="example_use_with_unordered_containers"><a class="anchor" href="#example_use_with_unordered_containers"></a>Use with Unordered Containers</h3>
<div class="paragraph">
<p>To use one of our <em>hash algorithms</em> (such as <code>fnv1a_64</code>) with an unordered container (such as <code>boost::unordered_flat_map</code>), we need
to create an adaptor class that exposes an interface compatible with <code>std::hash&lt;T&gt;</code>.</p>
</div>
<div class="paragraph">
<p>To do that, in the <code>operator()(T const&amp; v)</code> member function of our adaptor, we need to create an instance <code>h</code> of the <em>hash algorithm</em>,
use <code>hash_append(h, {}, v)</code> to send <code>v</code> to it, and then extract the result using <code>h.result()</code> and return it as <code>std::size_t</code>.</p>
</div>
<div class="paragraph">
<p>The minimal working example below illustrates this approach.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/fnv1a.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/hash_append.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/get_integral_result.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/unordered/unordered_flat_map.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">hash</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">H</span> <span class="n">h</span><span class="p">;</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">get_integral_result</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">h</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">hasher</span> <span class="o">=</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_64</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">hasher</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span>

    <span class="n">map</span><span class="p">[</span> <span class="s">"foo"</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">map</span><span class="p">[</span> <span class="s">"bar"</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since <code>hash&lt;T, H&gt;</code> is templated not just on the key type <code>T</code>, but on the hash algorithm type <code>H</code>, we can easily switch from <code>fnv1a_64</code>
to another hash algorithm, for example <code>siphash_64</code>, by only changing the line</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">using</span> <span class="n">hasher</span> <span class="o">=</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">fnv1a_64</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">using</span> <span class="n">hasher</span> <span class="o">=</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">siphash_64</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This will work, but SipHash is not intended to be used without an initial random seed, and we don&#8217;t pass any. To rectify this, let&#8217;s
modify <code>hash&lt;T, H&gt;</code> to have a constructor taking a seed of type <code>uint64_t</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/siphash.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/hash_append.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/get_integral_result.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/unordered/unordered_flat_map.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">hash</span>
<span class="p">{</span>
<span class="nl">private:</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed_</span><span class="p">;</span>

<span class="nl">public:</span>

    <span class="k">explicit</span> <span class="n">hash</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">)</span><span class="o">:</span> <span class="n">seed_</span><span class="p">(</span> <span class="n">seed</span> <span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="nf">operator</span><span class="p">()(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">H</span> <span class="n">h</span><span class="p">(</span> <span class="n">seed_</span> <span class="p">);</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">get_integral_result</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">h</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mh">0x0102030405060708ull</span><span class="p">;</span>

    <span class="k">using</span> <span class="n">hasher</span> <span class="o">=</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">siphash_64</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">hasher</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hasher</span><span class="p">(</span> <span class="n">seed</span> <span class="p">)</span> <span class="p">);</span>

    <span class="n">map</span><span class="p">[</span> <span class="s">"foo"</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">map</span><span class="p">[</span> <span class="s">"bar"</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
In real code, the seed will not be a hardcoded constant; ideally, every unordered container instance will have its own random and unpredictable seed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Since all <em>hash algorithms</em> that conform to our library requirements are constructible with an initial seed of type <code>uint64_t</code>, the above will work with any of them.</p>
</div>
<div class="paragraph">
<p>This is good enough for any practical purposes, but in principle, SipHash64 takes a 16 byte seed per specification, and we only (effectively) pass 8 bytes.
We could modify our <code>hash</code> yet again and this time use a constructor taking a sequence of bytes as the seed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/siphash.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/hash_append.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/get_integral_result.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/unordered/unordered_flat_map.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">hash</span>
<span class="p">{</span>
<span class="nl">private:</span>

    <span class="n">H</span> <span class="n">h_</span><span class="p">;</span>

<span class="nl">public:</span>

    <span class="n">hash</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">)</span><span class="o">:</span> <span class="n">h_</span><span class="p">(</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span> <span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="nf">operator</span><span class="p">()(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">H</span> <span class="n">h</span><span class="p">(</span> <span class="n">h_</span> <span class="p">);</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">get_integral_result</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">h</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span> <span class="n">seed</span><span class="p">[</span> <span class="mi">16</span> <span class="p">]</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x05</span><span class="p">,</span> <span class="mh">0x06</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span>
        <span class="mh">0x09</span><span class="p">,</span> <span class="mh">0x0A</span><span class="p">,</span> <span class="mh">0x0B</span><span class="p">,</span> <span class="mh">0x0C</span><span class="p">,</span> <span class="mh">0x0D</span><span class="p">,</span> <span class="mh">0x0E</span><span class="p">,</span> <span class="mh">0x0F</span><span class="p">,</span> <span class="mh">0x10</span>
    <span class="p">};</span>

    <span class="k">using</span> <span class="n">hasher</span> <span class="o">=</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">siphash_64</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">hasher</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hasher</span><span class="p">(</span> <span class="n">seed</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>

    <span class="n">map</span><span class="p">[</span> <span class="s">"foo"</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">map</span><span class="p">[</span> <span class="s">"bar"</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As before, construction from a byte sequence is a required part of the <em>hash algorithm</em> interface, so the above will work with any of them.</p>
</div>
<div class="paragraph">
<p>To avoid the need to store the initial seed as we did in the <code>uint64_t</code> case&#8201;&#8212;&#8201;which would require an allocation because <code>n</code> can be arbitrary, necessitating the use of <code>std::vector&lt;unsigned char&gt;</code>&#8201;&#8212;&#8201;we construct an instance <code>h_</code> of the hash algorithm, passing it the seed, to capture the initial seeded state, and then
copy this seeded instance in <code>operator()</code>.</p>
</div>
<div class="paragraph">
<p>But once we&#8217;ve done that, we might notice that we can construct this initial instance <code>h_</code> using any of the three supported constructors, not just the one taking a byte sequence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/siphash.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/hash_append.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/get_integral_result.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/unordered/unordered_flat_map.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">hash</span>
<span class="p">{</span>
<span class="nl">private:</span>

    <span class="n">H</span> <span class="n">h_</span><span class="p">;</span>

<span class="nl">public:</span>

    <span class="n">hash</span><span class="p">()</span><span class="o">:</span> <span class="n">h_</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">explicit</span> <span class="nf">hash</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">)</span><span class="o">:</span> <span class="n">h_</span><span class="p">(</span> <span class="n">seed</span> <span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">hash</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">)</span><span class="o">:</span> <span class="n">h_</span><span class="p">(</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span> <span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="nf">operator</span><span class="p">()(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">H</span> <span class="n">h</span><span class="p">(</span> <span class="n">h_</span> <span class="p">);</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">get_integral_result</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">h</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">hasher</span> <span class="o">=</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">siphash_64</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="p">{</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">hasher</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span>

        <span class="n">map</span><span class="p">[</span> <span class="s">"foo"</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">map</span><span class="p">[</span> <span class="s">"bar"</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mh">0x0102030405060708ull</span><span class="p">;</span>

        <span class="n">boost</span><span class="o">::</span><span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">hasher</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hasher</span><span class="p">(</span> <span class="n">seed</span> <span class="p">)</span> <span class="p">);</span>

        <span class="n">map</span><span class="p">[</span> <span class="s">"foo"</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">map</span><span class="p">[</span> <span class="s">"bar"</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span> <span class="n">seed</span><span class="p">[</span> <span class="mi">16</span> <span class="p">]</span> <span class="o">=</span>
        <span class="p">{</span>
            <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x05</span><span class="p">,</span> <span class="mh">0x06</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span>
            <span class="mh">0x09</span><span class="p">,</span> <span class="mh">0x0A</span><span class="p">,</span> <span class="mh">0x0B</span><span class="p">,</span> <span class="mh">0x0C</span><span class="p">,</span> <span class="mh">0x0D</span><span class="p">,</span> <span class="mh">0x0E</span><span class="p">,</span> <span class="mh">0x0F</span><span class="p">,</span> <span class="mh">0x10</span>
        <span class="p">};</span>

        <span class="n">boost</span><span class="o">::</span><span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">hasher</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hasher</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">seed</span><span class="p">))</span> <span class="p">);</span>

        <span class="n">map</span><span class="p">[</span> <span class="s">"foo"</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">map</span><span class="p">[</span> <span class="s">"bar"</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This variation of <code>hash&lt;T, H&gt;</code> is universal; it can be used without a seed, with an unsigned integer seed, and with a byte sequence seed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
In real code, you might want to omit the default constructor, to avoid the possibility of accidentally using an unseeded hash algorithm.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There&#8217;s one final modification we could do to <code>hash</code>. In the examples above, we unconditionally use the 64 bit variant of SipHash, even though we only need a result of type <code>std::size_t</code> because that&#8217;s what <code>std::hash</code> mandates.</p>
</div>
<div class="paragraph">
<p>It would be better for performance if we used <code>siphash_32</code> when <code>std::size_t</code> is 32 bit, and <code>siphash_64</code> when it&#8217;s 64 bit.</p>
</div>
<div class="paragraph">
<p>For that, we can make <code>hash</code> take two hash algorithms, one 32 bit and one 64 bit, and have it pick the appropriate one automatically:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/siphash.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/md5.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/hash_append.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/get_integral_result.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/unordered/unordered_flat_map.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/core/type_name.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H2</span> <span class="o">=</span> <span class="n">H1</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">hash</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">using</span> <span class="n">hash_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span>
        <span class="k">sizeof</span><span class="p">(</span><span class="k">typename</span> <span class="n">H1</span><span class="o">::</span><span class="n">result_type</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">),</span> <span class="n">H1</span><span class="p">,</span> <span class="n">H2</span>
    <span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>

<span class="nl">private:</span>

    <span class="n">hash_type</span> <span class="n">h_</span><span class="p">;</span>

<span class="nl">public:</span>

    <span class="n">hash</span><span class="p">()</span><span class="o">:</span> <span class="n">h_</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">explicit</span> <span class="nf">hash</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">)</span><span class="o">:</span> <span class="n">h_</span><span class="p">(</span> <span class="n">seed</span> <span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">hash</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">)</span><span class="o">:</span> <span class="n">h_</span><span class="p">(</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span> <span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="nf">operator</span><span class="p">()(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">hash_type</span> <span class="n">h</span><span class="p">(</span> <span class="n">h_</span> <span class="p">);</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h</span><span class="p">,</span> <span class="p">{},</span> <span class="n">v</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">get_integral_result</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">h</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">{</span>
        <span class="k">using</span> <span class="n">hasher</span> <span class="o">=</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">siphash_32</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">siphash_64</span><span class="o">&gt;</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">boost</span><span class="o">::</span><span class="n">core</span><span class="o">::</span><span class="n">type_name</span><span class="o">&lt;</span><span class="n">hasher</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" uses "</span>
            <span class="o">&lt;&lt;</span> <span class="n">boost</span><span class="o">::</span><span class="n">core</span><span class="o">::</span><span class="n">type_name</span><span class="o">&lt;</span><span class="n">hasher</span><span class="o">::</span><span class="n">hash_type</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="n">boost</span><span class="o">::</span><span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">hasher</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span>

        <span class="n">map</span><span class="p">[</span> <span class="s">"foo"</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">map</span><span class="p">[</span> <span class="s">"bar"</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">{</span>
        <span class="k">using</span> <span class="n">hasher</span> <span class="o">=</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">md5_128</span><span class="o">&gt;</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">boost</span><span class="o">::</span><span class="n">core</span><span class="o">::</span><span class="n">type_name</span><span class="o">&lt;</span><span class="n">hasher</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" uses "</span>
            <span class="o">&lt;&lt;</span> <span class="n">boost</span><span class="o">::</span><span class="n">core</span><span class="o">::</span><span class="n">type_name</span><span class="o">&lt;</span><span class="n">hasher</span><span class="o">::</span><span class="n">hash_type</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="n">boost</span><span class="o">::</span><span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">hasher</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span>

        <span class="n">map</span><span class="p">[</span> <span class="s">"foo"</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">map</span><span class="p">[</span> <span class="s">"bar"</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To keep the case where we only pass one hash algorithm working, we default the second template parameter to the first one, so that if only one hash algorithm is passed, it will always be used.</p>
</div>
</div>
<div class="sect2">
<h3 id="example_md5sum"><a class="anchor" href="#example_md5sum"></a>md5sum</h3>
<div class="paragraph">
<p>A command line utility that prints the MD5 digests
of a list of files passed as arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/md5.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cerrno&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">md5sum</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">f</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">fn</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">md5_128</span> <span class="n">hash</span><span class="p">;</span>

    <span class="kt">int</span> <span class="k">const</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span> <span class="n">N</span> <span class="p">];</span>

    <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">fread</span><span class="p">(</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">f</span> <span class="p">);</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ferror</span><span class="p">(</span> <span class="n">f</span> <span class="p">)</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"'%s': read error: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">strerror</span><span class="p">(</span> <span class="n">errno</span> <span class="p">)</span> <span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">break</span><span class="p">;</span>

        <span class="n">hash</span><span class="p">.</span><span class="n">update</span><span class="p">(</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">n</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">digest</span> <span class="o">=</span> <span class="n">to_string</span><span class="p">(</span> <span class="n">hash</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span> <span class="s">"%s *%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">digest</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">fn</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">fopen</span><span class="p">(</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">"rb"</span> <span class="p">);</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"'%s': open error: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">std</span><span class="o">::</span><span class="n">strerror</span><span class="p">(</span> <span class="n">errno</span> <span class="p">)</span> <span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">md5sum</span><span class="p">(</span> <span class="n">f</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>

        <span class="n">std</span><span class="o">::</span><span class="n">fclose</span><span class="p">(</span> <span class="n">f</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Sample command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>md5sum apache_builds.json canada.json citm_catalog.json twitter.json</pre>
</div>
</div>
<div class="paragraph">
<p>Sample output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>7dc25b5fd9eb2217ed648dad23b311da *apache_builds.json
8767d618bff99552b4946078d3a90c0c *canada.json
b4391581160654374bee934a3b91255e *citm_catalog.json
bf7d37451840af4e8873b65763315cbf *twitter.json</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="example_hash2sum"><a class="anchor" href="#example_hash2sum"></a>hash2sum</h3>
<div class="paragraph">
<p>A command line utility that prints the digests
of a list of files, using a specified hash algorithm.</p>
</div>
<div class="paragraph">
<p>The hash algorithm is passed as the first command
line argument.</p>
</div>
<div class="paragraph">
<p>This example requires C&#43;&#43;14.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/md5.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/sha1.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/sha2.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/ripemd.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/mp11.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cerrno&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">hash2sum</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">f</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">fn</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">Hash</span> <span class="n">hash</span><span class="p">;</span>

    <span class="kt">int</span> <span class="k">const</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span> <span class="n">N</span> <span class="p">];</span>

    <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">fread</span><span class="p">(</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">f</span> <span class="p">);</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ferror</span><span class="p">(</span> <span class="n">f</span> <span class="p">)</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"'%s': read error: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">strerror</span><span class="p">(</span> <span class="n">errno</span> <span class="p">)</span> <span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">break</span><span class="p">;</span>

        <span class="n">hash</span><span class="p">.</span><span class="n">update</span><span class="p">(</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">n</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">digest</span> <span class="o">=</span> <span class="n">to_string</span><span class="p">(</span> <span class="n">hash</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span> <span class="s">"%s *%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">digest</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">fn</span> <span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">hash2sum</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">fn</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">fopen</span><span class="p">(</span> <span class="n">fn</span><span class="p">,</span> <span class="s">"rb"</span> <span class="p">);</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"'%s': open error: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">strerror</span><span class="p">(</span> <span class="n">errno</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">hash2sum</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">f</span><span class="p">,</span> <span class="n">fn</span> <span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">fclose</span><span class="p">(</span> <span class="n">f</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">mp11</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="p">;</span>

<span class="k">using</span> <span class="n">hashes</span> <span class="o">=</span> <span class="n">mp_list</span><span class="o">&lt;</span>

    <span class="n">md5_128</span><span class="p">,</span>
    <span class="n">sha1_160</span><span class="p">,</span>
    <span class="n">sha2_256</span><span class="p">,</span>
    <span class="n">sha2_224</span><span class="p">,</span>
    <span class="n">sha2_512</span><span class="p">,</span>
    <span class="n">sha2_384</span><span class="p">,</span>
    <span class="n">sha2_512_256</span><span class="p">,</span>
    <span class="n">sha2_512_224</span><span class="p">,</span>
    <span class="n">ripemd_160</span><span class="p">,</span>
    <span class="n">ripemd_128</span>

<span class="o">&gt;</span><span class="p">;</span>

<span class="k">constexpr</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>

    <span class="s">"md5_128"</span><span class="p">,</span>
    <span class="s">"sha1_160"</span><span class="p">,</span>
    <span class="s">"sha2_256"</span><span class="p">,</span>
    <span class="s">"sha2_224"</span><span class="p">,</span>
    <span class="s">"sha2_512"</span><span class="p">,</span>
    <span class="s">"sha2_384"</span><span class="p">,</span>
    <span class="s">"sha2_512_256"</span><span class="p">,</span>
    <span class="s">"sha2_512_224"</span><span class="p">,</span>
    <span class="s">"ripemd_160"</span><span class="p">,</span>
    <span class="s">"ripemd_128"</span>

<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">fputs</span><span class="p">(</span> <span class="s">"usage: hash2sum &lt;hash&gt; &lt;files...&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">stderr</span> <span class="p">);</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">hash</span><span class="p">(</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
    <span class="kt">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">mp_for_each</span><span class="o">&lt;</span> <span class="n">mp_iota</span><span class="o">&lt;</span><span class="n">mp_size</span><span class="o">&lt;</span><span class="n">hashes</span><span class="o">&gt;&gt;</span> <span class="o">&gt;</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">I</span><span class="p">){</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">hash</span> <span class="o">==</span> <span class="n">names</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="k">using</span> <span class="n">Hash</span> <span class="o">=</span> <span class="n">mp_at_c</span><span class="o">&lt;</span><span class="n">hashes</span><span class="p">,</span> <span class="n">I</span><span class="o">&gt;</span><span class="p">;</span>

            <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="n">hash2sum</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
            <span class="p">}</span>

            <span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">});</span>

    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">found</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"hash2sum: unknown hash algorithm name '%s'; use one of the following:</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hash</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span> <span class="p">);</span>

        <span class="k">for</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">name</span><span class="o">:</span> <span class="n">names</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">fprintf</span><span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"   %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Sample command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>hash2sum sha2_512_224 apache_builds.json canada.json citm_catalog.json twitter.json</pre>
</div>
</div>
<div class="paragraph">
<p>Sample output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>a95d7fde785fe24f9507fd1709014567bbc595867f1abaad96f50dbc *apache_builds.json
b07e42587d10ec323a25fd8fc3eef2213fb0997beb7950350f4e8a4b *canada.json
4ceee5a83ad320fedb0dfddfb6f80af50b99677e87158e2d039aa168 *citm_catalog.json
854ebe0da98cadd426ea0fa3218d60bb52cf6494e435d2f385a37d48 *twitter.json</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="example_compile_time_hashing"><a class="anchor" href="#example_compile_time_hashing"></a>Compile Time Hashing</h3>
<div class="paragraph">
<p>This example demonstrates calculating the MD5 digest of a data array, embedded in the program source, at compile time. It requires C&#43;&#43;14.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/md5.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="c1">// xxd -i resource</span>
<span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">resource</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0x8b</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x6d</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">,</span>
  <span class="mh">0xcf</span><span class="p">,</span> <span class="mh">0x6e</span><span class="p">,</span> <span class="mh">0x83</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">,</span> <span class="mh">0x0c</span><span class="p">,</span> <span class="mh">0xc6</span><span class="p">,</span> <span class="mh">0xcf</span><span class="p">,</span> <span class="mh">0x45</span><span class="p">,</span> <span class="mh">0xea</span><span class="p">,</span> <span class="mh">0x3b</span><span class="p">,</span> <span class="mh">0x78</span><span class="p">,</span> <span class="mh">0x9c</span><span class="p">,</span>
  <span class="mh">0x4b</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x3d</span><span class="p">,</span> <span class="mh">0x6e</span><span class="p">,</span> <span class="mh">0xd0</span><span class="p">,</span> <span class="mh">0x43</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x1c</span><span class="p">,</span> <span class="mh">0x26</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x3b</span><span class="p">,</span> <span class="mh">0x14</span><span class="p">,</span>
  <span class="mh">0x6d</span><span class="p">,</span> <span class="mh">0xd7</span><span class="p">,</span> <span class="mh">0x2a</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x43</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x95</span><span class="p">,</span> <span class="mh">0x84</span><span class="p">,</span> <span class="mh">0x25</span><span class="p">,</span> <span class="mh">0x66</span><span class="p">,</span> <span class="mh">0x8c</span><span class="p">,</span> <span class="mh">0x47</span><span class="p">,</span>
  <span class="mh">0xda</span><span class="p">,</span> <span class="mh">0x5b</span><span class="p">,</span> <span class="mh">0x2e</span><span class="p">,</span> <span class="mh">0x91</span><span class="p">,</span> <span class="mh">0xd6</span><span class="p">,</span> <span class="mh">0xcb</span><span class="p">,</span> <span class="mh">0xd4</span><span class="p">,</span> <span class="mh">0x93</span><span class="p">,</span> <span class="mh">0x2d</span><span class="p">,</span> <span class="mh">0xdb</span><span class="p">,</span> <span class="mh">0xdf</span><span class="p">,</span> <span class="mh">0xef</span><span class="p">,</span>
  <span class="mh">0xb3</span><span class="p">,</span> <span class="mh">0x5d</span><span class="p">,</span> <span class="mh">0x2a</span><span class="p">,</span> <span class="mh">0x1a</span><span class="p">,</span> <span class="mh">0x6e</span><span class="p">,</span> <span class="mh">0xbb</span><span class="p">,</span> <span class="mh">0x75</span><span class="p">,</span> <span class="mh">0x52</span><span class="p">,</span> <span class="mh">0x2a</span><span class="p">,</span> <span class="mh">0x14</span><span class="p">,</span> <span class="mh">0x6d</span><span class="p">,</span> <span class="mh">0x8c</span><span class="p">,</span>
  <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x92</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x45</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">,</span> <span class="mh">0x66</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">,</span> <span class="mh">0x39</span><span class="p">,</span> <span class="mh">0xe9</span><span class="p">,</span> <span class="mh">0xaf</span><span class="p">,</span> <span class="mh">0x2a</span><span class="p">,</span> <span class="mh">0x75</span><span class="p">,</span>
  <span class="mh">0xd8</span><span class="p">,</span> <span class="mh">0x39</span><span class="p">,</span> <span class="mh">0xf4</span><span class="p">,</span> <span class="mh">0x2a</span><span class="p">,</span> <span class="mh">0x05</span><span class="p">,</span> <span class="mh">0x69</span><span class="p">,</span> <span class="mh">0x0d</span><span class="p">,</span> <span class="mh">0xa1</span><span class="p">,</span> <span class="mh">0xa1</span><span class="p">,</span> <span class="mh">0x2a</span><span class="p">,</span> <span class="mh">0xcd</span><span class="p">,</span> <span class="mh">0x5f</span><span class="p">,</span>
  <span class="mh">0xe0</span><span class="p">,</span> <span class="mh">0xfd</span><span class="p">,</span> <span class="mh">0x72</span><span class="p">,</span> <span class="mh">0xae</span><span class="p">,</span> <span class="mh">0x5a</span><span class="p">,</span> <span class="mh">0x2b</span><span class="p">,</span> <span class="mh">0x79</span><span class="p">,</span> <span class="mh">0x54</span><span class="p">,</span> <span class="mh">0x73</span><span class="p">,</span> <span class="mh">0x25</span><span class="p">,</span> <span class="mh">0xbc</span><span class="p">,</span> <span class="mh">0xda</span><span class="p">,</span>
  <span class="mh">0xb2</span><span class="p">,</span> <span class="mh">0x98</span><span class="p">,</span> <span class="mh">0xa6</span><span class="p">,</span> <span class="mh">0x91</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">,</span> <span class="mh">0xef</span><span class="p">,</span> <span class="mh">0xa8</span><span class="p">,</span> <span class="mh">0xc6</span><span class="p">,</span> <span class="mh">0xb6</span><span class="p">,</span> <span class="mh">0x4b</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="mh">0x17</span><span class="p">,</span>
  <span class="mh">0x6c</span><span class="p">,</span> <span class="mh">0xb5</span><span class="p">,</span> <span class="mh">0x43</span><span class="p">,</span> <span class="mh">0x49</span><span class="p">,</span> <span class="mh">0xda</span><span class="p">,</span> <span class="mh">0xf4</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x16</span><span class="p">,</span> <span class="mh">0xca</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x0f</span><span class="p">,</span> <span class="mh">0xcc</span><span class="p">,</span>
  <span class="mh">0x2a</span><span class="p">,</span> <span class="mh">0x7d</span><span class="p">,</span> <span class="mh">0xa8</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">,</span> <span class="mh">0x50</span><span class="p">,</span> <span class="mh">0x2c</span><span class="p">,</span> <span class="mh">0xb9</span><span class="p">,</span> <span class="mh">0xd8</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">,</span> <span class="mh">0xc6</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span> <span class="mh">0xf9</span><span class="p">,</span>
  <span class="mh">0x8f</span><span class="p">,</span> <span class="mh">0x58</span><span class="p">,</span> <span class="mh">0xf2</span><span class="p">,</span> <span class="mh">0xfb</span><span class="p">,</span> <span class="mh">0xd6</span><span class="p">,</span> <span class="mh">0x4f</span><span class="p">,</span> <span class="mh">0x59</span><span class="p">,</span> <span class="mh">0xb6</span><span class="p">,</span> <span class="mh">0x4e</span><span class="p">,</span> <span class="mh">0x56</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="mh">0x70</span><span class="p">,</span>
  <span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0xe3</span><span class="p">,</span> <span class="mh">0xe2</span><span class="p">,</span> <span class="mh">0x74</span><span class="p">,</span> <span class="mh">0xaf</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0xf6</span><span class="p">,</span> <span class="mh">0x38</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x47</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">,</span>
  <span class="mh">0xa3</span><span class="p">,</span> <span class="mh">0xdf</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">,</span> <span class="mh">0x36</span><span class="p">,</span> <span class="mh">0xcf</span><span class="p">,</span> <span class="mh">0x8b</span><span class="p">,</span> <span class="mh">0xd0</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="mh">0x6a</span><span class="p">,</span> <span class="mh">0x4f</span><span class="p">,</span> <span class="mh">0x4e</span><span class="p">,</span> <span class="mh">0x37</span><span class="p">,</span>
  <span class="mh">0x13</span><span class="p">,</span> <span class="mh">0x61</span><span class="p">,</span> <span class="mh">0x0b</span><span class="p">,</span> <span class="mh">0x93</span><span class="p">,</span> <span class="mh">0x69</span><span class="p">,</span> <span class="mh">0xd1</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x29</span><span class="p">,</span> <span class="mh">0x84</span><span class="p">,</span> <span class="mh">0xbd</span><span class="p">,</span> <span class="mh">0xb5</span><span class="p">,</span> <span class="mh">0x9e</span><span class="p">,</span>
  <span class="mh">0xa0</span><span class="p">,</span> <span class="mh">0xb6</span><span class="p">,</span> <span class="mh">0x1d</span><span class="p">,</span> <span class="mh">0xcd</span><span class="p">,</span> <span class="mh">0xc2</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span> <span class="mh">0x9c</span><span class="p">,</span> <span class="mh">0xb5</span><span class="p">,</span> <span class="mh">0x44</span><span class="p">,</span> <span class="mh">0xe3</span><span class="p">,</span> <span class="mh">0x71</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span>
  <span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0xe8</span><span class="p">,</span> <span class="mh">0xbc</span><span class="p">,</span> <span class="mh">0xb6</span><span class="p">,</span> <span class="mh">0x06</span><span class="p">,</span> <span class="mh">0x0a</span><span class="p">,</span> <span class="mh">0x96</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">,</span> <span class="mh">0xd3</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x8d</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span>
  <span class="mh">0x42</span><span class="p">,</span> <span class="mh">0x4a</span><span class="p">,</span> <span class="mh">0x3b</span><span class="p">,</span> <span class="mh">0x8c</span><span class="p">,</span> <span class="mh">0xc2</span><span class="p">,</span> <span class="mh">0x2c</span><span class="p">,</span> <span class="mh">0xf1</span><span class="p">,</span> <span class="mh">0x86</span><span class="p">,</span> <span class="mh">0x4e</span><span class="p">,</span> <span class="mh">0xdf</span><span class="p">,</span> <span class="mh">0xc2</span><span class="p">,</span> <span class="mh">0xf4</span><span class="p">,</span>
  <span class="mh">0xeb</span><span class="p">,</span> <span class="mh">0xe1</span><span class="p">,</span> <span class="mh">0xf4</span><span class="p">,</span> <span class="mh">0x56</span><span class="p">,</span> <span class="mh">0x9f</span><span class="p">,</span> <span class="mh">0xae</span><span class="p">,</span> <span class="mh">0xc5</span><span class="p">,</span> <span class="mh">0x35</span><span class="p">,</span> <span class="mh">0x67</span><span class="p">,</span> <span class="mh">0xf4</span><span class="p">,</span> <span class="mh">0x4d</span><span class="p">,</span> <span class="mh">0x60</span><span class="p">,</span>
  <span class="mh">0x5d</span><span class="p">,</span> <span class="mh">0xf8</span><span class="p">,</span> <span class="mh">0xcf</span><span class="p">,</span> <span class="mh">0xb8</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0xa0</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x89</span><span class="p">,</span> <span class="mh">0xef</span><span class="p">,</span> <span class="mh">0x7b</span><span class="p">,</span> <span class="mh">0xe6</span><span class="p">,</span> <span class="mh">0x7c</span><span class="p">,</span>
  <span class="mh">0x9e</span><span class="p">,</span> <span class="mh">0x67</span><span class="p">,</span> <span class="mh">0xd6</span><span class="p">,</span> <span class="mh">0x44</span><span class="p">,</span> <span class="mh">0x13</span><span class="p">,</span> <span class="mh">0x66</span><span class="p">,</span> <span class="mh">0x5d</span><span class="p">,</span> <span class="mh">0xcf</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x29</span><span class="p">,</span> <span class="mh">0xd6</span><span class="p">,</span> <span class="mh">0x49</span><span class="p">,</span>
  <span class="mh">0x96</span><span class="p">,</span> <span class="mh">0x85</span><span class="p">,</span> <span class="mh">0x0b</span><span class="p">,</span> <span class="mh">0x7e</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x36</span><span class="p">,</span> <span class="mh">0x66</span><span class="p">,</span> <span class="mh">0x95</span><span class="p">,</span> <span class="mh">0x6b</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
  <span class="mh">0x00</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="nf">md5</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)[</span> <span class="n">N</span> <span class="p">]</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">md5_128</span> <span class="n">hash</span><span class="p">;</span>
    <span class="n">hash</span><span class="p">.</span><span class="n">update</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="n">N</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">hash</span><span class="p">.</span><span class="n">result</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">resource_digest</span> <span class="o">=</span> <span class="n">md5</span><span class="p">(</span> <span class="n">resource</span> <span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resource digest: "</span> <span class="o">&lt;&lt;</span> <span class="n">resource_digest</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the <code>constexpr</code> overload of <code>update</code> takes <code>unsigned char const*</code> (<code>void const*</code> is not allowed in <code>constexpr</code> functions), if the
data to be hashed is a character array of type <code>char const[]</code>, passing it directly to <code>update</code> will not compile. In that case, we can
use <code>hash_append_range</code> instead of calling <code>update</code>, as in the following example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/sha2.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/hash_append.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">extern</span> <span class="k">constexpr</span> <span class="kt">char</span> <span class="k">const</span> <span class="n">license</span><span class="p">[]</span> <span class="o">=</span>

<span class="s">"Boost Software License - Version 1.0 - August 17th, 2003</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"Permission is hereby granted, free of charge, to any person or organization</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"obtaining a copy of the software and accompanying documentation covered by</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"this license (the </span><span class="se">\"</span><span class="s">Software</span><span class="se">\"</span><span class="s">) to use, reproduce, display, distribute,</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"execute, and transmit the Software, and to prepare derivative works of the</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"Software, and to permit third-parties to whom the Software is furnished to</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"do so, all subject to the following:</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"The copyright notices in the Software and this entire statement, including</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"the above license grant, this restriction and the following disclaimer,</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"must be included in all copies of the Software, in whole or in part, and</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"all derivative works of the Software, unless such copies or derivative</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"works are solely in the form of machine-executable object code generated by</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"a source language processor.</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"THE SOFTWARE IS PROVIDED </span><span class="se">\"</span><span class="s">AS IS</span><span class="se">\"</span><span class="s">, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span><span class="se">\n</span><span class="s">"</span>
<span class="s">"DEALINGS IN THE SOFTWARE.</span><span class="se">\n</span><span class="s">"</span>

<span class="p">;</span>

<span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">secret</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mh">0xA4</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x0E</span><span class="p">,</span> <span class="mh">0xE8</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x0B</span><span class="p">,</span> <span class="mh">0x7C</span><span class="p">,</span> <span class="mh">0x9A</span><span class="p">,</span>
    <span class="mh">0xF1</span><span class="p">,</span> <span class="mh">0x3E</span><span class="p">,</span> <span class="mh">0x3D</span><span class="p">,</span> <span class="mh">0xEC</span><span class="p">,</span> <span class="mh">0x64</span><span class="p">,</span> <span class="mh">0x4F</span><span class="p">,</span> <span class="mh">0x64</span><span class="p">,</span> <span class="mh">0xCA</span><span class="p">,</span>
    <span class="mh">0x33</span><span class="p">,</span> <span class="mh">0xCC</span><span class="p">,</span> <span class="mh">0x84</span><span class="p">,</span> <span class="mh">0xC8</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">,</span> <span class="mh">0xE3</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0xAE</span><span class="p">,</span>
    <span class="mh">0x92</span><span class="p">,</span> <span class="mh">0x89</span><span class="p">,</span> <span class="mh">0xEB</span><span class="p">,</span> <span class="mh">0xD0</span><span class="p">,</span> <span class="mh">0x47</span><span class="p">,</span> <span class="mh">0x39</span><span class="p">,</span> <span class="mh">0x87</span><span class="p">,</span> <span class="mh">0xD8</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="nf">hmac_sha2_256</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)[</span> <span class="n">N</span> <span class="p">]</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hmac_sha2_256</span> <span class="n">hmac</span><span class="p">(</span> <span class="n">secret</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">secret</span><span class="p">)</span> <span class="p">);</span>

    <span class="c1">// N-1, in order to not include the null terminator</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append_range</span><span class="p">(</span> <span class="n">hmac</span><span class="p">,</span> <span class="p">{},</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="o">+</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">);</span>

    <span class="k">return</span> <span class="n">hmac</span><span class="p">.</span><span class="n">result</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">license_mac</span> <span class="o">=</span> <span class="n">hmac_sha2_256</span><span class="p">(</span> <span class="n">license</span> <span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"License authentication code: "</span> <span class="o">&lt;&lt;</span> <span class="n">license_mac</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="example_result_extension"><a class="anchor" href="#example_result_extension"></a>Result Extension</h3>
<div class="paragraph">
<p>Some of our hash algorithms, such as <code>xxhash_64</code> and <code>siphash_64</code>, have more than 64 bits of internal state, but only produce a 64 bit result.</p>
</div>
<div class="paragraph">
<p>If we&#8217;re using one of these algorithms to produce file or content checksums, do not tolerate collisions, and operate on a large number of files or items (many millions), it might be better to use a 128 bit digest instead.</p>
</div>
<div class="paragraph">
<p>Since the algorithms maintain more than 64 bits of state, we can call <code>result()</code> twice and obtain a meaningful 128 bit result.</p>
</div>
<div class="paragraph">
<p>The following example demonstrates how. It defines an algorithm <code>xxhash_128</code> which is implemented by wrapping <code>xxhash_64</code> and redefining its <code>result_type</code> and <code>result</code> members appropriately:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/xxhash.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/digest.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/endian/conversion.hpp&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">xxhash_128</span><span class="o">:</span> <span class="k">private</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">xxhash_64</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">digest</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">using</span> <span class="n">xxhash_64</span><span class="o">::</span><span class="n">xxhash_64</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">xxhash_64</span><span class="o">::</span><span class="n">update</span><span class="p">;</span>

    <span class="n">result_type</span> <span class="n">result</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">xxhash_64</span><span class="o">::</span><span class="n">result</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">xxhash_64</span><span class="o">::</span><span class="n">result</span><span class="p">();</span>

        <span class="n">result_type</span> <span class="n">r</span> <span class="o">=</span> <span class="p">{};</span>

        <span class="n">boost</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">store_little_u64</span><span class="p">(</span> <span class="n">r</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r1</span> <span class="p">);</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">endian</span><span class="o">::</span><span class="n">store_little_u64</span><span class="p">(</span> <span class="n">r</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">r2</span> <span class="p">);</span>

        <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">tv</span><span class="p">(</span> <span class="s">"The quick brown fox jumps over the lazy dog"</span> <span class="p">);</span>

    <span class="n">xxhash_128</span> <span class="n">hash</span><span class="p">(</span> <span class="mi">43</span> <span class="p">);</span>
    <span class="n">hash</span><span class="p">.</span><span class="n">update</span><span class="p">(</span> <span class="n">tv</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">tv</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">hash</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="implementation"><a class="anchor" href="#implementation"></a>Implementation Features</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="implementation_supported_compilers"><a class="anchor" href="#implementation_supported_compilers"></a>Supported Compilers</h3>
<div class="paragraph">
<p>The library requires C&#43;&#43;11. The following compilers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>g++ 4.8 or later</p>
</li>
<li>
<p>clang++ 3.9 or later</p>
</li>
<li>
<p>Visual Studio 2015 and above</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>are being tested on <a href="https://github.com/pdimov/hash2/actions/">Github Actions</a>
and <a href="https://ci.appveyor.com/project/pdimov/hash2/">Appveyor</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference"><a class="anchor" href="#reference"></a>Reference</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="ref_hash_algorithms"><a class="anchor" href="#ref_hash_algorithms"></a>Hash Algorithms</h3>
<div class="sect3">
<h4 id="ref_fnv1a"><a class="anchor" href="#ref_fnv1a"></a>&lt;boost/hash2/fnv1a.hpp&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">fnv1a_32</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">fnv1a_64</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This header implements the <a href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">FNV-1a algorithm</a>, in 32 and 64 bit variants.</p>
</div>
<div class="sect4">
<h5 id="ref_fnv1a_fnv1a_32"><a class="anchor" href="#ref_fnv1a_fnv1a_32"></a>fnv1a_32</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">fnv1a_32</span>
<span class="p">{</span>
<span class="nl">private:</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">state_</span><span class="p">;</span> <span class="c1">// exposition only</span>

<span class="nl">public:</span>

    <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">fnv1a_32</span><span class="p">();</span>
    <span class="k">explicit</span> <span class="k">constexpr</span> <span class="n">fnv1a_32</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span>
    <span class="n">fnv1a_32</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="n">fnv1a_32</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="k">constexpr</span> <span class="n">result_type</span> <span class="n">result</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="ref_fnv1a_constructors"><a class="anchor" href="#ref_fnv1a_constructors"></a>Constructors</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="nf">fnv1a_32</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Default constructor.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes <code>state_</code> to <code>0x811c9dc5</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="k">constexpr</span> <span class="nf">fnv1a_32</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking an integer seed value.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, then if <code>seed</code> is not zero, performs <code>update(p, 8)</code> where <code>p</code> points to a little-endian representation of the value of <code>seed</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>seed</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">fnv1a_32</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="nf">fnv1a_32</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking a byte sequence seed.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, and then, if <code>n</code> is not zero, performs <code>update(p, n)</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>n</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_fnv1a_update"><a class="anchor" href="#ref_fnv1a_update"></a>update</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>For each <code>unsigned char</code> value <code>ch</code> in the range <code>[p, p+n)</code> performs <code>state_ = (state_ ^ ch) * 0x01000193</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_fnv1a_result"><a class="anchor" href="#ref_fnv1a_result"></a>result</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">result_type</span> <span class="nf">result</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Updates <code>state_</code> to <code>(state_ ^ 0xFF) * 0x01000193</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The value of <code>state_</code> before the update.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>The state is updated to allow repeated calls to <code>result()</code> to return
a pseudorandom sequence of <code>result_type</code> values, effectively extending
the output.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ref_fnv1a_fnv1a_64"><a class="anchor" href="#ref_fnv1a_fnv1a_64"></a>fnv1a_64</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">fnv1a_64</span>
<span class="p">{</span>
<span class="nl">private:</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">state_</span><span class="p">;</span> <span class="c1">// exposition only</span>

<span class="nl">public:</span>

    <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">fnv1a_64</span><span class="p">();</span>
    <span class="k">explicit</span> <span class="k">constexpr</span> <span class="n">fnv1a_64</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span>
    <span class="n">fnv1a_64</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="n">fnv1a_64</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="k">constexpr</span> <span class="n">result_type</span> <span class="n">result</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="ref_fnv1a_constructors_2"><a class="anchor" href="#ref_fnv1a_constructors_2"></a>Constructors</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="nf">fnv1a_64</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Default constructor.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes <code>state_</code> to <code>0xcbf29ce484222325</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="k">constexpr</span> <span class="nf">fnv1a_64</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking an integer seed value.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, then if <code>seed</code> is not zero, performs <code>update(p, 8)</code> where <code>p</code> points to a little-endian representation of the value of <code>seed</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>seed</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">fnv1a_64</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="nf">fnv1a_64</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking a byte sequence seed.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, and then, if <code>n</code> is not zero, performs <code>update(p, n)</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>n</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_fnv1a_update_2"><a class="anchor" href="#ref_fnv1a_update_2"></a>update</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>For each <code>unsigned char</code> value <code>ch</code> in the range <code>[p, p+n)</code> performs <code>state_ = (state_ ^ ch) * 0x100000001b3</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_fnv1a_result_2"><a class="anchor" href="#ref_fnv1a_result_2"></a>result</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">result_type</span> <span class="nf">result</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Updates <code>state_</code> to <code>(state_ ^ 0xFF) * 0x100000001b3</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The value of <code>state_</code> before the update.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>The state is updated to allow repeated calls to <code>result()</code> to return
a pseudorandom sequence of <code>result_type</code> values, effectively extending
the output.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ref_xxhash"><a class="anchor" href="#ref_xxhash"></a>&lt;boost/hash2/xxhash.hpp&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">xxhash_32</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">xxhash_64</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This header implements the <a href="https://xxhash.com/">XXH32 and XXH64 algorithms</a>.</p>
</div>
<div class="sect4">
<h5 id="ref_xxhash_xxhash_32"><a class="anchor" href="#ref_xxhash_xxhash_32"></a>xxhash_32</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">xxhash_32</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">xxhash_32</span><span class="p">();</span>
    <span class="k">explicit</span> <span class="k">constexpr</span> <span class="n">xxhash_32</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span>
    <span class="n">xxhash_32</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="n">xxhash_32</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="k">constexpr</span> <span class="n">result_type</span> <span class="n">result</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="ref_xxhash_constructors"><a class="anchor" href="#ref_xxhash_constructors"></a>Constructors</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="nf">xxhash_32</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Default constructor.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the internal state of the XXH32 algorithm to its initial values.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="k">constexpr</span> <span class="nf">xxhash_32</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking an integer seed value.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the internal state of the XXH32 algorithm using the low 32 bits of <code>seed</code> as the seed, then if the high 32 bits of <code>seed</code> aren&#8217;t zero, mixes them into the state.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>seed</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">xxhash_32</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="nf">xxhash_32</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking a byte sequence seed.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, then if <code>n</code> is not zero, performs <code>update(p, n); result()</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>n</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_xxhash_update"><a class="anchor" href="#ref_xxhash_update"></a>update</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Updates the internal state of the XXH32 algorithm from the byte sequence <code>[p, p+n)</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Consecutive calls to <code>update</code> are equivalent to a single call with the concatenated byte sequences of the individual calls.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_xxhash_result"><a class="anchor" href="#ref_xxhash_result"></a>result</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">result_type</span> <span class="nf">result</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Obtains a 32 bit hash value from the state as specified by XXH32, then updates the state.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The obtained hash value.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>The state is updated to allow repeated calls to <code>result()</code> to return a pseudorandom sequence of <code>result_type</code> values, effectively extending the output.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ref_xxhash_xxhash_64"><a class="anchor" href="#ref_xxhash_xxhash_64"></a>xxhash_64</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">xxhash_64</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">xxhash_64</span><span class="p">();</span>
    <span class="k">explicit</span> <span class="k">constexpr</span> <span class="n">xxhash_64</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span>
    <span class="n">xxhash_64</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="n">xxhash_64</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="k">constexpr</span> <span class="n">result_type</span> <span class="n">result</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="ref_xxhash_constructors_2"><a class="anchor" href="#ref_xxhash_constructors_2"></a>Constructors</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="nf">xxhash_64</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Default constructor.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the internal state of the XXH64 algorithm to its initial values.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="k">constexpr</span> <span class="nf">xxhash_64</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking an integer seed value.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the internal state of the XXH64 algorithm using <code>seed</code> as the seed.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>seed</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">xxhash_64</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="nf">xxhash_64</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking a byte sequence seed.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, then if <code>n</code> is not zero, performs <code>update(p, n); result()</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>n</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_xxhash_update_2"><a class="anchor" href="#ref_xxhash_update_2"></a>update</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Updates the internal state of the XXH64 algorithm from the byte sequence <code>[p, p+n)</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Consecutive calls to <code>update</code> are equivalent to a single call with the concatenated byte sequences of the individual calls.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_xxhash_result_2"><a class="anchor" href="#ref_xxhash_result_2"></a>result</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">result_type</span> <span class="nf">result</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Obtains a 64 bit hash value from the state as specified by XXH64, then updates the state.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The obtained hash value.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>The state is updated to allow repeated calls to <code>result()</code> to return a pseudorandom sequence of <code>result_type</code> values, effectively extending the output.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ref_siphash"><a class="anchor" href="#ref_siphash"></a>&lt;boost/hash2/siphash.hpp&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">siphash_32</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">siphash_64</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This header implements the <a href="https://github.com/veorq/SipHash">SipHash and HalfSipHash algorithms</a>.</p>
</div>
<div class="sect4">
<h5 id="ref_siphash_siphash_32"><a class="anchor" href="#ref_siphash_siphash_32"></a>siphash_32</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">siphash_32</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">siphash_32</span><span class="p">();</span>
    <span class="k">explicit</span> <span class="k">constexpr</span> <span class="n">siphash_32</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span>
    <span class="n">siphash_32</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="n">siphash_32</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="k">constexpr</span> <span class="n">result_type</span> <span class="n">result</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="ref_siphash_constructors"><a class="anchor" href="#ref_siphash_constructors"></a>Constructors</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="nf">siphash_32</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Default constructor.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the internal state of the HalfSipHash algorithm as if using a sequence of 8 zero bytes as the key.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="k">constexpr</span> <span class="nf">siphash_32</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking an integer seed value.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the internal state of the HalfSipHash algorithm using <code>seed</code> as the key, as if it were a sequence of its 8 constituent bytes, in little-endian order.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>seed</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">siphash_32</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="nf">siphash_32</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking a byte sequence seed.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>If <code>n</code> is 8, initializes the state as specified by the algorithm; otherwise, initializes the state as if by default construction, then if <code>n</code> is not zero, performs <code>update(p, n); result()</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>n</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_siphash_update"><a class="anchor" href="#ref_siphash_update"></a>update</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Updates the internal state of the HalfSipHash algorithm from the byte sequence <code>[p, p+n)</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Consecutive calls to <code>update</code> are equivalent to a single call with the concatenated byte sequences of the individual calls.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_siphash_result"><a class="anchor" href="#ref_siphash_result"></a>result</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">result_type</span> <span class="nf">result</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Obtains a 32 bit hash value from the state as specified by HalfSipHash.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The obtained hash value.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>The state is updated, which allows repeated calls to <code>result()</code> to return a pseudorandom sequence of <code>result_type</code> values, effectively extending the output.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ref_siphash_siphash_64"><a class="anchor" href="#ref_siphash_siphash_64"></a>siphash_64</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">siphash_64</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">siphash_64</span><span class="p">();</span>
    <span class="k">explicit</span> <span class="k">constexpr</span> <span class="n">siphash_64</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span>
    <span class="n">siphash_64</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="n">siphash_64</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="k">constexpr</span> <span class="n">result_type</span> <span class="n">result</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="ref_siphash_constructors_2"><a class="anchor" href="#ref_siphash_constructors_2"></a>Constructors</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="nf">siphash_64</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Default constructor.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the internal state of the SipHash algorithm as if using a sequence of 16 zero bytes as the key.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="k">constexpr</span> <span class="nf">siphash_64</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking an integer seed value.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the internal state of the SipHash algorithm using <code>seed</code> as the key, as if it were a sequence of its 8 constituent bytes, in little-endian order, followed by 8 zero bytes.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>seed</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">siphash_64</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="nf">siphash_64</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking a byte sequence seed.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>If <code>n</code> is 16, initializes the state as specified by the algorithm; otherwise, initializes the state as if by default construction, then if <code>n</code> is not zero, performs <code>update(p, n); result()</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>n</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_siphash_update_2"><a class="anchor" href="#ref_siphash_update_2"></a>update</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Updates the internal state of the SipHash algorithm from the byte sequence <code>[p, p+n)</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Consecutive calls to <code>update</code> are equivalent to a single call with the concatenated byte sequences of the individual calls.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_siphash_result_2"><a class="anchor" href="#ref_siphash_result_2"></a>result</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">result_type</span> <span class="nf">result</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Obtains a 64 bit hash value from the state as specified by SipHash, then updates the state.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The obtained hash value.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>The state is updated, which allows repeated calls to <code>result()</code> to return a pseudorandom sequence of <code>result_type</code> values, effectively extending the output.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ref_hmac"><a class="anchor" href="#ref_hmac"></a>&lt;boost/hash2/hmac.hpp&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">hmac</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This header implements the <a href="https://tools.ietf.org/html/rfc2104">HMAC algorithm</a>.</p>
</div>
<div class="sect4">
<h5 id="ref_hmac_hmac"><a class="anchor" href="#ref_hmac_hmac"></a>hmac</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">hmac</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">H</span><span class="o">::</span><span class="n">result_type</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">H</span><span class="o">::</span><span class="n">block_size</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">hmac</span><span class="p">();</span>
    <span class="k">explicit</span> <span class="k">constexpr</span> <span class="n">hmac</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span>
    <span class="n">hmac</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="n">hmac</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="k">constexpr</span> <span class="n">result_type</span> <span class="n">result</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The class template <code>hmac</code> takes as a parameter a cryptographic <em>hash algorithm</em> <code>H</code>
and implements the corresponding <em>hash-based message authentication code</em> (HMAC) algorithm.</p>
</div>
<div class="paragraph">
<p>For example, HMAC-SHA2-256 is implemented by <code>hmac&lt;sha2_256&gt;</code>.</p>
</div>
<div class="sect5">
<h6 id="ref_hmac_constructors"><a class="anchor" href="#ref_hmac_constructors"></a>Constructors</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="nf">hmac</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Default constructor.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the internal state using an empty byte sequence as the secret key.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="k">constexpr</span> <span class="nf">hmac</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking an integer seed value.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>If <code>seed</code> is zero, initializes the state as if by default construction, otherwise, initializes it using the 8 bytes of the little-endian representation of <code>seed</code> as the secret key.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>seed</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hmac</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="n">hmac</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking a byte sequence seed.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as specified by the HMAC algorithm using <code>[p, p+n)</code> as the secret key.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>n</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_hmac_update"><a class="anchor" href="#ref_hmac_update"></a>update</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Updates the internal state of the HMAC algorithm from the byte sequence <code>[p, p+n)</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Consecutive calls to <code>update</code> are equivalent to a single call with the concatenated byte sequences of the individual calls.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_hmac_result"><a class="anchor" href="#ref_hmac_result"></a>result</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">result_type</span> <span class="nf">result</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Pads the accumulated message and finalizes the HMAC digest.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The HMAC digest of the message formed from the byte sequences of the preceding calls to <code>update</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Repeated calls to <code>result()</code> return a pseudorandom sequence of <code>result_type</code> values, effectively extending the output.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ref_md5"><a class="anchor" href="#ref_md5"></a>&lt;boost/hash2/md5.hpp&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/hmac.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/digest.hpp&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">md5_128</span><span class="p">;</span>

<span class="k">using</span> <span class="n">hmac_md5_128</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">&lt;</span><span class="n">md5_128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This header implements the <a href="https://tools.ietf.org/html/rfc1321">MD5 algorithm</a>.</p>
</div>
<div class="sect4">
<h5 id="ref_md5_md5_128"><a class="anchor" href="#ref_md5_md5_128"></a>md5_128</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">md5_128</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">digest</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">md5_128</span><span class="p">();</span>
    <span class="k">explicit</span> <span class="k">constexpr</span> <span class="n">md5_128</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span>
    <span class="n">md5_128</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="n">md5_128</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="k">constexpr</span> <span class="n">result_type</span> <span class="n">result</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="ref_md5_constructors"><a class="anchor" href="#ref_md5_constructors"></a>Constructors</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="nf">md5_128</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Default constructor.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the internal state of the MD5 algorithm to its initial values.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="k">constexpr</span> <span class="nf">md5_128</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking an integer seed value.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, then if <code>seed</code> is not zero, performs <code>update(p, 8); result();</code> where <code>p</code> points to a little-endian representation of the value of <code>seed</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>seed</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">md5_128</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="nf">md5_128</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking a byte sequence seed.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, then if <code>n</code> is not zero, performs <code>update(p, n); result()</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>n</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_md5_update"><a class="anchor" href="#ref_md5_update"></a>update</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Updates the internal state of the MD5 algorithm from the byte sequence <code>[p, p+n)</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Consecutive calls to <code>update</code> are equivalent to a single call with the concatenated byte sequences of the individual calls.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_md5_result"><a class="anchor" href="#ref_md5_result"></a>result</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">result_type</span> <span class="nf">result</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Pads the accumulated message and finalizes the MD5 digest.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The MD5 digest of the message formed from the byte sequences of the preceding calls to <code>update</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Repeated calls to <code>result()</code> return a pseudorandom sequence of <code>result_type</code> values, effectively extending the output.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ref_sha1"><a class="anchor" href="#ref_sha1"></a>&lt;boost/hash2/sha1.hpp&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/hmac.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/digest.hpp&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">sha1_160</span><span class="p">;</span>

<span class="k">using</span> <span class="n">hmac_sha1_160</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">&lt;</span><span class="n">sha1_160</span><span class="o">&gt;</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This header implements the <a href="https://tools.ietf.org/html/rfc3174">SHA-1 algorithm</a>.</p>
</div>
<div class="sect4">
<h5 id="ref_sha1_sha1_160"><a class="anchor" href="#ref_sha1_sha1_160"></a>sha1_160</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">sha1_160</span>
<span class="p">{</span>
<span class="nl">public:</span>

    <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">digest</span><span class="o">&lt;</span><span class="mi">20</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">sha1_160</span><span class="p">();</span>
    <span class="k">explicit</span> <span class="k">constexpr</span> <span class="n">sha1_160</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span>
    <span class="n">sha1_160</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="n">sha1_160</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="k">constexpr</span> <span class="n">result_type</span> <span class="n">result</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="ref_sha1_constructors"><a class="anchor" href="#ref_sha1_constructors"></a>Constructors</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="nf">sha1_160</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Default constructor.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the internal state of the SHA-1 algorithm to its initial values.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="k">constexpr</span> <span class="nf">sha1_160</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking an integer seed value.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, then if <code>seed</code> is not zero, performs <code>update(p, 8); result();</code> where <code>p</code> points to a little-endian representation of the value of <code>seed</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>seed</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">sha1_160</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="nf">sha1_160</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking a byte sequence seed.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, then if <code>n</code> is not zero, performs <code>update(p, n); result()</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>n</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_sha1_update"><a class="anchor" href="#ref_sha1_update"></a>update</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Updates the internal state of the SHA-1 algorithm from the byte sequence <code>[p, p+n)</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Consecutive calls to <code>update</code> are equivalent to a single call with the concatenated byte sequences of the individual calls.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_sha1_result"><a class="anchor" href="#ref_sha1_result"></a>result</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">result_type</span> <span class="nf">result</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Pads the accumulated message and finalizes the SHA-1 digest.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The SHA-1 digest of the message formed from the byte sequences of the preceding calls to <code>update</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Repeated calls to <code>result()</code> return a pseudorandom sequence of <code>result_type</code> values, effectively extending the output.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ref_sha2"><a class="anchor" href="#ref_sha2"></a>&lt;boost/hash2/sha2.hpp&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/hmac.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/digest.hpp&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">sha2_256</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">sha2_224</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">sha2_512</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">sha2_384</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">sha2_512_256</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">sha2_512_224</span><span class="p">;</span>

<span class="k">using</span> <span class="n">hmac_sha2_256</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">&lt;</span><span class="n">sha2_256</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">hmac_sha2_224</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">&lt;</span><span class="n">sha2_224</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">hmac_sha2_512</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">&lt;</span><span class="n">sha2_512</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">hmac_sha2_384</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">&lt;</span><span class="n">sha2_384</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">hmac_sha2_512_256</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">&lt;</span><span class="n">sha2_512_256</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">hmac_sha2_512_224</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">&lt;</span><span class="n">sha2_512_224</span><span class="o">&gt;</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This header implements the <a href="https://csrc.nist.gov/pubs/fips/180-4/upd1/final">SHA-2</a> family of functions.</p>
</div>
<div class="sect4">
<h5 id="ref_sha2_sha2_256"><a class="anchor" href="#ref_sha2_sha2_256"></a>sha2_256</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">sha2_256</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">digest</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">sha2_256</span><span class="p">();</span>
    <span class="k">constexpr</span> <span class="k">explicit</span> <span class="n">sha2_256</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span>
    <span class="n">sha2_256</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="n">sha2_256</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="k">constexpr</span> <span class="n">result_type</span> <span class="n">result</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="ref_sha2_constructors"><a class="anchor" href="#ref_sha2_constructors"></a>Constructors</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="nf">sha2_256</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Default constructor.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the internal state of the SHA-256 algorithm to its initial values.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="k">explicit</span> <span class="nf">sha2_256</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking an integer seed value.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, then if <code>seed</code> is not zero, performs <code>update(p, 8); result();</code> where <code>p</code> points to a little-endian representation of the value of <code>seed</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>seed</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">sha2_256</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="nf">sha2_256</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking a byte sequence seed.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, then if <code>n</code> is not zero, performs <code>update(p, n); result()</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>n</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_sha2_update"><a class="anchor" href="#ref_sha2_update"></a>update</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Updates the internal state of the SHA-256 algorithm from the byte sequence <code>[p, p+n)</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Consecutive calls to <code>update</code> are equivalent to a single call with the concatenated byte sequences of the individual calls.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_sha2_result"><a class="anchor" href="#ref_sha2_result"></a>result</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">result_type</span> <span class="nf">result</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Pads the accumulated message and finalizes the SHA-256 digest.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The SHA-256 digest of the message formed from the byte sequences of the preceding calls to <code>update</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Repeated calls to <code>result()</code> return a pseudorandom sequence of <code>result_type</code> values, effectively extending the output.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ref_sha2_sha2_224"><a class="anchor" href="#ref_sha2_sha2_224"></a>sha2_224</h5>
<div class="paragraph">
<p>The SHA-224 algorithm is identical to the SHA-256 algorithm described above.</p>
</div>
<div class="paragraph">
<p>The only differences are the internal state&#8217;s initial values and the size of the message digest, which is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">digest</span><span class="o">&lt;</span><span class="mi">28</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise, all other operations and constants are identical.</p>
</div>
<div class="paragraph">
<p>The message digest is obtained by truncating the final results of the SHA-256 algorithm to its leftmost 224 bits.</p>
</div>
</div>
<div class="sect4">
<h5 id="ref_sha2_sha2_512"><a class="anchor" href="#ref_sha2_sha2_512"></a>sha2_512</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">sha2_512</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">digest</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">sha2_512</span><span class="p">();</span>
    <span class="k">constexpr</span> <span class="k">explicit</span> <span class="n">sha2_512</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span>
    <span class="n">sha2_512</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="n">sha2_512</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="k">constexpr</span> <span class="n">result_type</span> <span class="n">result</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="ref_sha2_constructors_2"><a class="anchor" href="#ref_sha2_constructors_2"></a>Constructors</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="nf">sha2_512</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Default constructor.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the internal state of the SHA-512 algorithm to its initial values.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="k">explicit</span> <span class="nf">sha2_512</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking an integer seed value.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, then if <code>seed</code> is not zero, performs <code>update(p, 8); result();</code> where <code>p</code> points to a little-endian representation of the value of <code>seed</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>seed</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">sha2_512</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="nf">sha2_512</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking a byte sequence seed.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, then if <code>n</code> is not zero, performs <code>update(p, n); result()</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>n</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_sha2_update_2"><a class="anchor" href="#ref_sha2_update_2"></a>update</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Updates the internal state of the SHA-512 algorithm from the byte sequence <code>[p, p+n)</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Consecutive calls to <code>update</code> are equivalent to a single call with the concatenated byte sequences of the individual calls.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_sha2_result_2"><a class="anchor" href="#ref_sha2_result_2"></a>result</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">result_type</span> <span class="nf">result</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Pads the accumulated message and finalizes the SHA-512 digest.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The SHA-512 digest of the message formed from the byte sequences of the preceding calls to <code>update</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Repeated calls to <code>result()</code> return a pseudorandom sequence of <code>result_type</code> values, effectively extending the output.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ref_sha2_sha2_384"><a class="anchor" href="#ref_sha2_sha2_384"></a>sha2_384</h5>
<div class="paragraph">
<p>The SHA-384 algorithm is identical to the SHA-512 algorithm described above.</p>
</div>
<div class="paragraph">
<p>The only differences are the internal state&#8217;s initial values and the size of the message digest, which is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">digest</span><span class="o">&lt;</span><span class="mi">48</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise, all other operations and constants are identical.</p>
</div>
<div class="paragraph">
<p>The message digest is obtained by truncating the final results of the SHA-512 algorithm to its leftmost 384 bits.</p>
</div>
</div>
<div class="sect4">
<h5 id="ref_sha2_sha2_512_224"><a class="anchor" href="#ref_sha2_sha2_512_224"></a>sha2_512_224</h5>
<div class="paragraph">
<p>The SHA-512/224 algorithm is identical to the SHA-512 algorithm described above.</p>
</div>
<div class="paragraph">
<p>The only differences are the internal state&#8217;s initial values and the size of the message digest, which is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">digest</span><span class="o">&lt;</span><span class="mi">28</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise, all other operations and constants are identical.</p>
</div>
<div class="paragraph">
<p>The message digest is obtained by truncating the final results of the SHA-512 algorithm to its leftmost 224 bits.</p>
</div>
</div>
<div class="sect4">
<h5 id="ref_sha2_sha2_512_256"><a class="anchor" href="#ref_sha2_sha2_512_256"></a>sha2_512_256</h5>
<div class="paragraph">
<p>The SHA-512/256 algorithm is identical to the SHA-512 algorithm described above.</p>
</div>
<div class="paragraph">
<p>The only differences are the internal state&#8217;s initial values and the size of the message digest, which is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">digest</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise, all other operations and constants are identical.</p>
</div>
<div class="paragraph">
<p>The message digest is obtained by truncating the final results of the SHA-512 algorithm to its leftmost 256 bits.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ref_sha3"><a class="anchor" href="#ref_sha3"></a>&lt;boost/hash2/sha3.hpp&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/digest.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/hmac.hpp&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">sha3_256</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">sha3_224</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">sha3_512</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">sha3_384</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">shake_128</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">shake_256</span><span class="p">;</span>

<span class="k">using</span> <span class="n">hmac_sha3_256</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">&lt;</span><span class="n">sha3_256</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">hmac_sha3_224</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">&lt;</span><span class="n">sha3_224</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">hmac_sha3_512</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">&lt;</span><span class="n">sha3_512</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">hmac_sha3_384</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">&lt;</span><span class="n">sha3_384</span><span class="o">&gt;</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This header implements the <a href="https://csrc.nist.gov/pubs/fips/202/final">SHA-3</a> family of functions.</p>
</div>
<div class="paragraph">
<p>The fixed-digest hash functions (<code>sha3_256</code>, <code>sha3_224</code>, <code>sha3_512</code>, <code>sha3_384</code>) all use the same constants internally and are initialized the same way.
The only differences between them are the size of the message digest and the size of the input block. Otherwise, digests are all gathered in the same way
which is by truncating the bottom portion of the 1600-bit state.</p>
</div>
<div class="paragraph">
<p>The <code>shake_128</code> and <code>shake_256</code> functions are similar to the fixed-digest functions except they use a different delimiter to denote finalization of the
digest and extending the output has defined behavior, unlike the default pseudorandom behavior used elsewhere in the library. But they work similary
in that truncations of the 1600-bit state are returned as the digest.</p>
</div>
<div class="sect4">
<h5 id="ref_sha3_sha3_256"><a class="anchor" href="#ref_sha3_sha3_256"></a>sha3_256</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">sha3_256</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">digest</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">136</span><span class="p">;</span> <span class="c1">// ( 1600 - 2 * 256 ) / 8 =&gt; 136</span>

    <span class="k">constexpr</span> <span class="n">sha3_256</span><span class="p">();</span>
    <span class="k">constexpr</span> <span class="k">explicit</span> <span class="n">sha3_256</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span>
    <span class="n">sha3_256</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="n">sha3_256</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="k">constexpr</span> <span class="n">result_type</span> <span class="n">result</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="ref_sha3_constructors"><a class="anchor" href="#ref_sha3_constructors"></a>Constructors</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="nf">sha3_256</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Default constructor.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the internal state of the SHA3-256 algorithm to its initial values.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="k">explicit</span> <span class="nf">sha3_256</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking an integer seed value.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, then if <code>seed</code> is not zero, performs <code>update(p, 8); result();</code> where <code>p</code> points to a little-endian representation of the value of <code>seed</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>seed</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">sha3_256</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="nf">sha3_256</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking a byte sequence seed.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, then if <code>n</code> is not zero, performs <code>update(p, n); result()</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>n</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_sha3_update"><a class="anchor" href="#ref_sha3_update"></a>update</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Updates the internal state of the SHA3-256 algorithm from the byte sequence <code>[p, p+n)</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Consecutive calls to <code>update</code> are equivalent to a single call with the concatenated byte sequences of the individual calls.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_sha3_result"><a class="anchor" href="#ref_sha3_result"></a>result</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">result_type</span> <span class="nf">result</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Pads the accumulated message and finalizes the digest.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The leftmost 256 bits of the Keccak-1600 state formed from the byte sequences of the preceding calls to <code>update</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Repeated calls to <code>result()</code> return a pseudorandom sequence of <code>result_type</code> values, effectively extending the output.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ref_sha3_sha3_224"><a class="anchor" href="#ref_sha3_sha3_224"></a>sha3_224</h5>
<div class="paragraph">
<p>The SHA3-224 algorithm is identical to the SHA3-256 algorithm described above.</p>
</div>
<div class="paragraph">
<p>The only differences are the size of the input block and the size of the message digest, which is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">digest</span><span class="o">&lt;</span><span class="mi">28</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">144</span><span class="p">;</span> <span class="c1">// ( 1600 - 2 * 224 ) / 8 =&gt; 144</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise, all other operations and constants are identical.</p>
</div>
<div class="paragraph">
<p>The message digest is obtained by truncating the final results of the Keccak-1600 algorithm to its leftmost 224 bits.</p>
</div>
</div>
<div class="sect4">
<h5 id="ref_sha3_sha3_512"><a class="anchor" href="#ref_sha3_sha3_512"></a>sha3_512</h5>
<div class="paragraph">
<p>The SHA3-512 algorithm is identical to the SHA3-256 algorithm described above.</p>
</div>
<div class="paragraph">
<p>The only differences are the size of the input block and the size of the message digest, which is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">digest</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">72</span><span class="p">;</span> <span class="c1">// ( 1600 - 2 * 512 ) / 8 =&gt; 72</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise, all other operations and constants are identical.</p>
</div>
<div class="paragraph">
<p>The message digest is obtained by truncating the final results of the Keccak-1600 algorithm to its leftmost 512 bits.</p>
</div>
</div>
<div class="sect4">
<h5 id="ref_sha3_sha3_384"><a class="anchor" href="#ref_sha3_sha3_384"></a>sha3_384</h5>
<div class="paragraph">
<p>The SHA3-384 algorithm is identical to the SHA3-256 algorithm described above.</p>
</div>
<div class="paragraph">
<p>The only differences are the size of the input block and the size of the message digest, which is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">digest</span><span class="o">&lt;</span><span class="mi">48</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">104</span><span class="p">;</span> <span class="c1">// ( 1600 - 2 * 384 ) / 8 =&gt; 104</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise, all other operations and constants are identical.</p>
</div>
<div class="paragraph">
<p>The message digest is obtained by truncating the final results of the Keccak-1600 algorithm to its leftmost 384 bits.</p>
</div>
</div>
<div class="sect4">
<h5 id="ref_sha3_shake_128"><a class="anchor" href="#ref_sha3_shake_128"></a>shake_128</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">shake_128</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">digest</span><span class="o">&lt;</span><span class="mi">168</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">168</span><span class="p">;</span> <span class="c1">// ( 1600 - 2 * 128 ) / 8 =&gt; 168</span>

    <span class="k">constexpr</span> <span class="n">shake_128</span><span class="p">();</span>
    <span class="k">constexpr</span> <span class="k">explicit</span> <span class="n">shake_128</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span>
    <span class="n">shake_128</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="n">shake_128</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="k">constexpr</span> <span class="n">result_type</span> <span class="n">result</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="ref_sha3_constructors_2"><a class="anchor" href="#ref_sha3_constructors_2"></a>Constructors</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="nf">shake_128</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Default constructor.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the internal state of the SHAKE128 algorithm to its initial values.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="k">explicit</span> <span class="nf">shake_128</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking an integer seed value.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, then if <code>seed</code> is not zero, performs <code>update(p, 8); result();</code> where <code>p</code> points to a little-endian representation of the value of <code>seed</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>seed</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">shake_128</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="nf">shake_128</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking a byte sequence seed.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, then if <code>n</code> is not zero, performs <code>update(p, n); result()</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>n</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_sha3_update_2"><a class="anchor" href="#ref_sha3_update_2"></a>update</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Updates the internal state of the SHAKE128 algorithm from the byte sequence <code>[p, p+n)</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Consecutive calls to <code>update</code> are equivalent to a single call with the concatenated byte sequences of the individual calls.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_sha3_result_2"><a class="anchor" href="#ref_sha3_result_2"></a>result</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">result_type</span> <span class="nf">result</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Pads the accumulated message and finalizes the digest.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The truncated portion of the 1600-bit state up to the specified rate <code>r</code>, which is the <code>block_size</code>, as specified in step 8 of Algorithm 8 in <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf">FIPS 202</a>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Repeated calls to <code>result()</code> extend the output of the hash function in a defined manner. Calling <code>update()</code> will reset the current finalization process.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ref_sha3_shake_256"><a class="anchor" href="#ref_sha3_shake_256"></a>shake_256</h5>
<div class="paragraph">
<p>The SHAKE256 algorithm is identical to the SHAKE128 algorithm described above.</p>
</div>
<div class="paragraph">
<p>The only differences are the size of the input block and the size of the message digest, which is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">digest</span><span class="o">&lt;</span><span class="mi">136</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">136</span><span class="p">;</span> <span class="c1">// ( 1600 - 2 * 256 ) / 8 =&gt; 136</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise, all other operations and constants are identical.</p>
</div>
<div class="paragraph">
<p>The message digest is similarly extended by repeated <code>result()</code> calls and any calls to <code>update()</code> reset the finalization process.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ref_ripemd"><a class="anchor" href="#ref_ripemd"></a>&lt;boost/hash2/ripemd.hpp&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/hmac.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/digest.hpp&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">ripemd_160</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ripemd_128</span><span class="p">;</span>

<span class="k">using</span> <span class="n">hmac_ripemd_160</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">&lt;</span><span class="n">ripemd_160</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">hmac_ripemd_128</span> <span class="o">=</span> <span class="n">hmac</span><span class="o">&lt;</span><span class="n">ripemd_128</span><span class="o">&gt;</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This header implements the <a href="https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf">RIPEMD-160 and RIPEMD-128</a> algorithms.</p>
</div>
<div class="sect4">
<h5 id="ref_ripemd_ripemd_160"><a class="anchor" href="#ref_ripemd_ripemd_160"></a>ripemd_160</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">class</span> <span class="nc">ripemd_160</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">digest</span><span class="o">&lt;</span><span class="mi">20</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">ripemd_160</span><span class="p">();</span>
    <span class="k">explicit</span> <span class="k">constexpr</span> <span class="n">ripemd_160</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span>
    <span class="n">ripemd_160</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="n">ripemd_160</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span> <span class="o">*</span> <span class="n">pv</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>

    <span class="k">constexpr</span> <span class="n">result_type</span> <span class="n">result</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="ref_ripemd_constructors"><a class="anchor" href="#ref_ripemd_constructors"></a>Constructors</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="nf">ripemd_160</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Default constructor.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the internal state of the RIPEMD-160 algorithm to its initial values.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="k">constexpr</span> <span class="nf">ripemd_160</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint64_t</span> <span class="n">seed</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking an integer seed value.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, then if <code>seed</code> is not zero, performs <code>update(p, 8); result();</code> where <code>p</code> points to a little-endian representation of the value of <code>seed</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>seed</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">ripemd_160</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="nf">ripemd_160</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructor taking a byte sequence seed.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the state as if by default construction, then if <code>n</code> is not zero, performs <code>update(p, n); result()</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>By convention, if <code>n</code> is zero, the effect of this constructor is the same as default construction.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_ripemd_update"><a class="anchor" href="#ref_ripemd_update"></a>update</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Updates the internal state of the RIPEMD-160 algorithm from the byte sequence <code>[p, p+n)</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Consecutive calls to <code>update</code> are equivalent to a single call with the concatenated byte sequences of the individual calls.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_ripemd_result"><a class="anchor" href="#ref_ripemd_result"></a>result</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">result_type</span> <span class="nf">result</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Pads the accumulated message and finalizes the RIPEMD-160 digest.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The RIPEMD-160 digest of the message formed from the byte sequences of the preceding calls to <code>update</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>Repeated calls to <code>result()</code> return a pseudorandom sequence of <code>result_type</code> values, effectively extending the output.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect4">
<h5 id="ref_ripemd_ripemd_128"><a class="anchor" href="#ref_ripemd_ripemd_128"></a>ripemd_128</h5>
<div class="paragraph">
<p>The RIPEMD-128 algorithm is identical to the RIPEMD-160 algorithm described above.</p>
</div>
<div class="paragraph">
<p>The only differences are the number of rounds used and the size of the message digest, which is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">digest</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise, all other operations and constants are identical.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ref_utilities_and_traits"><a class="anchor" href="#ref_utilities_and_traits"></a>Utilities and Traits</h3>
<div class="sect3">
<h4 id="ref_digest"><a class="anchor" href="#ref_digest"></a>&lt;boost/hash2/digest.hpp&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">digest</span>
<span class="p">{</span>
<span class="nl">private:</span> <span class="c1">// exposition only</span>

    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data_</span><span class="p">[</span> <span class="n">N</span> <span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>

<span class="k">public</span><span class="o">:</span>

    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">reference</span> <span class="o">=</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&amp;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">const_reference</span> <span class="o">=</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">iterator</span> <span class="o">=</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">const_iterator</span> <span class="o">=</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">difference_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span><span class="p">;</span>

    <span class="c1">// constructors</span>

    <span class="k">constexpr</span> <span class="n">digest</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="n">digest</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">)[</span> <span class="n">N</span> <span class="p">]</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="c1">// copy</span>

    <span class="k">constexpr</span> <span class="n">digest</span><span class="p">(</span> <span class="n">digest</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="n">digest</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">digest</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="c1">// iteration</span>

    <span class="k">constexpr</span> <span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="c1">// data, size</span>

    <span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="c1">// element access</span>

    <span class="k">constexpr</span> <span class="n">reference</span> <span class="k">operator</span><span class="p">[](</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="p">);</span>
    <span class="k">constexpr</span> <span class="n">const_reference</span> <span class="k">operator</span><span class="p">[](</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">reference</span> <span class="n">front</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="n">const_reference</span> <span class="n">front</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="n">reference</span> <span class="n">back</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="n">const_reference</span> <span class="n">back</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// comparisons</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">digest</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">digest</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">b</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span> <span class="n">digest</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">digest</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">b</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// to_chars</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">char</span><span class="o">*</span> <span class="n">to_chars</span><span class="p">(</span> <span class="n">digest</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">first</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">last</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">M</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="n">to_chars</span><span class="p">(</span> <span class="n">digest</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="p">)[</span> <span class="n">M</span> <span class="p">]</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="c1">// operator&lt;&lt;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">digest</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">);</span>

<span class="c1">// to_string</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">to_string</span><span class="p">(</span> <span class="n">digest</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">);</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="ref_digest_digest"><a class="anchor" href="#ref_digest_digest"></a>digest</h5>
<div class="paragraph">
<p><code>digest&lt;N&gt;</code> is a <code>constexpr</code>-friendly class template similar to <code>std::array&lt;unsigned char, N&gt;</code>.
It is used to store the resulting message digest of hash algorithms such as SHA2-256 or RIPEMD-160.</p>
</div>
<div class="sect5">
<h6 id="ref_digest_constructors"><a class="anchor" href="#ref_digest_constructors"></a>Constructors</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">digest</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Zero-initializes <code>data_</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">digest</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">)[</span> <span class="n">N</span> <span class="p">]</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Initializes the elements of <code>data_</code> from the corresponding elements of <code>v</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_digest_iteration"><a class="anchor" href="#ref_digest_iteration"></a>Iteration</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>data_</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>data_ + N</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_digest_accessors"><a class="anchor" href="#ref_digest_accessors"></a>Accessors</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>data_</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>N</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_digest_element_access"><a class="anchor" href="#ref_digest_element_access"></a>Element Access</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">reference</span> <span class="k">operator</span><span class="p">[](</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="p">);</span>
<span class="k">constexpr</span> <span class="n">const_reference</span> <span class="k">operator</span><span class="p">[](</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requires: </dt>
<dd>
<p><code>i &lt; size()</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>data_[ i ]</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">reference</span> <span class="n">front</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="n">const_reference</span> <span class="n">front</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>data_[ 0 ]</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">constexpr</span> <span class="n">reference</span> <span class="n">back</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="n">const_reference</span> <span class="n">back</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>data_[ N-1 ]</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_digest_comparisons"><a class="anchor" href="#ref_digest_comparisons"></a>Comparisons</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">digest</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">digest</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">b</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>true</code> when the elements of <code>a.data_</code> are equal to the corresponding elements of <code>b.data_</code>, <code>false</code> otherwise.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span> <span class="n">digest</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">digest</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">b</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>!(a == b)</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="ref_digest_formatting"><a class="anchor" href="#ref_digest_formatting"></a>Formatting</h6>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">char</span><span class="o">*</span> <span class="n">to_chars</span><span class="p">(</span> <span class="n">digest</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">first</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">last</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Writes the contents of <code>data_</code> as a hexadecimal string to the provided output range <code>[first, last)</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A pointer one past the end of the generated output, or <code>nullptr</code> if <code>[first, last)</code> is not large enough.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">M</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="n">to_chars</span><span class="p">(</span> <span class="n">digest</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="p">)[</span> <span class="n">M</span> <span class="p">]</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requires: </dt>
<dd>
<p><code>M &gt;= N*2 + 1</code>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Writes the contents of <code>data_</code> as a hexadecimal string, then a null terminator, to the provided output buffer <code>w</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">digest</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Writes the contents of <code>data_</code> as a hexadecimal string to <code>os</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>os</code>.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">to_string</span><span class="p">(</span> <span class="n">digest</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A string containing the contents of <code>data_</code> in hexadecimal format.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ref_endian"><a class="anchor" href="#ref_endian"></a>&lt;boost/hash2/endian.hpp&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">endian</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="ref_endian_endian"><a class="anchor" href="#ref_endian_endian"></a>endian</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">endian</span>
<span class="p">{</span>
    <span class="n">little</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">,</span>
    <span class="n">big</span> <span class="o">=</span> <span class="cm">/*...*/</span><span class="p">,</span>
    <span class="n">native</span> <span class="o">=</span> <span class="cm">/*little or big*/</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The enumeration type <code>endian</code> corresponds to the standard
<code>std::endian</code> type from C&#43;&#43;20. Its values are <code>little</code>,
signifying little-endian byte order, <code>big</code>, signifying
big-endian byte order, and <code>native</code>, which equals either
<code>little</code> or <code>big</code> depending on whether the current platform
is little- or big-endian.</p>
</div>
<div class="paragraph">
<p>Unlike <code>std::endian</code>, platforms where <code>little</code> equals <code>big</code>,
or where <code>native</code> equals neither <code>little</code> or <code>big</code>, aren&#8217;t
supported.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ref_flavor"><a class="anchor" href="#ref_flavor"></a>&lt;boost/hash2/flavor.hpp&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/endian.hpp&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">struct</span> <span class="nc">default_flavor</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">little_endian_flavor</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">big_endian_flavor</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The header <code>boost/hash2/flavor.hpp</code> contains the predefined <em>flavor</em> types.</p>
</div>
<div class="paragraph">
<p>(A <em>flavor</em> is passed as the second argument to <code>hash_append</code> in order to influence its behavior.)</p>
</div>
<div class="paragraph">
<p>Flavor types have two members, a type <code>size_type</code> and a value <code>byte_order</code> of type <code>boost::hash2::endian</code>.</p>
</div>
<div class="paragraph">
<p><code>size_type</code> controls how the argument of <code>hash_append_size</code> is treated (it&#8217;s converted to <code>size_type</code> before hashing.)</p>
</div>
<div class="paragraph">
<p><code>byte_order</code> controls the endianness that is used to hash scalar types.</p>
</div>
<div class="sect4">
<h5 id="ref_flavor_default_flavor"><a class="anchor" href="#ref_flavor_default_flavor"></a>default_flavor</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">default_flavor</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">byte_order</span> <span class="o">=</span> <span class="n">endian</span><span class="o">::</span><span class="n">native</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>default_flavor</code> requests native, endian-dependent, hashing of scalar types.
This makes the hash values dependent on the endianness of the current platform, but has the potential of being substantially faster if large arrays of scalar types are being passed to <code>hash_append</code>.</p>
</div>
<div class="paragraph">
<p>There is rarely a need to use <code>default_flavor</code> explicitly, because it&#8217;s default when no flavor is given to <code>hash_append</code>, like so: <code>hash_append( h, {}, v );</code></p>
</div>
</div>
<div class="sect4">
<h5 id="ref_flavor_little_endian_flavor"><a class="anchor" href="#ref_flavor_little_endian_flavor"></a>little_endian_flavor</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">little_endian_flavor</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">byte_order</span> <span class="o">=</span> <span class="n">endian</span><span class="o">::</span><span class="n">little</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>little_endian_flavor</code> requests little endian hashing of scalar types.
This makes the hash values independent of the endianness of the underlying platform.
However, if the platform is big endian, <code>hash_append</code> will be slower because it will need to convert scalar types to little endian.</p>
</div>
</div>
<div class="sect4">
<h5 id="ref_flavor_big_endian_flavor"><a class="anchor" href="#ref_flavor_big_endian_flavor"></a>big_endian_flavor</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">big_endian_flavor</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">byte_order</span> <span class="o">=</span> <span class="n">endian</span><span class="o">::</span><span class="n">big</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>big_endian_flavor</code> requests big endian hashing of scalar types.
This makes the hash values independent of the endianness of the underlying platform.
However, if the platform is little endian, which is very likely, <code>hash_append</code> will be slower because it will need to convert scalar types to big endian.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ref_get_integral_result"><a class="anchor" href="#ref_get_integral_result"></a>&lt;boost/hash2/get_integral_result.hpp&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">&gt;</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="n">get_integral_result</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span> <span class="p">);</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="ref_get_integral_result_get_integral_result"><a class="anchor" href="#ref_get_integral_result_get_integral_result"></a>get_integral_result</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">&gt;</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="nf">get_integral_result</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requires: </dt>
<dd>
<p><code>T</code> must be an integral type that is not <code>bool</code>.
<code>Hash</code> must be a <em>hash algorithm</em>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Calls <code>h.result()</code> one or more times.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A value that is derived from the return values of the <code>h.result()</code> calls in a way that is approximately uniformly distributed over the possible values of <code>T</code>.</p>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>When <code>Hash::result_type</code> is an array-like type, <code>get_integral_result</code> is allowed to assume that <code>Hash</code> is a high quality hash algorithm and that therefore the values of <code>h.result()</code> are uniformly distributed over the entire domain of <code>Hash::result_type</code>.</p>
</dd>
<dt class="hdlist1">Example: </dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">my_hash</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">st</span> <span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="n">Hash</span> <span class="n">hash</span><span class="p">;</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">hash</span><span class="p">,</span> <span class="p">{},</span> <span class="n">st</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">get_integral_result</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">hash</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ref_is_trivially_equality_comparable"><a class="anchor" href="#ref_is_trivially_equality_comparable"></a>&lt;boost/hash2/is_trivially_equality_comparable.hpp&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">is_trivially_equality_comparable</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="ref_is_trivially_equality_comparable_is_trivially_equality_comparable"><a class="anchor" href="#ref_is_trivially_equality_comparable_is_trivially_equality_comparable"></a>is_trivially_equality_comparable</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">is_trivially_equality_comparable</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span> <span class="kt">bool</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">is_enum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">is_pointer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&gt;</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">is_trivially_equality_comparable</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">const</span><span class="o">&gt;:</span>
  <span class="n">is_trivially_equality_comparable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The trait <code>is_trivially_equality_comparable</code> is used by the library to detect types that are <em>trivially equality comparable</em>.</p>
</div>
<div class="paragraph">
<p>A type is <em>trivially equality comparable</em> if, for two values <code>x</code> and <code>y</code> of that type, <code>x == y</code> is equivalent to <code>std::memcmp( &amp;x, &amp;y, sizeof(x) ) == 0</code>.</p>
</div>
<div class="paragraph">
<p>That is, for trivially equality comparable types, comparing their values is the same as comparing their storage byte representations.</p>
</div>
<div class="paragraph">
<p>This allows <code>hash_append</code> to assume that the <em>message</em> identifying an object&#8217;s value is the same as the storage bytes of the object.</p>
</div>
<div class="paragraph">
<p><code>is_trivially_equality_comparable</code> can be specialized for user-defined types if the default implementation does not give the correct result.</p>
</div>
<div class="paragraph">
<p>For example, for the following type</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">X</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">X</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x1</span><span class="p">,</span> <span class="n">X</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x2</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">x1</span><span class="p">.</span><span class="n">v</span> <span class="o">==</span> <span class="n">x2</span><span class="p">.</span><span class="n">v</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>(under the assumption that it has no padding bytes, that is, <code>sizeof(X) == sizeof(int)</code>)
<code>is_trivially_equality_comparable&lt;X&gt;::value</code> will be <code>false</code> by default, but the type meets the requirements for being trivially equality comparable, so a specialization can be added:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">is_trivially_equality_comparable</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>or, if you want to be on the safe side,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">is_trivially_equality_comparable</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>On the other hand, the following type</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">enum</span> <span class="n">E</span><span class="o">:</span> <span class="kt">unsigned</span> <span class="p">{};</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">E</span> <span class="n">e1</span><span class="p">,</span> <span class="n">E</span> <span class="n">e2</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">e1</span> <span class="o">%</span> <span class="mi">256</span> <span class="o">==</span> <span class="n">e2</span> <span class="o">%</span> <span class="mi">256</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>is not trivially equality comparable (because <code>(E)0x204 == (E)0x704</code>, but <code>memcmp</code> will give a nonzero result), but <code>is_trivially_equality_comparable&lt;E&gt;::value</code> will be <code>true</code> by default.</p>
</div>
<div class="paragraph">
<p>In this (quite rare) case, a specialization can be added to report <code>false</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">is_trivially_equality_comparable</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="p">{};</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ref_is_endian_independent"><a class="anchor" href="#ref_is_endian_independent"></a>&lt;boost/hash2/is_endian_independent.hpp&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">is_endian_independent</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="ref_is_endian_independent_is_endian_independent"><a class="anchor" href="#ref_is_endian_independent_is_endian_independent"></a>is_endian_independent</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">is_endian_independent</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span> <span class="kt">bool</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&gt;</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">is_endian_independent</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">const</span><span class="o">&gt;:</span>
    <span class="n">is_endian_independent</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The trait <code>is_endian_independent</code> is used by the library to detect <em>endian-independent</em> types.</p>
</div>
<div class="paragraph">
<p>A type is <em>endian-independent</em> if its memory representation is the same on little-endian and big-endian platforms.</p>
</div>
<div class="paragraph">
<p>This includes all single byte types (with a <code>sizeof</code> of 1) and all types whose constituent members are also endian-independent.</p>
</div>
<div class="paragraph">
<p>The default implementation of the trait only reports <code>true</code> for single byte types. It can be specialized for endian independent user-defined types.</p>
</div>
<div class="paragraph">
<p>For example, the following type</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">X</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>is endian-independent, and <code>is_endian_independent</code> can be specialized appropriately for it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">is_endian_independent</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{};</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ref_is_contiguously_hashable"><a class="anchor" href="#ref_is_contiguously_hashable"></a>&lt;boost/hash2/is_contiguously_hashable.hpp&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/endian.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/is_trivially_equality_comparable.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/is_endian_independent.hpp&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">endian</span> <span class="n">E</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">is_contiguously_hashable</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="ref_is_contiguously_hashable_is_contiguously_hashable"><a class="anchor" href="#ref_is_contiguously_hashable_is_contiguously_hashable"></a>is_contiguously_hashable</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">endian</span> <span class="n">E</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">is_contiguously_hashable</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span>
    <span class="n">is_trivially_equality_comparable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
      <span class="p">(</span><span class="n">E</span> <span class="o">==</span> <span class="n">endian</span><span class="o">::</span><span class="n">native</span> <span class="o">||</span> <span class="n">is_endian_independent</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">,</span> <span class="n">endian</span> <span class="n">E</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">is_contiguously_hashable</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">E</span><span class="o">&gt;:</span>
  <span class="n">is_contiguously_hashable</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The trait <code>is_contiguously_hashable</code> is used by the library to detect <em>contiguously hashable</em> types.</p>
</div>
<div class="paragraph">
<p>A type is <em>contiguously hashable</em> under a particular byte order <code>E</code> if the <em>message</em> that would have been produced for the type if it weren&#8217;t considered <em>contiguously hashable</em> is the same as its underlying storage byte representation.</p>
</div>
<div class="paragraph">
<p><code>hash_append(hash, flavor, value)</code>, when the type of <code>value</code> is <em>contiguously hashable</em> under the byte order requested by <code>flavor</code> (<code>decltype(flavor)::byte_order</code>), issues a single call to <code>hash.update(&amp;value, sizeof(value))</code> as an optimization.</p>
</div>
<div class="paragraph">
<p><code>is_contiguously_hashable</code> is not intended to be specialized for user-defined types. Its implementation relies on <code>is_trivially_equality_comparable</code> and <code>is_endian_independent</code>, and is correct as long as those underlying traits are correct.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ref_has_constant_size"><a class="anchor" href="#ref_has_constant_size"></a>&lt;boost/hash2/has_constant_size.hpp&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">has_constant_size</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="ref_has_constant_size_has_constant_size"><a class="anchor" href="#ref_has_constant_size_has_constant_size"></a>has_constant_size</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">has_constant_size</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="cm">/*see below*/</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">has_constant_size</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">const</span><span class="o">&gt;:</span> <span class="n">has_constant_size</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The trait <code>has_constant_size</code> is used by the library to detect container and range types that have a constant size.
This allows <code>hash_append</code> to not include the size in the <em>message</em>, as it doesn&#8217;t contribute to the object state.</p>
</div>
<div class="paragraph">
<p>A container or range type has constant size if for all values <code>v</code> of that type, <code>v.size()</code> has the same value.</p>
</div>
<div class="paragraph">
<p>The default implementation reports <code>true</code> for tuple-like types (those for which <code>std::tuple_size</code> is specialized), such as <code>std::array</code>, for <code>boost::array</code>, and for <code>digest</code>.</p>
</div>
<div class="paragraph">
<p><code>has_constant_size</code> can be specialized for user-defined container and range types that have constant size.</p>
</div>
<div class="paragraph">
<p>For example, <code>boost::uuids::uuid</code> has a constant size of 16, so a specialization can be added appropriately:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">has_constant_size</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">uuids</span><span class="o">::</span><span class="n">uuid</span><span class="o">&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{};</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ref_hashing_cpp_objects"><a class="anchor" href="#ref_hashing_cpp_objects"></a>Hashing C&#43;&#43; Objects</h3>
<div class="sect3">
<h4 id="ref_hash_append_fwd"><a class="anchor" href="#ref_hash_append_fwd"></a>&lt;boost/hash2/hash_append_fwd.hpp&gt;</h4>
<div class="sect4">
<h5 id="ref_hash_append_fwd_synopsis"><a class="anchor" href="#ref_hash_append_fwd_synopsis"></a>Synopsis</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="n">hash_append</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">It</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="n">hash_append_range</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span> <span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="n">hash_append_size</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">It</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="n">hash_append_range_and_size</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span> <span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">It</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="n">hash_append_unordered_range</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span> <span class="p">);</span>

<span class="k">struct</span> <span class="nc">hash_append_tag</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The header <code>boost/hash2/hash_append_fwd.hpp</code> declares the functions implemented in <code>boost/hash2/hash_append.hpp</code>.</p>
</div>
<div class="paragraph">
<p>It can be used when code wishes to implement <code>hash_append</code> support for a user-defined type without physically depending on the implementation of <code>hash_append</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="ref_hash_append_fwd_examples"><a class="anchor" href="#ref_hash_append_fwd_examples"></a>Examples</h5>
<div class="listingblock">
<div class="title">X.hpp</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/hash_append_fwd.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
<span class="nl">private:</span>

    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Provider</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span><span class="p">&gt;</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">tag_invoke</span><span class="p">(</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append_tag</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Provider</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span>
        <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">X</span> <span class="k">const</span><span class="o">*</span> <span class="n">v</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">a</span> <span class="p">);</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">b</span> <span class="p">);</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>

    <span class="n">X</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">main.cpp</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">"X.hpp"</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/hash_append.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;boost/hash2/md5.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">X</span> <span class="n">x</span><span class="p">;</span>

    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">md5_128</span> <span class="n">hash</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">hash</span><span class="p">,</span> <span class="p">{},</span> <span class="n">x</span> <span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"MD5 digest of x: "</span> <span class="o">&lt;&lt;</span> <span class="n">hash</span><span class="p">.</span><span class="n">result</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note, however, that it&#8217;s possible to achieve the same effect even without including <code>&lt;boost/hash2/hash_append_fwd.hpp&gt;</code>, by using the <code>Provider</code> argument of <code>tag_invoke</code>:</p>
</div>
<div class="listingblock">
<div class="title">X.hpp</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
<span class="nl">private:</span>

    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Provider</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span><span class="p">&gt;</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">tag_invoke</span><span class="p">(</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash2</span><span class="o">::</span><span class="n">hash_append_tag</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Provider</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">pr</span><span class="p">,</span>
        <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">X</span> <span class="k">const</span><span class="o">*</span> <span class="n">v</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pr</span><span class="p">.</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">a</span> <span class="p">);</span>
        <span class="n">pr</span><span class="p">.</span><span class="n">hash_append</span><span class="p">(</span> <span class="n">h</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">b</span> <span class="p">);</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>

    <span class="n">X</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ref_hash_append"><a class="anchor" href="#ref_hash_append"></a>&lt;boost/hash2/hash_append.hpp&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;boost/hash2/flavor.hpp&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">hash2</span> <span class="p">{</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span> <span class="o">=</span> <span class="n">default_flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="n">hash_append</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span> <span class="o">=</span> <span class="n">default_flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">It</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="n">hash_append_range</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span> <span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span> <span class="o">=</span> <span class="n">default_flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="n">hash_append_size</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span> <span class="o">=</span> <span class="n">default_flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">It</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="n">hash_append_range_and_size</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span> <span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span> <span class="o">=</span> <span class="n">default_flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">It</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="n">hash_append_unordered_range</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span> <span class="p">);</span>

<span class="k">struct</span> <span class="nc">hash_append_tag</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">hash_append_provider</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace hash2</span>
<span class="p">}</span> <span class="c1">// namespace boost</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="ref_hash_append_hash_append"><a class="anchor" href="#ref_hash_append_hash_append"></a>hash_append</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span> <span class="o">=</span> <span class="n">default_flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">hash_append</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Appends the representation of <code>v</code> to the message stored in <code>h</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If <code>is_contiguously_hashable&lt;T, Flavor::byte_order&gt;::value</code> is <code>true</code>, calls <code>h.update(&amp;v, sizeof(v))</code>;</p>
</li>
<li>
<p>If <code>std::is_integral&lt;T&gt;::value</code> is <code>true</code>, obtains a byte representation of <code>v</code> in the byte order requested by <code>Flavor::byte_order</code>, then calls <code>h.update(p, n)</code> where <code>p</code> is the address of that representation and <code>n</code> is <code>sizeof(v)</code>;</p>
</li>
<li>
<p>If <code>std::is_floating_point&lt;T&gt;::value</code> is true, first replaces <code>v</code> with positive zero if it&#8217;s negative zero, then calls <code>hash_append(h, f, std::bit_cast&lt;U&gt;(v))</code>, where <code>U</code> is an unsigned integer type with the same size as <code>T</code>;</p>
</li>
<li>
<p>If <code>std::is_pointer&lt;T&gt;::value</code> is <code>true</code>, calls <code>hash_append(h, f, reinterpret_cast&lt;std::uintptr_t&gt;(v))</code>;</p>
</li>
<li>
<p>If <code>T</code> is <code>std::nullptr_t</code>, calls <code>hash_append(h, f, static_cast&lt;void*&gt;(v))</code>;</p>
</li>
<li>
<p>If <code>T</code> is an array type <code>U[N]</code>, calls <code>hash_append_range(h, f, v + 0, v + N)</code>;</p>
</li>
<li>
<p>If a suitable overload of <code>tag_invoke</code> exists for <code>T</code>, calls (unqualified) <code>tag_invoke(hash_append_tag(), hash_append_provider(), h, f, v)</code>;</p>
</li>
<li>
<p>If <code>std::is_enum&lt;T&gt;::value</code> is <code>true</code>, calls <code>hash_append(h, f, w)</code>, where <code>w</code> is <code>v</code> converted to the underlying type of <code>T</code>;</p>
</li>
<li>
<p>If <code>boost::container_hash::is_unordered_range&lt;T&gt;::value</code> is <code>true</code>, calls <code>hash_append_unordered_range(h, f, v.begin(), v.end())</code>;</p>
</li>
<li>
<p>If <code>boost::container_hash::is_contiguous_range&lt;T&gt;::value</code> is <code>true</code> and</p>
<div class="ulist">
<ul>
<li>
<p><code>has_constant_size&lt;T&gt;::value</code> is <code>true</code>, calls <code>hash_append_range(h, f, v.data(), v.data() + v.size())</code>;</p>
</li>
<li>
<p><code>has_constant_size&lt;T&gt;::value</code> is <code>false</code>, calls <code>hash_append_range_and_size(h, f, v.data(), v.data() + v.size())</code>;</p>
</li>
</ul>
</div>
</li>
<li>
<p>If <code>boost::container_hash::is_range&lt;T&gt;::value</code> is <code>true</code> and</p>
<div class="ulist">
<ul>
<li>
<p><code>has_constant_size&lt;T&gt;::value</code> is <code>true</code>, calls <code>hash_append_range(h, f, v.begin(), v.end())</code>;</p>
</li>
<li>
<p><code>has_constant_size&lt;T&gt;::value</code> is <code>false</code>, calls <code>hash_append_range_and_size(h, f, v.begin(), v.end())</code>;</p>
</li>
</ul>
</div>
</li>
<li>
<p>If <code>boost::container_hash::is_tuple_like&lt;T&gt;::value</code> is <code>true</code>, calls <code>hash_append(h, f, w)</code> for each tuple element <code>w</code>;</p>
</li>
<li>
<p>If <code>boost::container_hash::is_described_class&lt;T&gt;::value</code> is <code>true</code>, calls <code>hash_append(h, f, b)</code> for each base class subobject <code>b</code> of <code>v</code>, then <code>hash_append(h, f, m)</code> for each member subobject <code>m</code> of <code>v</code>;</p>
</li>
<li>
<p>Otherwise, the result is a compile-time error.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>In case the above description would result in no calls being made (e.g. for a range of constant size zero, or a described <code>struct</code> with no bases and members),
a call to <code>hash_append(h, f, '\x00')</code> is made to satisfy the requirement that <code>hash_append</code> always results in at least one call to <code>Hash::update</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="ref_hash_append_hash_append_range"><a class="anchor" href="#ref_hash_append_hash_append_range"></a>hash_append_range</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span> <span class="o">=</span> <span class="n">default_flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">It</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">hash_append_range</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Appends the representations of the elements of the range <code>[first, last)</code> to the message stored in <code>h</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requires: </dt>
<dd>
<p><code>It</code> must be an <em>iterator</em> type. <code>[first, last)</code> must be a valid <em>iterator range</em>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If <code>It</code> is <code>T*</code> and <code>is_contiguously_hashable&lt;T, Flavor::byte_order&gt;::value</code> is <code>true</code>, calls <code>h.update(first, (last - first) * sizeof(T));</code>.</p>
</li>
<li>
<p>Otherwise, for each element <code>v</code> in the range denoted by <code>[first, last)</code>, calls <code>hash_append(h, f, v);</code>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Remarks: </dt>
<dd>
<p>If <code>hash_append_range</code> is called in a constant expression, the contiguously hashable optimization is only applied for <code>unsigned char*</code> and <code>unsigned char const*</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="ref_hash_append_hash_append_size"><a class="anchor" href="#ref_hash_append_hash_append_size"></a>hash_append_size</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span> <span class="o">=</span> <span class="n">default_flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">hash_append_size</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Appends the representation of <code>v</code>, converted to <code>Flavor::size_type</code>, to the message stored in <code>h</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requires: </dt>
<dd>
<p><code>T</code> must be an integral type.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Equivalent to <code>hash_append(h, f, static_cast&lt;typename Flavor::size_type&gt;(v));</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="ref_hash_append_hash_append_range_and_size"><a class="anchor" href="#ref_hash_append_hash_append_range_and_size"></a>hash_append_range_and_size</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span> <span class="o">=</span> <span class="n">default_flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">It</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">hash_append_range_and_size</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Appends the representations of the elements of the range <code>[first, last)</code>, followed by the size of the range, to the message stored in <code>h</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requires: </dt>
<dd>
<p><code>It</code> must be an <em>iterator</em> type. <code>[first, last)</code> must be a valid <em>iterator range</em>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Equivalent to <code>hash_append_range(h, f, first, last); hash_append(h, f, m);</code>, where <code>m</code> is <code>std::distance(first, last)</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="ref_hash_append_hash_append_unordered_range"><a class="anchor" href="#ref_hash_append_hash_append_unordered_range"></a>hash_append_unordered_range</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span> <span class="o">=</span> <span class="n">default_flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">It</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">hash_append_unordered_range</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs a value from the representations of the elements of the range <code>[first, last)</code>, in a way such that their order doesn&#8217;t affect the result, then appends that value, followed by the size of the range, to the message stored in <code>h</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requires: </dt>
<dd>
<p><code>It</code> must be an <em>iterator</em> type. <code>[first, last)</code> must be a valid <em>iterator range</em>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="paragraph">
<p>For each element <code>v</code> in the range denoted by <code>[first, last)</code>, obtains a hash value <code>r</code> by doing</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">Hash</span> <span class="nf">h2</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
<span class="n">hash_append</span><span class="p">(</span><span class="n">h2</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">h2</span><span class="p">.</span><span class="n">result</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>and then combines the so obtained <code>r</code> values in a way that is not sensitive to their order, producing a combined value <code>q</code>. Calls <code>hash_append(h, f, q)</code>, followed by <code>hash_append(h, f, m)</code>, where <code>m</code> is <code>std::distance(first, last)</code>.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="ref_hash_append_hash_append_tag"><a class="anchor" href="#ref_hash_append_hash_append_tag"></a>hash_append_tag</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">hash_append_tag</span>
<span class="p">{</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>hash_append_tag</code> is a tag type used as the first argument of a <code>tag_invoke</code> overload to identify the <code>hash_append</code> operation.</p>
</div>
</div>
<div class="sect4">
<h5 id="ref_hash_append_hash_append_provider"><a class="anchor" href="#ref_hash_append_hash_append_provider"></a>hash_append_provider</h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">hash_append_provider</span>
<span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">hash_append</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">);</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">It</span><span class="p">&gt;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">hash_append_range</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span> <span class="p">);</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">hash_append_size</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="p">);</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">It</span><span class="p">&gt;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">hash_append_range_and_size</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span>
        <span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span> <span class="p">);</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Flavor</span><span class="p">,</span> <span class="k">class</span> <span class="nc">It</span><span class="p">&gt;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">hash_append_unordered_range</span><span class="p">(</span> <span class="n">Hash</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">,</span> <span class="n">Flavor</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span>
        <span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span> <span class="p">);</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An object of type <code>hash_append_provider</code> is passed as the second argument of a <code>tag_invoke</code> overload.</p>
</div>
<div class="paragraph">
<p>All its member functions call the corresponding functions with the same names in <code>boost::hash2</code>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="copyright"><a class="anchor" href="#copyright"></a>Copyright and License</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This documentation is copyright 2020, 2024 Peter Dimov and Christian Mazakas
and is distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-04-03 11:37:18 UTC
</div>
</div>
<style>

*:not(pre)>code { background: none; color: #600000; }
:not(pre):not([class^=L])>code { background: none; color: #600000; }

</style>
</body>
</html>