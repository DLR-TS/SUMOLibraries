<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Scope guards</title>
<link rel="stylesheet" href="../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="Chapter 1. Boost.Scope">
<link rel="up" href="../index.html" title="Chapter 1. Boost.Scope">
<link rel="prev" href="install_compat.html" title="Installation and compatibility">
<link rel="next" href="unique_resource.html" title="Unique resource wrapper">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../boost.png"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="install_compat.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="unique_resource.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="scope.scope_guards"></a><a class="link" href="scope_guards.html" title="Scope guards">Scope guards</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="scope_guards.html#scope.scope_guards.conditional">Conditional scope guards:
      <code class="computeroutput"><span class="identifier">scope_exit</span></code>, <code class="computeroutput"><span class="identifier">scope_success</span></code>
      and <code class="computeroutput"><span class="identifier">scope_fail</span></code></a></span></dt>
<dt><span class="section"><a href="scope_guards.html#scope.scope_guards.condition_functions">Scope guard condition
      functions</a></span></dt>
<dt><span class="section"><a href="scope_guards.html#scope.scope_guards.unconditional">Unconditional scope
      guard: <code class="computeroutput"><span class="identifier">defer_guard</span></code></a></span></dt>
<dt><span class="section"><a href="scope_guards.html#scope.scope_guards.capture_by_reference_caveats">Caveats
      of capturing by reference</a></span></dt>
<dt><span class="section"><a href="scope_guards.html#scope.scope_guards.runtime_defined">Setting up scope
      exit actions at run time</a></span></dt>
<dt><span class="section"><a href="scope_guards.html#scope.scope_guards.comparison_with_boost_scope_exit">Comparison
      with Boost.ScopeExit library</a></span></dt>
<dt><span class="section"><a href="scope_guards.html#scope.scope_guards.comparison_with_library_fundamentals_ts">Comparison
      with scope guards defined in C++ Extensions for Library Fundamentals</a></span></dt>
</dl></div>
<p>
      A scope guard is an object that invokes an arbitrary <span class="emphasis"><em>action</em></span>
      function object on destruction. Scope guards are useful for implementing actions
      that need to be reliably performed upon control leaving an execution scope
      (for example, when returning from a function), which is especially helpful
      for handling exceptions.
    </p>
<p>
      The wrapped action function object is specified on the scope guard construction
      and cannot be changed afterwards. Its type must be one of:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          a user-defined class with a public <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> taking no arguments, or
        </li>
<li class="listitem">
          an lvalue reference to such class, or
        </li>
<li class="listitem">
          an lvalue reference or pointer to a function taking no arguments.
        </li>
</ul></div>
<p>
      Note that if the wrapped function is a reference to a function object, that
      object must be stored externally to the scope guard and must remain valid for
      the entire lifetime of the scope guard.
    </p>
<p>
      Some scope guards also support specifying an additional <span class="emphasis"><em>condition</em></span>
      function object, which allows for customizing the conditions in which the action
      function object must be called. Condition function objects are discussed in
      more detail in a <a class="link" href="scope_guards.html#scope.scope_guards.condition_functions" title="Scope guard condition functions">later
      section</a>.
    </p>
<p>
      Boost.Scope provides four kinds of scope guards, differing in their features
      and conditions upon which the action function object is called, summarised
      in the table below.
    </p>
<div class="table">
<a name="scope.scope_guards.scope_guard_comparison"></a><p class="title"><b>Table 1.2. Scope guard comparison</b></p>
<div class="table-contents"><table class="table" summary="Scope guard comparison">
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Feature
              </p>
            </th>
<th>
              <p>
                <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>
              </p>
            </th>
<th>
              <p>
                <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__success.html" title="Class template scope_success">scope_success</a></code>
              </p>
            </th>
<th>
              <p>
                <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code>
              </p>
            </th>
<th>
              <p>
                <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1defer__guard.html" title="Class template defer_guard">defer_guard</a></code>
              </p>
            </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                Supports a condition function?
              </p>
            </td>
<td>
              <p>
                Yes
              </p>
            </td>
<td>
              <p>
                Yes
              </p>
            </td>
<td>
              <p>
                Yes
              </p>
            </td>
<td>
              <p>
                No
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Invokes action on normal scope exit?
              </p>
            </td>
<td>
              <p>
                Yes, by default. Depends on condition.
              </p>
            </td>
<td>
              <p>
                Yes
              </p>
            </td>
<td>
              <p>
                No
              </p>
            </td>
<td>
              <p>
                Yes
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Invokes action on scope exit due to failure?
              </p>
            </td>
<td>
              <p>
                Yes, by default. Depends on condition.
              </p>
            </td>
<td>
              <p>
                No
              </p>
            </td>
<td>
              <p>
                Yes
              </p>
            </td>
<td>
              <p>
                Yes
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Action may throw?
              </p>
            </td>
<td>
              <p>
                Yes, by default. Depends on condition.
              </p>
            </td>
<td>
              <p>
                Typically yes
              </p>
            </td>
<td>
              <p>
                Typically no
              </p>
            </td>
<td>
              <p>
                Yes
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Can be (de)activated?
              </p>
            </td>
<td>
              <p>
                Yes
              </p>
            </td>
<td>
              <p>
                Yes
              </p>
            </td>
<td>
              <p>
                Yes
              </p>
            </td>
<td>
              <p>
                No
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Move-constructible? (requires function objects to be move-constructible)
              </p>
            </td>
<td>
              <p>
                Yes
              </p>
            </td>
<td>
              <p>
                Yes
              </p>
            </td>
<td>
              <p>
                Yes
              </p>
            </td>
<td>
              <p>
                No
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Has factory function? (C++11-friendly)
              </p>
            </td>
<td>
              <p>
                Yes
              </p>
            </td>
<td>
              <p>
                Yes
              </p>
            </td>
<td>
              <p>
                Yes
              </p>
            </td>
<td>
              <p>
                No
              </p>
            </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
      In the table above, the term "failure" is used broadly. What constitutes
      a failure in a given context is specified by user in the form of the condition
      function object. Most often, a thrown exception is taken as an indication of
      a failure, but it can be changed to, for example, a check for an error code
      that is being returned from the enclosing function.
    </p>
<p>
      For <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>, there
      is no notion of "success" or "failure". Rather, the scope
      guard invokes the action function object if the condition returns <code class="computeroutput"><span class="keyword">true</span></code>. By default, if the condition function
      object is not specified by user, the scope guard operates as if the condition
      always returns <code class="computeroutput"><span class="keyword">true</span></code>, which means,
      for example, that it will invoke the action whether the control leaves the
      scope normally or due to an exception.
    </p>
<p>
      Although it is possible to specify arbitrary condition function objects, the
      intended use case for <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__success.html" title="Class template scope_success">scope_success</a></code>
      is to invoke its action when the scope is left normally (i.e. not because of
      a failure) and for <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code>
      - to invoke its action to handle errors, including exceptions. For this reason,
      action functions that are used with <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code>
      are typically not allowed to throw, as this may cause the program to terminate.
      This is also a concern with other scope guards, such as <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>
      and <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1defer__guard.html" title="Class template defer_guard">defer_guard</a></code>, which
      also may invoke their actions due to an exception. It is user's responsibility
      to ensure that scope guard actions don't throw if another exception is being
      propagated. Generally, it is recommended to use scope guards to implement actions
      that cannot throw and move all operations that may fail to the normal code
      flow.
    </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="scope.scope_guards.conditional"></a><a class="link" href="scope_guards.html#scope.scope_guards.conditional" title="Conditional scope guards: scope_exit, scope_success and scope_fail">Conditional scope guards:
      <code class="computeroutput"><span class="identifier">scope_exit</span></code>, <code class="computeroutput"><span class="identifier">scope_success</span></code>
      and <code class="computeroutput"><span class="identifier">scope_fail</span></code></a>
</h3></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><code class="computeroutput"><a class="link" href="../reference.html#doxygen.reference.scope__exit_8hpp" title="Header &lt;boost/scope/scope_exit.hpp&gt;">boost/scope/scope_exit.hpp</a></code><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><code class="computeroutput"><a class="link" href="../reference.html#doxygen.reference.scope__success_8hpp" title="Header &lt;boost/scope/scope_success.hpp&gt;">boost/scope/scope_success.hpp</a></code><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><code class="computeroutput"><a class="link" href="../reference.html#doxygen.reference.scope__fail_8hpp" title="Header &lt;boost/scope/scope_fail.hpp&gt;">boost/scope/scope_fail.hpp</a></code><span class="special">&gt;</span>
</pre>
<p>
        The <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>, <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__success.html" title="Class template scope_success">scope_success</a></code>, and <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code> scope guards have a
        lot of similarities in interfaces and capabilities and differ in conditions
        when they invoke the action function object. As shown in the table above,
        these scope guards support specifying an additional condition function object.
        By default, <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__success.html" title="Class template scope_success">scope_success</a></code>
        will invoke its action if it is destroyed normally, <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code>
        - if it is destroyed due to an exception being thrown. <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>
        by default operates as if the condition always allows executing the action.
      </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../../../doc/src/images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
          Condition function objects will be discussed in more detail in the <a class="link" href="scope_guards.html#scope.scope_guards.condition_functions" title="Scope guard condition functions">next</a> section. Note
          that there are caveats with detecting whether an exception has been thrown,
          also discussed in the next section.
        </p></td></tr>
</table></div>
<p>
        Given the different default condition function objects, the different scope
        guard types are typically useful for different purposes:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code> is useful
            for general cleanup tasks, which need to be performed regardless of success
            or failure of the enclosing function.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__success.html" title="Class template scope_success">scope_success</a></code>
            can be used for common finalization code that needs to be performed on
            successful completion of the function.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code> is intended
            for handling errors, for example, to revert a partially complete operation
            to the previous valid state.
          </li>
</ul></div>
<p>
        All scope guards are especially useful if there are multiple return points
        (both normal and via exception), and when the scope guard action is not easy
        to extract as a function.
      </p>
<p>
        Let's consider an example of a class that receives network requests, validates
        them and passes to session objects to which each request corresponds. After
        receiving a request, the class must send a response - either a successful
        one, with the results of processing the request, or an error.
      </p>
<pre class="programlisting"><span class="comment">// A network request receiver</span>
<span class="keyword">class</span> <span class="identifier">receiver</span>
<span class="special">{</span>
    <span class="comment">// A network connection</span>
    <span class="identifier">connection</span> <span class="identifier">m_conn</span><span class="special">;</span>
    <span class="comment">// A collection of sessions, searchable by session id</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="identifier">session</span> <span class="special">&gt;</span> <span class="identifier">m_sessions</span><span class="special">;</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// Processes a network request and sends a response</span>
    <span class="keyword">void</span> <span class="identifier">process_request</span><span class="special">(</span><span class="identifier">request</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">req</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">const</span> <span class="keyword">auto</span> <span class="identifier">start_time</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">steady_clock</span><span class="special">::</span><span class="identifier">now</span><span class="special">();</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">time_guard</span><span class="special">([</span><span class="identifier">start_time</span><span class="special">]</span>
        <span class="special">{</span>
            <span class="comment">// Log the amount of time it took to process the request</span>
            <span class="keyword">const</span> <span class="keyword">auto</span> <span class="identifier">finish_time</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">steady_clock</span><span class="special">::</span><span class="identifier">now</span><span class="special">();</span>

            <span class="identifier">std</span><span class="special">::</span><span class="identifier">clog</span> <span class="special">&lt;&lt;</span> <span class="string">"Request processed in "</span>
                <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration_cast</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">milliseconds</span> <span class="special">&gt;(</span><span class="identifier">finish_time</span> <span class="special">-</span> <span class="identifier">start_time</span><span class="special">).</span><span class="identifier">count</span><span class="special">()</span>
                <span class="special">&lt;&lt;</span> <span class="string">" ms"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="special">});</span>

        <span class="identifier">response</span> <span class="identifier">resp</span><span class="special">;</span>

        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_fail</span> <span class="identifier">failure_guard</span><span class="special">([&amp;]</span>
        <span class="special">{</span>
            <span class="comment">// Disconnect in case of exceptions</span>
            <span class="identifier">m_conn</span><span class="special">.</span><span class="identifier">disconnect</span><span class="special">();</span> <span class="comment">// doesn't throw</span>
        <span class="special">});</span>

        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_success</span> <span class="identifier">success_guard</span><span class="special">([&amp;]</span>
        <span class="special">{</span>
            <span class="comment">// Send a response that was populated while processing the request</span>
            <span class="identifier">m_conn</span><span class="special">.</span><span class="identifier">send_message</span><span class="special">(</span><span class="identifier">resp</span><span class="special">);</span>
        <span class="special">});</span>

        <span class="comment">// Validate the request and populate the response based on the contents of the request</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">req</span><span class="special">.</span><span class="identifier">start_line</span><span class="special">().</span><span class="identifier">version</span> <span class="special">&gt;</span> <span class="identifier">max_supported_version</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="identifier">resp</span><span class="special">.</span><span class="identifier">start_line</span><span class="special">().</span><span class="identifier">version</span> <span class="special">=</span> <span class="identifier">max_supported_version</span><span class="special">;</span>
            <span class="identifier">resp</span><span class="special">.</span><span class="identifier">start_line</span><span class="special">().</span><span class="identifier">set_status</span><span class="special">(</span><span class="identifier">protocol_version_not_supported</span><span class="special">);</span>
            <span class="keyword">return</span><span class="special">;</span>
        <span class="special">}</span>

        <span class="identifier">resp</span><span class="special">.</span><span class="identifier">start_line</span><span class="special">().</span><span class="identifier">version</span> <span class="special">=</span> <span class="identifier">req</span><span class="special">.</span><span class="identifier">start_line</span><span class="special">().</span><span class="identifier">version</span><span class="special">;</span>

        <span class="keyword">auto</span> <span class="identifier">it_cseq</span> <span class="special">=</span> <span class="identifier">req</span><span class="special">.</span><span class="identifier">headers</span><span class="special">().</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">cseq_header</span><span class="special">);</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">it_cseq</span> <span class="special">==</span> <span class="identifier">req</span><span class="special">.</span><span class="identifier">headers</span><span class="special">().</span><span class="identifier">end</span><span class="special">())</span>
        <span class="special">{</span>
            <span class="identifier">resp</span><span class="special">.</span><span class="identifier">start_line</span><span class="special">().</span><span class="identifier">set_status</span><span class="special">(</span><span class="identifier">bad_request</span><span class="special">);</span>
            <span class="identifier">resp</span><span class="special">.</span><span class="identifier">set_body</span><span class="special">(</span><span class="identifier">mime</span><span class="special">::</span><span class="identifier">text_plain</span><span class="special">,</span> <span class="string">"CSeq not specified"</span><span class="special">);</span>
            <span class="keyword">return</span><span class="special">;</span>
        <span class="special">}</span>

        <span class="identifier">resp</span><span class="special">.</span><span class="identifier">headers</span><span class="special">().</span><span class="identifier">add</span><span class="special">(</span><span class="identifier">cseq_header</span><span class="special">,</span> <span class="special">*</span><span class="identifier">it_cseq</span><span class="special">);</span>

        <span class="keyword">auto</span> <span class="identifier">it_session_id</span> <span class="special">=</span> <span class="identifier">req</span><span class="special">.</span><span class="identifier">headers</span><span class="special">().</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">session_id_header</span><span class="special">);</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">it_session_id</span> <span class="special">==</span> <span class="identifier">req</span><span class="special">.</span><span class="identifier">headers</span><span class="special">().</span><span class="identifier">end</span><span class="special">())</span>
        <span class="special">{</span>
            <span class="identifier">resp</span><span class="special">.</span><span class="identifier">start_line</span><span class="special">().</span><span class="identifier">set_status</span><span class="special">(</span><span class="identifier">bad_request</span><span class="special">);</span>
            <span class="identifier">resp</span><span class="special">.</span><span class="identifier">set_body</span><span class="special">(</span><span class="identifier">mime</span><span class="special">::</span><span class="identifier">text_plain</span><span class="special">,</span> <span class="string">"Session id not specified"</span><span class="special">);</span>
            <span class="keyword">return</span><span class="special">;</span>
        <span class="special">}</span>

        <span class="identifier">resp</span><span class="special">.</span><span class="identifier">headers</span><span class="special">().</span><span class="identifier">add</span><span class="special">(</span><span class="identifier">session_id_header</span><span class="special">,</span> <span class="special">*</span><span class="identifier">it_session_id</span><span class="special">);</span>

        <span class="comment">// Find the session to forward the request to</span>
        <span class="keyword">auto</span> <span class="identifier">it_session</span> <span class="special">=</span> <span class="identifier">m_sessions</span><span class="special">.</span><span class="identifier">find</span><span class="special">(*</span><span class="identifier">it_session_id</span><span class="special">);</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">it_session</span> <span class="special">==</span> <span class="identifier">m_sessions</span><span class="special">.</span><span class="identifier">end</span><span class="special">())</span>
        <span class="special">{</span>
            <span class="identifier">resp</span><span class="special">.</span><span class="identifier">start_line</span><span class="special">().</span><span class="identifier">set_status</span><span class="special">(</span><span class="identifier">session_not_found</span><span class="special">);</span>
            <span class="keyword">return</span><span class="special">;</span>
        <span class="special">}</span>

        <span class="comment">// Process the request in the session and complete populating the response</span>
        <span class="identifier">it_session</span><span class="special">-&gt;</span><span class="identifier">second</span><span class="special">.</span><span class="identifier">process_request</span><span class="special">(</span><span class="identifier">req</span><span class="special">,</span> <span class="identifier">resp</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
        In the example above, the scope guards automatically perform their respective
        actions regardless of the return point of the <code class="computeroutput"><span class="identifier">process_request</span></code>
        method. <code class="computeroutput"><span class="identifier">success_guard</span></code> makes
        sure the response is sent, whether it is a successful response after handling
        the request in the target session object, or one of the error responses.
        <code class="computeroutput"><span class="identifier">failure_guard</span></code> handles the
        case when the processing fails with an exception and terminates the connection
        in this case. Note that as <code class="computeroutput"><span class="identifier">failure_guard</span></code>
        is destroyed after <code class="computeroutput"><span class="identifier">success_guard</span></code>,
        it also covers errors that might occur while sending the response. Finally,
        <code class="computeroutput"><span class="identifier">time_guard</span></code> logs the time
        it took to process the request, whether successfully or with an exception,
        for diagnostic purposes.
      </p>
<p>
        Each of the scope guards described in this section supports active and inactive
        states. The action function object will only be called if the scope guard
        is in active state while being destroyed. By default, scope guards are created
        in the active state, but this can be changed by passing <code class="computeroutput"><span class="keyword">false</span></code>
        as the last argument for the constructor. Scope guards can also be deactivated
        or activated during their lifetime by calling the <code class="computeroutput"><span class="identifier">set_active</span></code>
        method. Deactivating the scope guard is often used as a way to "commit"
        the effects of the block of code between the scope guard creation and deactivation.
        Manual activation of a scope guard can sometimes be useful if the scope guard
        needs to be created before it becomes known whether the scope guard action
        needs to be executed (e.g. when the scope guard needs to be created at an
        outer scope compared to where the decision on whether it should be enabled
        is made).
      </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">collection</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span> <span class="keyword">int</span><span class="special">,</span> <span class="identifier">object</span> <span class="special">&gt;</span> <span class="identifier">objects</span><span class="special">;</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// Finds an existing object by key or creates a new one and returns a reference to it</span>
    <span class="identifier">object</span><span class="special">&amp;</span> <span class="identifier">obtain_object</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">key</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="comment">// Find the object or the position where it should be</span>
        <span class="keyword">auto</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">objects</span><span class="special">.</span><span class="identifier">lower_bound</span><span class="special">(</span><span class="identifier">key</span><span class="special">);</span>

        <span class="comment">// Create an inactive scope guard initially. Needs to be created</span>
        <span class="comment">// at this scope to cover the on_requested() call below.</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_fail</span> <span class="identifier">rollback_guard</span><span class="special">{[&amp;]</span>
        <span class="special">{</span>
            <span class="comment">// Remove the object that was just inserted</span>
            <span class="identifier">objects</span><span class="special">.</span><span class="identifier">erase</span><span class="special">(</span><span class="identifier">it</span><span class="special">);</span>
        <span class="special">},</span>
        <span class="keyword">false</span><span class="special">};</span>

        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">it</span> <span class="special">==</span> <span class="identifier">objects</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">||</span> <span class="identifier">it</span><span class="special">-&gt;</span><span class="identifier">first</span> <span class="special">!=</span> <span class="identifier">key</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="comment">// Insert a new object that correspond to the specified key</span>
            <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">objects</span><span class="special">.</span><span class="identifier">emplace_hint</span><span class="special">(</span><span class="identifier">it</span><span class="special">,</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">object</span><span class="special">{});</span>

            <span class="comment">// Activate rollback guard to revert the insertion in case of error</span>
            <span class="identifier">rollback_guard</span><span class="special">.</span><span class="identifier">set_active</span><span class="special">(</span><span class="keyword">true</span><span class="special">);</span>

            <span class="comment">// Initialize the inserted object. May throw.</span>
            <span class="identifier">it</span><span class="special">-&gt;</span><span class="identifier">second</span><span class="special">.</span><span class="identifier">initialize</span><span class="special">(*</span><span class="keyword">this</span><span class="special">,</span> <span class="identifier">key</span><span class="special">);</span>
        <span class="special">}</span>

        <span class="comment">// Notify the object that is has been requested. May throw.</span>
        <span class="identifier">it</span><span class="special">-&gt;</span><span class="identifier">second</span><span class="special">.</span><span class="identifier">on_requested</span><span class="special">();</span>

        <span class="keyword">return</span> <span class="identifier">it</span><span class="special">-&gt;</span><span class="identifier">second</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
        The code samples above rely on C++17 <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction" target="_top">class
        template argument deduction (CTAD)</a> for the scope guard types to deduce
        the function object type (which is the lambda). If this feature is not available,
        the scope guard construction can be rewritten using a factory function, like
        this:
      </p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">rollback_guard</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">make_scope_fail</span><span class="special">([&amp;]</span>
<span class="special">{</span>
    <span class="identifier">objects</span><span class="special">.</span><span class="identifier">erase</span><span class="special">(</span><span class="identifier">it</span><span class="special">);</span>
<span class="special">},</span>
<span class="keyword">false</span><span class="special">);</span>
</pre>
<p>
        Factory functions are provided for each of the three scope guards described
        in this section and are compatible with C++11. The factory functions are
        named as <code class="computeroutput"><span class="identifier">make_</span><span class="special">&lt;</span><span class="identifier">scope_guard</span><span class="special">&gt;</span></code>
        and accept the same arguments as the corresponding scope guard's constructor.
      </p>
<p>
        Scope guards described in this section are move-constructible (but not assignable),
        which requires the wrapped function objects to be move- or copy-constructible
        as well. After moving, the moved-from scope guard becomes inactive. If a
        moved-from scope guard is active on destruction, the behavior is undefined.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="scope.scope_guards.condition_functions"></a><a class="link" href="scope_guards.html#scope.scope_guards.condition_functions" title="Scope guard condition functions">Scope guard condition
      functions</a>
</h3></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><code class="computeroutput"><a class="link" href="../reference.html#doxygen.reference.exception__checker_8hpp" title="Header &lt;boost/scope/exception_checker.hpp&gt;">boost/scope/exception_checker.hpp</a></code><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><code class="computeroutput"><a class="link" href="../reference.html#doxygen.reference.error__code__checker_8hpp" title="Header &lt;boost/scope/error_code_checker.hpp&gt;">boost/scope/error_code_checker.hpp</a></code><span class="special">&gt;</span>
</pre>
<p>
        As discussed before, <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>,
        <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__success.html" title="Class template scope_success">scope_success</a></code> and
        <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code> support
        specifying an additional condition function object that will be called to
        decide whether the scope guard should invoke the action. A condition function
        object must satisfy the following requirements:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            the type of a condition function object must be one of:
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                  a user-defined class with a public <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> taking no arguments, or
                </li>
<li class="listitem">
                  an lvalue reference to such class, or
                </li>
<li class="listitem">
                  an lvalue reference or pointer to a function taking no arguments;
                </li>
</ul></div>
          </li>
<li class="listitem">
            invoking the condition function object must return a value contextually
            convertible to <code class="computeroutput"><span class="keyword">bool</span></code>, and
          </li>
<li class="listitem">
            invoking the condition function object must not throw exceptions.
          </li>
</ul></div>
<p>
        For all the three scope guards, the condition function object is optional.
        If not specified, <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>
        operates as if the condition function object always returns <code class="computeroutput"><span class="keyword">true</span></code> and will invoke its action function object
        as long as the scope guard is active. Otherwise, the scope guard only invokes
        its action if the condition returns <code class="computeroutput"><span class="keyword">true</span></code>.
      </p>
<p>
        For <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__success.html" title="Class template scope_success">scope_success</a></code>
        and <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code>, the
        <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1exception__checker.html" title="Class exception_checker">exception_checker</a></code>
        condition function is used by default. It works by capturing the number of
        uncaught exceptions on construction (which happens at the point of construction
        of the scope guard) and then comparing the captured value with the number
        of uncaught exceptions when it is called (which happens when the scope guard
        is destroyed). If the number has increased, it is taken as a sign that a
        new exception is in flight, and the predicate returns <code class="computeroutput"><span class="keyword">true</span></code>;
        otherwise, the predicate returns <code class="computeroutput"><span class="keyword">false</span></code>.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          By design, <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1exception__checker.html" title="Class exception_checker">exception_checker</a></code>
          is intended for a specific use case with scope guards created on the stack.
          It is incompatible with C++20 coroutines and similar facilities (e.g. fibers
          and userspace context switching), where the thread of execution may be
          suspended after the predicate captures the number of uncaught exceptions
          and then resumed in a different context, where the number of uncaught exceptions
          has changed. Similarly, it is incompatible with usage patterns where the
          predicate is cached after construction and is invoked after the thread
          has left the scope where the predicate was constructed (e.g. when the predicate
          or the associated scope guard is stored as a class data member or a namespace-scope
          variable).
        </p></td></tr>
</table></div>
<p>
        <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__success.html" title="Class template scope_success">scope_success</a></code> invokes
        its action when the condition returns <code class="computeroutput"><span class="keyword">false</span></code>
        (i.e. when the failure is not detected) and <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code>
        - when the condition returns <code class="computeroutput"><span class="keyword">true</span></code>
        (i.e. when the failure is detected). In relation to these two scope guard
        types, the condition function object is sometimes called the failure condition
        because it indicates whether a failure has happened.
      </p>
<p>
        You may notice that <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>
        behavior (with a user-specified condition function object) is similar to
        <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code> and opposite
        to <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__success.html" title="Class template scope_success">scope_success</a></code>
        in terms of their usage of condition function objects. The main difference
        is a semantic one: <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>
        does not have a success/failure connotation and may be used with arbitrary
        condition functions. On the other hand, <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__success.html" title="Class template scope_success">scope_success</a></code>
        and <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code> typically
        correspond to their respective intended use cases, and the default condition
        function makes them equivalent to the scope guards defined in <a href="https://cplusplus.github.io/fundamentals-ts/v3.html#scope.syn" target="_top"><code class="computeroutput"><span class="special">&lt;</span><span class="identifier">experimental</span><span class="special">/</span><span class="identifier">scope</span><span class="special">&gt;</span></code></a>.
      </p>
<p>
        It is possible to emulate each of the scope guards described in this section
        by using <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>,
        either with a custom condition function object, with the condition function
        embedded into the action function, or by activating or deactivating the scope
        guard after construction. For example, the following four pieces of code
        have the same effect:
      </p>
<div class="table">
<a name="scope.scope_guards.condition_functions.comparison_of_scope_fail_and_sco"></a><p class="title"><b>Table 1.3. Comparison of <code class="computeroutput"><span class="identifier">scope_fail</span></code>
        and <code class="computeroutput"><span class="identifier">scope_exit</span></code></b></p>
<div class="table-contents"><table class="table" summary="Comparison of scope_fail
        and scope_exit">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  <code class="computeroutput"><span class="identifier">scope_fail</span></code>
                </p>
              </th>
<th>
                <p>
                  <code class="computeroutput"><span class="identifier">scope_exit</span></code> with
                  a condition
                </p>
              </th>
<th>
                <p>
                  <code class="computeroutput"><span class="identifier">scope_exit</span></code> with
                  embedded condition
                </p>
              </th>
<th>
                <p>
                  <code class="computeroutput"><span class="identifier">scope_exit</span></code> with
                  manual deactivation
                </p>
              </th>
</tr></thead>
<tbody><tr>
<td>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">x</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;&amp;</span> <span class="identifier">vec1</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;&amp;</span> <span class="identifier">vec2</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">vec1</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span>

    <span class="comment">// Revert vec1 modification on failure</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_fail</span> <span class="identifier">rollback_guard</span><span class="special">{[&amp;]</span>
    <span class="special">{</span>
        <span class="identifier">vec1</span><span class="special">.</span><span class="identifier">pop_back</span><span class="special">();</span>
    <span class="special">}};</span>

    <span class="identifier">vec2</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span>
<span class="special">}</span>
</pre>
              </td>
<td>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">x</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;&amp;</span> <span class="identifier">vec1</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;&amp;</span> <span class="identifier">vec2</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">vec1</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span>

    <span class="comment">// Revert vec1 modification on failure</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">rollback_guard</span>
    <span class="special">{</span>
        <span class="special">[&amp;]</span> <span class="special">{</span> <span class="identifier">vec1</span><span class="special">.</span><span class="identifier">pop_back</span><span class="special">();</span> <span class="special">},</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">exception_checker</span><span class="special">()</span>
    <span class="special">};</span>

    <span class="identifier">vec2</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span>
<span class="special">}</span>
</pre>
              </td>
<td>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">x</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;&amp;</span> <span class="identifier">vec1</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;&amp;</span> <span class="identifier">vec2</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">vec1</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span>

    <span class="comment">// Revert vec1 modification on failure</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">rollback_guard</span>
    <span class="special">{</span>
        <span class="special">[&amp;,</span> <span class="identifier">uncaught_count</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">uncaught_exceptions</span><span class="special">()]</span>
        <span class="special">{</span>
            <span class="keyword">if</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">uncaught_exceptions</span><span class="special">()</span> <span class="special">&gt;</span> <span class="identifier">uncaught_count</span><span class="special">)</span>
                <span class="identifier">vec1</span><span class="special">.</span><span class="identifier">pop_back</span><span class="special">();</span>
        <span class="special">}</span>
    <span class="special">};</span>

    <span class="identifier">vec2</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span>
<span class="special">}</span>
</pre>
              </td>
<td>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">x</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;&amp;</span> <span class="identifier">vec1</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;&amp;</span> <span class="identifier">vec2</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">vec1</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span>

    <span class="comment">// Revert vec1 modification on failure</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">rollback_guard</span><span class="special">{[&amp;]</span>
    <span class="special">{</span>
        <span class="identifier">vec1</span><span class="special">.</span><span class="identifier">pop_back</span><span class="special">();</span>
    <span class="special">}};</span>

    <span class="identifier">vec2</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span>

    <span class="comment">// Commit vec1 modification</span>
    <span class="identifier">rollback_guard</span><span class="special">.</span><span class="identifier">set_active</span><span class="special">(</span><span class="keyword">false</span><span class="special">);</span>
<span class="special">}</span>
</pre>
              </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break"><p>
        The main benefit of using <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code>
        in this example is reducing code size and complexity. You can see that adding
        the check for the number of uncaught exceptions to the scope guard action
        makes it notably more verbose, and if such a check needs to be performed
        in multiple scope guards, this code would have to be duplicated. Explicitly
        deactivating the scope guard also has its downsides, as it may be prone to
        errors if it has to be performed in multiple places of the code (for example,
        when there are multiple return points, where the transaction needs to be
        committed). This goes against the intended purpose of the scope guard, as
        it was supposed to automate the correct execution of its action without the
        user having to manually ensure this at every possible point of leaving the
        scope.
      </p>
<p>
        Another benefit of <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code>
        is improved code readability. For a reader, <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code>
        immediately indicates an error handler, whereas <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>
        does not have such connotation and may contain a general cleanup code.
      </p>
<p>
        That being said, there may be reasons to still use one of the techniques
        demonstrated above instead of <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__success.html" title="Class template scope_success">scope_success</a></code>/<code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code>, especially when paired
        with <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1exception__checker.html" title="Class exception_checker">exception_checker</a></code>.
        As noted above, <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1exception__checker.html" title="Class exception_checker">exception_checker</a></code>
        is incompatible with coroutines and similar facilities, so using a manually
        managed <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>
        can be a solution. Another consideration is performance, specifically in
        relation with <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1exception__checker.html" title="Class exception_checker">exception_checker</a></code>.
        This predicate has to invoke runtime functions to obtain the number of uncaught
        exceptions, and has to do this twice - on scope guard construction and destruction.
        Although these functions are usually cheap, these calls are typically not
        optimized away by the compiler, even if no exception is thrown, and deactivating
        a scope guard is cheaper still. So, if a scope guard is used in a tight loop
        where its performance overhead may be significant, preferring <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code> with manual deactivation
        may be a reasonable choice.
      </p>
<p>
        <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>, <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__success.html" title="Class template scope_success">scope_success</a></code> and <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code> accept the condition
        function object as the second argument for the constructor or factory function,
        after the action function object. If the condition function object is default-constructible
        and the default constructor doesn't throw, the function object may be omitted
        from the scope guard constructor arguments.
      </p>
<pre class="programlisting"><span class="comment">// Writes a string to a file using a file descriptor, with file locking.</span>
<span class="comment">// Reports errors via an error_code parameter.</span>
<span class="keyword">void</span> <span class="identifier">locked_write_string</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">fd</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">str</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">&amp;</span> <span class="identifier">ec</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">err</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>

    <span class="comment">// Automatically transform errors to error_code on exit</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_fail</span> <span class="identifier">fail_guard</span>
    <span class="special">{</span>
        <span class="comment">// Action function object</span>
        <span class="special">[&amp;]</span> <span class="special">{</span> <span class="identifier">ec</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">(</span><span class="identifier">err</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">generic_category</span><span class="special">());</span> <span class="special">},</span>
        <span class="comment">// Condition function object</span>
        <span class="special">[&amp;</span><span class="identifier">err</span><span class="special">]()</span> <span class="keyword">noexcept</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">err</span> <span class="special">!=</span> <span class="number">0</span><span class="special">;</span> <span class="special">}</span>
    <span class="special">};</span>

    <span class="comment">// Performs a lock operation on the file descriptor, returns error code or 0 on success</span>
    <span class="keyword">auto</span> <span class="identifier">lock_operation</span> <span class="special">=</span> <span class="special">[</span><span class="identifier">fd</span><span class="special">](</span><span class="keyword">int</span> <span class="identifier">operation</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">while</span> <span class="special">(</span><span class="identifier">flock</span><span class="special">(</span><span class="identifier">fd</span><span class="special">,</span> <span class="identifier">operation</span><span class="special">)</span> <span class="special">&lt;</span> <span class="number">0</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="keyword">int</span> <span class="identifier">err</span> <span class="special">=</span> <span class="identifier">errno</span><span class="special">;</span>
            <span class="keyword">if</span> <span class="special">(</span><span class="identifier">err</span> <span class="special">!=</span> <span class="identifier">EINTR</span><span class="special">)</span>
                <span class="keyword">return</span> <span class="identifier">err</span><span class="special">;</span>
        <span class="special">}</span>

        <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
    <span class="special">};</span>

    <span class="comment">// Lock the file</span>
    <span class="identifier">err</span> <span class="special">=</span> <span class="identifier">lock_operation</span><span class="special">(</span><span class="identifier">LOCK_EX</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">err</span> <span class="special">!=</span> <span class="number">0</span><span class="special">)</span>
        <span class="keyword">return</span><span class="special">;</span>

    <span class="comment">// Unlock the file on exit</span>
    <span class="identifier">BOOST_SCOPE_DEFER</span> <span class="special">[&amp;]</span> <span class="special">{</span> <span class="identifier">lock_operation</span><span class="special">(</span><span class="identifier">LOCK_UN</span><span class="special">);</span> <span class="special">};</span>

    <span class="comment">// Write data</span>
    <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">p</span> <span class="special">=</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">data</span><span class="special">();</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">size_left</span> <span class="special">=</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">size</span><span class="special">();</span>
    <span class="keyword">while</span> <span class="special">(</span><span class="identifier">size_left</span> <span class="special">&gt;</span> <span class="number">0</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">ssize_t</span> <span class="identifier">written</span> <span class="special">=</span> <span class="identifier">write</span><span class="special">(</span><span class="identifier">fd</span><span class="special">,</span> <span class="identifier">p</span><span class="special">,</span> <span class="identifier">size_left</span><span class="special">);</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">written</span> <span class="special">&lt;</span> <span class="number">0</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="identifier">err</span> <span class="special">=</span> <span class="identifier">errno</span><span class="special">;</span>
            <span class="keyword">if</span> <span class="special">(</span><span class="identifier">err</span> <span class="special">==</span> <span class="identifier">EINTR</span><span class="special">)</span>
            <span class="special">{</span>
                <span class="identifier">err</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="comment">// we do not want to report EINTR to the caller</span>
                <span class="keyword">continue</span><span class="special">;</span>
            <span class="special">}</span>
            <span class="keyword">return</span><span class="special">;</span>
        <span class="special">}</span>

        <span class="identifier">p</span> <span class="special">+=</span> <span class="identifier">written</span><span class="special">;</span>
        <span class="identifier">size_left</span> <span class="special">-=</span> <span class="identifier">written</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
        Besides <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1exception__checker.html" title="Class exception_checker">exception_checker</a></code>,
        the library also provides <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1error__code__checker.html" title="Class template error_code_checker">error_code_checker</a></code>
        that can be used as a condition function object. On construction, <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1error__code__checker.html" title="Class template error_code_checker">error_code_checker</a></code> captures
        a reference to an external error code object and checks it for an error indication
        when being called. This implies that the error code object must remain valid
        for the entire lifetime duration of the <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1error__code__checker.html" title="Class template error_code_checker">error_code_checker</a></code>
        predicate.
      </p>
<p>
        An object <code class="computeroutput"><span class="identifier">ec</span></code> can be used
        as an error code object if:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            the expression <code class="computeroutput"><span class="special">!</span><span class="identifier">ec</span></code>
            is valid, never throws, and returns a value contextually convertible
            to <code class="computeroutput"><span class="keyword">bool</span></code>, and
          </li>
<li class="listitem">
            the expression <code class="computeroutput"><span class="special">!</span><span class="identifier">ec</span></code>
            produces a value contextually convertible to <code class="computeroutput"><span class="keyword">true</span></code>
            when there is no error and <code class="computeroutput"><span class="keyword">false</span></code>
            otherwise.
          </li>
</ul></div>
<p>
        That is, for an error code object <code class="computeroutput"><span class="identifier">ec</span></code>,
        invoking <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1error__code__checker.html" title="Class template error_code_checker">error_code_checker</a></code>
        results in a value equivalent to <code class="computeroutput"><span class="special">!!</span><span class="identifier">ec</span></code>. This makes <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1error__code__checker.html" title="Class template error_code_checker">error_code_checker</a></code>
        compatible with a wide variety of error code types, including:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">error_code</span></code> or <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span></code>
            from <a href="https://www.boost.org/doc/libs/release/libs/system/doc/html/system.html" target="_top">Boost.System</a>,
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">expected</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">outcome_v2</span><span class="special">::</span><span class="identifier">basic_outcome</span></code>
            or <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">outcome_v2</span><span class="special">::</span><span class="identifier">basic_result</span></code> from <a href="https://www.boost.org/doc/libs/release/libs/outcome/doc/html/index.html" target="_top">Boost.Outcome</a>,
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="keyword">int</span></code>, where the value of
            0 indicates no error,
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="keyword">bool</span></code>, where the value of
            <code class="computeroutput"><span class="keyword">false</span></code> indicates no error,
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">T</span><span class="special">*</span></code>,
            where a null pointer indicates no error.
          </li>
</ul></div>
<p>
        For C++11 compilers, the library also provides a factory function <code class="computeroutput"><span class="identifier">check_error_code</span></code>. For example, our previous
        example could use this condition function object like this:
      </p>
<pre class="programlisting"><span class="comment">// Writes a string to a file using a file descriptor, with file locking.</span>
<span class="comment">// Reports errors via an error_code parameter.</span>
<span class="keyword">void</span> <span class="identifier">locked_write_string</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">fd</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">str</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">&amp;</span> <span class="identifier">ec</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">err</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>

    <span class="comment">// Automatically transform errors to error_code on exit</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_fail</span> <span class="identifier">fail_guard</span>
    <span class="special">{</span>
        <span class="comment">// Action function object</span>
        <span class="special">[&amp;]</span> <span class="special">{</span> <span class="identifier">ec</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">(</span><span class="identifier">err</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">generic_category</span><span class="special">());</span> <span class="special">},</span>
        <span class="comment">// Condition function object</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">check_error_code</span><span class="special">(</span><span class="identifier">err</span><span class="special">)</span>
    <span class="special">};</span>

    <span class="comment">// ...</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="scope.scope_guards.unconditional"></a><a class="link" href="scope_guards.html#scope.scope_guards.unconditional" title="Unconditional scope guard: defer_guard">Unconditional scope
      guard: <code class="computeroutput"><span class="identifier">defer_guard</span></code></a>
</h3></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><code class="computeroutput"><a class="link" href="../reference.html#doxygen.reference.defer_8hpp" title="Header &lt;boost/scope/defer.hpp&gt;">boost/scope/defer.hpp</a></code><span class="special">&gt;</span>
</pre>
<p>
        The <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1defer__guard.html" title="Class template defer_guard">defer_guard</a></code> scope
        guard is similar to <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>
        without a user-specified condition function object in terms of when it invokes
        the action function. But it does not support custom condition functions and
        lacks support for moveability and activation/deactivation - this scope guard
        is always active upon construction. This allows for a more efficient implementation
        when these features are not needed.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1defer__guard.html" title="Class template defer_guard">defer_guard</a></code> is a
          more lightweight version of <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>,
          similar to how <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">lock_guard</span></code> is a more lightweight version
          of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_lock</span></code>.
        </p></td></tr>
</table></div>
<p>
        Since <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1defer__guard.html" title="Class template defer_guard">defer_guard</a></code>
        effectively provides no interface to interact with after construction, it
        is better suited for anonymous "set up and forget" kind of scope
        guards. To emphasize this affinity, the library provides a <code class="computeroutput"><span class="identifier">BOOST_SCOPE_DEFER</span></code> macro, which acts as
        a keyword defining a uniquely named <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1defer__guard.html" title="Class template defer_guard">defer_guard</a></code>
        scope guard. The macro should be followed by the function object to be invoked
        on scope exit.
      </p>
<pre class="programlisting"><span class="identifier">BOOST_SCOPE_DEFER</span> <span class="special">[]</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Hello world!"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          <code class="computeroutput"><span class="identifier">BOOST_SCOPE_DEFER</span></code> requires
          support for C++17 <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction" target="_top">CTAD</a>.
          The <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1defer__guard.html" title="Class template defer_guard">defer_guard</a></code>
          class itself is compatible with C++11, but given that there is no factory
          function for it, C++17 support is very much desired.
        </p></td></tr>
</table></div>
<p>
        As you can see, <code class="computeroutput"><span class="identifier">BOOST_SCOPE_DEFER</span></code>
        offers a few syntax improvements over the other scope guard declarations:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            The declaration does not name a scope guard variable, meaning one does
            not need to invent one and there is no possibility to accidentally omit
            one or clash with other variables.
          </li>
<li class="listitem">
            The declaration is generally shorter to type and easier to spot.
          </li>
<li class="listitem">
            There are no extra parenthesis or curly braces around the function object.
          </li>
</ul></div>
<p>
        However, it should be noted that the use of the <code class="computeroutput"><span class="identifier">BOOST_SCOPE_DEFER</span></code>
        macro is entirely optional. Users are free to use <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1defer__guard.html" title="Class template defer_guard">defer_guard</a></code>
        directly.
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">defer_guard</span> <span class="identifier">guard</span><span class="special">{[]</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Hello world!"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}};</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="scope.scope_guards.capture_by_reference_caveats"></a><a class="link" href="scope_guards.html#scope.scope_guards.capture_by_reference_caveats" title="Caveats of capturing by reference">Caveats
      of capturing by reference</a>
</h3></div></div></div>
<p>
        When using scope guards, users should make sure that all variables captured
        by reference are still in a valid state upon the scope guard destruction.
        This especially pertains to lambda functions that capture variables by reference
        by default (i.e. where the capture clause starts with <code class="computeroutput"><span class="special">&amp;</span></code>).
        Consider the following example:
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">bad</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;</span> <span class="identifier">ptr</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">ptr</span> <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>

    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">guard</span><span class="special">{[&amp;]</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"processed: "</span> <span class="special">&lt;&lt;</span> <span class="special">*</span><span class="identifier">ptr</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">}};</span>

    <span class="identifier">process</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">ptr</span><span class="special">));</span> <span class="comment">// may consume ptr, leaving it null for the scope guard action</span>
<span class="special">}</span>
</pre>
<p>
        Or a slightly less obvious version of it, involving implicit move of the
        returned value:
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;</span> <span class="identifier">bad</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;</span> <span class="identifier">ptr</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">ptr</span> <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>

    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">guard</span><span class="special">{[&amp;]</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"processed: "</span> <span class="special">&lt;&lt;</span> <span class="special">*</span><span class="identifier">ptr</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">}};</span>

    <span class="identifier">process</span><span class="special">(*</span><span class="identifier">ptr</span><span class="special">);</span>

    <span class="keyword">return</span> <span class="identifier">ptr</span><span class="special">;</span> <span class="comment">// moves from ptr, leaving it null for the scope guard action</span>
<span class="special">}</span>
</pre>
<p>
        In cases like this consider capturing by value in the function object or
        moving the scope guard to a deeper scope, so that it executes its action
        before the variables captured by reference become invalid.
      </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;</span> <span class="identifier">good</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;</span> <span class="identifier">ptr</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">ptr</span> <span class="special">!=</span> <span class="keyword">nullptr</span><span class="special">);</span>

    <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">guard</span><span class="special">{[&amp;]</span>
        <span class="special">{</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"processed: "</span> <span class="special">&lt;&lt;</span> <span class="special">*</span><span class="identifier">ptr</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="special">}};</span>

        <span class="identifier">process</span><span class="special">(*</span><span class="identifier">ptr</span><span class="special">);</span>
    <span class="special">}</span> <span class="comment">// &lt;- scope guard action runs here, before ptr is moved-from</span>

    <span class="keyword">return</span> <span class="identifier">ptr</span><span class="special">;</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="scope.scope_guards.runtime_defined"></a><a class="link" href="scope_guards.html#scope.scope_guards.runtime_defined" title="Setting up scope exit actions at run time">Setting up scope
      exit actions at run time</a>
</h3></div></div></div>
<p>
        It is possible to use scope guard classes to implement scope exit actions
        that are initialized at run time. One way to do this is to use a function
        object wrapper such as <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span></code>
        together with the scope guard to schedule the function call. For example:
      </p>
<pre class="programlisting"><span class="keyword">using</span> <span class="identifier">cleanup_func_t</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span> <span class="keyword">void</span><span class="special">()</span> <span class="special">&gt;;</span>
<span class="identifier">cleanup_func_t</span> <span class="identifier">cleanup_func</span><span class="special">;</span>
<span class="comment">// Create an inactive scope guard first, since the cleanup function is not set yet</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_exit</span><span class="special">&lt;</span> <span class="identifier">cleanup_func_t</span><span class="special">&amp;</span> <span class="special">&gt;</span> <span class="identifier">cleanup</span><span class="special">(</span><span class="identifier">cleanup_func</span><span class="special">,</span> <span class="keyword">false</span><span class="special">);</span>

<span class="comment">// Later in the program, initialize the cleanup function with the function selected at run time</span>
<span class="keyword">if</span> <span class="special">(</span><span class="identifier">cond</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">cleanup_func</span> <span class="special">=</span> <span class="special">[]</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"cond is true"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">};</span>
<span class="special">}</span>
<span class="keyword">else</span>
<span class="special">{</span>
    <span class="identifier">cleanup_func</span> <span class="special">=</span> <span class="special">[]</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"cond is false"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">};</span>
<span class="special">}</span>

<span class="comment">// Activate the scope guard once the cleanup function is initialized</span>
<span class="identifier">cleanup</span><span class="special">.</span><span class="identifier">set_active</span><span class="special">(</span><span class="keyword">true</span><span class="special">);</span>
</pre>
<p>
        It is also possible to do this with <code class="computeroutput"><span class="identifier">BOOST_SCOPE_DEFER</span></code>,
        although it eliminates one of the advantages provided by this macro, namely
        not having to invent a variable name. Also note that the function wrapper
        must be valid at all times once the scope guard is constructed.
      </p>
<pre class="programlisting"><span class="comment">// Create a non-empty function wrapper that does nothing</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span> <span class="keyword">void</span><span class="special">()</span> <span class="special">&gt;</span> <span class="identifier">cleanup_func</span> <span class="special">=</span> <span class="special">[]</span> <span class="special">{};</span>
<span class="comment">// Create a scope guard that refers to the function wrapper</span>
<span class="identifier">BOOST_SCOPE_DEFER</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">cleanup_func</span><span class="special">);</span>

<span class="comment">// Later in the program, initialize the function wrapper</span>
<span class="keyword">if</span> <span class="special">(</span><span class="identifier">cond</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">cleanup_func</span> <span class="special">=</span> <span class="special">[]</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"cond is true"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">};</span>
<span class="special">}</span>
<span class="keyword">else</span>
<span class="special">{</span>
    <span class="identifier">cleanup_func</span> <span class="special">=</span> <span class="special">[]</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"cond is false"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">};</span>
<span class="special">}</span>
</pre>
<p>
        However, users should be aware that function wrappers typically use dynamic
        memory allocation internally and copy the function object data, which may
        involve calling copy constructors that may also fail with an exception. Although
        many standard library implementations use small object optimization for
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span></code>, and this technique is also used
        in other implementations like <a href="https://www.boost.org/doc/libs/release/doc/html/function.html" target="_top">Boost.Function</a>,
        it is generally not guaranteed that initializing the function wrapper with
        a given function object will not throw. Because of this, using <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span></code>
        and similar wrappers is usually not recommended.
      </p>
<p>
        If setting up the scope exit action needs to be a non-throwing operation
        (for example, if the scope guard is supposed to revert the effects of the
        immediately preceding operation), it is recommended to initialize inactive
        scope guards beforehand and only activate one of them at a later point in
        the program.
      </p>
<pre class="programlisting"><span class="comment">// Create inactive scope guards for both branches</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">cleanup_true</span><span class="special">([]</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"cond is true"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">},</span>
<span class="keyword">false</span><span class="special">);</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">cleanup_false</span><span class="special">([]</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"cond is false"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">},</span>
<span class="keyword">false</span><span class="special">);</span>

<span class="comment">// Later in the program, activate one of the scope guards.</span>
<span class="comment">// This won't throw.</span>
<span class="keyword">if</span> <span class="special">(</span><span class="identifier">cond</span><span class="special">)</span>
    <span class="identifier">cleanup_true</span><span class="special">.</span><span class="identifier">set_active</span><span class="special">(</span><span class="keyword">true</span><span class="special">);</span>
<span class="keyword">else</span>
    <span class="identifier">cleanup_false</span><span class="special">.</span><span class="identifier">set_active</span><span class="special">(</span><span class="keyword">true</span><span class="special">);</span>
</pre>
<p>
        Alternatively, one could implement the selection within the scope guard action
        itself.
      </p>
<pre class="programlisting"><span class="comment">// Create a single inactive scope guard that implements both branches</span>
<span class="keyword">bool</span> <span class="identifier">cond</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">cleanup</span><span class="special">([&amp;</span><span class="identifier">cond</span><span class="special">]</span>
<span class="special">{</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">cond</span><span class="special">)</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"cond is true"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="keyword">else</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"cond is false"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">},</span>
<span class="keyword">false</span><span class="special">);</span>

<span class="comment">// Later in the program, select the branch to perform</span>
<span class="comment">// and activate the scope guard.</span>
<span class="identifier">cond</span> <span class="special">=</span> <span class="identifier">select_branch</span><span class="special">();</span>
<span class="identifier">cleanup</span><span class="special">.</span><span class="identifier">set_active</span><span class="special">(</span><span class="keyword">true</span><span class="special">);</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="scope.scope_guards.comparison_with_boost_scope_exit"></a><a class="link" href="scope_guards.html#scope.scope_guards.comparison_with_boost_scope_exit" title="Comparison with Boost.ScopeExit library">Comparison
      with Boost.ScopeExit library</a>
</h3></div></div></div>
<p>
        <a href="https://www.boost.org/doc/libs/release/libs/scope_exit/doc/html/index.html" target="_top">Boost.ScopeExit</a>
        defines a set of macros for defining code blocks to be executed at scope
        exit. Scope guards provided by Boost.Scope provide similar functionality,
        but with simpler syntax and new features. Differences between libraries are
        summarized in the table below.
      </p>
<div class="table">
<a name="scope.scope_guards.comparison_with_boost_scope_exit.boost_scope_exit_and_boost_scope"></a><p class="title"><b>Table 1.4. <a href="https://www.boost.org/doc/libs/release/libs/scope_exit/doc/html/index.html" target="_top">Boost.ScopeExit</a>
        and Boost.Scope comparison</b></p>
<div class="table-contents"><table class="table" summary="Boost.ScopeExit
        and Boost.Scope comparison">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Feature
                </p>
              </th>
<th>
                <p>
                  <a href="https://www.boost.org/doc/libs/release/libs/scope_exit/doc/html/index.html" target="_top">Boost.ScopeExit</a>
                </p>
              </th>
<th>
                <p>
                  Boost.Scope
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  Minimum and recommended C++ version.
                </p>
              </td>
<td>
                <p>
                  C++03 minimum, C++11 recommended for some features.
                </p>
              </td>
<td>
                <p>
                  C++11 minimum, C++17 recommended for some features.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  Basic functionality.
                </p>
              </td>
<td>
<pre class="programlisting"><span class="identifier">BOOST_SCOPE_EXIT</span><span class="special">(</span><span class="keyword">void</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Hello, World!"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
<span class="identifier">BOOST_SCOPE_EXIT_END</span><span class="special">;</span>
</pre>
              </td>
<td>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">guard</span><span class="special">([]</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Hello, World!"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">});</span>
</pre>
                <p>
                  Or:
                </p>
<pre class="programlisting"><span class="identifier">BOOST_SCOPE_DEFER</span> <span class="special">[]</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Hello, World!"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">};</span>
</pre>
              </td>
</tr>
<tr>
<td>
                <p>
                  Capturing variables.
                </p>
              </td>
<td>
                <p>
                  Yes, both by value and by reference.
                </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">x</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">;</span>
<span class="identifier">BOOST_SCOPE_EXIT</span><span class="special">(</span><span class="identifier">x</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">str</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"x = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">x</span> <span class="special">&lt;&lt;</span> <span class="string">", str = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">str</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
<span class="identifier">BOOST_SCOPE_EXIT_END</span><span class="special">;</span>
</pre>
                <p>
                  In C++03 mode without variadic macros support, Boost.Preprocessor
                  sequence should be used to list captured variables.
                </p>
              </td>
<td>
                <p>
                  Yes, by means of the standard C++ lambda captures.
                </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">x</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">guard</span><span class="special">([</span><span class="identifier">x</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">str</span><span class="special">]</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"x = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">x</span> <span class="special">&lt;&lt;</span> <span class="string">", str = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">str</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">});</span>
</pre>
                <p>
                  Or:
                </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">x</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">;</span>
<span class="identifier">BOOST_SCOPE_DEFER</span> <span class="special">[</span><span class="identifier">x</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">str</span><span class="special">]</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"x = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">x</span> <span class="special">&lt;&lt;</span> <span class="string">", str = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">str</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">};</span>
</pre>
              </td>
</tr>
<tr>
<td>
                <p>
                  Capturing all variables.
                </p>
              </td>
<td>
                <p>
                  Yes, requires C++11.
                </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">x</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">;</span>
<span class="identifier">BOOST_SCOPE_EXIT_ALL</span><span class="special">(&amp;)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"x = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">x</span> <span class="special">&lt;&lt;</span> <span class="string">", str = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">str</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">};</span>
</pre>
                <p>
                  Note that no <code class="computeroutput"><span class="identifier">BOOST_SCOPE_EXIT_END</span></code>
                  is used in this case. See below for <code class="computeroutput"><span class="identifier">BOOST_SCOPE_EXIT_ALL</span></code>
                  caveats.
                </p>
              </td>
<td>
                <p>
                  Yes, by means of the standard C++ lambda captures.
                </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">x</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">guard</span><span class="special">([&amp;]</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"x = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">x</span> <span class="special">&lt;&lt;</span> <span class="string">", str = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">str</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">});</span>
</pre>
                <p>
                  Or:
                </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">x</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">;</span>
<span class="identifier">BOOST_SCOPE_DEFER</span> <span class="special">[&amp;]</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"x = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">x</span> <span class="special">&lt;&lt;</span> <span class="string">", str = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">str</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">};</span>
</pre>
              </td>
</tr>
<tr>
<td>
                <p>
                  Capturing <code class="computeroutput"><span class="keyword">this</span></code>.
                </p>
              </td>
<td>
                <p>
                  Yes, with a special <code class="computeroutput"><span class="identifier">this_</span></code>
                  keyword.
                </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">my_class</span>
<span class="special">{</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">int</span> <span class="identifier">x</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">;</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">foo</span><span class="special">()</span>
    <span class="special">{</span>
        <span class="identifier">BOOST_SCOPE_EXIT</span><span class="special">(</span><span class="identifier">this_</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"x = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">this_</span><span class="special">-&gt;</span><span class="identifier">x</span> <span class="special">&lt;&lt;</span> <span class="string">", str = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">this_</span><span class="special">-&gt;</span><span class="identifier">str</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="special">}</span>
        <span class="identifier">BOOST_SCOPE_EXIT_END</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
                <p>
                  Note that the keyword must be explicitly used to reference members
                  of the class within the scope exit block.
                </p>
                <p>
                  Capturing <code class="computeroutput"><span class="keyword">this</span></code> is
                  also possible using <code class="computeroutput"><span class="identifier">BOOST_SCOPE_EXIT_ALL</span></code>
                  (with the caveats described below).
                </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">my_class</span>
<span class="special">{</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">int</span> <span class="identifier">x</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">;</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">foo</span><span class="special">()</span>
    <span class="special">{</span>
        <span class="identifier">BOOST_SCOPE_EXIT_ALL</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"x = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">x</span> <span class="special">&lt;&lt;</span> <span class="string">", str = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">str</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="special">};</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
              </td>
<td>
                <p>
                  Yes, by means of the standard C++ lambda captures.
                </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">my_class</span>
<span class="special">{</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">int</span> <span class="identifier">x</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">;</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">foo</span><span class="special">()</span>
    <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">guard</span><span class="special">([</span><span class="keyword">this</span><span class="special">]</span>
        <span class="special">{</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"x = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">x</span> <span class="special">&lt;&lt;</span> <span class="string">", str = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">str</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="special">};</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
                <p>
                  Or:
                </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">my_class</span>
<span class="special">{</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">int</span> <span class="identifier">x</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">;</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">foo</span><span class="special">()</span>
    <span class="special">{</span>
        <span class="identifier">BOOST_SCOPE_DEFER</span> <span class="special">[</span><span class="keyword">this</span><span class="special">]</span>
        <span class="special">{</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"x = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">x</span> <span class="special">&lt;&lt;</span> <span class="string">", str = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">str</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="special">};</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
              </td>
</tr>
<tr>
<td>
                <p>
                  Capturing specific members of a class.
                </p>
              </td>
<td>
                <p>
                  Yes.
                </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">my_class</span>
<span class="special">{</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">int</span> <span class="identifier">x</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">;</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">foo</span><span class="special">()</span>
    <span class="special">{</span>
        <span class="identifier">BOOST_SCOPE_EXIT</span><span class="special">(</span><span class="identifier">x</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">str</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"x = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">x</span> <span class="special">&lt;&lt;</span> <span class="string">", str = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">str</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="special">}</span>
        <span class="identifier">BOOST_SCOPE_EXIT_END</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
              </td>
<td>
                <p>
                  No. Capture <code class="computeroutput"><span class="keyword">this</span></code> or
                  use lambda capture initializers (requires C++14) instead.
                </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">my_class</span>
<span class="special">{</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">int</span> <span class="identifier">x</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">;</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">foo</span><span class="special">()</span>
    <span class="special">{</span>
        <span class="identifier">BOOST_SCOPE_DEFER</span> <span class="special">[</span><span class="identifier">x</span> <span class="special">=</span> <span class="identifier">x</span><span class="special">,</span> <span class="identifier">str</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">str</span><span class="special">)]</span>
        <span class="special">{</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"x = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">x</span> <span class="special">&lt;&lt;</span> <span class="string">", str = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">str</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
        <span class="special">};</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
              </td>
</tr>
<tr>
<td>
                <p>
                  Support for scope guards in templates.
                </p>
              </td>
<td>
                <p>
                  Yes, using a special macro.
                </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">foo</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">param</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">BOOST_SCOPE_EXIT_TPL</span><span class="special">(&amp;</span><span class="identifier">param</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Param: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">param</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="identifier">BOOST_SCOPE_EXIT_END</span><span class="special">;</span>
<span class="special">}</span>
</pre>
              </td>
<td>
                <p>
                  Yes, with no special syntax.
                </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">foo</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">param</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">BOOST_SCOPE_DEFER</span> <span class="special">[&amp;</span><span class="identifier">param</span><span class="special">]</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Param: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">param</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">};</span>
<span class="special">}</span>
</pre>
              </td>
</tr>
<tr>
<td>
                <p>
                  Support for variadic templates and argument packs.
                </p>
              </td>
<td>
                <p>
                  Yes, using the <code class="computeroutput"><span class="identifier">BOOST_SCOPE_EXIT_ALL</span></code>
                  macro (see the caveats below).
                </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span><span class="special">...</span> <span class="identifier">Args</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">foo</span><span class="special">(</span><span class="identifier">Args</span><span class="special">&amp;&amp;...</span> <span class="identifier">args</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">BOOST_SCOPE_EXIT_ALL</span><span class="special">(&amp;</span><span class="identifier">args</span><span class="special">...)</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Params: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tuples</span><span class="special">::</span><span class="identifier">tie</span><span class="special">(</span><span class="identifier">args</span><span class="special">...)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">};</span>
<span class="special">}</span>
</pre>
              </td>
<td>
                <p>
                  Yes, by means of the standard C++ lambda captures.
                </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span><span class="special">...</span> <span class="identifier">Args</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">foo</span><span class="special">(</span><span class="identifier">Args</span><span class="special">&amp;&amp;...</span> <span class="identifier">args</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">BOOST_SCOPE_DEFER</span> <span class="special">[&amp;</span><span class="identifier">args</span><span class="special">...]</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Params: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tuples</span><span class="special">::</span><span class="identifier">tie</span><span class="special">(</span><span class="identifier">args</span><span class="special">...)</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">};</span>
<span class="special">}</span>
</pre>
              </td>
</tr>
<tr>
<td>
                <p>
                  Native support for activation/deactivation of the scope guard.
                </p>
              </td>
<td>
                <p>
                  No, the activation/deactivation logic needs to be embedded into
                  the action code block.
                </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">active</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>
<span class="identifier">BOOST_SCOPE_EXIT</span><span class="special">(&amp;</span><span class="identifier">active</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">active</span><span class="special">)</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Hello, World!"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
<span class="identifier">BOOST_SCOPE_EXIT_END</span><span class="special">;</span>

<span class="identifier">active</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
              </td>
<td>
                <p>
                  Yes, with <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>,
                  <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__success.html" title="Class template scope_success">scope_success</a></code>
                  and <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code>.
                  This includes the ability to delay activation of the initially
                  inactive scope guards.
                </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">guard</span><span class="special">([]</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Hello, World!"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">},</span>
<span class="keyword">false</span><span class="special">);</span>

<span class="identifier">guard</span><span class="special">.</span><span class="identifier">set_active</span><span class="special">(</span><span class="keyword">true</span><span class="special">);</span>
</pre>
              </td>
</tr>
<tr>
<td>
                <p>
                  Support for custom conditions for executing the action.
                </p>
              </td>
<td>
                <p>
                  No, the condition needs to be embedded into the action code block.
                </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="keyword">auto</span> <span class="identifier">uncaught_count</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">uncaught_exceptions</span><span class="special">();</span>
<span class="identifier">BOOST_SCOPE_EXIT</span><span class="special">(</span><span class="identifier">uncaught_count</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">uncaught_exceptions</span><span class="special">()</span> <span class="special">&gt;</span> <span class="identifier">uncaught_count</span><span class="special">)</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Exception thrown!"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
<span class="identifier">BOOST_SCOPE_EXIT_END</span><span class="special">;</span>
</pre>
              </td>
<td>
                <p>
                  Yes, with <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>,
                  <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__success.html" title="Class template scope_success">scope_success</a></code>
                  and <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code>.
                </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">guard</span><span class="special">(</span>
<span class="special">[]</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Exception thrown!"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">},</span>
<span class="special">[</span><span class="identifier">uncaught_count</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">uncaught_exceptions</span><span class="special">()]</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">uncaught_exceptions</span><span class="special">()</span> <span class="special">&gt;</span> <span class="identifier">uncaught_count</span><span class="special">;</span>
<span class="special">});</span>
</pre>
                <p>
                  Or simply:
                </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_fail</span> <span class="identifier">guard</span><span class="special">([]</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Exception thrown!"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">});</span>
</pre>
              </td>
</tr>
<tr>
<td>
                <p>
                  Utilities for checking exceptions and error codes as criteria for
                  invoking the action.
                </p>
              </td>
<td>
                <p>
                  No, the condition needs to be embedded into the action code block.
                </p>
<pre class="programlisting"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">uncaught_count</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">core</span><span class="special">::</span><span class="identifier">uncaught_exceptions</span><span class="special">();</span>
<span class="identifier">BOOST_SCOPE_EXIT</span><span class="special">(</span><span class="identifier">uncaught_count</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">uncaught_count</span> <span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">core</span><span class="special">::</span><span class="identifier">uncaught_exceptions</span><span class="special">())</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Exception thrown!"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
<span class="identifier">BOOST_SCOPE_EXIT_END</span><span class="special">;</span>
</pre>
                <p>
                  Or:
                </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">error_code</span> <span class="identifier">ec</span><span class="special">;</span>
<span class="identifier">BOOST_SCOPE_EXIT</span><span class="special">(&amp;</span><span class="identifier">ec</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">ec</span><span class="special">)</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Execution failed!"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
<span class="identifier">BOOST_SCOPE_EXIT_END</span><span class="special">;</span>
</pre>
              </td>
<td>
                <p>
                  Yes, <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1exception__checker.html" title="Class exception_checker">exception_checker</a></code>
                  and <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1error__code__checker.html" title="Class template error_code_checker">error_code_checker</a></code>.
                </p>
<pre class="programlisting"><span class="comment">// scope_fail by default checks for an exception</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_fail</span> <span class="identifier">guard</span><span class="special">([]</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Exception thrown!"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">});</span>
</pre>
                <p>
                  Or:
                </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">error_code</span> <span class="identifier">ec</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_fail</span> <span class="identifier">guard</span><span class="special">([]</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Execution failed!"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">},</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">check_error_code</span><span class="special">(</span><span class="identifier">ec</span><span class="special">));</span>
</pre>
              </td>
</tr>
<tr>
<td>
                <p>
                  Named scope guards.
                </p>
              </td>
<td>
                <p>
                  No, the scope guard is declared as an unnamed code block. (The
                  scope guard is internally implemented as an object with a unique
                  name on the stack, but this is not part of the public interface.)
                </p>
              </td>
<td>
                <p>
                  Yes, scope guards are defined as objects. Also, <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>,
                  <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__success.html" title="Class template scope_success">scope_success</a></code>
                  and <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code>
                  are move-constructible and can be returned from functions.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  Anonymous scope guards.
                </p>
              </td>
<td>
                <p>
                  Yes.
                </p>
              </td>
<td>
                <p>
                  Yes, using the <code class="computeroutput"><span class="identifier">BOOST_SCOPE_DEFER</span></code>
                  macro.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  Macro-less usage.
                </p>
              </td>
<td>
                <p>
                  No.
                </p>
              </td>
<td>
                <p>
                  Yes.
                </p>
              </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
        In the table above, you may notice that a significant amount of feature parity
        between <a href="https://www.boost.org/doc/libs/release/libs/scope_exit/doc/html/index.html" target="_top">Boost.ScopeExit</a>
        and Boost.Scope is achieved by using the <code class="computeroutput"><span class="identifier">BOOST_SCOPE_EXIT_ALL</span></code>
        macro in the former. This macro is implemented using C++11 lambda functions
        internally, which explains a lot of similarities between the libraries in
        this case. Users can also define <code class="computeroutput"><span class="identifier">BOOST_SCOPE_EXIT_CONFIG_USE_LAMBDAS</span></code>
        to force other <a href="https://www.boost.org/doc/libs/release/libs/scope_exit/doc/html/index.html" target="_top">Boost.ScopeExit</a>
        macros to use C++11 lambdas internally, which will change the syntax and
        variable capture rules accordingly. However, there are a few caveats one
        needs to keep in mind when using the library in this mode (or the <code class="computeroutput"><span class="identifier">BOOST_SCOPE_EXIT_ALL</span></code> macro in any mode):
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Since it relies on C++11 lambda functions, it is not available in C++03
            mode.
          </li>
<li class="listitem">
            <a href="https://www.boost.org/doc/libs/release/libs/scope_exit/doc/html/index.html" target="_top">Boost.ScopeExit</a>
            scope guards that are implemented using C++11 lambdas store the lambda
            function in a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">function</span></code> object internally. This means
            that creating the scope guard may require dynamic memory allocation and
            can fail with an exception. <a href="https://www.boost.org/doc/libs/release/libs/scope_exit/doc/html/index.html" target="_top">Boost.ScopeExit</a>
            does not document behavior in this case, but in practice, as of Boost
            1.83.0, the scope exit block does not get executed in this case. This
            means that <a href="https://www.boost.org/doc/libs/release/libs/scope_exit/doc/html/index.html" target="_top">Boost.ScopeExit</a>
            in this mode cannot be safely used in non-throwing contexts, and cannot
            guarantee execution of the scope exit block. There is also performance
            overhead associated both with construction and execution of the scope
            guard.
          </li>
</ul></div>
<p>
        In comparison, Boost.Scope scope guards do not use function object wrappers,
        such as <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">function</span></code> or <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span></code>,
        to store the function objects. This means that the scope guards do not perform
        dynamic memory allocation (unless the function objects themselves do) and
        do not have the associated exception safety issues and performance overhead.
        Additionally, the scope guards will execute the action if initializing the
        scope guard fails with an exception.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="scope.scope_guards.comparison_with_library_fundamentals_ts"></a><a class="link" href="scope_guards.html#scope.scope_guards.comparison_with_library_fundamentals_ts" title="Comparison with scope guards defined in C++ Extensions for Library Fundamentals">Comparison
      with scope guards defined in C++ Extensions for Library Fundamentals</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="scope_guards.html#scope.scope_guards.comparison_with_library_fundamentals_ts.condition_functions">Condition
        functions</a></span></dt>
<dt><span class="section"><a href="scope_guards.html#scope.scope_guards.comparison_with_library_fundamentals_ts.activation">Flexible
        activation and deactivation of scope guards</a></span></dt>
<dt><span class="section"><a href="scope_guards.html#scope.scope_guards.comparison_with_library_fundamentals_ts.relaxed_dtor_noexcept">Relaxed
        <code class="computeroutput"><span class="keyword">noexcept</span></code> specification on destructors</a></span></dt>
</dl></div>
<p>
        The <a href="https://cplusplus.github.io/fundamentals-ts/v3.html#scopeguard.exit" target="_top">C++
        Extensions for Library Fundamentals TS</a> defines three scope guard
        types, <code class="computeroutput"><span class="identifier">scope_exit</span></code>, <code class="computeroutput"><span class="identifier">scope_success</span></code> and <code class="computeroutput"><span class="identifier">scope_fail</span></code>,
        which have similar semantics to the same-named scope guards provided by this
        library. There are some differences and extensions that are summarised below.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="scope.scope_guards.comparison_with_library_fundamentals_ts.condition_functions"></a><a class="link" href="scope_guards.html#scope.scope_guards.comparison_with_library_fundamentals_ts.condition_functions" title="Condition functions">Condition
        functions</a>
</h4></div></div></div>
<p>
          All three of the <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__exit.html" title="Class template scope_exit">scope_exit</a></code>,
          <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__success.html" title="Class template scope_success">scope_success</a></code>
          and <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code> scope
          guards provided by Boost.Scope support an optional <a class="link" href="scope_guards.html#scope.scope_guards.condition_functions" title="Scope guard condition functions">condition
          function</a> that is used to decide whether the scope guard should invoke
          its wrapped action function. The scope guards defined by the TS do not
          have this feature, the behavior of each of the three scope guards is predefined
          by the specification.
        </p>
<p>
          The default condition functions used in the Boost.Scope scope guards make
          the behavior equivalent to the TS, so if the user doesn't use custom condition
          functions, the scope guard usage is equivalent between the two. If custom
          condition functions are used, those can be emulated in TS scope guards
          by embedding the condition function into the action called by <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">experimental</span><span class="special">::</span><span class="identifier">scope_exit</span></code>. For example, if the user's
          code uses error codes as the failure indication with <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code>,
          the equivalent TS code could look like this:
        </p>
<div class="table">
<a name="scope.scope_guards.comparison_with_library_fundamentals_ts.condition_functions.using_custom_condition_functions"></a><p class="title"><b>Table 1.5. Using custom condition functions</b></p>
<div class="table-contents"><table class="table" summary="Using custom condition functions">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                  <p>
                    Boost.Scope
                  </p>
                </th>
<th>
                  <p>
                    Library Fundamentals TS
                  </p>
                </th>
</tr></thead>
<tbody><tr>
<td>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">error_code</span> <span class="identifier">ec</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_fail</span> <span class="identifier">guard</span>
<span class="special">{</span>
    <span class="special">[]</span> <span class="special">{</span> <span class="identifier">handle_error</span><span class="special">();</span> <span class="special">},</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">check_error_code</span><span class="special">(</span><span class="identifier">ec</span><span class="special">)</span>
<span class="special">};</span>
</pre>
                </td>
<td>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">error_code</span> <span class="identifier">ec</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">experimental</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">guard</span>
<span class="special">{</span>
    <span class="special">[&amp;</span><span class="identifier">ec</span><span class="special">]</span>
    <span class="special">{</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">ec</span><span class="special">)</span>
            <span class="identifier">handle_error</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
                </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break"><p>
          Note that we had to switch from <code class="computeroutput"><span class="identifier">scope_fail</span></code>
          to <code class="computeroutput"><span class="identifier">scope_exit</span></code> in case of
          TS.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="scope.scope_guards.comparison_with_library_fundamentals_ts.activation"></a><a class="link" href="scope_guards.html#scope.scope_guards.comparison_with_library_fundamentals_ts.activation" title="Flexible activation and deactivation of scope guards">Flexible
        activation and deactivation of scope guards</a>
</h4></div></div></div>
<p>
          Scope guards defined in the TS are always constructed active and can only
          be deactivated by calling <code class="computeroutput"><span class="identifier">release</span><span class="special">()</span></code> method. Boost.Scope supports creating
          initially inactive scope guards, as well as activating and deactivating
          them after creation. This allows for more flexible placement of the scope
          guards in the user's code, which is useful if the decision on whether to
          execute the scope guard action needs to be made after the scope guard is
          constructed.
        </p>
<p>
          This feature can be emulated in TS using additional state that the scope
          guard action checks to see if the action needs to be performed.
        </p>
<div class="table">
<a name="scope.scope_guards.comparison_with_library_fundamentals_ts.activation.explicitly_activating_scope_guar"></a><p class="title"><b>Table 1.6. Explicitly activating scope guards</b></p>
<div class="table-contents"><table class="table" summary="Explicitly activating scope guards">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                  <p>
                    Boost.Scope
                  </p>
                </th>
<th>
                  <p>
                    Library Fundamentals TS
                  </p>
                </th>
</tr></thead>
<tbody><tr>
<td>
<pre class="programlisting"><span class="comment">// Insert value into both containers and call on_inserted() afterwards.</span>
<span class="comment">// pv may be null, in which case only insert the value into the set.</span>
<span class="comment">// Maintain both containers intact if an exception is thrown.</span>
<span class="keyword">void</span> <span class="identifier">insert_two</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;*</span> <span class="identifier">pv</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;&amp;</span> <span class="identifier">set</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">value</span><span class="special">)</span>
<span class="special">{</span>
    <span class="comment">// Initially inactive scope guard</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_fail</span> <span class="identifier">pv_rollback</span><span class="special">([</span><span class="identifier">pv</span><span class="special">]</span> <span class="special">{</span> <span class="identifier">pv</span><span class="special">-&gt;</span><span class="identifier">pop_back</span><span class="special">();</span> <span class="special">},</span> <span class="keyword">false</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">pv</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">pv</span><span class="special">-&gt;</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">value</span><span class="special">);</span> <span class="comment">// may throw</span>
        <span class="identifier">pv_rollback</span><span class="special">.</span><span class="identifier">set_active</span><span class="special">(</span><span class="keyword">true</span><span class="special">);</span> <span class="comment">// activate the scope guard</span>
    <span class="special">}</span>

    <span class="keyword">auto</span> <span class="special">[</span><span class="identifier">it</span><span class="special">,</span> <span class="identifier">inserted</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">set</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">value</span><span class="special">);</span> <span class="comment">// may throw</span>
    <span class="comment">// Initially active scope guard, if a new element was inserted, otherwise inactive</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_fail</span> <span class="identifier">set_rollback</span><span class="special">([&amp;</span><span class="identifier">set</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">it</span><span class="special">]</span> <span class="special">{</span> <span class="identifier">set</span><span class="special">.</span><span class="identifier">erase</span><span class="special">(</span><span class="identifier">it</span><span class="special">);</span> <span class="special">},</span> <span class="identifier">inserted</span><span class="special">);</span>

    <span class="identifier">on_inserted</span><span class="special">();</span> <span class="comment">// may throw</span>
<span class="special">}</span>
</pre>
                </td>
<td>
<pre class="programlisting"><span class="comment">// Insert value into both containers and call on_inserted() afterwards.</span>
<span class="comment">// pv may be null, in which case only insert the value into the set.</span>
<span class="comment">// Maintain both containers intact if an exception is thrown.</span>
<span class="keyword">void</span> <span class="identifier">insert_two</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;*</span> <span class="identifier">pv</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;&amp;</span> <span class="identifier">set</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">value</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">bool</span> <span class="identifier">pv_inserted</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>
    <span class="comment">// Initially active scope guard, but blocked by pv_inserted == false</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">experimental</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">pv_rollback</span><span class="special">([</span><span class="identifier">pv</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">pv_inserted</span><span class="special">]</span>
    <span class="special">{</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">pv_inserted</span><span class="special">)</span>
            <span class="identifier">pv</span><span class="special">-&gt;</span><span class="identifier">pop_back</span><span class="special">();</span>
    <span class="special">});</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">pv</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">pv</span><span class="special">-&gt;</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">value</span><span class="special">);</span> <span class="comment">// may throw</span>
        <span class="identifier">pv_inserted</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span> <span class="comment">// unblock the scope guard</span>
    <span class="special">}</span>

    <span class="keyword">auto</span> <span class="special">[</span><span class="identifier">it</span><span class="special">,</span> <span class="identifier">inserted</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">set</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">value</span><span class="special">);</span> <span class="comment">// may throw</span>
    <span class="comment">// Initially active scope guard, which we immediately deactivate if no element was inserted</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">experimental</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">set_rollback</span><span class="special">([&amp;</span><span class="identifier">set</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">it</span><span class="special">]</span> <span class="special">{</span> <span class="identifier">set</span><span class="special">.</span><span class="identifier">erase</span><span class="special">(</span><span class="identifier">it</span><span class="special">);</span> <span class="special">});</span>
    <span class="keyword">if</span> <span class="special">(!</span><span class="identifier">inserted</span><span class="special">)</span>
        <span class="identifier">set_rollback</span><span class="special">.</span><span class="identifier">release</span><span class="special">();</span>

    <span class="identifier">on_inserted</span><span class="special">();</span> <span class="comment">// may throw</span>
<span class="special">}</span>
</pre>
                </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break"><p>
          Note that Boost.Scope guards don't provide <code class="computeroutput"><span class="identifier">release</span><span class="special">()</span></code> member function and instead provide
          <code class="computeroutput"><span class="identifier">set_active</span><span class="special">()</span></code>
          with a <code class="computeroutput"><span class="keyword">bool</span></code> argument, where
          <code class="computeroutput"><span class="identifier">release</span><span class="special">()</span></code>
          is equivalent to <code class="computeroutput"><span class="identifier">set_active</span><span class="special">(</span><span class="keyword">false</span><span class="special">)</span></code>.
          This allows for both activating and deactivating the scope guard. The
          <code class="computeroutput"><span class="keyword">bool</span></code> argument is more convenient
          than two distinct methods for activating and deactivating the scope guard
          when the indication of whether the scope guard needs to be active is expressed
          as a run time value. For example, the insertion into <code class="computeroutput"><span class="identifier">set</span></code>
          above could be written like this:
        </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;::</span><span class="identifier">iterator</span> <span class="identifier">it</span><span class="special">;</span>
<span class="comment">// Initially create an inactive scope guard to revert the insertion</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_fail</span> <span class="identifier">set_rollback</span><span class="special">([&amp;</span><span class="identifier">set</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">it</span><span class="special">]</span> <span class="special">{</span> <span class="identifier">set</span><span class="special">.</span><span class="identifier">erase</span><span class="special">(</span><span class="identifier">it</span><span class="special">);</span> <span class="special">},</span> <span class="keyword">false</span><span class="special">);</span>

<span class="comment">// Try insering a new element into the set</span>
<span class="keyword">bool</span> <span class="identifier">inserted</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">tie</span><span class="special">(</span><span class="identifier">it</span><span class="special">,</span> <span class="identifier">inserted</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">set</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">value</span><span class="special">);</span> <span class="comment">// may throw</span>

<span class="comment">// Activate the scope guard only if the element was inserted</span>
<span class="identifier">set_rollback</span><span class="special">.</span><span class="identifier">set_active</span><span class="special">(</span><span class="identifier">inserted</span><span class="special">);</span>
</pre>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            At least one person during the Boost.Scope review <a href="https://lists.boost.org/Archives/boost/2023/11/255424.php" target="_top">noted</a>
            that <code class="computeroutput"><span class="identifier">release</span><span class="special">()</span></code>
            is a poor name in the context of scope guards. This, and the fact that
            a method with a <code class="computeroutput"><span class="keyword">bool</span></code> argument
            is more flexible and provides the same functionality, is why Boost.Scope
            does not provide <code class="computeroutput"><span class="identifier">release</span><span class="special">()</span></code>.
          </p></td></tr>
</table></div>
<p>
          In addition to <code class="computeroutput"><span class="identifier">set_active</span><span class="special">()</span></code>, Boost.Scope scope guards can be queried
          whether they are active via the <code class="computeroutput"><span class="identifier">active</span><span class="special">()</span></code> method. This feature has no equivalent
          in the TS.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="scope.scope_guards.comparison_with_library_fundamentals_ts.relaxed_dtor_noexcept"></a><a class="link" href="scope_guards.html#scope.scope_guards.comparison_with_library_fundamentals_ts.relaxed_dtor_noexcept" title="Relaxed noexcept specification on destructors">Relaxed
        <code class="computeroutput"><span class="keyword">noexcept</span></code> specification on destructors</a>
</h4></div></div></div>
<p>
          In the Library Fundamentals TS, only <code class="computeroutput"><span class="identifier">scope_success</span></code>
          action is allowed to throw exceptions, while <code class="computeroutput"><span class="identifier">scope_fail</span></code>
          and <code class="computeroutput"><span class="identifier">scope_exit</span></code> destructors
          are unconditionally marked <code class="computeroutput"><span class="keyword">noexcept</span></code>.
          Since the TS does not support custom condition functions, <code class="computeroutput"><span class="identifier">scope_fail</span></code> can only invoke its action
          while an exception is unwinding the stack, so throwing an exception from
          the scope guard action would cause the program to terminate. In case of
          <code class="computeroutput"><span class="identifier">scope_exit</span></code> the justification
          is less definitive, as this scope guard may invoke its action when no exception
          is in flight. However, the situation when the action is called due to an
          exception is still possible, and the TS takes a conservative approach by
          prohibiting the action to throw exceptions.
        </p>
<p>
          Boost.Scope takes a different approach. Since all three scope guards support
          custom condition functions, each of them may invoke its action whether
          or not an exception is propagating through the stack. The notion of "failure"
          is no longer equivalent to "exception", so even for a <code class="computeroutput"><a class="link" href="../doxygen/reference/classboost_1_1scope_1_1scope__fail.html" title="Class template scope_fail">scope_fail</a></code> scope guard with
          a custom failure condition it may make sense to allow throwing exceptions.
          Therefore, for all scope guards provided by Boost.Scope, their destructors
          are <code class="computeroutput"><span class="keyword">noexcept</span></code> only if their
          action and condition functions are both marked <code class="computeroutput"><span class="keyword">noexcept</span></code>.
          It is user's responsibity to ensure that the scope guard actions and conditions
          do not throw exceptions when another exception is in flight. The user may
          even perform a runtime check with <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">uncaught_exceptions</span></code>,
          if needed. If the user is willing to enforce the non-throwing guarantee
          for his scope guards, he is able to do this by marking his action functions
          <code class="computeroutput"><span class="keyword">noexcept</span></code>:
        </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">scope</span><span class="special">::</span><span class="identifier">scope_exit</span> <span class="identifier">guard</span><span class="special">([&amp;]()</span> <span class="keyword">noexcept</span> <span class="special">{</span> <span class="comment">/* I promise I won't throw */</span> <span class="special">});</span>
</pre>
<p>
          While this allows more scope guards to throw exceptions, it makes no difference
          in behavior when the action throws during an exception propagation. Whether
          the scope guard's destructor is marked <code class="computeroutput"><span class="keyword">noexcept</span></code>
          or not, the program will terminate either way in this case.
        </p>
<p>
          This Boost.Scope feature cannot be emulated with TS scope guards (other
          than when the use case fits <code class="computeroutput"><span class="identifier">scope_success</span></code>).
        </p>
</div>
</div>
</div>
<div class="copyright-footer">Copyright © 2022-2024 Andrey Semashev<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="https://www.boost.org/LICENSE_1_0.txt" target="_top">https://www.boost.org/LICENSE_1_0.txt</a>).
      </p>
</div>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="install_compat.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="unique_resource.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
