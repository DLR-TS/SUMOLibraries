<?xml version="1.0" standalone="yes"?>
<library-reference id="boost_sort_c___reference"><title>Boost.Sort C++ Reference</title><header id="doxygen.boost_sort_c___reference.pdqsort_8hpp" name="boost/sort/pdqsort/pdqsort.hpp">
<namespace name="boost">
<namespace name="sort">
<function id="doxygen.boost_sort_c___reference.pdqsort_8hpp_1adddfff1361acf7a3f2ef939d94d8ac5b" name="pdqsort"><type>void</type><template>
          <template-type-parameter name="Iter"/>
          <template-type-parameter name="Compare"/>
        </template><parameter name="first"><paramtype>Iter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>Iter</paramtype><description><para>Iterator pointing to one beyond the end of data. </para></description></parameter><parameter name="comp"><paramtype>Compare</paramtype><description><para>A binary functor that returns whether the first element passed to it should go before the second in order. </para></description></parameter><purpose>Generic sort algorithm using random access iterators and a user-defined comparison operator. </purpose><description><para><computeroutput>pdqsort</computeroutput> is a fast generic sorting algorithm that is similar in concept to introsort but runs faster on certain patterns. <computeroutput>pdqsort</computeroutput> is in-place, unstable, deterministic, has a worst case runtime of <emphasis>O(N * lg(N))</emphasis> and a best case of <emphasis>O(N)</emphasis>. Even without patterns, the quicksort has been very efficiently implemented, and <computeroutput>pdqsort</computeroutput> runs 1-5% faster than GCC 6.2's <computeroutput>std::sort</computeroutput>. If the type being sorted is <computeroutput>std::is_arithmetic</computeroutput> and Compare is <computeroutput>std::less</computeroutput> or <computeroutput>std::greater</computeroutput> this function will automatically use <computeroutput>pdqsort_branchless</computeroutput> for far greater speedups.</para><para>







<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<warning><para>Throwing an exception may cause data loss. </para>
</warning>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/MoveAssignable">MoveAssignable</ulink> </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/MoveConstructible">MoveConstructible</ulink> </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</ulink> </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><returns><para><computeroutput>void</computeroutput>.</para>
</returns><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), functors, or any operations on iterators throw. </simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.pdqsort_8hpp_1a352cf5d780ed4c4183362e3101f85a1d" name="pdqsort_branchless"><type>void</type><template>
          <template-type-parameter name="Iter"/>
          <template-type-parameter name="Compare"/>
        </template><parameter name="first"><paramtype>Iter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>Iter</paramtype><description><para>Iterator pointing to one beyond the end of data. </para></description></parameter><parameter name="comp"><paramtype>Compare</paramtype><description><para>A binary functor that returns whether the first element passed to it should go before the second in order. </para></description></parameter><purpose>Generic sort algorithm using random access iterators and a user-defined comparison operator. </purpose><description><para><computeroutput>pdqsort_branchless</computeroutput> is a fast generic sorting algorithm that is similar in concept to introsort but runs faster on certain patterns. <computeroutput>pdqsort_branchless</computeroutput> is in-place, unstable, deterministic, has a worst case runtime of <emphasis>O(N * lg(N))</emphasis> and a best case of <emphasis>O(N)</emphasis>. Even without patterns, the quicksort has been very efficiently implemented with block based partitioning, and <computeroutput>pdqsort_branchless</computeroutput> runs 80-90% faster than GCC 6.2's <computeroutput>std::sort</computeroutput> when sorting small data such as integers. However, this speedup is gained by totally bypassing the branch predictor, if your comparison operator or iterator contains branches you will most likely see little gain or a small loss in performance.</para><para>







<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<warning><para>Throwing an exception may cause data loss. </para>
</warning>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/MoveAssignable">MoveAssignable</ulink> </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/MoveConstructible">MoveConstructible</ulink> </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</ulink> </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><returns><para><computeroutput>void</computeroutput>.</para>
</returns><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), functors, or any operations on iterators throw. </simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.pdqsort_8hpp_1ab421a2ff7179433aef01ee44418c582e" name="pdqsort"><type>void</type><template>
          <template-type-parameter name="Iter"/>
        </template><parameter name="first"><paramtype>Iter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>Iter</paramtype><description><para>Iterator pointing to one beyond the end of data. </para></description></parameter><purpose>Generic sort algorithm using random access iterators. </purpose><description><para><computeroutput>pdqsort</computeroutput> is a fast generic sorting algorithm that is similar in concept to introsort but runs faster on certain patterns. <computeroutput>pdqsort</computeroutput> is in-place, unstable, deterministic, has a worst case runtime of <emphasis>O(N * lg(N))</emphasis> and a best case of <emphasis>O(N)</emphasis>. Even without patterns, the quicksort partitioning has been very efficiently implemented, and <computeroutput>pdqsort</computeroutput> runs 80-90% faster than GCC 6.2's <computeroutput>std::sort</computeroutput>. If the type being sorted is <computeroutput>std::is_arithmetic</computeroutput> this function will automatically use <computeroutput>pdqsort_branchless</computeroutput>.</para><para>







<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<warning><para>Throwing an exception may cause data loss. </para>
</warning>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/MoveAssignable">MoveAssignable</ulink> </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/MoveConstructible">MoveConstructible</ulink> </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</ulink> </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><returns><para><computeroutput>void</computeroutput>.</para>
</returns><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), functors, or any operations on iterators throw. </simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.pdqsort_8hpp_1a20e2f4c8b9ed5fed4fd00cf73304125e" name="pdqsort_branchless"><type>void</type><template>
          <template-type-parameter name="Iter"/>
        </template><parameter name="first"><paramtype>Iter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>Iter</paramtype><description><para>Iterator pointing to one beyond the end of data. </para></description></parameter><purpose>Generic sort algorithm using random access iterators. </purpose><description><para><computeroutput>pdqsort_branchless</computeroutput> is a fast generic sorting algorithm that is similar in concept to introsort but runs faster on certain patterns. <computeroutput>pdqsort_branchless</computeroutput> is in-place, unstable, deterministic, has a worst case runtime of <emphasis>O(N * lg(N))</emphasis> and a best case of <emphasis>O(N)</emphasis>. Even without patterns, the quicksort has been very efficiently implemented with block based partitioning, and <computeroutput>pdqsort_branchless</computeroutput> runs 80-90% faster than GCC 6.2's <computeroutput>std::sort</computeroutput> when sorting small data such as integers. However, this speedup is gained by totally bypassing the branch predictor, if your comparison operator or iterator contains branches you will most likely see little gain or a small loss in performance.</para><para>







<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<warning><para>Throwing an exception may cause data loss. </para>
</warning>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/MoveAssignable">MoveAssignable</ulink> </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/MoveConstructible">MoveConstructible</ulink> </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</ulink> </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><returns><para><computeroutput>void</computeroutput>.</para>
</returns><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), functors, or any operations on iterators throw. </simpara>
</throws></function>
</namespace>
</namespace>
<macro id="doxygen.boost_sort_c___reference.pdqsort_8hpp_1a5ec42d1a9784dc74131fab9bf920b27d" name="BOOST_PDQSORT_PREFER_MOVE" kind="functionlike"><macro-parameter name="x"/></macro>
</header>
<header id="doxygen.boost_sort_c___reference.float__sort_8hpp" name="boost/sort/spreadsort/float_sort.hpp">
<namespace name="boost">
<namespace name="sort">
<namespace name="spreadsort">

























<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1aab8b153d3ef535b944e1218e1b882550" name="float_mem_cast"><type>Cast_type</type><template>
          <template-type-parameter name="Data_type"><purpose><para>Floating-point IEEE 754/IEC559 type. </para></purpose></template-type-parameter>
          <template-type-parameter name="Cast_type"><purpose><para>Integer type (same size) to which to cast.</para></purpose></template-type-parameter>
        </template><parameter name="data"><paramtype>const Data_type &amp;</paramtype></parameter><purpose>Casts a float to the specified integer type. </purpose><description><para>
<formalpara><title>Example:</title><para><programlisting language="c++">struct rightshift {
  int operator()(const DATA_TYPE &amp;x, const unsigned offset) const {
    return float_mem_cast&lt;KEY_TYPE, CAST_TYPE&gt;(x.key) &gt;&gt; offset;
  }
};
</programlisting> </para>
</formalpara>
</para></description></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a48eb6c87a87c6a13048e60ed7595d32f" name="float_sort"><type>void</type><template>
          <template-type-parameter name="RandomAccessIter"/>
        </template><parameter name="first"><paramtype>RandomAccessIter</paramtype></parameter><parameter name="last"><paramtype>RandomAccessIter</paramtype></parameter><description><para>\brief @c float_sort with casting to the appropriate size.

\param[in] first Iterator pointer to first element.
\param[in] last Iterator pointing to one beyond the end of data.
</para><para>Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
 <ulink url="../../doc/graph/windows_float_sort.htm">windows_float_sort</ulink> <sbr/>
 <ulink url="../../doc/graph/osx_float_sort.htm">osx_float_sort</ulink></para><para><formalpara><title>A simple example of sorting some floating-point is:</title><para><programlisting language="c++">vector&lt;float&gt; vec;
vec.push_back(1.0);
vec.push_back(2.3);
vec.push_back(1.3);
<link linkend="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1aa143c1e3a5c287ef971515883077fa0e">spreadsort</link>(vec.begin(), vec.end());
</programlisting> </para>
</formalpara>
<formalpara><title>The sorted vector contains ascending values "1.0 1.3 2.3".</title><para/>
</formalpara>
</para></description></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a665f9b0e0efa9a802144b24af8a16566" name="float_sort"><type>void</type><template>
          <template-type-parameter name="Range"/>
        </template><parameter name="range"><paramtype>Range &amp;</paramtype><description><para>Range [first, last) for sorting. </para></description></parameter><purpose>Floating-point sort algorithm using range. </purpose><description><para>
</para></description></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a2544b731b91ab79b52a038649260c581" name="float_sort"><type>void</type><template>
          <template-type-parameter name="RandomAccessIter"/>
          <template-type-parameter name="Right_shift"/>
        </template><parameter name="first"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointing to one beyond the end of data. </para></description></parameter><parameter name="rshift"><paramtype>Right_shift</paramtype><description><para>Functor that returns the result of shifting the value_type right a specified number of bits. </para></description></parameter><purpose>Floating-point sort algorithm using random access iterators with just right-shift functor. </purpose><description><para>
</para></description></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a108a128d005a7160c51fdd3b7d507ce0" name="float_sort"><type>void</type><template>
          <template-type-parameter name="Range"/>
          <template-type-parameter name="Right_shift"/>
        </template><parameter name="range"><paramtype>Range &amp;</paramtype><description><para>Range [first, last) for sorting. </para></description></parameter><parameter name="rshift"><paramtype>Right_shift</paramtype><description><para>Functor that returns the result of shifting the value_type right a specified number of bits. </para></description></parameter><purpose>Floating-point sort algorithm using range with just right-shift functor. </purpose><description><para>
</para></description></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1ace960bdb6bc3cbb523549171612dff0d" name="float_sort"><type>void</type><template>
          <template-type-parameter name="RandomAccessIter"/>
          <template-type-parameter name="Right_shift"/>
          <template-type-parameter name="Compare"/>
        </template><parameter name="first"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointing to one beyond the end of data. </para></description></parameter><parameter name="rshift"><paramtype>Right_shift</paramtype><description><para>Functor that returns the result of shifting the value_type right a specified number of bits. </para></description></parameter><parameter name="comp"><paramtype>Compare</paramtype><description><para>A binary functor that returns whether the first element passed to it should go before the second in order. </para></description></parameter><purpose>Float sort algorithm using random access iterators with both right-shift and user-defined comparison operator. </purpose><description><para>
</para></description></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1ad3a3e7b14af26d7f2328a9ed5c3cdd76" name="float_sort"><type>void</type><template>
          <template-type-parameter name="Range"/>
          <template-type-parameter name="Right_shift"/>
          <template-type-parameter name="Compare"/>
        </template><parameter name="range"><paramtype>Range &amp;</paramtype><description><para>Range [first, last) for sorting. </para></description></parameter><parameter name="rshift"><paramtype>Right_shift</paramtype><description><para>Functor that returns the result of shifting the value_type right a specified number of bits. </para></description></parameter><parameter name="comp"><paramtype>Compare</paramtype><description><para>A binary functor that returns whether the first element passed to it should go before the second in order. </para></description></parameter><purpose>Float sort algorithm using range with both right-shift and user-defined comparison operator. </purpose><description><para>
</para></description></function>
</namespace>




</namespace>
</namespace>
</header>
<header id="doxygen.boost_sort_c___reference.integer__sort_8hpp" name="boost/sort/spreadsort/integer_sort.hpp">
<namespace name="boost">
<namespace name="sort">
<namespace name="spreadsort">



















<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a52c38ef0d053ecdf4428dd5d0ad97070" name="integer_sort"><type>void</type><template>
          <template-type-parameter name="RandomAccessIter"/>
        </template><parameter name="first"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointing to one beyond the end of data.</para></description></parameter><purpose>Integer sort algorithm using random access iterators. (All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; <computeroutput>detail::min_sort_size</computeroutput>). </purpose><description><para><computeroutput>integer_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>integer_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <computeroutput>s</computeroutput> is <computeroutput>max_splits</computeroutput>, which defaults to 11, so its worst-case with default settings for 32-bit integers is <emphasis> O(N * ((32/11) </emphasis> slow radix-based iterations fast comparison-based iterations).<sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
 <ulink url="../../doc/graph/windows_integer_sort.htm">windows_integer_sort</ulink> <sbr/>
 <ulink url="../../doc/graph/osx_integer_sort.htm">osx_integer_sort</ulink></para><para>






<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is mutable. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</ulink> </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> supports the <computeroutput>operator&gt;&gt;</computeroutput>, which returns an integer-type right-shifted a specified number of bits. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a4193608cc66cd838229074a9aa21c08d" name="integer_sort"><type>void</type><template>
          <template-type-parameter name="Range"/>
        </template><parameter name="range"><paramtype>Range &amp;</paramtype><description><para>Range [first, last) for sorting.</para></description></parameter><purpose>Integer sort algorithm using range. (All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; <computeroutput>detail::min_sort_size</computeroutput>). </purpose><description><para><computeroutput>integer_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>integer_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <computeroutput>s</computeroutput> is <computeroutput>max_splits</computeroutput>, which defaults to 11, so its worst-case with default settings for 32-bit integers is <emphasis> O(N * ((32/11) </emphasis> slow radix-based iterations fast comparison-based iterations).<sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
 <ulink url="../../doc/graph/windows_integer_sort.htm">windows_integer_sort</ulink> <sbr/>
 <ulink url="../../doc/graph/osx_integer_sort.htm">osx_integer_sort</ulink></para><para>



<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1af0c44e0faf716fa1aefc365c55dee7b5" name="integer_sort"><type>void</type><template>
          <template-type-parameter name="RandomAccessIter"/>
          <template-type-parameter name="Right_shift"/>
          <template-type-parameter name="Compare"/>
        </template><parameter name="first"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointing to one beyond the end of data. </para></description></parameter><parameter name="shift"><paramtype>Right_shift</paramtype><description><para>Functor that returns the result of shifting the value_type right a specified number of bits. </para></description></parameter><parameter name="comp"><paramtype>Compare</paramtype><description><para>A binary functor that returns whether the first element passed to it should go before the second in order.</para></description></parameter><purpose>Integer sort algorithm using random access iterators with both right-shift and user-defined comparison operator. (All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; <computeroutput>detail::min_sort_size</computeroutput>). </purpose><description><para><computeroutput>integer_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>integer_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <computeroutput>s</computeroutput> is <computeroutput>max_splits</computeroutput>, which defaults to 11, so its worst-case with default settings for 32-bit integers is <emphasis> O(N * ((32/11) </emphasis> slow radix-based iterations fast comparison-based iterations).<sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
 <ulink url="../../doc/graph/windows_integer_sort.htm">windows_integer_sort</ulink> <sbr/>
 <ulink url="../../doc/graph/osx_integer_sort.htm">osx_integer_sort</ulink></para><para>





<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is mutable. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><returns><para><computeroutput>void</computeroutput>.</para>
</returns><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a7ac6209615aa55eafa3b47c5bba56d4b" name="integer_sort"><type>void</type><template>
          <template-type-parameter name="Range"/>
          <template-type-parameter name="Right_shift"/>
          <template-type-parameter name="Compare"/>
        </template><parameter name="range"><paramtype>Range &amp;</paramtype><description><para>Range [first, last) for sorting. </para></description></parameter><parameter name="shift"><paramtype>Right_shift</paramtype><description><para>Functor that returns the result of shifting the value_type right a specified number of bits. </para></description></parameter><parameter name="comp"><paramtype>Compare</paramtype><description><para>A binary functor that returns whether the first element passed to it should go before the second in order.</para></description></parameter><purpose>Integer sort algorithm using range with both right-shift and user-defined comparison operator. (All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; <computeroutput>detail::min_sort_size</computeroutput>). </purpose><description><para><computeroutput>integer_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>integer_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <computeroutput>s</computeroutput> is <computeroutput>max_splits</computeroutput>, which defaults to 11, so its worst-case with default settings for 32-bit integers is <emphasis> O(N * ((32/11) </emphasis> slow radix-based iterations fast comparison-based iterations).<sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
 <ulink url="../../doc/graph/windows_integer_sort.htm">windows_integer_sort</ulink> <sbr/>
 <ulink url="../../doc/graph/osx_integer_sort.htm">osx_integer_sort</ulink></para><para>




<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><returns><para><computeroutput>void</computeroutput>.</para>
</returns><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a5dac4deaae147b66a6b061294d196218" name="integer_sort"><type>void</type><template>
          <template-type-parameter name="RandomAccessIter"/>
          <template-type-parameter name="Right_shift"/>
        </template><parameter name="first"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointing to one beyond the end of data. </para></description></parameter><parameter name="shift"><paramtype>Right_shift</paramtype><description><para>A functor that returns the result of shifting the value_type right a specified number of bits.</para></description></parameter><purpose>Integer sort algorithm using random access iterators with just right-shift functor. (All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; <computeroutput>detail::min_sort_size</computeroutput>). </purpose><description><para><computeroutput>integer_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
 <formalpara><title>Performance:</title><para>Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>integer_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <computeroutput>s</computeroutput> is <computeroutput>max_splits</computeroutput>, which defaults to 11, so its worst-case with default settings for 32-bit integers is <emphasis> O(N * ((32/11) </emphasis> slow radix-based iterations fast comparison-based iterations).<sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
 <ulink url="../../doc/graph/windows_integer_sort.htm">windows_integer_sort</ulink><sbr/>
 <ulink url="../../doc/graph/osx_integer_sort.htm">osx_integer_sort</ulink></para>
</formalpara>






<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is mutable. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</ulink> </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a1101cc6362857496268bce5144f6f544" name="integer_sort"><type>void</type><template>
          <template-type-parameter name="Range"/>
          <template-type-parameter name="Right_shift"/>
        </template><parameter name="range"><paramtype>Range &amp;</paramtype><description><para>Range [first, last) for sorting. </para></description></parameter><parameter name="shift"><paramtype>Right_shift</paramtype><description><para>A functor that returns the result of shifting the value_type right a specified number of bits.</para></description></parameter><purpose>Integer sort algorithm using range with just right-shift functor. (All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; <computeroutput>detail::min_sort_size</computeroutput>). </purpose><description><para><computeroutput>integer_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
 <formalpara><title>Performance:</title><para>Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>integer_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <computeroutput>s</computeroutput> is <computeroutput>max_splits</computeroutput>, which defaults to 11, so its worst-case with default settings for 32-bit integers is <emphasis> O(N * ((32/11) </emphasis> slow radix-based iterations fast comparison-based iterations).<sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
 <ulink url="../../doc/graph/windows_integer_sort.htm">windows_integer_sort</ulink><sbr/>
 <ulink url="../../doc/graph/osx_integer_sort.htm">osx_integer_sort</ulink></para>
</formalpara>




<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>







</namespace>




</namespace>
</namespace>
</header>
<header id="doxygen.boost_sort_c___reference.spreadsort_8hpp" name="boost/sort/spreadsort/spreadsort.hpp">
<namespace name="boost">
<namespace name="sort">
<namespace name="spreadsort">














<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1aa143c1e3a5c287ef971515883077fa0e" name="spreadsort"><type>boost::enable_if_c&lt; std::numeric_limits&lt; typenamestd::iterator_traits&lt; RandomAccessIter &gt;::value_type &gt;::is_integer, void &gt;::type</type><template>
          <template-type-parameter name="RandomAccessIter"/>
        </template><parameter name="first"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointing to one beyond the end of data.</para></description></parameter><purpose>Generic <computeroutput>spreadsort</computeroutput> variant detecting integer-type elements so call to <computeroutput>integer_sort</computeroutput>. </purpose><description><para>If the data type provided is an integer, <computeroutput>integer_sort</computeroutput> is used. <note><para>Sorting other data types requires picking between <computeroutput>integer_sort</computeroutput>, <computeroutput>float_sort</computeroutput> and <computeroutput>string_sort</computeroutput> directly, as <computeroutput>spreadsort</computeroutput> won't accept types that don't have the appropriate <computeroutput>type_traits</computeroutput>. </para>
</note>






</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is mutable. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</ulink> </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> supports the <computeroutput>operator&gt;&gt;</computeroutput>, which returns an integer-type right-shifted a specified number of bits. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order. </para>
</postconditions></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a51394cf971edadc344af184931559053" name="spreadsort"><type>boost::enable_if_c&lt;!std::numeric_limits&lt; typenamestd::iterator_traits&lt; RandomAccessIter &gt;::value_type &gt;::is_integer &amp;&amp;std::numeric_limits&lt; typenamestd::iterator_traits&lt; RandomAccessIter &gt;::value_type &gt;::is_iec559, void &gt;::type</type><template>
          <template-type-parameter name="RandomAccessIter"/>
        </template><parameter name="first"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointing to one beyond the end of data.</para></description></parameter><purpose>Generic <computeroutput>spreadsort</computeroutput> variant detecting float element type so call to <computeroutput>float_sort</computeroutput>. </purpose><description><para>If the data type provided is a float or castable-float, <computeroutput>float_sort</computeroutput> is used. <note><para>Sorting other data types requires picking between <computeroutput>integer_sort</computeroutput>, <computeroutput>float_sort</computeroutput> and <computeroutput>string_sort</computeroutput> directly, as <computeroutput>spreadsort</computeroutput> won't accept types that don't have the appropriate <computeroutput>type_traits</computeroutput>.</para>
</note>






</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is mutable. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</ulink> </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> supports the <computeroutput>operator&gt;&gt;</computeroutput>, which returns an integer-type right-shifted a specified number of bits. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order. </para>
</postconditions></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a3c1cea14929a59760e8452233dfac777" name="spreadsort"><type>boost::enable_if_c&lt; is_same&lt; typenamestd::iterator_traits&lt; RandomAccessIter &gt;::value_type, typenamestd::string &gt;::value, void &gt;::type</type><template>
          <template-type-parameter name="RandomAccessIter"/>
        </template><parameter name="first"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointing to one beyond the end of data.</para></description></parameter><purpose>Generic <computeroutput>spreadsort</computeroutput> variant detecting string element type so call to <computeroutput>string_sort</computeroutput> for <computeroutput>std::strings</computeroutput>. </purpose><description><para>If the data type provided is a string, <computeroutput>string_sort</computeroutput> is used. <note><para>Sorting other data types requires picking between <computeroutput>integer_sort</computeroutput>, <computeroutput>float_sort</computeroutput> and <computeroutput>string_sort</computeroutput> directly, as <computeroutput>spreadsort</computeroutput> won't accept types that don't have the appropriate <computeroutput>type_traits</computeroutput>.</para>
</note>






</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is mutable. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</ulink> </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> supports the <computeroutput>operator&gt;&gt;</computeroutput>, which returns an integer-type right-shifted a specified number of bits. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order. </para>
</postconditions></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a9165bd5b505bbc065441d3cd089e5b32" name="spreadsort"><type>boost::enable_if_c&lt; is_same&lt; typenamestd::iterator_traits&lt; RandomAccessIter &gt;::value_type, typenamestd::wstring &gt;::value &amp;&amp;sizeof(wchar_t)==2, void &gt;::type</type><template>
          <template-type-parameter name="RandomAccessIter"/>
        </template><parameter name="first"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointing to one beyond the end of data.</para></description></parameter><purpose>Generic <computeroutput>spreadsort</computeroutput> variant detecting string element type so call to <computeroutput>string_sort</computeroutput> for <computeroutput>std::wstrings</computeroutput>. </purpose><description><para>If the data type provided is a wstring, <computeroutput>string_sort</computeroutput> is used. <note><para>Sorting other data types requires picking between <computeroutput>integer_sort</computeroutput>, <computeroutput>float_sort</computeroutput> and <computeroutput>string_sort</computeroutput> directly, as <computeroutput>spreadsort</computeroutput> won't accept types that don't have the appropriate <computeroutput>type_traits</computeroutput>. Also, 2-byte wide-characters are the limit above which string_sort is inefficient, so on platforms with wider characters, this will not accept wstrings.</para>
</note>






</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is mutable. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</ulink> </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> supports the <computeroutput>operator&gt;&gt;</computeroutput>, which returns an integer-type right-shifted a specified number of bits. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order. </para>
</postconditions></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1ac355a603dcfeef332a8cfc20d5dc438e" name="spreadsort"><type>void</type><template>
          <template-type-parameter name="Range"/>
        </template><parameter name="range"><paramtype>Range &amp;</paramtype><description><para>Range [first, last) for sorting.</para></description></parameter><purpose>Generic <computeroutput>spreadsort</computeroutput> variant detects value_type and calls required sort function. </purpose><description><para><note><para>Sorting other data types requires picking between <computeroutput>integer_sort</computeroutput>, <computeroutput>float_sort</computeroutput> and <computeroutput>string_sort</computeroutput> directly, as <computeroutput>spreadsort</computeroutput> won't accept types that don't have the appropriate <computeroutput>type_traits</computeroutput>.</para>
</note>



</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order. </para>
</postconditions></function>













</namespace>




</namespace>
</namespace>
</header>
<header id="doxygen.boost_sort_c___reference.string__sort_8hpp" name="boost/sort/spreadsort/string_sort.hpp">
<namespace name="boost">
<namespace name="sort">
<namespace name="spreadsort">
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a570174ec84a69d1affbfcbd78f5fb567" name="string_sort"><type>void</type><template>
          <template-type-parameter name="RandomAccessIter"><purpose><para><ulink url="http://www.cplusplus.com/reference/iterator/RandomAccessIterator/">Random access iterator</ulink> </para></purpose></template-type-parameter>
          <template-type-parameter name="Unsigned_char_type"><purpose><para>Unsigned character type used for string. </para></purpose></template-type-parameter>
        </template><parameter name="first"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointing to one beyond the end of data. </para></description></parameter><parameter name="unused"><paramtype>Unsigned_char_type</paramtype><description><para>value with the same type as the result of the [] operator, defining the Unsigned_char_type. The actual value is unused.</para></description></parameter><purpose>String sort algorithm using random access iterators, allowing character-type overloads.<sbr/>
 (All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; <computeroutput>detail::min_sort_size</computeroutput>). </purpose><description><para><computeroutput>string_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
<formalpara><title/><para>Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>string_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
<ulink url="../../doc/graph/windows_string_sort.htm">windows_string_sort</ulink><sbr/>
<ulink url="../../doc/graph/osx_string_sort.htm">osx_string_sort</ulink></para>
</formalpara>








<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is mutable. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</ulink> </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> supports the <computeroutput>operator&gt;&gt;</computeroutput>, which returns an integer-type right-shifted a specified number of bits. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a5fca79cd8320d713a3ab114d9542418a" name="string_sort"><type>void</type><template>
          <template-type-parameter name="Range"/>
          <template-type-parameter name="Unsigned_char_type"><purpose><para>Unsigned character type used for string. </para></purpose></template-type-parameter>
        </template><parameter name="range"><paramtype>Range &amp;</paramtype><description><para>Range [first, last) for sorting. </para></description></parameter><parameter name="unused"><paramtype>Unsigned_char_type</paramtype><description><para>value with the same type as the result of the [] operator, defining the Unsigned_char_type. The actual value is unused.</para></description></parameter><purpose>String sort algorithm using range, allowing character-type overloads.<sbr/>
 (All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; <computeroutput>detail::min_sort_size</computeroutput>). </purpose><description><para><computeroutput>string_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
<formalpara><title/><para>Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>string_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
<ulink url="../../doc/graph/windows_string_sort.htm">windows_string_sort</ulink><sbr/>
<ulink url="../../doc/graph/osx_string_sort.htm">osx_string_sort</ulink></para>
</formalpara>





<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1ac36b3e2777cf78ab7ebf097926cfa191" name="string_sort"><type>void</type><template>
          <template-type-parameter name="RandomAccessIter"/>
        </template><parameter name="first"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointing to one beyond the end of data.</para></description></parameter><purpose>String sort algorithm using random access iterators, wraps using default of unsigned char. (All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; <computeroutput>detail::min_sort_size</computeroutput>). </purpose><description><para><computeroutput>string_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>string_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
 <ulink url="../../doc/graph/windows_string_sort.htm">windows_string_sort</ulink> <sbr/>
 <ulink url="../../doc/graph/osx_string_sort.htm">osx_string_sort</ulink></para><para>






<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is mutable. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</ulink> </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> supports the <computeroutput>operator&gt;&gt;</computeroutput>, which returns an integer-type right-shifted a specified number of bits. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a809ce0c3a87429f9b93ccb0468408814" name="string_sort"><type>void</type><template>
          <template-type-parameter name="Range"/>
        </template><parameter name="range"><paramtype>Range &amp;</paramtype><description><para>Range [first, last) for sorting.</para></description></parameter><purpose>String sort algorithm using range, wraps using default of unsigned char. (All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; <computeroutput>detail::min_sort_size</computeroutput>). </purpose><description><para><computeroutput>string_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>string_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
 <ulink url="../../doc/graph/windows_string_sort.htm">windows_string_sort</ulink> <sbr/>
 <ulink url="../../doc/graph/osx_string_sort.htm">osx_string_sort</ulink></para><para>



<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a4dfeb97d6b2a168375656f2de144f442" name="reverse_string_sort"><type>void</type><template>
          <template-type-parameter name="RandomAccessIter"><purpose><para><ulink url="http://www.cplusplus.com/reference/iterator/RandomAccessIterator/">Random access iterator</ulink> </para></purpose></template-type-parameter>
          <template-type-parameter name="Compare"/>
          <template-type-parameter name="Unsigned_char_type"><purpose><para>Unsigned character type used for string.</para></purpose></template-type-parameter>
        </template><parameter name="first"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointing to one beyond the end of data. </para></description></parameter><parameter name="comp"><paramtype>Compare</paramtype><description><para>A binary functor that returns whether the first element passed to it should go before the second in order. </para></description></parameter><parameter name="unused"><paramtype>Unsigned_char_type</paramtype><description><para>value with the same type as the result of the [] operator, defining the Unsigned_char_type. The actual value is unused.</para></description></parameter><purpose>String sort algorithm using random access iterators, allowing character-type overloads. </purpose><description><para>(All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; detail::min_sort_size).</para><para><computeroutput>string_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
<formalpara><title/><para>Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>string_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
<ulink url="../../doc/graph/windows_string_sort.htm">windows_string_sort</ulink><sbr/>
<ulink url="../../doc/graph/osx_string_sort.htm">osx_string_sort</ulink></para>
</formalpara>









<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is mutable. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</ulink> </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> supports the <computeroutput>operator&gt;&gt;</computeroutput>, which returns an integer-type right-shifted a specified number of bits. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><returns><para><computeroutput>void</computeroutput>.</para>
</returns><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a36b1af1e0ded50576c19fba4742b26ef" name="reverse_string_sort"><type>void</type><template>
          <template-type-parameter name="Range"/>
          <template-type-parameter name="Compare"/>
          <template-type-parameter name="Unsigned_char_type"><purpose><para>Unsigned character type used for string.</para></purpose></template-type-parameter>
        </template><parameter name="range"><paramtype>Range &amp;</paramtype><description><para>Range [first, last) for sorting. </para></description></parameter><parameter name="comp"><paramtype>Compare</paramtype><description><para>A binary functor that returns whether the first element passed to it should go before the second in order. </para></description></parameter><parameter name="unused"><paramtype>Unsigned_char_type</paramtype><description><para>value with the same type as the result of the [] operator, defining the Unsigned_char_type. The actual value is unused.</para></description></parameter><purpose>String sort algorithm using range, allowing character-type overloads. </purpose><description><para>(All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; detail::min_sort_size).</para><para><computeroutput>string_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>string_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
 <ulink url="../../doc/graph/windows_integer_sort.htm">windows_integer_sort</ulink> <sbr/>
 <ulink url="../../doc/graph/osx_integer_sort.htm">osx_integer_sort</ulink></para><para>





<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><returns><para><computeroutput>void</computeroutput>.</para>
</returns><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1ab59bfb76c292ac046b978e00843b910c" name="reverse_string_sort"><type>void</type><template>
          <template-type-parameter name="RandomAccessIter"/>
          <template-type-parameter name="Compare"/>
        </template><parameter name="first"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointing to one beyond the end of data. </para></description></parameter><parameter name="comp"><paramtype>Compare</paramtype><description><para>A binary functor that returns whether the first element passed to it should go before the second in order.</para></description></parameter><purpose>String sort algorithm using random access iterators, wraps using default of <computeroutput>unsigned</computeroutput> char. </purpose><description><para>(All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; <computeroutput>detail::min_sort_size</computeroutput>).</para><para><computeroutput>string_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
<formalpara><title/><para>Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>string_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms.<sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
<ulink url="../../doc/graph/windows_string_sort.htm">windows_string_sort</ulink><sbr/>
<ulink url="../../doc/graph/osx_string_sort.htm">osx_string_sort</ulink></para>
</formalpara>








<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is mutable. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</ulink> </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> supports the <computeroutput>operator&gt;&gt;</computeroutput>, which returns an integer-type right-shifted a specified number of bits. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><returns><para><computeroutput>void</computeroutput>.</para>
</returns><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a266049cfc730f787bafc63d13bf0a831" name="reverse_string_sort"><type>void</type><template>
          <template-type-parameter name="Range"/>
          <template-type-parameter name="Compare"/>
        </template><parameter name="range"><paramtype>Range &amp;</paramtype><description><para>Range [first, last) for sorting. </para></description></parameter><parameter name="comp"><paramtype>Compare</paramtype><description><para>A binary functor that returns whether the first element passed to it should go before the second in order.</para></description></parameter><purpose>String sort algorithm using range, wraps using default of <computeroutput>unsigned</computeroutput> char. </purpose><description><para>(All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; <computeroutput>detail::min_sort_size</computeroutput>).</para><para><computeroutput>string_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
<formalpara><title/><para>Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>string_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
<ulink url="../../doc/graph/windows_string_sort.htm">windows_string_sort</ulink><sbr/>
<ulink url="../../doc/graph/osx_string_sort.htm">osx_string_sort</ulink></para>
</formalpara>





<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><returns><para><computeroutput>void</computeroutput>.</para>
</returns><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a556f051d6b33a215192a4587c5c47f55" name="string_sort"><type>void</type><template>
          <template-type-parameter name="RandomAccessIter"/>
          <template-type-parameter name="Get_char"/>
          <template-type-parameter name="Get_length"/>
        </template><parameter name="first"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointing to one beyond the end of data. </para></description></parameter><parameter name="get_character"><paramtype>Get_char</paramtype><description><para>Bracket functor equivalent to <computeroutput>operator</computeroutput>[], taking a number corresponding to the character offset. </para></description></parameter><parameter name="length"><paramtype>Get_length</paramtype><description><para>Functor to get the length of the string in characters.</para></description></parameter><purpose>String sort algorithm using random access iterators, wraps using default of <computeroutput>unsigned</computeroutput> char. </purpose><description><para>(All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; <computeroutput>detail::min_sort_size</computeroutput>).</para><para><computeroutput>string_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
<formalpara><title/><para>Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>string_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
<ulink url="../../doc/graph/windows_string_sort.htm">windows_string_sort</ulink><sbr/>
<ulink url="../../doc/graph/osx_string_sort.htm">osx_string_sort</ulink></para>
</formalpara>








<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is mutable. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</ulink> </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> supports the <computeroutput>operator&gt;&gt;</computeroutput>, which returns an integer-type right-shifted a specified number of bits. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><returns><para><computeroutput>void</computeroutput>.</para>
</returns><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1af6141b4ef799d54cb42c1d1534a70535" name="string_sort"><type>void</type><template>
          <template-type-parameter name="Range"/>
          <template-type-parameter name="Get_char"/>
          <template-type-parameter name="Get_length"/>
        </template><parameter name="range"><paramtype>Range &amp;</paramtype><description><para>Range [first, last) for sorting. </para></description></parameter><parameter name="get_character"><paramtype>Get_char</paramtype><description><para>Bracket functor equivalent to <computeroutput>operator</computeroutput>[], taking a number corresponding to the character offset. </para></description></parameter><parameter name="length"><paramtype>Get_length</paramtype><description><para>Functor to get the length of the string in characters.</para></description></parameter><purpose>String sort algorithm using range, wraps using default of <computeroutput>unsigned</computeroutput> char. </purpose><description><para>(All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; <computeroutput>detail::min_sort_size</computeroutput>).</para><para><computeroutput>string_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
<formalpara><title/><para>Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>string_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
<ulink url="../../doc/graph/windows_string_sort.htm">windows_string_sort</ulink><sbr/>
<ulink url="../../doc/graph/osx_string_sort.htm">osx_string_sort</ulink></para>
</formalpara>





<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><returns><para><computeroutput>void</computeroutput>.</para>
</returns><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1af11ceeb894dab87e9cea770614c64e51" name="string_sort"><type>void</type><template>
          <template-type-parameter name="RandomAccessIter"/>
          <template-type-parameter name="Get_char"/>
          <template-type-parameter name="Get_length"/>
          <template-type-parameter name="Compare"/>
        </template><parameter name="first"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointing to one beyond the end of data. </para></description></parameter><parameter name="get_character"><paramtype>Get_char</paramtype><description><para>Bracket functor equivalent to <computeroutput>operator</computeroutput>[], taking a number corresponding to the character offset. </para></description></parameter><parameter name="length"><paramtype>Get_length</paramtype><description><para>Functor to get the length of the string in characters. </para></description></parameter><parameter name="comp"><paramtype>Compare</paramtype><description><para>A binary functor that returns whether the first element passed to it should go before the second in order.</para></description></parameter><purpose>String sort algorithm using random access iterators, wraps using default of <computeroutput>unsigned</computeroutput> char. </purpose><description><para>(All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; <computeroutput>detail::min_sort_size</computeroutput>).</para><para><computeroutput>string_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
<formalpara><title/><para>Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>string_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
<ulink url="../../doc/graph/windows_string_sort.htm">windows_string_sort</ulink><sbr/>
<ulink url="../../doc/graph/osx_string_sort.htm">osx_string_sort</ulink></para>
</formalpara>







<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is mutable. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</ulink> </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><returns><para><computeroutput>void</computeroutput>.</para>
</returns><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1ac35217c7ffc264186751d63fae114a87" name="string_sort"><type>void</type><template>
          <template-type-parameter name="Range"/>
          <template-type-parameter name="Get_char"/>
          <template-type-parameter name="Get_length"/>
          <template-type-parameter name="Compare"/>
        </template><parameter name="range"><paramtype>Range &amp;</paramtype><description><para>Range [first, last) for sorting. </para></description></parameter><parameter name="get_character"><paramtype>Get_char</paramtype><description><para>Bracket functor equivalent to <computeroutput>operator</computeroutput>[], taking a number corresponding to the character offset. </para></description></parameter><parameter name="length"><paramtype>Get_length</paramtype><description><para>Functor to get the length of the string in characters. </para></description></parameter><parameter name="comp"><paramtype>Compare</paramtype><description><para>A binary functor that returns whether the first element passed to it should go before the second in order.</para></description></parameter><purpose>String sort algorithm using range, wraps using default of <computeroutput>unsigned</computeroutput> char. </purpose><description><para>(All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; <computeroutput>detail::min_sort_size</computeroutput>).</para><para><computeroutput>string_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
<formalpara><title/><para>Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>string_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
<ulink url="../../doc/graph/windows_string_sort.htm">windows_string_sort</ulink><sbr/>
<ulink url="../../doc/graph/osx_string_sort.htm">osx_string_sort</ulink></para>
</formalpara>





<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><returns><para><computeroutput>void</computeroutput>.</para>
</returns><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a4502e6d0592a5a106dbf5d5d273841a8" name="reverse_string_sort"><type>void</type><template>
          <template-type-parameter name="RandomAccessIter"/>
          <template-type-parameter name="Get_char"/>
          <template-type-parameter name="Get_length"/>
          <template-type-parameter name="Compare"/>
        </template><parameter name="first"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointer to first element. </para></description></parameter><parameter name="last"><paramtype>RandomAccessIter</paramtype><description><para>Iterator pointing to one beyond the end of data. </para></description></parameter><parameter name="get_character"><paramtype>Get_char</paramtype><description><para>Bracket functor equivalent to <computeroutput>operator</computeroutput>[], taking a number corresponding to the character offset. </para></description></parameter><parameter name="length"><paramtype>Get_length</paramtype><description><para>Functor to get the length of the string in characters. </para></description></parameter><parameter name="comp"><paramtype>Compare</paramtype><description><para>A binary functor that returns whether the first element passed to it should go before the second in order.</para></description></parameter><purpose>Reverse String sort algorithm using random access iterators. </purpose><description><para>(All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; <computeroutput>detail::min_sort_size</computeroutput>).</para><para><computeroutput>string_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
<formalpara><title/><para>Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>string_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
<ulink url="../../doc/graph/windows_string_sort.htm">windows_string_sort</ulink><sbr/>
<ulink url="../../doc/graph/osx_string_sort.htm">osx_string_sort</ulink></para>
</formalpara>







<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is mutable. </para>
</requires><requires><para><computeroutput>RandomAccessIter</computeroutput> <computeroutput>value_type</computeroutput> is <ulink url="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</ulink> </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><returns><para><computeroutput>void</computeroutput>.</para>
</returns><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>
<function id="doxygen.boost_sort_c___reference.namespaceboost_1_1sort_1_1spreadsort_1a91ede6f2746cc8a33a54daf5d38df872" name="reverse_string_sort"><type>void</type><template>
          <template-type-parameter name="Range"/>
          <template-type-parameter name="Get_char"/>
          <template-type-parameter name="Get_length"/>
          <template-type-parameter name="Compare"/>
        </template><parameter name="range"><paramtype>Range &amp;</paramtype><description><para>Range [first, last) for sorting. </para></description></parameter><parameter name="get_character"><paramtype>Get_char</paramtype><description><para>Bracket functor equivalent to <computeroutput>operator</computeroutput>[], taking a number corresponding to the character offset. </para></description></parameter><parameter name="length"><paramtype>Get_length</paramtype><description><para>Functor to get the length of the string in characters. </para></description></parameter><parameter name="comp"><paramtype>Compare</paramtype><description><para>A binary functor that returns whether the first element passed to it should go before the second in order.</para></description></parameter><purpose>Reverse String sort algorithm using range. </purpose><description><para>(All variants fall back to <computeroutput>boost::sort::pdqsort</computeroutput> if the data size is too small, &lt; <computeroutput>detail::min_sort_size</computeroutput>).</para><para><computeroutput>string_sort</computeroutput> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <computeroutput>std::sort</computeroutput> for large tests (&gt;=100kB).<sbr/>
<formalpara><title/><para>Worst-case performance is <emphasis> O(N * (lg(range)/s + s)) </emphasis>, so <computeroutput>string_sort</computeroutput> is asymptotically faster than pure comparison-based algorithms. <sbr/>
<sbr/>
Some performance plots of runtime vs. n and log(range) are provided:<sbr/>
<ulink url="../../doc/graph/windows_string_sort.htm">windows_string_sort</ulink><sbr/>
<ulink url="../../doc/graph/osx_string_sort.htm">osx_string_sort</ulink></para>
</formalpara>





<warning><para>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </para>
</warning>
<warning><para>Invalid arguments cause undefined behaviour. </para>
</warning>
<note><para><computeroutput>spreadsort</computeroutput> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</para>
</note>
<note><para>The lesser of <emphasis> O(N*log(N)) </emphasis> comparisons and <emphasis> O(N*log(K/S + S)) </emphasis>operations worst-case, where: </para>
</note>
<note><para>* N is <computeroutput>last</computeroutput> - <computeroutput>first</computeroutput>, </para>
</note>
<note><para>* K is the log of the range in bits (32 for 32-bit integers using their full range), </para>
</note>
<note><para>* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </para>
</note>
</para></description><requires><para>[<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) is a valid range. </para>
</requires><postconditions><para>The elements in the range [<computeroutput>first</computeroutput>, <computeroutput>last</computeroutput>) are sorted in ascending order.</para>
</postconditions><returns><para><computeroutput>void</computeroutput>.</para>
</returns><throws><simpara><classname>std::exception</classname> Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</simpara>
</throws></function>


















</namespace>




</namespace>
</namespace>
</header>
</library-reference>