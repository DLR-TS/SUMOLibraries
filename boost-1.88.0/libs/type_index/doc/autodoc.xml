<?xml version="1.0" standalone="yes"?>
<library-reference id="boost_typeindex_header_reference"><title>Boost.TypeIndex Header Reference</title><header id="doxygen.boost_typeindex_header_reference.type__index_8hpp" name="boost/type_index.hpp">
<para>Includes minimal set of headers required to use the Boost.TypeIndex library. </para><para>By inclusion of this file most optimal type index classes will be included and used as a <link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a92396e4950b1278f4df4b0919f3168be">boost::typeindex::type_index</link> and <link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1acd639a0640fcc187eb762567a855b517">boost::typeindex::type_info</link>. </para><namespace name="boost">
<namespace name="typeindex">
<typedef id="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a92396e4950b1278f4df4b0919f3168be" name="type_index"><description><para>Depending on a compiler flags, optimal implementation of type_index will be used as a default <link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a92396e4950b1278f4df4b0919f3168be">boost::typeindex::type_index</link>.</para><para>Could be a <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index">boost::typeindex::stl_type_index</link>, <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index">boost::typeindex::ctti_type_index</link> or user defined type_index class.</para><para><emphasis role="bold">See</emphasis> <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade">boost::typeindex::type_index_facade</link> for a full description of type_index functions. </para></description><type>platform_specific</type></typedef>
<typedef id="doxygen.boost_typeindex_header_reference.type__index_8hpp_1acd639a0640fcc187eb762567a855b517" name="type_info"><description><para>Depending on a compiler flags, optimal implementation of type_info will be used as a default <link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1acd639a0640fcc187eb762567a855b517">boost::typeindex::type_info</link>.</para><para>Could be a std::type_info, <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1detail_1_1ctti__data">boost::typeindex::detail::ctti_data</link> or some user defined class.</para><para>type_info <emphasis role="bold">is</emphasis> <emphasis role="bold">not</emphasis> copyable or default constructible. It is <emphasis role="bold">not</emphasis> assignable too! </para></description><type>type_index::type_info_t</type></typedef>
<function id="doxygen.boost_typeindex_header_reference.type__index_8hpp_1aaa8536b5c80315f205036a85a9e8e3e2" name="type_id"><type>type_index</type><template>
          <template-type-parameter name="T"><purpose><para>Type for which type_index must be created. </para></purpose></template-type-parameter>
        </template><description><para>Function to get <link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a92396e4950b1278f4df4b0919f3168be">boost::typeindex::type_index</link> for a type T. Removes const, volatile &amp;&amp; and &amp; modifiers from T.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++"><link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a92396e4950b1278f4df4b0919f3168be">type_index</link> ti = type_id&lt;int&amp;&gt;();
std::cout &lt;&lt; ti.pretty_name();  // Outputs 'int'
</programlisting></para><para>


</para></description><returns><para><link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a92396e4950b1278f4df4b0919f3168be">boost::typeindex::type_index</link> with information about the specified type T. </para>
</returns><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></function>
<function id="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a15beb7454116a3e5aa29f30cbaad5315" name="type_id_with_cvr"><type>type_index</type><template>
          <template-type-parameter name="T"><purpose><para>Type for which type_index must be created. </para></purpose></template-type-parameter>
        </template><description><para>Function for constructing <link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a92396e4950b1278f4df4b0919f3168be">boost::typeindex::type_index</link> instance for type T. Does not remove const, volatile, &amp; and &amp;&amp; modifiers from T.</para><para>If T has no const, volatile, &amp; and &amp;&amp; modifiers, then returns exactly the same result as in case of calling <computeroutput>type_id&lt;T&gt;()</computeroutput>.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++"><link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a92396e4950b1278f4df4b0919f3168be">type_index</link> ti = type_id_with_cvr&lt;int&amp;&gt;();
std::cout &lt;&lt; ti.pretty_name();  // Outputs 'int&amp;'
</programlisting></para><para>


</para></description><returns><para><link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a92396e4950b1278f4df4b0919f3168be">boost::typeindex::type_index</link> with information about the specified type T. </para>
</returns><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></function>
<function id="doxygen.boost_typeindex_header_reference.type__index_8hpp_1ae179d82aeceebc66d4fe38985bdb9e82" name="type_id_runtime"><type>type_index</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="runtime_val"><paramtype>const T &amp;</paramtype><description><para>Variable which runtime type must be returned. </para></description></parameter><description><para>Function that works exactly like C++ typeid(rtti_val) call, but returns boost::type_index.</para><para>Returns runtime information about specified type.</para><para><emphasis role="bold">Requirements:</emphasis> RTTI available or Base and Derived classes must be marked with BOOST_TYPE_INDEX_REGISTER_CLASS.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct Base { virtual ~Base(){} };
struct Derived: public Base  {};
...
Derived d;
Base&amp; b = d;
<link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a92396e4950b1278f4df4b0919f3168be">type_index</link> ti = <link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1ae179d82aeceebc66d4fe38985bdb9e82">type_id_runtime</link>(b);
std::cout &lt;&lt; ti.pretty_name();  // Outputs 'Derived'
</programlisting></para><para>


</para></description><returns><para><link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a92396e4950b1278f4df4b0919f3168be">boost::typeindex::type_index</link> with information about the specified variable. </para>
</returns><throws><simpara><classname>Nothing.</classname> </simpara>
</throws></function>














</namespace>
</namespace>
<macro id="doxygen.boost_typeindex_header_reference.type__index_8hpp_1aa95e33fb9aa2d570e580cfbde489f6c6" name="BOOST_TYPE_INDEX_REGISTER_CLASS"><description><para>BOOST_TYPE_INDEX_REGISTER_CLASS is used to help to emulate RTTI. Put this macro into the public section of polymorphic class to allow runtime type detection.</para><para>Depending on the typeid() availability this macro will expand to nothing or to virtual helper function <computeroutput>virtual const type_info&amp; boost_type_info_type_id_runtime_() const noexcept</computeroutput>.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">class A {
public:
    BOOST_TYPE_INDEX_REGISTER_CLASS
    virtual ~A(){}
};

struct B: public A {
    BOOST_TYPE_INDEX_REGISTER_CLASS
};

struct C: public B {
    BOOST_TYPE_INDEX_REGISTER_CLASS
};

...

C c1;
A* pc1 = &amp;c1;
assert(boost::typeindex::type_id&lt;C&gt;() == boost::typeindex::type_id_runtime(*pc1));
</programlisting> </para></description></macro>
<macro id="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a5e8825576a5e3115161687310469396a" name="BOOST_TYPE_INDEX_FUNCTION_SIGNATURE"><description><para>BOOST_TYPE_INDEX_FUNCTION_SIGNATURE is used by <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index">boost::typeindex::ctti_type_index</link> class to deduce the name of a type. If your compiler is not recognized by the TypeIndex library and you wish to work with <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index">boost::typeindex::ctti_type_index</link>, you may define this macro by yourself.</para><para>BOOST_TYPE_INDEX_FUNCTION_SIGNATURE must be defined to a compiler specific macro that outputs the <emphasis role="bold">whole</emphasis> function signature <emphasis role="bold">including</emphasis> <emphasis role="bold">template</emphasis> <emphasis role="bold">parameters</emphasis>.</para><para>If your compiler is not recognised and BOOST_TYPE_INDEX_FUNCTION_SIGNATURE is not defined, then a compile-time error will arise at any attempt to use <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index">boost::typeindex::ctti_type_index</link> classes.</para><para>See BOOST_TYPE_INDEX_REGISTER_CTTI_PARSING_PARAMS and BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING for an information of how to tune the implementation to make a nice pretty_name() output. </para></description></macro>
<macro id="doxygen.boost_typeindex_header_reference.type__index_8hpp_1aa1457292331bac605f998b53d85e4422" name="BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING"><description><para>This is a helper macro for making correct pretty_names() with RTTI off.</para><para>BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING macro may be defined to '(begin_skip, end_skip, runtime_skip, runtime_skip_until)' with parameters for adding a support for compilers, that by default are not recognized by TypeIndex library.</para><para><emphasis role="bold">Example:</emphasis> </para><para>Imagine the situation when <programlisting language="c++">boost::typeindex::ctti_type_index::type_id&lt;int&gt;().pretty_name() 
</programlisting> returns the following string: <programlisting language="c++">"static const char *boost::detail::ctti&lt;int&gt;::n() [T = int]" 
</programlisting> and <programlisting language="c++">boost::typeindex::ctti_type_index::type_id&lt;short&gt;().pretty_name() 
</programlisting> returns the following: <programlisting language="c++">"static const char *boost::detail::ctti&lt;short&gt;::n() [T = short]" 
</programlisting></para><para>As we may see first 39 characters are "static const char *boost::detail::ctti&lt;" and they do not depend on the type T. After first 39 characters we have a human readable type name which is duplicated at the end of a string. String always ends on ']', which consumes 1 character.</para><para>Now if we define <computeroutput>BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING</computeroutput> to <computeroutput>(39, 1, false, "")</computeroutput> we'll be getting <programlisting language="c++">"int&gt;::n() [T = int" 
</programlisting> for <computeroutput>boost::typeindex::ctti_type_index::type_id&lt;int&gt;().pretty_name()</computeroutput> and <programlisting language="c++">"short&gt;::n() [T = short" 
</programlisting> for <computeroutput>boost::typeindex::ctti_type_index::type_id&lt;short&gt;().pretty_name()</computeroutput>.</para><para>Now we need to take additional care of the characters that go before the last mention of our type. We'll do that by telling the macro that we need to cut off everything that goes before the "T = " including the "T = " itself:</para><para><programlisting language="c++">(39, 1, true, "T = ") 
</programlisting></para><para>In case of GCC or Clang command line we need to add the following line while compiling all the sources:</para><para><programlisting language="c++">-DBOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING='(39, 1, true, "T = ")'
</programlisting> 
See <ulink url="boost_typeindex/rtti_emulation_limitations.html">RTTI emulation limitations</ulink> for more info. </para></description></macro>
<macro id="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a1f36cbfc68e152f766416d8def27bb56" name="BOOST_TYPE_INDEX_USER_TYPEINDEX"><description><para>BOOST_TYPE_INDEX_USER_TYPEINDEX can be defined to the path to header file with user provided implementation of type_index.</para><para>See <ulink url="boost_typeindex/making_a_custom_type_index.html">Making a custom type_index</ulink> section of documentation for usage example. </para></description></macro>
<macro id="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a9d2fd5c65259b62ed652f7011670c55a" name="BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY"><description><para>BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY is a helper macro that must be defined if mixing RTTI on/off modules. See <ulink url="boost_typeindex/mixing_sources_with_rtti_on_and_.html">Mixing sources with RTTI on and RTTI off</ulink> section of documentation for more info. </para></description></macro>
</header>
<header id="doxygen.boost_typeindex_header_reference.ctti__type__index_8hpp" name="boost/type_index/ctti_type_index.hpp">
<para>Contains <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index">boost::typeindex::ctti_type_index</link> class that is constexpr if C++14 constexpr is supported by compiler. </para><para><link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index">boost::typeindex::ctti_type_index</link> class can be used as a drop-in replacement for std::type_index.</para><para>It is used in situations when typeid() method is not available or BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY macro is defined. </para><namespace name="boost">
<namespace name="typeindex">
<class id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index" name="ctti_type_index"><description><para>This class is a wrapper that pretends to work exactly like <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index">stl_type_index</link>, but does not require RTTI support. <emphasis role="bold">For</emphasis> <emphasis role="bold">description</emphasis> <emphasis role="bold">of</emphasis> <emphasis role="bold">functions</emphasis> <emphasis role="bold">see</emphasis> <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade">type_index_facade</link>.</para><para>This class on C++14 compatible compilers has following functions marked as constexpr:<itemizedlist>
<listitem><para>default constructor</para>
</listitem><listitem><para>copy constructors and assignemnt operations</para>
</listitem><listitem><para>class methods: name(), before(const ctti_type_index&amp; rhs), equal(const ctti_type_index&amp; rhs)</para>
</listitem><listitem><para>static methods type_id&lt;T&gt;(), type_id_with_cvr&lt;T&gt;()</para>
</listitem><listitem><para>comparison operators</para>
</listitem></itemizedlist>
</para><para>This class produces slightly longer type names, so consider using <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index">stl_type_index</link> in situations when typeid() is working. </para></description><typedef id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index_1a043189b6e044b5c0cc111aa8cfae34da" name="type_info_t"><type><emphasis>unspecified</emphasis></type></typedef>
<method-group name="private member functions">
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index_1a44191fad83e563b19e2486aaf737f496" name="get_raw_name_length" cv="const noexcept"><type>std::size_t</type></method>
<constructor id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index_1a16392aee3f737b188ab44b17d970fb28" specifiers="explicit" cv="noexcept"><parameter name="data"><paramtype>const char *</paramtype></parameter></constructor>
</method-group>
<method-group name="public member functions">
<constructor id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index_1ade7b5fc5e0ef3a3ec8bacdc6ca4b170b" cv="noexcept"/>
<constructor id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index_1aa59fc9c56cb726abde25e91c76aa6b72" cv="noexcept"><parameter name="data"><paramtype>const <classname>type_info_t</classname> &amp;</paramtype></parameter></constructor>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index_1a200214096952268e8370e0558dccfc15" name="type_info" cv="const noexcept"><type>const <classname>type_info_t</classname> &amp;</type></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index_1ae31d7cd3dadf409d4cbfbf229c5c9a01" name="raw_name" cv="const noexcept"><type>const char *</type></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index_1aaca34fabdc40c950b7b7496ca11bd48a" name="name" cv="const noexcept"><type>const char *</type></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index_1aba0ac00bf43d0067e6df894888bdb667" name="pretty_name" cv="const"><type>std::string</type></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index_1a28a63a31e0e91abb1d158d4cdbd74ba8" name="hash_code" cv="const noexcept"><type>std::size_t</type></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index_1ab8b9ff1b77984b48b5aa46d183851544" name="equal" cv="const noexcept"><type>bool</type><parameter name="rhs"><paramtype>const <classname>ctti_type_index</classname> &amp;</paramtype></parameter></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index_1ab0b257ccc4642825347187698e9d99a1" name="before" cv="const noexcept"><type>bool</type><parameter name="rhs"><paramtype>const <classname>ctti_type_index</classname> &amp;</paramtype></parameter></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index_1a0b4ccfcd5d0717c09795913ea1cc4e70" name="type_id" cv="noexcept" specifiers="static"><type><classname>ctti_type_index</classname></type><template>
          <template-type-parameter name="T"/>
        </template></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index_1a9ed3942228509c11dd966198047e9948" name="type_id_with_cvr" cv="noexcept" specifiers="static"><type><classname>ctti_type_index</classname></type><template>
          <template-type-parameter name="T"/>
        </template></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index_1a0ecee3e5b27591f1071cee276e7a1373" name="type_id_runtime" cv="noexcept" specifiers="static"><type><classname>ctti_type_index</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="variable"><paramtype>const T &amp;</paramtype></parameter></method>
</method-group>
</class>







<function id="doxygen.boost_typeindex_header_reference.ctti__type__index_8hpp_1a1822527e75864a16f71788788698d5ab" name="ctti_construct"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
        </template><purpose>Helper method for getting <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1detail_1_1ctti__data">detail::ctti_data</link> of a template parameter T. </purpose></function>








</namespace>
</namespace>
</header>
<header id="doxygen.boost_typeindex_header_reference.runtime__cast_8hpp" name="boost/type_index/runtime_cast.hpp">
<para>Contains the basic utilities necessary to fully emulate dynamic_cast for language level constructs (raw pointers and references). </para><para><link linkend="doxygen.boost_typeindex_header_reference.reference__cast_8hpp_1a5e0f815ef2610b51ac34d4ffb5349d7d">boost::typeindex::runtime_cast</link> is a drop in replacement for dynamic_cast that can be used in situations where traditional rtti is either unavailable or undesirable. </para></header>
<header id="doxygen.boost_typeindex_header_reference.boost__shared__ptr__cast_8hpp" name="boost/type_index/runtime_cast/boost_shared_ptr_cast.hpp">
<para>Contains the overload of <link linkend="doxygen.boost_typeindex_header_reference.std__shared__ptr__cast_8hpp_1a8746ae3acba511243cdf31abe0508483">boost::typeindex::runtime_pointer_cast</link> for <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1shared__ptr">boost::shared_ptr</link> types. </para><namespace name="boost">
<class id="doxygen.boost_typeindex_header_reference.classboost_1_1shared__ptr" name="shared_ptr"><template>
      <template-type-parameter name="T"/>
    </template></class><namespace name="typeindex">
















<function id="doxygen.boost_typeindex_header_reference.boost__shared__ptr__cast_8hpp_1a48db9c4fcbd1c20f02bbb12a94b791a0" name="runtime_pointer_cast"><type><classname>boost::shared_ptr</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"><purpose><para>The desired target type to return a pointer of. </para></purpose></template-type-parameter>
          <template-type-parameter name="U"><purpose><para>A complete class type of the source instance pointed to from u. </para></purpose></template-type-parameter>
        </template><parameter name="u"><paramtype><classname>boost::shared_ptr</classname>&lt; U &gt; const &amp;</paramtype></parameter><purpose>Creates a new instance of std::shared_ptr whose stored pointer is obtained from u's stored pointer using a runtime_cast. </purpose><description><para>The new <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1shared__ptr">shared_ptr</link> will share ownership with u, except that it is empty if the runtime_cast performed by runtime_pointer_cast returns a null pointer. 

</para></description><returns><para>If there exists a valid conversion from U* to T*, returns a boost::shared_ptr&lt;T&gt; that points to an address suitably offset from u. If no such conversion exists, returns boost::shared_ptr&lt;T&gt;(); </para>
</returns></function>
</namespace>
</namespace>
</header>
<header id="doxygen.boost_typeindex_header_reference.pointer__cast_8hpp" name="boost/type_index/runtime_cast/pointer_cast.hpp">
<namespace name="boost">
<namespace name="typeindex">












<function id="doxygen.boost_typeindex_header_reference.pointer__cast_8hpp_1a66cf6da45dea8507fc86b36327223cda" name="runtime_cast"><type>T</type><template>
          <template-type-parameter name="T"><purpose><para>The desired target type. Like dynamic_cast, must be a pointer to complete class type. </para></purpose></template-type-parameter>
          <template-type-parameter name="U"><purpose><para>A complete class type of the source instance, u. </para></purpose></template-type-parameter>
        </template><parameter name="u"><paramtype>U *</paramtype></parameter><purpose>Safely converts pointers to classes up, down, and sideways along the inheritance hierarchy. </purpose><description><para>

</para></description><returns><para>If there exists a valid conversion from U* to T, returns a T that points to an address suitably offset from u. If no such conversion exists, returns nullptr. </para>
</returns></function>
<function id="doxygen.boost_typeindex_header_reference.pointer__cast_8hpp_1ac94537643e7bc5a501d21cc2751625a6" name="runtime_cast"><type>T</type><template>
          <template-type-parameter name="T"><purpose><para>The desired target type. Like dynamic_cast, must be a pointer to complete class type. </para></purpose></template-type-parameter>
          <template-type-parameter name="U"><purpose><para>A complete class type of the source instance, u. </para></purpose></template-type-parameter>
        </template><parameter name="u"><paramtype>U const *</paramtype></parameter><purpose>Safely converts pointers to classes up, down, and sideways along the inheritance hierarchy. </purpose><description><para>

</para></description><returns><para>If there exists a valid conversion from U* to T, returns a T that points to an address suitably offset from u. If no such conversion exists, returns nullptr. </para>
</returns></function>
<function id="doxygen.boost_typeindex_header_reference.pointer__cast_8hpp_1a07b884bb05ee0ef3e5dac347980fe73f" name="runtime_pointer_cast"><type>T *</type><template>
          <template-type-parameter name="T"><purpose><para>The desired target type to return a pointer to. </para></purpose></template-type-parameter>
          <template-type-parameter name="U"><purpose><para>A complete class type of the source instance, u. </para></purpose></template-type-parameter>
        </template><parameter name="u"><paramtype>U *</paramtype></parameter><purpose>Safely converts pointers to classes up, down, and sideways along the inheritance hierarchy. </purpose><description><para>

</para></description><returns><para>If there exists a valid conversion from U const* to T*, returns a T* that points to an address suitably offset from u. If no such conversion exists, returns nullptr. </para>
</returns></function>
<function id="doxygen.boost_typeindex_header_reference.pointer__cast_8hpp_1ace84532a2a2564339a3f2cb830f4030c" name="runtime_pointer_cast"><type>T const *</type><template>
          <template-type-parameter name="T"><purpose><para>The desired target type to return a pointer to. </para></purpose></template-type-parameter>
          <template-type-parameter name="U"><purpose><para>A complete class type of the source instance, u. </para></purpose></template-type-parameter>
        </template><parameter name="u"><paramtype>U const *</paramtype></parameter><purpose>Safely converts pointers to classes up, down, and sideways along the inheritance hierarchy. </purpose><description><para>

</para></description><returns><para>If there exists a valid conversion from U const* to T const*, returns a T const* that points to an address suitably offset from u. If no such conversion exists, returns nullptr. </para>
</returns></function>

</namespace>
</namespace>
</header>
<header id="doxygen.boost_typeindex_header_reference.reference__cast_8hpp" name="boost/type_index/runtime_cast/reference_cast.hpp">
<para>Contains the overload of <link linkend="doxygen.boost_typeindex_header_reference.reference__cast_8hpp_1a5e0f815ef2610b51ac34d4ffb5349d7d">boost::typeindex::runtime_cast</link> for reference types. </para><namespace name="boost">
<namespace name="typeindex">
<struct id="doxygen.boost_typeindex_header_reference.structboost_1_1typeindex_1_1bad__runtime__cast" name="bad_runtime_cast"><inherit access="public">std::exception</inherit><purpose>Indicates that runtime_cast was unable to perform the desired cast operation because the source instance was not also an instance of the target type. </purpose></struct>









<function id="doxygen.boost_typeindex_header_reference.reference__cast_8hpp_1a5e0f815ef2610b51ac34d4ffb5349d7d" name="runtime_cast"><type>std::add_lvalue_reference&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"><purpose><para>The desired target type. Like dynamic_cast, must be a pointer to complete class type. </para></purpose></template-type-parameter>
          <template-type-parameter name="U"><purpose><para>A complete class type of the source instance, u. </para></purpose></template-type-parameter>
        </template><parameter name="u"><paramtype>U &amp;</paramtype></parameter><purpose>Safely converts references to classes up, down, and sideways along the inheritance hierarchy. </purpose><description><para>

</para></description><returns><para>If there exists a valid conversion from U&amp; to T, returns a T that references an address suitably offset from u. If no such conversion exists, throws <link linkend="doxygen.boost_typeindex_header_reference.structboost_1_1typeindex_1_1bad__runtime__cast">boost::typeindex::bad_runtime_cast</link>. </para>
</returns></function>
<function id="doxygen.boost_typeindex_header_reference.reference__cast_8hpp_1a4bec5039015928c6df6b974d08631849" name="runtime_cast"><type>std::add_lvalue_reference&lt; constT &gt;::type</type><template>
          <template-type-parameter name="T"><purpose><para>The desired target type. Like dynamic_cast, must be a pointer to complete class type. </para></purpose></template-type-parameter>
          <template-type-parameter name="U"><purpose><para>A complete class type of the source instance, u. </para></purpose></template-type-parameter>
        </template><parameter name="u"><paramtype>U const &amp;</paramtype></parameter><purpose>Safely converts references to classes up, down, and sideways along the inheritance hierarchy. </purpose><description><para>

</para></description><returns><para>If there exists a valid conversion from U const&amp; to T const, returns a T const that references an address suitably offset from u. If no such conversion exists, throws <link linkend="doxygen.boost_typeindex_header_reference.structboost_1_1typeindex_1_1bad__runtime__cast">boost::typeindex::bad_runtime_cast</link>. </para>
</returns></function>





</namespace>
</namespace>
</header>
<header id="doxygen.boost_typeindex_header_reference.register__runtime__class_8hpp" name="boost/type_index/runtime_cast/register_runtime_class.hpp">
<para>Contains the macros BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST and BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS. </para><namespace name="boost">
<namespace name="typeindex">

















</namespace>
</namespace>
<macro id="doxygen.boost_typeindex_header_reference.register__runtime__class_8hpp_1a7c9256cdd957c8893b0c997ba26825f9" name="BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS" kind="functionlike"><macro-parameter name="..."/><purpose>Macro used to make a class compatible with <link linkend="doxygen.boost_typeindex_header_reference.reference__cast_8hpp_1a5e0f815ef2610b51ac34d4ffb5349d7d">boost::typeindex::runtime_cast</link>. </purpose><description><para>BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS generates a virtual function in the current class that, when combined with the supplied base class information, allows <link linkend="doxygen.boost_typeindex_header_reference.reference__cast_8hpp_1a5e0f815ef2610b51ac34d4ffb5349d7d">boost::typeindex::runtime_cast</link> to accurately convert between dynamic types of instances of the current class.</para><para>BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS also adds support for <link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1ae179d82aeceebc66d4fe38985bdb9e82">boost::typeindex::type_id_runtime</link> by including BOOST_TYPE_INDEX_REGISTER_CLASS. It is typical that these features are used together, but in the event that BOOST_TYPE_INDEX_REGISTER_CLASS is undesirable in the current class, BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST is provided.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct base1 {
    BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS()
    virtual ~base1();
};

struct base2 {
    BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS()
    virtual ~base2();
};

struct derived1 : base1 {
    BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS(base1)
};

struct derived2 : base1, base2 {
    BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS(base1, base2)
};

...

base1* pb1 = get_object();
if(derived2* pb2 = boost::typeindex::runtime_cast&lt;derived2*&gt;(pb1)) {
    assert(boost::typeindex::type_id_runtime(*pb1)) == boost::typeindex::type_id&lt;derived2&gt;());
}
</programlisting></para><para>
</para></description></macro>
<macro id="doxygen.boost_typeindex_header_reference.register__runtime__class_8hpp_1a8cb786ffc23c58379c4f346b5b88d1cc" name="BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST" kind="functionlike"><macro-parameter name="..."/><purpose>Macro used to make a class compatible with <link linkend="doxygen.boost_typeindex_header_reference.reference__cast_8hpp_1a5e0f815ef2610b51ac34d4ffb5349d7d">boost::typeindex::runtime_cast</link> without including support for <link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1ae179d82aeceebc66d4fe38985bdb9e82">boost::typeindex::type_id_runtime</link>. </purpose><description><para>BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST is provided as an alternative to BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS in the event that support for <link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1ae179d82aeceebc66d4fe38985bdb9e82">boost::typeindex::type_id_runtime</link> is undesirable.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">struct base1 {
    BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST()
    virtual ~base1();
};

struct base2 {
    BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST()
    virtual ~base2();
};

struct derived1 : base1 {
    BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST(base1)
};

struct derived2 : base1, base2 {
    BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST(base1, base2)
};

...

base1* pb1 = get_object();
if(derived2* pb2 = boost::typeindex::runtime_cast&lt;derived2*&gt;(pb1))
{ /* can't call boost::typeindex::type_id_runtime(*pb1) here */ }
</programlisting></para><para>
</para></description></macro>
<macro id="doxygen.boost_typeindex_header_reference.register__runtime__class_8hpp_1a23b242cbe8011c10233940830c83dcb4" name="BOOST_TYPE_INDEX_NO_BASE_CLASS"><purpose>Instructs BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS and BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST that this class has no base classes. </purpose><description><para><xrefsect id="deprecated_1_deprecated000001"><xreftitle>Deprecated</xreftitle><xrefdescription><para>Just remove and use <link linkend="doxygen.boost_typeindex_header_reference.register__runtime__class_8hpp_1a7c9256cdd957c8893b0c997ba26825f9">BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS()</link> or <link linkend="doxygen.boost_typeindex_header_reference.register__runtime__class_8hpp_1a8cb786ffc23c58379c4f346b5b88d1cc">BOOST_TYPE_INDEX_IMPLEMENT_RUNTIME_CAST()</link> </para>
</xrefdescription></xrefsect></para></description></macro>
</header>
<header id="doxygen.boost_typeindex_header_reference.std__shared__ptr__cast_8hpp" name="boost/type_index/runtime_cast/std_shared_ptr_cast.hpp">
<para>Contains the overload of <link linkend="doxygen.boost_typeindex_header_reference.std__shared__ptr__cast_8hpp_1a8746ae3acba511243cdf31abe0508483">boost::typeindex::runtime_pointer_cast</link> for std::shared_ptr types. </para><namespace name="boost">
<namespace name="typeindex">









<function id="doxygen.boost_typeindex_header_reference.std__shared__ptr__cast_8hpp_1a8746ae3acba511243cdf31abe0508483" name="runtime_pointer_cast"><type>std::shared_ptr&lt; T &gt;</type><template>
          <template-type-parameter name="T"><purpose><para>The desired target type to return a pointer of. </para></purpose></template-type-parameter>
          <template-type-parameter name="U"><purpose><para>A complete class type of the source instance pointed to from u. </para></purpose></template-type-parameter>
        </template><parameter name="u"><paramtype>std::shared_ptr&lt; U &gt; const &amp;</paramtype></parameter><purpose>Creates a new instance of std::shared_ptr whose stored pointer is obtained from u's stored pointer using a runtime_cast. </purpose><description><para>The new <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1shared__ptr">shared_ptr</link> will share ownership with u, except that it is empty if the runtime_cast performed by runtime_pointer_cast returns a null pointer. 

</para></description><returns><para>If there exists a valid conversion from U* to T*, returns a std::shared_ptr&lt;T&gt; that points to an address suitably offset from u. If no such conversion exists, returns std::shared_ptr&lt;T&gt;(); </para>
</returns></function>







</namespace>
</namespace>
</header>
<header id="doxygen.boost_typeindex_header_reference.stl__type__index_8hpp" name="boost/type_index/stl_type_index.hpp">
<para>Contains <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index">boost::typeindex::stl_type_index</link> class. </para><para><link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index">boost::typeindex::stl_type_index</link> class can be used as a drop-in replacement for std::type_index.</para><para>It is used in situations when RTTI is enabled or typeid() method is available. When typeid() is disabled or BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY macro is defined boost::typeindex::ctti is usually used instead of <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index">boost::typeindex::stl_type_index</link>. </para><namespace name="boost">
<namespace name="typeindex">
<class id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index" name="stl_type_index"><inherit access="public">boost::typeindex::type_index_facade&lt; stl_type_index, std::type_info &gt;</inherit><description><para>This class is a wrapper around std::type_info, that workarounds issues and provides much more rich interface. <emphasis role="bold">For</emphasis> <emphasis role="bold">description</emphasis> <emphasis role="bold">of</emphasis> <emphasis role="bold">functions</emphasis> <emphasis role="bold">see</emphasis> <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade">type_index_facade</link>.</para><para>This class requires typeid() to work. For cases when RTTI is disabled see <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1ctti__type__index">ctti_type_index</link>. </para></description><typedef id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index_1ac6105ec9388e17900d5ee15a9b9e3332" name="type_info_t"><type>std::type_info</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index_1af869e634b2d7b494e3ecdeac6ff93dc1" cv="noexcept"/>
<constructor id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index_1a293b41e75648e6c5d6f9a9953e41b530" cv="noexcept"><parameter name="data"><paramtype>const type_info_t &amp;</paramtype></parameter></constructor>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index_1a8bd1cfb93cb1206aae2f124c8ab9bcf8" name="type_info" cv="const noexcept"><type>const type_info_t &amp;</type></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index_1a083ee4e0bba81db6df03ba76ac028119" name="raw_name" cv="const noexcept"><type>const char *</type></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index_1a527a81e9cc9e514b3c7c3e4d5c3191c1" name="name" cv="const noexcept"><type>const char *</type></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index_1aa422b799f3e506df955244ec9e87b5e4" name="pretty_name" cv="const"><type>std::string</type></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index_1af091fb747fb1639ebf017246dd3d73c0" name="hash_code" cv="const noexcept"><type>std::size_t</type></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index_1a9996ec904bcf1fd1c5eb39e548efd6b4" name="equal" cv="const noexcept"><type>bool</type><parameter name="rhs"><paramtype>const <classname>stl_type_index</classname> &amp;</paramtype></parameter></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index_1a3d098afdf960171b89755d465855d9ab" name="before" cv="const noexcept"><type>bool</type><parameter name="rhs"><paramtype>const <classname>stl_type_index</classname> &amp;</paramtype></parameter></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index_1a373f58c5a9a5d8e5f72b6290c469d1b2" name="type_id" cv="noexcept" specifiers="static"><type><classname>stl_type_index</classname></type><template>
          <template-type-parameter name="T"/>
        </template></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index_1a44e8dad6d3301118cdc973090a104652" name="type_id_with_cvr" cv="noexcept" specifiers="static"><type><classname>stl_type_index</classname></type><template>
          <template-type-parameter name="T"/>
        </template></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1stl__type__index_1a765fb08b9e78ced399b5741be665400f" name="type_id_runtime" cv="noexcept" specifiers="static"><type><classname>stl_type_index</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="value"><paramtype>const T &amp;</paramtype></parameter></method>
</method-group>
</class>
















</namespace>
</namespace>
</header>
<header id="doxygen.boost_typeindex_header_reference.type__index__facade_8hpp" name="boost/type_index/type_index_facade.hpp">
<namespace name="boost">
<namespace name="typeindex">
<class id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade" name="type_index_facade"><template>
      <template-type-parameter name="Derived"><purpose><para>Class derived from <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade">type_index_facade</link>. </para></purpose></template-type-parameter>
      <template-type-parameter name="TypeInfo"><purpose><para>Class that will be used as a base type_info class. </para></purpose></template-type-parameter>
    </template><description><para>This class takes care about the comparison operators, hash functions and ostream operators. Use this class as a public base class for defining new type_info-conforming classes.</para><para><emphasis role="bold">Example:</emphasis> <programlisting language="c++">class stl_type_index: public type_index_facade&lt;stl_type_index, std::type_info&gt; 
{
public:
    typedef std::type_info type_info_t;
private:
    const type_info_t* data_;

public:
    stl_type_index(const type_info_t&amp; data) noexcept
        : data_(&amp;data)
    {}
// ...
};
</programlisting></para><para>
<note><para>Take a look at the protected methods. They are <emphasis role="bold">not</emphasis> <emphasis role="bold">defined</emphasis> in <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade">type_index_facade</link>. Protected member functions <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade_1a0199e1a80f28dd9d95cd202ed7e39c5e">raw_name()</link> <emphasis role="bold">must</emphasis> be defined in Derived class. All the other methods are mandatory. </para>
</note>
<formalpara><title>See Also:</title><para>'Making a custom <link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a92396e4950b1278f4df4b0919f3168be">type_index</link>' section for more information about creating your own <link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a92396e4950b1278f4df4b0919f3168be">type_index</link> using <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade">type_index_facade</link>. </para>
</formalpara>
</para></description><typedef id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade_1a920e3e44aae878212a2cc5d1fc5e37ca" name="type_info_t"><type>TypeInfo</type></typedef>
<method-group name="public member functions">
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade_1a592dc8afebf346a07721293391980dcb" name="name" cv="const noexcept"><type>const char *</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>Name of a type. By default returns Derived::raw_name(). </para>
</returns></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade_1a50fcb3144a54cacdeeec13ab5305f82a" name="pretty_name" cv="const"><type>std::string</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides may throw. 
</para></description><returns><para>Human readable type name. By default returns Derived::name(). </para>
</returns></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade_1a56e45113630a76ddacd1b1f30da59294" name="equal" cv="const noexcept"><type>bool</type><parameter name="rhs"><paramtype>const Derived &amp;</paramtype></parameter><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>True if two types are equal. By default compares types by <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade_1a0199e1a80f28dd9d95cd202ed7e39c5e">raw_name()</link>. </para>
</returns></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade_1a04eb5897b4de19f9a445f8672a0e4a36" name="before" cv="const noexcept"><type>bool</type><parameter name="rhs"><paramtype>const Derived &amp;</paramtype></parameter><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>True if rhs is greater than this. By default compares types by <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade_1a0199e1a80f28dd9d95cd202ed7e39c5e">raw_name()</link>. </para>
</returns></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade_1a784cfd6418d0de6da0d0cca78f554c92" name="hash_code" cv="const noexcept"><type>std::size_t</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
<note><para>Derived class header <emphasis role="bold">must</emphasis> include &lt;boost/container_hash/hash.hpp&gt;, <emphasis role="bold">unless</emphasis> this function is redefined in Derived class to not use boost::hash_range(). </para>
</note>
</para></description><returns><para>Hash code of a type. By default hashes types by <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade_1a0199e1a80f28dd9d95cd202ed7e39c5e">raw_name()</link>. </para>
</returns></method>
</method-group>
<method-group name="protected member functions">
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade_1a0199e1a80f28dd9d95cd202ed7e39c5e" name="raw_name" cv="const noexcept"><type>const char *</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">must</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>Pointer to unredable/raw type name. </para>
</returns></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade_1a343245d2135b1844d1e00a8f3dae8b8c" name="type_info" cv="const noexcept"><type>const type_info_t &amp;</type><description><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. 
</para></description><returns><para>Const reference to underlying low level type_info_t. </para>
</returns></method>
</method-group>
<method-group name="protected static functions">
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade_1a69a7cb9b3dff2da97609c5ff20be10ef" name="type_id" cv="noexcept" specifiers="static"><type>Derived</type><template>
          <template-type-parameter name="T"><purpose><para>Type for which type_index must be created. </para></purpose></template-type-parameter>
        </template><description><para>This is a factory method that is used to create instances of Derived classes. <link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1aaa8536b5c80315f205036a85a9e8e3e2">boost::typeindex::type_id()</link> will call this method, if Derived has same type as <link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a92396e4950b1278f4df4b0919f3168be">boost::typeindex::type_index</link>.</para><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined and made public in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. Overrides <emphasis role="bold">must</emphasis> remove const, volatile &amp;&amp; and &amp; modifiers from T. 

</para></description><returns><para>type_index for type T. </para>
</returns></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade_1a7c867a1935e2db86eae2ea7d02e5c26e" name="type_id_with_cvr" cv="noexcept" specifiers="static"><type>Derived</type><template>
          <template-type-parameter name="T"><purpose><para>Type for which type_index must be created. </para></purpose></template-type-parameter>
        </template><description><para>This is a factory method that is used to create instances of Derived classes. <link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a15beb7454116a3e5aa29f30cbaad5315">boost::typeindex::type_id_with_cvr()</link> will call this method, if Derived has same type as <link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a92396e4950b1278f4df4b0919f3168be">boost::typeindex::type_index</link>.</para><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined and made public in Derived class. Overrides <emphasis role="bold">must</emphasis> not throw. Overrides <emphasis role="bold">must</emphasis> <emphasis role="bold">not</emphasis> remove const, volatile &amp;&amp; and &amp; modifiers from T. 

</para></description><returns><para>type_index for type T. </para>
</returns></method>
<method id="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade_1ad3fb0a5425db871e0471e2f0c93b9bd8" name="type_id_runtime" cv="noexcept" specifiers="static"><type>Derived</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="variable"><paramtype>const T &amp;</paramtype><description><para>Variable which runtime type will be stored in type_index. </para></description></parameter><description><para>This is a factory method that is used to create instances of Derived classes. <link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1ae179d82aeceebc66d4fe38985bdb9e82">boost::typeindex::type_id_runtime(const T&amp;)</link> will call this method, if Derived has same type as <link linkend="doxygen.boost_typeindex_header_reference.type__index_8hpp_1a92396e4950b1278f4df4b0919f3168be">boost::typeindex::type_index</link>.</para><para><emphasis role="bold">Override:</emphasis> This function <emphasis role="bold">may</emphasis> be redefined and made public in Derived class. 

</para></description><returns><para>type_index with runtime type of variable. </para>
</returns></method>
</method-group>
</class>


<function id="doxygen.boost_typeindex_header_reference.type__index__facade_8hpp_1a0eefc76d461d00b0f4c7885197a9703d" name="operator==,!=,&lt;,..."><type>bool</type><parameter name="lhs"><paramtype>const <classname>type_index_facade</classname> &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>type_index_facade</classname> &amp;</paramtype></parameter><purpose>noexcept comparison operators for <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade">type_index_facade</link> classes. </purpose></function>
<function id="doxygen.boost_typeindex_header_reference.type__index__facade_8hpp_1ad3356a13a05f1f66ed0233990fb03d43" name="operator==,!=,&lt;,..."><type>bool</type><parameter name="lhs"><paramtype>const <classname>type_index_facade</classname> &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const TypeInfo &amp;</paramtype></parameter><purpose>noexcept comparison operators for <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade">type_index_facade</link> and it's TypeInfo classes. </purpose></function>
<function id="doxygen.boost_typeindex_header_reference.type__index__facade_8hpp_1ac25d3f9fde8306b00a291ceac35726ff" name="operator==,!=,&lt;,..."><type>bool</type><parameter name="lhs"><paramtype>const TypeInfo &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>type_index_facade</classname> &amp;</paramtype></parameter><purpose>noexcept comparison operators for <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade">type_index_facade</link>'s TypeInfo and <link linkend="doxygen.boost_typeindex_header_reference.classboost_1_1typeindex_1_1type__index__facade">type_index_facade</link> classes. </purpose></function>
<function id="doxygen.boost_typeindex_header_reference.type__index__facade_8hpp_1a94b96da87ed9b336e4240bc1beb97673" name="operator&lt;&lt;"><type>std::basic_ostream&lt; CharT, TriatT &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TriatT"/>
          <template-type-parameter name="Derived"/>
          <template-type-parameter name="TypeInfo"/>
        </template><parameter name="ostr"><paramtype>std::basic_ostream&lt; CharT, TriatT &gt; &amp;</paramtype></parameter><parameter name="ind"><paramtype>const <classname>type_index_facade</classname>&lt; Derived, TypeInfo &gt; &amp;</paramtype></parameter><purpose>Ostream operator that will output demangled name. </purpose></function>
<function id="doxygen.boost_typeindex_header_reference.type__index__facade_8hpp_1a20a9e97693898043009d53006aaaf3c3" name="hash_value"><type>std::size_t</type><template>
          <template-type-parameter name="Derived"/>
          <template-type-parameter name="TypeInfo"/>
        </template><parameter name="lhs"><paramtype>const <classname>type_index_facade</classname>&lt; Derived, TypeInfo &gt; &amp;</paramtype></parameter><description><para>This free function is used by Boost's unordered containers. <note><para>&lt;boost/container_hash/hash.hpp&gt; has to be included if this function is used. </para>
</note>
</para></description></function>









</namespace>
</namespace>
</header>
</library-reference>