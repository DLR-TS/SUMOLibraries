<?xml version="1.0" standalone="yes"?>
<library-reference id="boost_pool_c___reference"><title>Boost.Pool C++ Reference</title><header id="doxygen.boost_pool_c___reference.object__pool_8hpp" name="boost/pool/object_pool.hpp">
<para>Provides a template type boost::object_pool&lt;T, UserAllocator&gt; that can be used for fast and efficient memory allocation of objects of type T. It also provides automatic destruction of non-deallocated objects. </para><namespace name="boost">
</namespace>
</header>
<header id="doxygen.boost_pool_c___reference.pool_8hpp" name="boost/pool/pool.hpp">
<para>Provides class pool: a fast memory allocator that guarantees proper alignment of all allocated chunks, and which extends and generalizes the framework provided by the simple segregated storage solution. Also provides two UserAllocator classes which can be used in conjuction with pool. </para><namespace name="boost">
<struct id="doxygen.boost_pool_c___reference.structboost_1_1default__user__allocator__malloc__free" name="default_user_allocator_malloc_free"><purpose><ulink url="boost_pool/pool/pooling.html#boost_pool.pool.pooling.user_allocator">UserAllocator</ulink> used as template parameter for <link linkend="doxygen.boost_pool_c___reference.classboost_1_1pool">pool</link> and <link linkend="doxygen.boost_pool_c___reference.classboost_1_1object__pool">object_pool</link>. Uses malloc and free internally. </purpose><typedef id="doxygen.boost_pool_c___reference.structboost_1_1default__user__allocator__malloc__free_1a65bbf60c8a94a4a82aa31eac9e8c48ef" name="size_type"><purpose>An unsigned integral type that can represent the size of the largest object to be allocated. </purpose><type>std::size_t</type></typedef>
<typedef id="doxygen.boost_pool_c___reference.structboost_1_1default__user__allocator__malloc__free_1a6587e214ec971952c73a3902bc80c945" name="difference_type"><purpose>A signed integral type that can represent the difference of any two pointers. </purpose><type>std::ptrdiff_t</type></typedef>
<method-group name="public static functions">
<method id="doxygen.boost_pool_c___reference.structboost_1_1default__user__allocator__malloc__free_1ab4a9932a341c0623f3012a724400be0c" name="malloc" specifiers="static"><type>char *</type><parameter name="bytes"><paramtype>const size_type</paramtype></parameter></method>
<method id="doxygen.boost_pool_c___reference.structboost_1_1default__user__allocator__malloc__free_1a562f074bdd9303ec964b32c73bc26384" name="free" specifiers="static"><type>void</type><parameter name="block"><paramtype>char *const</paramtype></parameter></method>
</method-group>
</struct><struct id="doxygen.boost_pool_c___reference.structboost_1_1default__user__allocator__new__delete" name="default_user_allocator_new_delete"><purpose>Allocator used as the default template parameter for a <ulink url="boost_pool/pool/pooling.html#boost_pool.pool.pooling.user_allocator">UserAllocator</ulink> template parameter. Uses new and delete. </purpose><typedef id="doxygen.boost_pool_c___reference.structboost_1_1default__user__allocator__new__delete_1a113e1cafdffa92c4cef828dfabeabff0" name="size_type"><purpose>An unsigned integral type that can represent the size of the largest object to be allocated. </purpose><type>std::size_t</type></typedef>
<typedef id="doxygen.boost_pool_c___reference.structboost_1_1default__user__allocator__new__delete_1afab839f988f8f88f5e03bc91ba98c1d9" name="difference_type"><purpose>A signed integral type that can represent the difference of any two pointers. </purpose><type>std::ptrdiff_t</type></typedef>
<method-group name="public static functions">
<method id="doxygen.boost_pool_c___reference.structboost_1_1default__user__allocator__new__delete_1aef8a48dbffae9cfbf561b69cdb80bee2" name="malloc" specifiers="static"><type>char *</type><parameter name="bytes"><paramtype>const size_type</paramtype></parameter><description><para>Attempts to allocate n bytes from the system. Returns 0 if out-of-memory</para></description></method>
<method id="doxygen.boost_pool_c___reference.structboost_1_1default__user__allocator__new__delete_1aa5475b12c83b6ac7e7fd3579e33687aa" name="free" specifiers="static"><type>void</type><parameter name="block"><paramtype>char *const</paramtype></parameter><description><para>Attempts to de-allocate block. 
</para></description><requires><para>Block must have been previously returned from a call to UserAllocator::malloc.</para>
</requires></method>
</method-group>
</struct></namespace>
</header>
<header id="doxygen.boost_pool_c___reference.pool__alloc_8hpp" name="boost/pool/pool_alloc.hpp">
<para>C++ Standard Library compatible pool-based allocators. </para><para>This header provides two template types - pool_allocator and fast_pool_allocator - that can be used for fast and efficient memory allocation in conjunction with the C++ Standard Library containers.</para><para>These types both satisfy the Standard Allocator requirements [20.1.5] and the additional requirements in [20.1.5/4], so they can be used with either Standard or user-supplied containers.</para><para>In addition, the fast_pool_allocator also provides an additional allocation and an additional deallocation function:</para><para><informaltable><tgroup cols="4"><tbody><row>
<entry><emphasis role="bold">Expression</emphasis></entry><entry><emphasis role="bold">Return Type</emphasis></entry><entry><emphasis role="bold">Semantic Equivalence</emphasis></entry><entry><emphasis role="bold"/></entry></row>
<row>
<entry><computeroutput>PoolAlloc::allocate()</computeroutput></entry><entry><computeroutput>T *</computeroutput></entry><entry><computeroutput>PoolAlloc::allocate(1)</computeroutput> </entry></row>
<row>
<entry><computeroutput>PoolAlloc::deallocate(p)</computeroutput></entry><entry>void</entry><entry><computeroutput>PoolAlloc::deallocate(p, 1)</computeroutput> </entry></row>
</tbody></tgroup></informaltable>
</para><para>The typedef user_allocator publishes the value of the UserAllocator template parameter.</para><para><emphasis role="bold">Notes</emphasis></para><para>If the allocation functions run out of memory, they will throw <computeroutput>std::bad_alloc</computeroutput>.</para><para>The underlying Pool type used by the allocators is accessible through the Singleton Pool Interface. The identifying tag used for pool_allocator is pool_allocator_tag, and the tag used for fast_pool_allocator is fast_pool_allocator_tag. All template parameters of the allocators (including implementation-specific ones) determine the type of the underlying Pool, with the exception of the first parameter T, whose size is used instead.</para><para>Since the size of T is used to determine the type of the underlying Pool, each allocator for different types of the same size will share the same underlying pool. The tag class prevents pools from being shared between pool_allocator and fast_pool_allocator. For example, on a system where <computeroutput>sizeof(int) == sizeof(void *)</computeroutput>, <computeroutput>pool_allocator&lt;int&gt;</computeroutput> and <computeroutput>pool_allocator&lt;void *&gt;</computeroutput> will both allocate/deallocate from/to the same pool.</para><para>If there is only one thread running before main() starts and after main() ends, then both allocators are completely thread-safe.</para><para><emphasis role="bold">Compiler and STL Notes</emphasis></para><para>A number of common STL libraries contain bugs in their using of allocators. Specifically, they pass null pointers to the deallocate function, which is explicitly forbidden by the Standard [20.1.5 Table 32]. PoolAlloc will work around these libraries if it detects them; currently, workarounds are in place for: Borland C++ (Builder and command-line compiler) with default (RogueWave) library, ver. 5 and earlier, STLport (with any compiler), ver. 4.0 and earlier. </para><namespace name="boost">
<class-specialization id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator_3_01void_00_01UserAllocator_00_01Mutex_00_01NextSize_00_01MaxSize_01_4" name="fast_pool_allocator"><template>
      <template-type-parameter name="UserAllocator"/>
      <template-type-parameter name="Mutex"/>
      <template-nontype-parameter name="NextSize"><type>unsigned</type></template-nontype-parameter>
      <template-nontype-parameter name="MaxSize"><type>unsigned</type></template-nontype-parameter>
    </template><specialization><template-arg>void</template-arg><template-arg>UserAllocator</template-arg><template-arg>Mutex</template-arg><template-arg>NextSize</template-arg><template-arg>MaxSize</template-arg></specialization><purpose>Specialization of fast_pool_allocator&lt;void&gt;. </purpose><description><para>Specialization of fast_pool_allocator&lt;void&gt; required to make the allocator standard-conforming. </para></description><struct id="doxygen.boost_pool_c___reference.structboost_1_1fast__pool__allocator_3_01void_00_01UserAllocator_00_01Mutex_00_01NextSize_00_01MaxSize_01_4_1_1rebind" name="rebind"><template>
      <template-type-parameter name="U"/>
    </template><purpose>Nested class rebind allows for transformation from fast_pool_allocator&lt;T&gt; to <link linkend="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator">fast_pool_allocator</link><underline>. </underline></purpose><description><para>Nested class rebind allows for transformation from fast_pool_allocator&lt;T&gt; to <link linkend="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator">fast_pool_allocator</link><underline> via the member typedef other. </underline></para></description><typedef id="doxygen.boost_pool_c___reference.structboost_1_1fast__pool__allocator_3_01void_00_01UserAllocator_00_01Mutex_00_01NextSize_00_01MaxSize_01_4_1_1rebind_1ab1a807047f597d5918d889d7e8b17d4d" name="other"><type><classname>fast_pool_allocator</classname>&lt; U, UserAllocator, Mutex, NextSize, MaxSize &gt;</type></typedef>
</struct><typedef id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator_3_01void_00_01UserAllocator_00_01Mutex_00_01NextSize_00_01MaxSize_01_4_1a3c082537c660639b40935f7c8ffa4284" name="pointer"><type>void *</type></typedef>
<typedef id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator_3_01void_00_01UserAllocator_00_01Mutex_00_01NextSize_00_01MaxSize_01_4_1a1141002c173dd73b69838b4ec431b677" name="const_pointer"><type>const void *</type></typedef>
<typedef id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator_3_01void_00_01UserAllocator_00_01Mutex_00_01NextSize_00_01MaxSize_01_4_1a109d1e1a993a2540b329e395e2119999" name="value_type"><type>void</type></typedef>
</class-specialization><struct id="doxygen.boost_pool_c___reference.structboost_1_1fast__pool__allocator__tag" name="fast_pool_allocator_tag"><purpose>Simple tag type used by <link linkend="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator">fast_pool_allocator</link> as a template parameter to the underlying <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link>. </purpose></struct><class-specialization id="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator_3_01void_00_01UserAllocator_00_01Mutex_00_01NextSize_00_01MaxSize_01_4" name="pool_allocator"><template>
      <template-type-parameter name="UserAllocator"/>
      <template-type-parameter name="Mutex"/>
      <template-nontype-parameter name="NextSize"><type>unsigned</type></template-nontype-parameter>
      <template-nontype-parameter name="MaxSize"><type>unsigned</type></template-nontype-parameter>
    </template><specialization><template-arg>void</template-arg><template-arg>UserAllocator</template-arg><template-arg>Mutex</template-arg><template-arg>NextSize</template-arg><template-arg>MaxSize</template-arg></specialization><purpose>Specialization of pool_allocator&lt;void&gt;. </purpose><description><para>Specialization of <link linkend="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator">pool_allocator</link> for type void: required by the standard to make this a conforming allocator type. </para></description><struct id="doxygen.boost_pool_c___reference.structboost_1_1pool__allocator_3_01void_00_01UserAllocator_00_01Mutex_00_01NextSize_00_01MaxSize_01_4_1_1rebind" name="rebind"><template>
      <template-type-parameter name="U"/>
    </template><purpose>Nested class rebind allows for transformation from pool_allocator&lt;T&gt; to <link linkend="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator">pool_allocator</link><underline>. </underline></purpose><description><para>Nested class rebind allows for transformation from pool_allocator&lt;T&gt; to <link linkend="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator">pool_allocator</link><underline> via the member typedef other. </underline></para></description><typedef id="doxygen.boost_pool_c___reference.structboost_1_1pool__allocator_3_01void_00_01UserAllocator_00_01Mutex_00_01NextSize_00_01MaxSize_01_4_1_1rebind_1a76a82b98b48d9eeb1a4ce1091f885c45" name="other"><type><classname>pool_allocator</classname>&lt; U, UserAllocator, Mutex, NextSize, MaxSize &gt;</type></typedef>
</struct><typedef id="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator_3_01void_00_01UserAllocator_00_01Mutex_00_01NextSize_00_01MaxSize_01_4_1ac713ec1057495761d71b048ed2b89177" name="pointer"><type>void *</type></typedef>
<typedef id="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator_3_01void_00_01UserAllocator_00_01Mutex_00_01NextSize_00_01MaxSize_01_4_1a40cbd0e878868a799bcfb1879fad1a9f" name="const_pointer"><type>const void *</type></typedef>
<typedef id="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator_3_01void_00_01UserAllocator_00_01Mutex_00_01NextSize_00_01MaxSize_01_4_1a05a0f3bc2a6c068198452fa57bd4d6a0" name="value_type"><type>void</type></typedef>
</class-specialization><struct id="doxygen.boost_pool_c___reference.structboost_1_1pool__allocator__tag" name="pool_allocator_tag"><description><para>Simple tag type used by <link linkend="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator">pool_allocator</link> as an argument to the underlying <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link>. </para></description></struct></namespace>
</header>
<header id="doxygen.boost_pool_c___reference.poolfwd_8hpp" name="boost/pool/poolfwd.hpp">
<para>Forward declarations of all public (non-implemention) classes. </para><namespace name="boost">
<class id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator" name="fast_pool_allocator"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="UserAllocator"/>
      <template-type-parameter name="Mutex"/>
      <template-nontype-parameter name="NextSize"><type>unsigned</type></template-nontype-parameter>
      <template-nontype-parameter name="MaxSize"><type>unsigned</type></template-nontype-parameter>
    </template><purpose>A C++ Standard Library conforming allocator geared towards allocating single chunks. </purpose><description><para>While class template <computeroutput><link linkend="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator">pool_allocator</link></computeroutput> is a more general-purpose solution geared towards efficiently servicing requests for any number of contiguous chunks, <computeroutput><link linkend="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator">fast_pool_allocator</link></computeroutput> is also a general-purpose solution, but is geared towards efficiently servicing requests for one chunk at a time; it will work for contiguous chunks, but not as well as <computeroutput><link linkend="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator">pool_allocator</link></computeroutput>.</para><para>If you are seriously concerned about performance, use <computeroutput><link linkend="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator">fast_pool_allocator</link></computeroutput> when dealing with containers such as <computeroutput>std::list</computeroutput>, and use <computeroutput><link linkend="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator">pool_allocator</link></computeroutput> when dealing with containers such as <computeroutput>std::vector</computeroutput>.</para><para>The template parameters are defined as follows:</para><para><emphasis role="bold">T</emphasis> Type of object to allocate/deallocate.</para><para><emphasis role="bold">UserAllocator</emphasis>. Defines the method that the underlying Pool will use to allocate memory from the system. See <ulink url="boost_pool/pool/pooling.html#boost_pool.pool.pooling.user_allocator">User Allocators</ulink> for details.</para><para><emphasis role="bold">Mutex</emphasis> Allows the user to determine the type of synchronization to be used on the underlying <computeroutput><link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link></computeroutput>.</para><para><emphasis role="bold">NextSize</emphasis> The value of this parameter is passed to the underlying Pool when it is created.</para><para><emphasis role="bold">MaxSize</emphasis> Limit on the maximum size used.</para><para><important><para>The underlying <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link> used by the this allocator constructs a pool instance that <emphasis role="bold">is never freed</emphasis>. This means that memory allocated by the allocator can be still used after main() has completed, but may mean that some memory checking programs will complain about leaks. </para>
</important>
</para></description><method-group name="public member functions">
<constructor id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator_1a76bf35d5807690f9d53de468819bf534"><description><para>Ensures construction of the underlying <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link> IFF an instance of this allocator is constructed during global initialization. See ticket #2359 for a complete explanation at <ulink url="http://svn.boost.org/trac/boost/ticket/2359">http://svn.boost.org/trac/boost/ticket/2359</ulink> .</para></description></constructor>
<constructor id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator_1ad4d2b417f488e593db48109d67c6854b"><template>
          <template-type-parameter name="U"/>
        </template><parameter name=""><paramtype>const <classname>fast_pool_allocator</classname>&lt; U, UserAllocator, Mutex, NextSize, MaxSize &gt; &amp;</paramtype></parameter><description><para>Ensures construction of the underlying <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link> IFF an instance of this allocator is constructed during global initialization. See ticket #2359 for a complete explanation at <ulink url="http://svn.boost.org/trac/boost/ticket/2359">http://svn.boost.org/trac/boost/ticket/2359</ulink> .</para></description></constructor>
<method id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator_1a80d84adf29127f5859107a60c86018bc" name="construct"><type>void</type><parameter name="ptr"><paramtype>const pointer</paramtype></parameter><parameter name="t"><paramtype>const value_type &amp;</paramtype></parameter></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator_1aa1a6e1190172676d92e9f8c676e6f689" name="destroy"><type>void</type><parameter name="ptr"><paramtype>const pointer</paramtype></parameter><description><para>Destroy ptr using destructor.</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator_1aee74b929ad2c5abdf37ed8b064ebeb83" name="operator==" cv="const"><type>bool</type><parameter name=""><paramtype>const <classname>fast_pool_allocator</classname> &amp;</paramtype></parameter></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator_1a2ce614dae1caab01e51d897666a61f7d" name="operator!=" cv="const"><type>bool</type><parameter name=""><paramtype>const <classname>fast_pool_allocator</classname> &amp;</paramtype></parameter></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator_1ae49379674da2ca969053428057a8c20d" name="address" specifiers="static"><type>pointer</type><parameter name="r"><paramtype>reference</paramtype></parameter></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator_1a8cec5d79b4b5b040c6c55114d52c7029" name="address" specifiers="static"><type>const_pointer</type><parameter name="s"><paramtype>const_reference</paramtype></parameter></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator_1a47c89f9d635d4b3becf34d3931877d1b" name="max_size" specifiers="static"><type>size_type</type></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator_1a948c2ae8f780b3438ea095dbf8c1448b" name="allocate" specifiers="static"><type>pointer</type><parameter name="n"><paramtype>const size_type</paramtype></parameter></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator_1a7d7e122b1a85cfe7837c21658f02e2d2" name="allocate" specifiers="static"><type>pointer</type><parameter name="n"><paramtype>const size_type</paramtype></parameter><parameter name=""><paramtype>const void * const</paramtype></parameter><description><para>Allocate memory .</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator_1af745b208b9151081937461470f0cf78d" name="allocate" specifiers="static"><type>pointer</type><description><para>Allocate memory.</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator_1a489f11d40d28926627a556da573eed22" name="deallocate" specifiers="static"><type>void</type><parameter name="ptr"><paramtype>const pointer</paramtype></parameter><parameter name="n"><paramtype>const size_type</paramtype></parameter><description><para>Deallocate memory.</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1fast__pool__allocator_1ab43e39f55d8c48a29bf4ed2b4f6b3401" name="deallocate" specifiers="static"><type>void</type><parameter name="ptr"><paramtype>const pointer</paramtype></parameter><description><para>deallocate/free</para></description></method>
</method-group>
</class><class id="doxygen.boost_pool_c___reference.classboost_1_1object__pool" name="object_pool"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="UserAllocator"/>
    </template><inherit access="protected">boost::pool&lt; UserAllocator &gt;</inherit><purpose>A template class that can be used for fast and efficient memory allocation of objects. It also provides automatic destruction of non-deallocated objects. </purpose><description><para><emphasis role="bold">T</emphasis> The type of object to allocate/deallocate. T must have a non-throwing destructor.</para><para><emphasis role="bold">UserAllocator</emphasis> Defines the allocator that the underlying Pool will use to allocate memory from the system. See <ulink url="boost_pool/pool/pooling.html#boost_pool.pool.pooling.user_allocator">User Allocators</ulink> for details.</para><para>Class <link linkend="doxygen.boost_pool_c___reference.classboost_1_1object__pool">object_pool</link> is a template class that can be used for fast and efficient memory allocation of objects. It also provides automatic destruction of non-deallocated objects.</para><para>When the object pool is destroyed, then the destructor for type T is called for each allocated T that has not yet been deallocated. O(N).</para><para>Whenever an object of type ObjectPool needs memory from the system, it will request it from its UserAllocator template parameter. The amount requested is determined using a doubling algorithm; that is, each time more system memory is allocated, the amount of system memory requested is doubled. Users may control the doubling algorithm by the parameters passed to the <link linkend="doxygen.boost_pool_c___reference.classboost_1_1object__pool">object_pool</link>'s constructor. </para></description><method-group name="protected member functions">
<method id="doxygen.boost_pool_c___reference.classboost_1_1object__pool_1ac46c8eae24436fa125a22a55180482fe" name="store"><type><classname>pool</classname>&lt; UserAllocator &gt; &amp;</type><description><para>
</para></description><returns><para>The underlying boost:: <link linkend="doxygen.boost_pool_c___reference.classboost_1_1pool">pool</link> storage used by *this. </para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1object__pool_1a008fa107fa5473f5367b11b020c6b161" name="store" cv="const"><type>const <classname>pool</classname>&lt; UserAllocator &gt; &amp;</type><description><para>
</para></description><returns><para>The underlying boost:: <link linkend="doxygen.boost_pool_c___reference.classboost_1_1pool">pool</link> storage used by *this. </para>
</returns></method>
</method-group>
<method-group name="protected static functions">
<method id="doxygen.boost_pool_c___reference.classboost_1_1object__pool_1aca7c4555ab966c6e042ad719479d50ca" name="nextof" specifiers="static"><type>void *&amp;</type><parameter name="ptr"><paramtype>void *const</paramtype></parameter><description><para>
</para></description><returns><para>The next memory block after ptr (for the sake of code readability :)</para>
</returns></method>
</method-group>
<method-group name="public member functions">
<constructor id="doxygen.boost_pool_c___reference.classboost_1_1object__pool_1a6216a1f7b7a0625b58d8d451ac3dd2c0" specifiers="explicit"><parameter name="arg_next_size"><paramtype>const size_type</paramtype><default>32</default></parameter><parameter name="arg_max_size"><paramtype>const size_type</paramtype><default>0</default></parameter><description><para>Constructs a new (empty by default) ObjectPool. 


</para></description><requires><para>next_size != 0. </para>
</requires></constructor>
<destructor id="doxygen.boost_pool_c___reference.classboost_1_1object__pool_1aa55bebffcf7c2cf612b8e1837e8685b7"/>
<method id="doxygen.boost_pool_c___reference.classboost_1_1object__pool_1afa33c40e90c4991963691226935f0b5a" name="malloc"><type>element_type *</type><description><para>Allocates memory that can hold one object of type ElementType.</para><para>If out of memory, returns 0.</para><para>Amortized O(1).</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1object__pool_1a1dcfdb5d3432bfbf773759d679b65a83" name="free"><type>void</type><parameter name="chunk"><paramtype>element_type *const</paramtype></parameter><description><para>De-Allocates memory that holds a chunk of type ElementType.</para><para>Note that p may not be 0.<sbr/>
 Note that the destructor for p is not called. O(N).</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1object__pool_1a038ba5715aaa64136f724ec3e6c7b3eb" name="is_from" cv="const"><type>bool</type><parameter name="chunk"><paramtype>element_type *const</paramtype></parameter><description><para>
Returns false if chunk was allocated from some other pool or may be returned as the result of a future allocation from some other pool.</para><para>Otherwise, the return value is meaningless.</para><para><note><para>This function may NOT be used to reliably test random pointer values!</para>
</note>
</para></description><returns><para>true if chunk was allocated from *this or may be returned as the result of a future allocation from *this.</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1object__pool_1a44c96ef0ab8cdbae82bf447810c6ce9a" name="construct"><type>element_type *</type><description><para>
</para></description><returns><para>A pointer to an object of type T, allocated in memory from the underlying pool and default constructed. The returned objected can be freed by a call to <link linkend="doxygen.boost_pool_c___reference.classboost_1_1object__pool_1a8f65da7b01fcfbbbedf866a133ad19f7">destroy</link>. Otherwise the returned object will be automatically destroyed when *this is destroyed.</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1object__pool_1a54fd24e59bcac7e83421356bc0f5b31d" name="construct"><type>element_type *</type><template>
          <template-type-parameter name="Arg1"/>
          <template-nontype-parameter name="ArgN"><type>... class</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>Arg1 &amp;</paramtype></parameter><parameter name=""><paramtype>... ArgN &amp;</paramtype></parameter><description><para>
<note><para>Since the number and type of arguments to this function is totally arbitrary, a simple system has been set up to automatically generate template construct functions. This system is based on the macro preprocessor m4, which is standard on UNIX systems and also available for Win32 systems.<sbr/>
<sbr/>
detail/pool_construct.m4, when run with m4, will create the file detail/pool_construct.ipp, which only defines the construct functions for the proper number of arguments. The number of arguments may be passed into the file as an m4 macro, NumberOfArguments; if not provided, it will default to 3.<sbr/>
<sbr/>
For each different number of arguments (1 to NumberOfArguments), a template function is generated. There are the same number of template parameters as there are arguments, and each argument's type is a reference to that (possibly cv-qualified) template argument. Each possible permutation of the cv-qualifications is also generated.<sbr/>
<sbr/>
Because each permutation is generated for each possible number of arguments, the included file size grows exponentially in terms of the number of constructor arguments, not linearly. For the sake of rational compile times, only use as many arguments as you need.<sbr/>
<sbr/>
detail/pool_construct.bat and detail/pool_construct.sh are also provided to call m4, defining NumberOfArguments to be their command-line parameter. See these files for more details.</para>
</note>
</para></description><returns><para>A pointer to an object of type T, allocated in memory from the underlying pool and constructed from arguments Arg1 to ArgN. The returned objected can be freed by a call to <link linkend="doxygen.boost_pool_c___reference.classboost_1_1object__pool_1a8f65da7b01fcfbbbedf866a133ad19f7">destroy</link>. Otherwise the returned object will be automatically destroyed when *this is destroyed.</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1object__pool_1a8f65da7b01fcfbbbedf866a133ad19f7" name="destroy"><type>void</type><parameter name="chunk"><paramtype>element_type *const</paramtype></parameter><description><para>Destroys an object allocated with <link linkend="doxygen.boost_pool_c___reference.classboost_1_1object__pool_1a44c96ef0ab8cdbae82bf447810c6ce9a">construct</link>.</para><para>Equivalent to:</para><para>p-&gt;~ElementType(); this-&gt;free(p);</para><para>
</para></description><requires><para>p must have been previously allocated from *this via a call to <link linkend="doxygen.boost_pool_c___reference.classboost_1_1object__pool_1a44c96ef0ab8cdbae82bf447810c6ce9a">construct</link>.</para>
</requires></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1object__pool_1a4d46e34d4605d1689f6808d24d790d28" name="get_next_size" cv="const"><type>size_type</type><description><para>
</para></description><returns><para>The number of chunks that will be allocated next time we run out of memory.</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1object__pool_1a74a501bb377ec5ccc18da2b39ed233f7" name="set_next_size"><type>void</type><parameter name="x"><paramtype>const size_type</paramtype><description><para>wanted next_size (must not be zero).</para></description></parameter><description><para>Set a new number of chunks to allocate the next time we run out of memory. 
</para></description></method>
</method-group>
</class><class id="doxygen.boost_pool_c___reference.classboost_1_1pool" name="pool"><template>
      <template-type-parameter name="UserAllocator"/>
    </template><inherit access="protected">boost::simple_segregated_storage&lt; UserAllocator::size_type &gt;</inherit><purpose>A fast memory allocator that guarantees proper alignment of all allocated chunks. </purpose><description><para>Whenever an object of type pool needs memory from the system, it will request it from its UserAllocator template parameter. The amount requested is determined using a doubling algorithm; that is, each time more system memory is allocated, the amount of system memory requested is doubled.</para><para>Users may control the doubling algorithm by using the following extensions:</para><para>Users may pass an additional constructor parameter to pool. This parameter is of type size_type, and is the number of chunks to request from the system the first time that object needs to allocate system memory. The default is 32. This parameter may not be 0.</para><para>Users may also pass an optional third parameter to pool's constructor. This parameter is of type size_type, and sets a maximum size for allocated chunks. When this parameter takes the default value of 0, then there is no upper limit on chunk size.</para><para>Finally, if the doubling algorithm results in no memory being allocated, the pool will backtrack just once, halving the chunk size and trying again.</para><para><emphasis role="bold">UserAllocator type</emphasis> - the method that the Pool will use to allocate memory from the system.</para><para>There are essentially two ways to use class pool: the client can call <link linkend="doxygen.boost_pool_c___reference.classboost_1_1pool_1af9052867b239e8623fc20fd73a7b4d7b">malloc()</link> and <link linkend="doxygen.boost_pool_c___reference.classboost_1_1pool_1af75b007562bab4ed80860261e0752f51">free()</link> to allocate and free single chunks of memory, this is the most efficient way to use a pool, but does not allow for the efficient allocation of arrays of chunks. Alternatively, the client may call <link linkend="doxygen.boost_pool_c___reference.classboost_1_1pool_1adc89892e1fed68d541c6a8c40b01ad57">ordered_malloc()</link> and <link linkend="doxygen.boost_pool_c___reference.classboost_1_1pool_1aca402414a3920eb67d800b2c38581533">ordered_free()</link>, in which case the free list is maintained in an ordered state, and efficient allocation of arrays of chunks are possible. However, this latter option can suffer from poor performance when large numbers of allocations are performed. </para></description><method-group name="private member functions">
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1aa28e378d455b528da508198c9bbb46fd" name="malloc_need_resize"><type>void *</type><description><para>
</para></description><description><para>No memory in any of our storages; make a new storage, Allocates chunk in newly malloc aftert resize. 
</para></description><returns><para>0 if out-of-memory. Called if malloc/ordered_malloc needs to resize the free list. </para>
</returns><returns><para>pointer to chunk.</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1a4126578d7378dd66ff35928748d9cc2a" name="ordered_malloc_need_resize"><type>void *</type><purpose>Called if malloc needs to resize the free list. </purpose><description><para>No memory in any of our storages; make a new storage, 
</para></description><returns><para>pointer to new chunk.</para>
</returns></method>
</method-group>
<method-group name="protected member functions">
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1a8ae8c592cafd3005833985e6007f4ce9" name="store"><type><classname>simple_segregated_storage</classname>&lt; size_type &gt; &amp;</type><description><para>
</para></description><returns><para>pointer to store.</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1abe909c23eb3fa1001828e66c087de3a8" name="store" cv="const"><type>const <classname>simple_segregated_storage</classname>&lt; size_type &gt; &amp;</type><description><para>
</para></description><returns><para>pointer to store.</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1a45fee647ab7f770084f9df17b4dcb349" name="find_POD" cv="const"><type><classname>details::PODptr</classname>&lt; size_type &gt;</type><parameter name="chunk"><paramtype>void *const</paramtype></parameter><purpose>finds which POD in the list 'chunk' was allocated from. </purpose><description><para>find which PODptr storage memory that this chunk is from. 
</para></description><returns><para>the PODptr that holds this chunk.</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1a5e45c9d14db05e898fb6aafca2fddf09" name="alloc_size" cv="const"><type>size_type</type><description><para>Calculated size of the memory chunks that will be allocated by this Pool. 
</para></description><returns><para>allocated size.</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1aac21da60f091ec190d2833a995a08d10" name="max_chunks" cv="const"><type>size_type</type><description><para>Calculated maximum number of memory chunks that can be allocated in a single call by this Pool.</para></description></method>
</method-group>
<method-group name="protected static functions">
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1a9742ecb2b7c3e2d3a6037b7885515be1" name="is_from" specifiers="static"><type>bool</type><parameter name="chunk"><paramtype>void *const</paramtype><description><para>chunk to check if is from this pool. </para></description></parameter><parameter name="i"><paramtype>char *const</paramtype><description><para>memory chunk at i with element sizeof_i. </para></description></parameter><parameter name="sizeof_i"><paramtype>const size_type</paramtype><description><para>element size (size of the chunk area of that block, not the total size of that block). </para></description></parameter><description><para>

Returns false if chunk was allocated from some other pool, or may be returned as the result of a future allocation from some other pool. Otherwise, the return value is meaningless.</para><para>Note that this function may not be used to reliably test random pointer values.</para></description><returns><para>true if chunk was allocated or may be returned. as the result of a future allocation.</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1a647d065ad02da75fca18b83936508b8e" name="nextof" specifiers="static"><type>void *&amp;</type><parameter name="ptr"><paramtype>void *const</paramtype></parameter><description><para>
</para></description><returns><para>Pointer dereferenced. (Provided and used for the sake of code readability :)</para>
</returns></method>
</method-group>
<method-group name="public member functions">
<constructor id="doxygen.boost_pool_c___reference.classboost_1_1pool_1ad7c9846bf121da66fffed34983b4768c" specifiers="explicit"><parameter name="nrequested_size"><paramtype>const size_type</paramtype><description><para>Requested chunk size </para></description></parameter><parameter name="nnext_size"><paramtype>const size_type</paramtype><default>32</default><description><para>parameter is of type size_type, is the number of chunks to request from the system the first time that object needs to allocate system memory. The default is 32. This parameter may not be 0. </para></description></parameter><parameter name="nmax_size"><paramtype>const size_type</paramtype><default>0</default><description><para>is the maximum number of chunks to allocate in one block.</para></description></parameter><description><para>Constructs a new empty Pool that can be used to allocate chunks of size RequestedSize. 
</para></description></constructor>
<destructor id="doxygen.boost_pool_c___reference.classboost_1_1pool_1a60752fe8cccb8fe989abe2e72c91c311"><description><para>Destructs the Pool, freeing its list of memory blocks.</para></description></destructor>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1a1132035ce513c0ff2659d1b7c7575c17" name="release_memory"><type>bool</type><description><para>pool must be ordered. Frees every memory block that doesn't have any allocated chunks. 
</para></description><returns><para>true if at least one memory block was freed.</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1a0ce9152982cbc7708f67448f8bd65fb4" name="purge_memory"><type>bool</type><description><para>pool must be ordered. Frees every memory block.</para><para>This function invalidates any pointers previously returned by allocation functions of t. 
</para></description><returns><para>true if at least one memory block was freed.</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1a3768a795a629249618f0238de0edf8db" name="get_next_size" cv="const"><type>size_type</type><description><para>Number of chunks to request from the system the next time that object needs to allocate system memory. This value should never be 0. 
</para></description><returns><para>next_size;</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1a848bb66044817b4a4ee0fd80a5cc5d6e" name="set_next_size"><type>void</type><parameter name="nnext_size"><paramtype>const size_type</paramtype></parameter><description><para>Set number of chunks to request from the system the next time that object needs to allocate system memory. This value should never be set to 0.</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1a1ce292da5c327b318958f8861c3a733d" name="get_max_size" cv="const"><type>size_type</type><description><para>
</para></description><returns><para>max_size.</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1a6fa26b3d49451c16d2235d56430aef50" name="set_max_size"><type>void</type><parameter name="nmax_size"><paramtype>const size_type</paramtype></parameter><description><para>Set max_size.</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1a5e1075c1466dd1bb77c453e66d55fc0a" name="get_requested_size" cv="const"><type>size_type</type><description><para>
</para></description><returns><para>the requested size passed into the constructor. (This value will not change during the lifetime of a Pool object).</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1af9052867b239e8623fc20fd73a7b4d7b" name="malloc"><type>void *</type><description><para>Allocates a chunk of memory. Searches in the list of memory blocks for a block that has a free chunk, and returns that free chunk if found. Otherwise, creates a new memory block, adds its free list to pool's free list, 
</para></description><returns><para>a free chunk from that block. If a new memory block cannot be allocated, returns 0. Amortized O(1).</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1adc89892e1fed68d541c6a8c40b01ad57" name="ordered_malloc"><type>void *</type><description><para>Same as malloc, only merges the free lists, to preserve order. Amortized O(1). 
</para></description><returns><para>a free chunk from that block. If a new memory block cannot be allocated, returns 0. Amortized O(1).</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1a5944c78bdc6847943051466b1545d1f3" name="ordered_malloc"><type>void *</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para>Gets address of a chunk n, allocating new memory if not already available. 

</para></description><returns><para>Address of chunk n if allocated ok. </para>
</returns><returns><para>0 if not enough memory for n chunks.</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1af75b007562bab4ed80860261e0752f51" name="free"><type>void</type><parameter name="chunk"><paramtype>void *const</paramtype></parameter><description><para>Same as malloc, only allocates enough contiguous chunks to cover n * requested_size bytes. Amortized O(n). 
</para></description><description><para>Deallocates a chunk of memory. Note that chunk may not be 0. O(1).</para><para>Chunk must have been previously returned by t.malloc() or t.ordered_malloc(). Assumes that chunk actually refers to a block of chunks spanning n * partition_sz bytes. deallocates each chunk in that block. Note that chunk may not be 0. O(n).</para></description><returns><para>a free chunk from that block. If a new memory block cannot be allocated, returns 0. Amortized O(1). </para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1aca402414a3920eb67d800b2c38581533" name="ordered_free"><type>void</type><parameter name="chunk"><paramtype>void *const</paramtype></parameter><description><para>Same as above, but is order-preserving.</para><para>Note that chunk may not be 0. O(N) with respect to the size of the free list. chunk must have been previously returned by t.malloc() or t.ordered_malloc().</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1aa7505f045b2e5517cd8ce2ba104c74ae" name="free"><type>void</type><parameter name="chunks"><paramtype>void *const</paramtype></parameter><parameter name="n"><paramtype>const size_type</paramtype></parameter><description><para>Assumes that chunk actually refers to a block of chunks.</para><para>chunk must have been previously returned by t.ordered_malloc(n) spanning n * partition_sz bytes. Deallocates each chunk in that block. Note that chunk may not be 0. O(n).</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1a3afd0962c8693316db536fd817918105" name="ordered_free"><type>void</type><parameter name="chunks"><paramtype>void *const</paramtype></parameter><parameter name="n"><paramtype>const size_type</paramtype></parameter><description><para>Assumes that chunk actually refers to a block of chunks spanning n * partition_sz bytes; deallocates each chunk in that block.</para><para>Note that chunk may not be 0. Order-preserving. O(N + n) where N is the size of the free list. chunk must have been previously returned by t.malloc() or t.ordered_malloc().</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool_1ae9fdb0b69d12775105e726841af224ee" name="is_from" cv="const"><type>bool</type><parameter name="chunk"><paramtype>void *const</paramtype></parameter><description><para>
</para></description><returns><para>Returns true if chunk was allocated from u or may be returned as the result of a future allocation from u. Returns false if chunk was allocated from some other pool or may be returned as the result of a future allocation from some other pool. Otherwise, the return value is meaningless. Note that this function may not be used to reliably test random pointer values.</para>
</returns></method>
</method-group>
</class><class id="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator" name="pool_allocator"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="UserAllocator"/>
      <template-type-parameter name="Mutex"/>
      <template-nontype-parameter name="NextSize"><type>unsigned</type></template-nontype-parameter>
      <template-nontype-parameter name="MaxSize"><type>unsigned</type></template-nontype-parameter>
    </template><purpose>A C++ Standard Library conforming allocator, based on an underlying pool. </purpose><description><para>Template parameters for <link linkend="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator">pool_allocator</link> are defined as follows:</para><para><emphasis role="bold">T</emphasis> Type of object to allocate/deallocate.</para><para><emphasis role="bold">UserAllocator</emphasis>. Defines the method that the underlying Pool will use to allocate memory from the system. See <ulink url="boost_pool/pool/pooling.html#boost_pool.pool.pooling.user_allocator">User Allocators</ulink> for details.</para><para><emphasis role="bold">Mutex</emphasis> Allows the user to determine the type of synchronization to be used on the underlying <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link>.</para><para><emphasis role="bold">NextSize</emphasis> The value of this parameter is passed to the underlying <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link> when it is created.</para><para><emphasis role="bold">MaxSize</emphasis> Limit on the maximum size used.</para><para><important><para>The underlying <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link> used by the this allocator constructs a pool instance that <emphasis role="bold">is never freed</emphasis>. This means that memory allocated by the allocator can be still used after main() has completed, but may mean that some memory checking programs will complain about leaks. </para>
</important>
</para></description><method-group name="public member functions">
<constructor id="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator_1ad88508bcc45fceca67c27be54b3f4a90"><description><para>Results in default construction of the underlying <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link> IFF an instance of this allocator is constructed during global initialization ( required to ensure construction of <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link> IFF an instance of this allocator is constructed during global initialization. See ticket #2359 for a complete explanation at <ulink url="http://svn.boost.org/trac/boost/ticket/2359">http://svn.boost.org/trac/boost/ticket/2359</ulink>) .</para></description></constructor>
<constructor id="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator_1a61534e4b8aa94b125f290d431eec6c5c"><template>
          <template-type-parameter name="U"/>
        </template><parameter name=""><paramtype>const <classname>pool_allocator</classname>&lt; U, UserAllocator, Mutex, NextSize, MaxSize &gt; &amp;</paramtype></parameter><description><para>Results in the default construction of the underlying <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link>, this is required to ensure construction of <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link> IFF an instance of this allocator is constructed during global initialization. See ticket #2359 for a complete explanation at <ulink url="http://svn.boost.org/trac/boost/ticket/2359">http://svn.boost.org/trac/boost/ticket/2359</ulink> .</para></description></constructor>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator_1a6c17b6c415b4c242f4a1f56c0adc677c" name="operator==" cv="const"><type>bool</type><parameter name=""><paramtype>const <classname>pool_allocator</classname> &amp;</paramtype></parameter></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator_1a259b4780834985f78525d9e1b011c259" name="operator!=" cv="const"><type>bool</type><parameter name=""><paramtype>const <classname>pool_allocator</classname> &amp;</paramtype></parameter></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator_1a9cd2b2ddb69430473cdb7172942c3a9e" name="address" specifiers="static"><type>pointer</type><parameter name="r"><paramtype>reference</paramtype></parameter></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator_1a2e3efab718647cc9cf8c608703712281" name="address" specifiers="static"><type>const_pointer</type><parameter name="s"><paramtype>const_reference</paramtype></parameter></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator_1ab629505ce4532ceb4dee0228f98989f9" name="max_size" specifiers="static"><type>size_type</type></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator_1a2035bb6106237a3a6e30ca71314bdd00" name="construct" specifiers="static"><type>void</type><parameter name="ptr"><paramtype>const pointer</paramtype></parameter><parameter name="t"><paramtype>const value_type &amp;</paramtype></parameter></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator_1a062384543c5991717542951e3c8d6239" name="destroy" specifiers="static"><type>void</type><parameter name="ptr"><paramtype>const pointer</paramtype></parameter></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator_1aa420af2372fef49feb118c34092c8eb7" name="allocate" specifiers="static"><type>pointer</type><parameter name="n"><paramtype>const size_type</paramtype></parameter></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator_1a306a471b79f79147903cff6b1173ebda" name="allocate" specifiers="static"><type>pointer</type><parameter name="n"><paramtype>const size_type</paramtype><description><para>bytes to allocate. </para></description></parameter><parameter name=""><paramtype>const void * const</paramtype></parameter><description><para>allocate n bytes</para><para>
</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1pool__allocator_1ab097fc65a24a2610d721317e140e311c" name="deallocate" specifiers="static"><type>void</type><parameter name="ptr"><paramtype>const pointer</paramtype><description><para>location to deallocate from. </para></description></parameter><parameter name="n"><paramtype>const size_type</paramtype><description><para>number of bytes to deallocate.</para></description></parameter><description><para>Deallocate n bytes from ptr 
</para></description></method>
</method-group>
</class></namespace>
</header>
<header id="doxygen.boost_pool_c___reference.simple__segregated__storage_8hpp" name="boost/pool/simple_segregated_storage.hpp">
<para>Simple Segregated Storage. </para><para>A simple segregated storage implementation: simple segregated storage is the basic idea behind the Boost Pool library. Simple segregated storage is the simplest, and probably the fastest, memory allocation/deallocation algorithm. It begins by partitioning a memory block into fixed-size chunks. Where the block comes from is not important until implementation time. A Pool is some object that uses Simple Segregated Storage in this fashion. </para><namespace name="boost">
<class id="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage" name="simple_segregated_storage"><template>
      <template-type-parameter name="SizeType"><default>std::size_t</default></template-type-parameter>
    </template><purpose>Simple Segregated Storage is the simplest, and probably the fastest, memory allocation/deallocation algorithm. It is responsible for partitioning a memory block into fixed-size chunks: where the block comes from is determined by the client of the class. </purpose><description><para>Template class <link linkend="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage">simple_segregated_storage</link> controls access to a free list of memory chunks. Please note that this is a very simple class, with preconditions on almost all its functions. It is intended to be the fastest and smallest possible quick memory allocator - e.g., something to use in embedded systems. This class delegates many difficult preconditions to the user (i.e., alignment issues).</para><para>An object of type simple_segregated_storage&lt;SizeType&gt; is empty if its free list is empty. If it is not empty, then it is ordered if its free list is ordered. A free list is ordered if repeated calls to <computeroutput><link linkend="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1a39f01a838f1928cba031cae6d3826444">malloc()</link></computeroutput> will result in a constantly-increasing sequence of values, as determined by <computeroutput>std::less&lt;void *&gt;</computeroutput>. A member function is <emphasis>order-preserving</emphasis> if the free list maintains its order orientation (that is, an ordered free list is still ordered after the member function call). </para></description><typedef id="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1ab4b473ba89b8c5cba04b986a843f890f" name="size_type"><type>SizeType</type></typedef>
<method-group name="private member functions">
<constructor id="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1a75ab1f5ebcdcbd31bb2a9187d4fec332"><parameter name=""><paramtype>const <classname>simple_segregated_storage</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment id="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1a48abb001b04d9aec5c00a0acca54e81f"><type>void</type><parameter name=""><paramtype>const <classname>simple_segregated_storage</classname> &amp;</paramtype></parameter></copy-assignment>
</method-group>
<method-group name="private static functions">
<method id="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1a10bbd9d10214529aefa5387561c27439" name="try_malloc_n" specifiers="static"><type>void *</type><parameter name="start"><paramtype>void *&amp;</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="partition_size"><paramtype>size_type</paramtype></parameter><description><para>

</para></description><requires><para>(n &gt; 0), (start != 0), (nextof(start) != 0) </para>
</requires><postconditions><para>(start != 0) The function attempts to find n contiguous chunks of size partition_size in the free list, starting at start. If it succeds, it returns the last chunk in that contiguous sequence, so that the sequence is known by [start, {retval}] If it fails, it does do either because it's at the end of the free list or hits a non-contiguous chunk. In either case, it will return 0, and set start to the last considered chunk. You are at the end of the free list if nextof(start) == 0. Otherwise, start points to the last chunk in the contiguous sequence, and nextof(start) points to the first chunk in the next contiguous sequence (assuming an ordered free list). </para>
</postconditions></method>
</method-group>
<method-group name="protected member functions">
<method id="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1acfc346dce5955df4c48a9bab9b0c2e06" name="find_prev"><type>void *</type><parameter name="ptr"><paramtype>void *</paramtype></parameter><description><para>Traverses the free list referred to by "first", and returns the iterator previous to where "ptr" would go if it was in the free list. Returns 0 if "ptr" would go at the beginning of the free list (i.e., before "first"). <note><para>Note that this function finds the location previous to where ptr would go if it was in the free list. It does not find the entry in the free list before ptr (unless ptr is already in the free list). Specifically, find_prev(0) will return 0, not the last entry in the free list. </para>
</note>

</para></description><returns><para>location previous to where ptr would go if it was in the free list. </para>
</returns></method>
</method-group>
<method-group name="protected static functions">
<method id="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1a4ee181a8a1d3fdabb78b49a7c57875bf" name="nextof" specifiers="static"><type>void *&amp;</type><parameter name="ptr"><paramtype>void *const</paramtype></parameter><description><para>The return value is just *ptr cast to the appropriate type. ptr must not be 0. (For the sake of code readability :)</para><para>As an example, let us assume that we want to truncate the free list after the first chunk. That is, we want to set *first to 0; this will result in a free list with only one entry. The normal way to do this is to first cast first to a pointer to a pointer to void, and then dereference and assign (*static_cast&lt;void **&gt;(first) = 0;). This can be done more easily through the use of this convenience function (nextof(first) = 0;). 
</para></description><returns><para>dereferenced pointer.</para>
</returns></method>
</method-group>
<method-group name="public member functions">
<constructor id="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1ac53c269d9e59802b32001d80407d582f"><description><para>Construct empty storage area. 
</para></description><postconditions><para><link linkend="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1a1d39b9f2298361a46483cf1468ce1346">empty()</link></para>
</postconditions></constructor>
<method id="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1a96bb4fb051edea7d0f3c44d5637918c2" name="add_block"><type>void</type><parameter name="block"><paramtype>void *const</paramtype></parameter><parameter name="nsz"><paramtype>const size_type</paramtype></parameter><parameter name="npartition_sz"><paramtype>const size_type</paramtype></parameter><description><para>Add block Segregate this block and merge its free list into the free list referred to by "first". 

</para></description><requires><para>Same as segregate. </para>
</requires><postconditions><para>!empty()</para>
</postconditions></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1ae4078771e60bb3d188e1cf79a6f69629" name="add_ordered_block"><type>void</type><parameter name="block"><paramtype>void *const</paramtype></parameter><parameter name="nsz"><paramtype>const size_type</paramtype></parameter><parameter name="npartition_sz"><paramtype>const size_type</paramtype></parameter><description><para>add block (ordered into list) This (slower) version of add_block segregates the block and merges its free list into our free list in the proper order.</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1a1d39b9f2298361a46483cf1468ce1346" name="empty" cv="const"><type>bool</type><description><para>
</para></description><returns><para>true only if <link linkend="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage">simple_segregated_storage</link> is empty.</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1a39f01a838f1928cba031cae6d3826444" name="malloc"><type>void *</type><description><para>Create a chunk. 
</para></description><requires><para>!empty() Increment the "first" pointer to point to the next chunk.</para>
</requires></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1acf1dbdaf47e328ae8c882542ffee7029" name="free"><type>void</type><parameter name="chunk"><paramtype>void *const</paramtype></parameter><description><para>Free a chunk. 

</para></description><requires><para>chunk was previously returned from a <link linkend="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1a39f01a838f1928cba031cae6d3826444">malloc()</link> referring to the same free list. </para>
</requires><postconditions><para>!empty()</para>
</postconditions></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1a33fac301f6a81b169d5bc70ebd7827f6" name="ordered_free"><type>void</type><parameter name="chunk"><paramtype>void *const</paramtype></parameter><description><para>This (slower) implementation of 'free' places the memory back in the list in its proper order. 

</para></description><requires><para>chunk was previously returned from a <link linkend="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1a39f01a838f1928cba031cae6d3826444">malloc()</link> referring to the same free list </para>
</requires><postconditions><para>!empty().</para>
</postconditions></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1a8841fe26c425992669368bff5f8d2989" name="malloc_n"><type>void *</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="partition_size"><paramtype>size_type</paramtype></parameter><description><para>Attempts to find a contiguous sequence of n partition_sz-sized chunks. If found, removes them all from the free list and returns a pointer to the first. If not found, returns 0. It is strongly recommended (but not required) that the free list be ordered, as this algorithm will fail to find a contiguous sequence unless it is contiguous in the free list as well. Order-preserving. O(N) with respect to the size of the free list. </para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1a6c77c2626c1b3cca53b6d1ee80924839" name="free_n"><type>void</type><parameter name="chunks"><paramtype>void *const</paramtype></parameter><parameter name="n"><paramtype>const size_type</paramtype></parameter><parameter name="partition_size"><paramtype>const size_type</paramtype></parameter><description><para>

<note><para>If you're allocating/deallocating n a lot, you should be using an ordered pool. </para>
</note>
</para></description><requires><para>chunks was previously allocated from *this with the same values for n and partition_size. </para>
</requires><postconditions><para>!empty() </para>
</postconditions></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1a8d2ad5d0f4c0b2798710252d8957dc6a" name="ordered_free_n"><type>void</type><parameter name="chunks"><paramtype>void *const</paramtype></parameter><parameter name="n"><paramtype>const size_type</paramtype></parameter><parameter name="partition_size"><paramtype>const size_type</paramtype></parameter><description><para>Free n chunks from order list. 

</para></description><requires><para>chunks was previously allocated from *this with the same values for n and partition_size.</para>
</requires><requires><para>n should not be zero (n == 0 has no effect).</para>
</requires></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_pool_c___reference.classboost_1_1simple__segregated__storage_1ae3c3bcdafd3f30d6e0ff9194f340d1f9" name="segregate" specifiers="static"><type>void *</type><parameter name="block"><paramtype>void *</paramtype></parameter><parameter name="nsz"><paramtype>size_type</paramtype></parameter><parameter name="npartition_sz"><paramtype>size_type</paramtype></parameter><parameter name="end"><paramtype>void *</paramtype><default>0</default></parameter><description><para>Segregate block into chunks. 



</para></description><requires><para>npartition_sz &gt;= sizeof(void *) </para>
</requires><requires><para>npartition_sz = sizeof(void *) * i, for some integer i </para>
</requires><requires><para>nsz &gt;= npartition_sz </para>
</requires><requires><para>Block is properly aligned for an array of object of size npartition_sz and array of void *. The requirements above guarantee that any pointer to a chunk (which is a pointer to an element in an array of npartition_sz) may be cast to void **. </para>
</requires></method>
</method-group>
</class></namespace>
<macro id="doxygen.boost_pool_c___reference.simple__segregated__storage_8hpp_1acab210ef5b761593792fb53e618f566d" name="BOOST_POOL_VALIDATE_INTERNALS"/>
</header>
<header id="doxygen.boost_pool_c___reference.singleton__pool_8hpp" name="boost/pool/singleton_pool.hpp">
<para>The <computeroutput>singleton_pool</computeroutput> class allows other pool interfaces for types of the same size to share the same underlying pool. </para><para>Header <link linkend="doxygen.boost_pool_c___reference.singleton__pool_8hpp">singleton_pool.hpp</link> provides a template class <computeroutput>singleton_pool</computeroutput>, which provides access to a pool as a singleton object. </para><namespace name="boost">
<class id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool" name="singleton_pool"><template>
      <template-type-parameter name="Tag"/>
      <template-nontype-parameter name="RequestedSize"><type>unsigned</type></template-nontype-parameter>
      <template-type-parameter name="UserAllocator"><default>default_user_allocator_new_delete</default></template-type-parameter>
      <template-type-parameter name="Mutex"><default>details::pool::default_mutex</default></template-type-parameter>
      <template-nontype-parameter name="NextSize"><type>unsigned</type><default>32</default></template-nontype-parameter>
      <template-nontype-parameter name="MaxSize"><type>unsigned</type><default>0</default></template-nontype-parameter>
    </template><description><para>The <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link> class allows other pool interfaces for types of the same size to share the same pool. Template parameters are as follows:</para><para><emphasis role="bold">Tag</emphasis> User-specified type to uniquely identify this pool: allows different unbounded sets of singleton pools to exist.</para><para><emphasis role="bold">RequestedSize</emphasis> The size of each chunk returned by member function <computeroutput><link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1afe25e78e7f7f5659dac48d34074e0802">malloc()</link></computeroutput>.</para><para><emphasis role="bold">UserAllocator</emphasis> User allocator, default = <link linkend="doxygen.boost_pool_c___reference.structboost_1_1default__user__allocator__new__delete">default_user_allocator_new_delete</link>.</para><para><emphasis role="bold">Mutex</emphasis> This class is the type of mutex to use to protect simultaneous access to the underlying Pool. Can be any Boost.Thread Mutex type or <computeroutput>boost::details::pool::null_mutex</computeroutput>. It is exposed so that users may declare some singleton pools normally (i.e., with synchronization), but some singleton pools without synchronization (by specifying <computeroutput>boost::details::pool::null_mutex</computeroutput>) for efficiency reasons. The member typedef <computeroutput>mutex</computeroutput> exposes the value of this template parameter. The default for this parameter is boost::details::pool::default_mutex which is a synonym for either <computeroutput>boost::details::pool::null_mutex</computeroutput> (when threading support is turned off in the compiler (so BOOST_HAS_THREADS is not set), or threading support has ben explicitly disabled with BOOST_DISABLE_THREADS (Boost-wide disabling of threads) or BOOST_POOL_NO_MT (this library only)) or for <computeroutput>boost::mutex</computeroutput> (when threading support is enabled in the compiler).</para><para><emphasis role="bold">NextSize</emphasis> The value of this parameter is passed to the underlying Pool when it is created and specifies the number of chunks to allocate in the first allocation request (defaults to 32). The member typedef <computeroutput>static const value next_size</computeroutput> exposes the value of this template parameter.</para><para><emphasis role="bold">MaxSize</emphasis>The value of this parameter is passed to the underlying Pool when it is created and specifies the maximum number of chunks to allocate in any single allocation request (defaults to 0).</para><para><emphasis role="bold">Notes:</emphasis></para><para>The underlying pool <emphasis>p</emphasis> referenced by the static functions in <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link> is actually declared in a way that is:</para><para>1 Thread-safe if there is only one thread running before main() begins and after main() ends – all of the static functions of <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link> synchronize their access to p.</para><para>2 Guaranteed to be constructed before it is used – thus, the simple static object in the synopsis above would actually be an incorrect implementation. The actual implementation to guarantee this is considerably more complicated.</para><para>3 Note too that a different underlying pool p exists for each different set of template parameters, including implementation-specific ones.</para><para>4 The underlying pool is constructed "as if" by:</para><para>pool&lt;UserAllocator&gt; <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1a697141920e09016bc9030c3821edf061">p(RequestedSize, NextSize, MaxSize)</link>;</para><para><important><para>The underlying pool constructed by the singleton <emphasis role="bold">is never freed</emphasis>. This means that memory allocated by a <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link> can be still used after main() has completed, but may mean that some memory checking programs will complain about leaks from <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link>. </para>
</important>
</para></description><struct id="doxygen.boost_pool_c___reference.structboost_1_1singleton__pool_1_1object__creator" name="object_creator"><method-group name="public member functions">
<constructor id="doxygen.boost_pool_c___reference.structboost_1_1singleton__pool_1_1object__creator_1aa85f003fe2b6042f412e5abc1e9d565a"/>
<method id="doxygen.boost_pool_c___reference.structboost_1_1singleton__pool_1_1object__creator_1a8570244b9d82d6a81de28b5b31534f89" name="do_nothing" cv="const"><type>void</type></method>
</method-group>
</struct><typedef id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1abd842f2e2328480908ea421828905b52" name="tag"><description><para>The Tag template parameter uniquely identifies this pool and allows different unbounded sets of singleton pools to exist. For example, the pool allocators use two tag classes to ensure that the two different allocator types never share the same underlying singleton pool. Tag is never actually used by <link linkend="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool">singleton_pool</link>. </para></description><type>Tag</type></typedef>
<typedef id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1ad5d18e7eb70d43a94961619877bf7ff1" name="mutex"><purpose>The type of mutex used to synchonise access to this pool (default <computeroutput>details::pool::default_mutex</computeroutput>). </purpose><type>Mutex</type></typedef>
<typedef id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1a8c05b8a299d8c7391e376f4dc659c71f" name="user_allocator"><purpose>The user-allocator used by this pool, default = <computeroutput><link linkend="doxygen.boost_pool_c___reference.structboost_1_1default__user__allocator__new__delete">default_user_allocator_new_delete</link></computeroutput>. </purpose><type>UserAllocator</type></typedef>
<typedef id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1ae498ee1f1fdc9bda0f648b2e224d26d2" name="size_type"><purpose>size_type of user allocator. </purpose><type><classname>pool</classname>&lt; UserAllocator &gt;::size_type</type></typedef>
<typedef id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1aaffbe9abdb378cab2ba1a343308e96da" name="difference_type"><purpose>difference_type of user allocator. </purpose><type><classname>pool</classname>&lt; UserAllocator &gt;::difference_type</type></typedef>
<data-member id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1a8b826206d4f41f7600e50527f8fe4bcb" name="requested_size" specifiers="static"><type>const unsigned</type><purpose>The size of each chunk allocated by this pool. </purpose></data-member>
<data-member id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1a740c14b6b4675ad770b40942845c753c" name="next_size" specifiers="static"><type>const unsigned</type><purpose>The number of chunks to allocate on the first allocation. </purpose></data-member>
<data-member id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1a697141920e09016bc9030c3821edf061" name="p" specifiers="static"><type><classname>pool</classname>&lt; UserAllocator &gt;</type><purpose>For exposition only! </purpose></data-member>
<method-group name="private member functions">
<constructor id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1ae864c03b4cf2e756c16fa4693adb6060"/>
</method-group>
<method-group name="public static functions">
<method id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1afe25e78e7f7f5659dac48d34074e0802" name="malloc" specifiers="static"><type>void *</type><description><para>Equivalent to SingletonPool::p.malloc(); synchronized.</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1a6ea4c7d61529c7570c5eaea341e5dbcc" name="ordered_malloc" specifiers="static"><type>void *</type><description><para>Equivalent to SingletonPool::p.ordered_malloc(); synchronized.</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1ad6ed3c5bb8f1faa143dbcb2ad1bbbaf5" name="ordered_malloc" specifiers="static"><type>void *</type><parameter name="n"><paramtype>const size_type</paramtype></parameter><description><para>Equivalent to SingletonPool::p.ordered_malloc(n); synchronized.</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1a81e54e7aeb2392edf61e796c3dbafc6c" name="is_from" specifiers="static"><type>bool</type><parameter name="ptr"><paramtype>void *const</paramtype></parameter><description><para>Equivalent to SingletonPool::p.is_from(chunk); synchronized. 
</para></description><returns><para>true if chunk is from SingletonPool::is_from(chunk)</para>
</returns></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1aa20e9be7b6792e3f405c38448b32731d" name="free" specifiers="static"><type>void</type><parameter name="ptr"><paramtype>void *const</paramtype></parameter><description><para>Equivalent to SingletonPool::p.free(chunk); synchronized.</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1a615c8ae379d0fdd13d9fa06dd2b5869e" name="ordered_free" specifiers="static"><type>void</type><parameter name="ptr"><paramtype>void *const</paramtype></parameter><description><para>Equivalent to SingletonPool::p.ordered_free(chunk); synchronized.</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1ad2d71787e12f321371859542c59243e7" name="free" specifiers="static"><type>void</type><parameter name="ptr"><paramtype>void *const</paramtype></parameter><parameter name="n"><paramtype>const size_type</paramtype></parameter><description><para>Equivalent to SingletonPool::p.free(chunk, n); synchronized.</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1a466bdda8c90d13affcadff7390455610" name="ordered_free" specifiers="static"><type>void</type><parameter name="ptr"><paramtype>void *const</paramtype></parameter><parameter name="n"><paramtype>const size_type</paramtype></parameter><description><para>Equivalent to SingletonPool::p.ordered_free(chunk, n); synchronized.</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1a085914426cf6974f4a794db427e41675" name="release_memory" specifiers="static"><type>bool</type><description><para>Equivalent to SingletonPool::p.release_memory(); synchronized.</para></description></method>
<method id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1ac00b8f2aa0cd18f525b1006fb1460d68" name="purge_memory" specifiers="static"><type>bool</type><description><para>Equivalent to SingletonPool::p.purge_memory(); synchronized.</para></description></method>
</method-group>
<method-group name="private static functions">
<method id="doxygen.boost_pool_c___reference.classboost_1_1singleton__pool_1aec05c8122d8ad0cc5ccda0a2c7daa373" name="get_pool" specifiers="static"><type>pool_type &amp;</type></method>
</method-group>
</class></namespace>
</header>
</library-reference>