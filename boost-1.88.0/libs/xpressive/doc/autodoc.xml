<?xml version="1.0" standalone="yes"?>
<library-reference><header id="doxygen.basic__regex_8hpp" name="boost/xpressive/basic_regex.hpp">
<para>Contains the definition of the basic_regex&lt;&gt; class template and its associated helper functions. </para><namespace name="boost">
<namespace name="xpressive">
























































































<function id="doxygen.namespaceboost_1_1xpressive_1af6cdd2ef455a77e7f9378ebd97f341c7" name="swap"><type>void</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="left"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>The first <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> object. </para></description></parameter><parameter name="right"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>The second <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> object. </para></description></parameter><purpose>Swaps the contents of two <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> objects. </purpose><description><para>
<important><para>This is a shallow swap that does not do reference tracking. If you embed a <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> object by reference in another regular expression and then swap its contents with another <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> object, the change will not be visible to the enclosing regular expression. It is done this way to ensure that <link linkend="doxygen.namespaceboost_1_1xpressive_1af6cdd2ef455a77e7f9378ebd97f341c7">swap()</link> cannot throw. </para>
</important>

</para></description><throws><simpara>Will not throw.</simpara>
</throws></function>
</namespace>
</namespace>
</header>
<header id="doxygen.match__results_8hpp" name="boost/xpressive/match_results.hpp">
<para>Contains the definition of the match_results type and associated helpers. The match_results type holds the results of a regex_match() or regex_search() operation. </para><namespace name="boost">
<namespace name="xpressive">

























































































</namespace>
</namespace>
</header>
<header id="doxygen.regex__actions_8hpp" name="boost/xpressive/regex_actions.hpp">
<para>Defines the syntax elements of xpressive's action expressions. </para><namespace name="boost">
<namespace name="xpressive">
<struct id="doxygen.structboost_1_1xpressive_1_1function" name="function"><template>
      <template-type-parameter name="PolymorphicFunctionObject"/>
    </template><purpose>A unary metafunction that turns an ordinary function object type into the type of a deferred function object for use in xpressive semantic actions. </purpose><description><para>Use <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1function">xpressive::function</link>&lt;&gt;</computeroutput> to turn an ordinary polymorphic function object type into a type that can be used to declare an object for use in xpressive semantic actions.</para><para>For example, the global object <computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1a9cec0d7e6ed05c5df3960a214c03af08">xpressive::push_back</link></computeroutput> can be used to create deferred actions that have the effect of pushing a value into a container. It is defined with <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1function">xpressive::function</link>&lt;&gt;</computeroutput> as follows: <programlisting language="c++"><link linkend="doxygen.structboost_1_1xpressive_1_1function_1ac0ba99d9072741bb71fb8e225121eb54">xpressive::function&lt;xpressive::op::push_back&gt;::type</link> const <link linkend="doxygen.namespaceboost_1_1xpressive_1a9cec0d7e6ed05c5df3960a214c03af08">push_back</link> = {};
</programlisting> where <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1op_1_1push__back">op::push_back</link></computeroutput> is an ordinary function object that pushes its second argument into its first. Thus defined, <computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1a9cec0d7e6ed05c5df3960a214c03af08">xpressive::push_back</link></computeroutput> can be used in semantic actions as follows: <programlisting language="c++">namespace xp = <link linkend="doxygen.namespaceboost_1_1xpressive">boost::xpressive</link>;
using xp::_;
std::list&lt;int&gt; result;
std::string <link linkend="doxygen.namespaceboost_1_1xpressive_1a3359fafa9e5c7964a0bd5364de930e9c">str</link>("1 23 456 7890");
xp::sregex rx = (+<link linkend="doxygen.namespaceboost_1_1xpressive_1afae3ed7c3a8ebd3c2f06a943ff974a58">_d</link>)[ xp::push_back(xp::ref(result), xp::as&lt;int&gt;(<link linkend="doxygen.namespaceboost_1_1xpressive_1a12ce0e9a6350027c3c11d11e54411e23">_</link>) ]
    &gt;&gt; *(' ' &gt;&gt; (+<link linkend="doxygen.namespaceboost_1_1xpressive_1afae3ed7c3a8ebd3c2f06a943ff974a58">_d</link>)[ xp::push_back(xp::ref(result), xp::as&lt;int&gt;(<link linkend="doxygen.namespaceboost_1_1xpressive_1a12ce0e9a6350027c3c11d11e54411e23">_</link>) ) ]);
</programlisting> </para></description><typedef id="doxygen.structboost_1_1xpressive_1_1function_1ac0ba99d9072741bb71fb8e225121eb54" name="type"><type>proto::terminal&lt; PolymorphicFunctionObject &gt;::type</type></typedef>
</struct><namespace name="op">
<struct id="doxygen.structboost_1_1xpressive_1_1op_1_1at" name="at"><purpose><computeroutput>at</computeroutput> is a PolymorphicFunctionObject for indexing into a sequence </purpose><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1at_1_1result" name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization id="doxygen.structboost_1_1xpressive_1_1op_1_1at_1_1result_3_01This_07Cont_01_6_00_01Idx_08_4" name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Cont"/>
      <template-type-parameter name="Idx"/>
    </template><specialization><template-arg>This(Cont &amp;</template-arg><template-arg>Idx)</template-arg></specialization><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1at_1_1result_3_01This_07Cont_01_6_00_01Idx_08_4_1a100278a54344faee135eec695c367e07" name="type"><type>Cont::reference</type></typedef>
</struct-specialization><struct-specialization id="doxygen.structboost_1_1xpressive_1_1op_1_1at_1_1result_3_01This_07Cont_01const_01_6_00_01Idx_08_4" name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Cont"/>
      <template-type-parameter name="Idx"/>
    </template><specialization><template-arg>This(Cont const &amp;</template-arg><template-arg>Idx)</template-arg></specialization><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1at_1_1result_3_01This_07Cont_01const_01_6_00_01Idx_08_4_1ac78e88baf6059485fd0b8ed675fdc41d" name="type"><type>Cont::const_reference</type></typedef>
</struct-specialization><struct-specialization id="doxygen.structboost_1_1xpressive_1_1op_1_1at_1_1result_3_01This_07Cont_00_01Idx_08_4" name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Cont"/>
      <template-type-parameter name="Idx"/>
    </template><specialization><template-arg>This(Cont</template-arg><template-arg>Idx)</template-arg></specialization><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1at_1_1result_3_01This_07Cont_00_01Idx_08_4_1abace655dda982c4db4e01f40a96b94f8" name="type"><type>Cont::const_reference</type></typedef>
</struct-specialization><method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1at_1a569964943fe7764650d0795082074b3d" name="operator()" cv="const"><type>Cont::reference</type><template>
          <template-type-parameter name="Cont"/>
          <template-type-parameter name="Idx"/>
        </template><parameter name="c"><paramtype>Cont &amp;</paramtype><description><para>The RandomAccessSequence to index into </para></description></parameter><parameter name="idx"><paramtype>Idx</paramtype><description><para>The index </para></description></parameter><description><para>


</para></description><requires><para><computeroutput>Cont</computeroutput> is a model of RandomAccessSequence </para>
</requires><returns><para><computeroutput>c[idx]</computeroutput> </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1at_1acfea4b801f0b6744a73bd87cc205b496" name="operator()" cv="const"><type>Cont::const_reference</type><template>
          <template-type-parameter name="Cont"/>
          <template-type-parameter name="Idx"/>
        </template><parameter name="c"><paramtype>Cont const &amp;</paramtype></parameter><parameter name="idx"><paramtype>Idx</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1back" name="back"><purpose><computeroutput>back</computeroutput> is a PolymorphicFunctionObject for fetching the back element of a container. </purpose><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1back_1_1result" name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization id="doxygen.structboost_1_1xpressive_1_1op_1_1back_1_1result_3_01This_07Sequence_08_4" name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>This(Sequence)</template-arg></specialization><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1back_1_1result_3_01This_07Sequence_08_4_1ada665cec0edcfc27c2b4f2811cd5f2c3" name="sequence_type"><type>remove_reference&lt; Sequence &gt;::type</type></typedef>
<typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1back_1_1result_3_01This_07Sequence_08_4_1a7533de5dda117833690ba9743670dacd" name="type"><type>mpl::if_c&lt; is_const&lt; sequence_type &gt;::value, typenamesequence_type::const_reference, typenamesequence_type::reference &gt;::type</type></typedef>
</struct-specialization><method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1back_1aaec04c3861ece03ebffb600abf762aa5" name="operator()" cv="const"><type><classname>result</classname>&lt; <classname>back</classname>(Sequence &amp;)&gt;::type</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype><description><para>The sequence from which to fetch the back. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>seq.back()</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1first" name="first"><purpose><computeroutput>first</computeroutput> is a PolymorphicFunctionObject for fetching the first element of a pair. </purpose><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1first_1_1result" name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization id="doxygen.structboost_1_1xpressive_1_1op_1_1first_1_1result_3_01This_07Pair_08_4" name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Pair"/>
    </template><specialization><template-arg>This(Pair)</template-arg></specialization><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1first_1_1result_3_01This_07Pair_08_4_1af26618236ed6f604493f6b5e8e406df9" name="type"><type>remove_reference&lt; Pair &gt;::type::first_type</type></typedef>
</struct-specialization><method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1first_1a5a9498257576fe69a7885ec973d98977" name="operator()" cv="const"><type>Pair::first_type</type><template>
          <template-type-parameter name="Pair"/>
        </template><parameter name="p"><paramtype>Pair const &amp;</paramtype><description><para>The pair from which to fetch the first element. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>p.first</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1front" name="front"><purpose><computeroutput>front</computeroutput> is a PolymorphicFunctionObject for fetching the front element of a container. </purpose><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1front_1_1result" name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization id="doxygen.structboost_1_1xpressive_1_1op_1_1front_1_1result_3_01This_07Sequence_08_4" name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>This(Sequence)</template-arg></specialization><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1front_1_1result_3_01This_07Sequence_08_4_1ae6c1ae70b9af28a0ae791a785ee78729" name="sequence_type"><type>remove_reference&lt; Sequence &gt;::type</type></typedef>
<typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1front_1_1result_3_01This_07Sequence_08_4_1a72349b954e2fe52eabe54269d4dcd8d5" name="type"><type>mpl::if_c&lt; is_const&lt; sequence_type &gt;::value, typenamesequence_type::const_reference, typenamesequence_type::reference &gt;::type</type></typedef>
</struct-specialization><method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1front_1aaf63702c91d3ed24336536c2b43de909" name="operator()" cv="const"><type><classname>result</classname>&lt; <classname>front</classname>(Sequence &amp;)&gt;::type</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype><description><para>The sequence from which to fetch the front. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>seq.front()</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1insert" name="insert"><purpose><computeroutput>insert</computeroutput> is a PolymorphicFunctionObject for inserting a value or a sequence of values into a sequence container, an associative container, or a string. </purpose><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1insert_1_1result" name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1insert_1_1result_1aaf8aaca51eb6fdbf58c329d82a82f27b" name="type"><type><emphasis>unspecified</emphasis></type></typedef>
</struct><method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1insert_1ac4fc6c8a3ddde8a01562cb4269c37d8b" name="operator()" cv="const"><type><classname>result</classname>&lt; <classname>insert</classname>(Cont &amp;, A0const &amp;)&gt;::type</type><template>
          <template-type-parameter name="Cont"/>
          <template-type-parameter name="A0"/>
        </template><parameter name="cont"><paramtype>Cont &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1insert_1a63951b3da26832fee8470ecff2b534bb" name="operator()" cv="const"><type><classname>result</classname>&lt; <classname>insert</classname>(Cont &amp;, A0const &amp;, A1const &amp;)&gt;::type</type><template>
          <template-type-parameter name="Cont"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="cont"><paramtype>Cont &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1insert_1a7dcec27af45fcc33a400ea16616c8bd8" name="operator()" cv="const"><type><classname>result</classname>&lt; <classname>insert</classname>(Cont &amp;, A0const &amp;, A1const &amp;, A2const &amp;)&gt;::type</type><template>
          <template-type-parameter name="Cont"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="cont"><paramtype>Cont &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1insert_1a8c999bf1144593bc9d26c108b2242809" name="operator()" cv="const"><type><classname>result</classname>&lt; <classname>insert</classname>(Cont &amp;, A0const &amp;, A1const &amp;, A2const &amp;, A3const &amp;)&gt;::type</type><template>
          <template-type-parameter name="Cont"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="cont"><paramtype>Cont &amp;</paramtype><description><para>The container into which to insert the element(s) </para></description></parameter><parameter name="a0"><paramtype>A0 const &amp;</paramtype><description><para>A value, iterator, or count </para></description></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype><description><para>A value, iterator, string, count, or character </para></description></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype><description><para>A value, iterator, or count </para></description></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype><description><para>A count </para></description></parameter><description><para>

</para></description><returns><para><itemizedlist>
<listitem><para>For the form <computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1a1592ad63ebb2bf13b8645af4d053be70">insert()</link>(cont, a0)</computeroutput>, return <computeroutput>cont.insert(a0)</computeroutput>. </para>
</listitem>
<listitem><para>For the form <computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1a1592ad63ebb2bf13b8645af4d053be70">insert()</link>(cont, a0, a1)</computeroutput>, return <computeroutput>cont.insert(a0, a1)</computeroutput>. </para>
</listitem>
<listitem><para>For the form <computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1a1592ad63ebb2bf13b8645af4d053be70">insert()</link>(cont, a0, a1, a2)</computeroutput>, return <computeroutput>cont.insert(a0, a1, a2)</computeroutput>. </para>
</listitem>
<listitem><para>For the form <computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1a1592ad63ebb2bf13b8645af4d053be70">insert()</link>(cont, a0, a1, a2, a3)</computeroutput>, return <computeroutput>cont.insert(a0, a1, a2, a3)</computeroutput>. </para>
</listitem>
</itemizedlist>
</para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1length" name="length"><purpose><computeroutput>length</computeroutput> is a PolymorphicFunctionObject for fetching the length of <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link></computeroutput>. </purpose><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1length_1_1result" name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization id="doxygen.structboost_1_1xpressive_1_1op_1_1length_1_1result_3_01This_07Sub_08_4" name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sub"/>
    </template><specialization><template-arg>This(Sub)</template-arg></specialization><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1length_1_1result_3_01This_07Sub_08_4_1ae334e3915a310149592c3c4213f69b91" name="type"><type>remove_reference&lt; Sub &gt;::type::difference_type</type></typedef>
</struct-specialization><method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1length_1a1f3c9704e1532e881b3b2ee4eae6cbb1" name="operator()" cv="const"><type>Sub::difference_type</type><template>
          <template-type-parameter name="Sub"/>
        </template><parameter name="sub"><paramtype>Sub const &amp;</paramtype><description><para>The <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link></computeroutput> object. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>sub.length()</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1make__pair" name="make_pair"><purpose><computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1op_1_1make__pair">make_pair</link></computeroutput> is a PolymorphicFunctionObject for building a <computeroutput><link linkend="doxygen.structstd_1_1pair">std::pair</link></computeroutput> out of two parameters </purpose><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1make__pair_1_1result" name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization id="doxygen.structboost_1_1xpressive_1_1op_1_1make__pair_1_1result_3_01This_07First_00_01Second_08_4" name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="First"/>
      <template-type-parameter name="Second"/>
    </template><specialization><template-arg>This(First</template-arg><template-arg>Second)</template-arg></specialization><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1make__pair_1_1result_3_01This_07First_00_01Second_08_4_1a2d458855d549f9999fdc6fbff0f1cae6" name="first_type"><purpose>For exposition only. </purpose><type>decay&lt; First &gt;::type</type></typedef>
<typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1make__pair_1_1result_3_01This_07First_00_01Second_08_4_1a65422995cd2aae9ad8af2ddab61e508f" name="second_type"><purpose>For exposition only. </purpose><type>decay&lt; Second &gt;::type</type></typedef>
<typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1make__pair_1_1result_3_01This_07First_00_01Second_08_4_1a8d8056f0f19a1f02ee640a6fe7fc0c20" name="type"><type><classname>std::pair</classname>&lt; first_type, second_type &gt;</type></typedef>
</struct-specialization><method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1make__pair_1a09529703532745a71b2151a60746ca5d" name="operator()" cv="const"><type><classname>std::pair</classname>&lt; First, Second &gt;</type><template>
          <template-type-parameter name="First"/>
          <template-type-parameter name="Second"/>
        </template><parameter name="first"><paramtype>First const &amp;</paramtype><description><para>The first element of the pair </para></description></parameter><parameter name="second"><paramtype>Second const &amp;</paramtype><description><para>The second element of the pair </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>std::make_pair(first, second)</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1matched" name="matched"><purpose><computeroutput>matched</computeroutput> is a PolymorphicFunctionObject for assessing whether a <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link></computeroutput> object matched or not. </purpose><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1matched_1a93ddf267fa4bedf4f9768a87a425dee7" name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1matched_1a4af424421fa88fb4af90b739e7b2dab3" name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="Sub"/>
        </template><parameter name="sub"><paramtype>Sub const &amp;</paramtype><description><para>The <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link></computeroutput> object. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>sub.matched</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1pop" name="pop"><purpose><computeroutput>pop</computeroutput> is a PolymorphicFunctionObject for popping an element from a container. </purpose><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1pop_1a98011f19d9cb264416bde2f55bad1ac3" name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1pop_1acb07deed324908d756d6e64f494e3637" name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype><description><para>The sequence from which to pop. </para></description></parameter><purpose>Equivalent to <computeroutput>seq.pop()</computeroutput>. </purpose><description><para>

</para></description><returns><para><computeroutput>void</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1pop__back" name="pop_back"><purpose><computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1op_1_1pop__back">pop_back</link></computeroutput> is a PolymorphicFunctionObject for popping an element from the back of a container. </purpose><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1pop__back_1adb50580370a120a7b3725e40b716dc83" name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1pop__back_1a89c3d29e0681bd2c6c7d1bc735cacd3f" name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype><description><para>The sequence from which to pop. </para></description></parameter><purpose>Equivalent to <computeroutput>seq.pop_back()</computeroutput>. </purpose><description><para>

</para></description><returns><para><computeroutput>void</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1pop__front" name="pop_front"><purpose><computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1op_1_1pop__front">pop_front</link></computeroutput> is a PolymorphicFunctionObject for popping an element from the front of a container. </purpose><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1pop__front_1aa197fcc27816ded9e076fd7238e0d8cb" name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1pop__front_1a6a279f0386a1ebc63c69c63d0cd44d74" name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype><description><para>The sequence from which to pop. </para></description></parameter><purpose>Equivalent to <computeroutput>seq.pop_front()</computeroutput>. </purpose><description><para>

</para></description><returns><para><computeroutput>void</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1push" name="push"><purpose><computeroutput>push</computeroutput> is a PolymorphicFunctionObject for pushing an element into a container. </purpose><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1push_1a32f403fb6fa6267cc6710556d0d1ca6d" name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1push_1a7df7fc25b34287e7cfa9460b4c59343d" name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Sequence"/>
          <template-type-parameter name="Value"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype><description><para>The sequence into which the value should be pushed. </para></description></parameter><parameter name="val"><paramtype>Value const &amp;</paramtype><description><para>The value to push into the sequence. </para></description></parameter><purpose>Equivalent to <computeroutput>seq.push(val)</computeroutput>. </purpose><description><para>

</para></description><returns><para><computeroutput>void</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1push__back" name="push_back"><purpose><computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1op_1_1push__back">push_back</link></computeroutput> is a PolymorphicFunctionObject for pushing an element into the back of a container. </purpose><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1push__back_1aa70fe9522568d9d18d873c8c2af85b21" name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1push__back_1afba61e2c6a58f5448c3df4593bebb8d8" name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Sequence"/>
          <template-type-parameter name="Value"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype><description><para>The sequence into which the value should be pushed. </para></description></parameter><parameter name="val"><paramtype>Value const &amp;</paramtype><description><para>The value to push into the sequence. </para></description></parameter><purpose>Equivalent to <computeroutput>seq.push_back(val)</computeroutput>. </purpose><description><para>

</para></description><returns><para><computeroutput>void</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1push__front" name="push_front"><purpose><computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1op_1_1push__front">push_front</link></computeroutput> is a PolymorphicFunctionObject for pushing an element into the front of a container. </purpose><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1push__front_1a9d367419c98cde224ae08afdd4978fcd" name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1push__front_1ac2ad2aa23391540fe59c57e76fb86ce0" name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Sequence"/>
          <template-type-parameter name="Value"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype><description><para>The sequence into which the value should be pushed. </para></description></parameter><parameter name="val"><paramtype>Value const &amp;</paramtype><description><para>The value to push into the sequence. </para></description></parameter><purpose>Equivalent to <computeroutput>seq.push_front(val)</computeroutput>. </purpose><description><para>

</para></description><returns><para><computeroutput>void</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1second" name="second"><purpose><computeroutput>second</computeroutput> is a PolymorphicFunctionObject for fetching the second element of a pair. </purpose><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1second_1_1result" name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization id="doxygen.structboost_1_1xpressive_1_1op_1_1second_1_1result_3_01This_07Pair_08_4" name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Pair"/>
    </template><specialization><template-arg>This(Pair)</template-arg></specialization><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1second_1_1result_3_01This_07Pair_08_4_1a548dda970d7ddcfc60db88cecb6da2a1" name="type"><type>remove_reference&lt; Pair &gt;::type::second_type</type></typedef>
</struct-specialization><method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1second_1aef20e3821b55aaf76f95f523ec84804d" name="operator()" cv="const"><type>Pair::second_type</type><template>
          <template-type-parameter name="Pair"/>
        </template><parameter name="p"><paramtype>Pair const &amp;</paramtype><description><para>The pair from which to fetch the second element. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>p.second</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1str" name="str"><purpose><computeroutput>str</computeroutput> is a PolymorphicFunctionObject for turning a <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link></computeroutput> into an equivalent <computeroutput>std::string</computeroutput>. </purpose><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1str_1_1result" name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization id="doxygen.structboost_1_1xpressive_1_1op_1_1str_1_1result_3_01This_07Sub_08_4" name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sub"/>
    </template><specialization><template-arg>This(Sub)</template-arg></specialization><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1str_1_1result_3_01This_07Sub_08_4_1a0e4168b72ed39960aaa73c84e6ab889c" name="type"><type>remove_reference&lt; Sub &gt;::type::string_type</type></typedef>
</struct-specialization><method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1str_1afc2db51034f3d66b9b7439486816fbe2" name="operator()" cv="const"><type>Sub::string_type</type><template>
          <template-type-parameter name="Sub"/>
        </template><parameter name="sub"><paramtype>Sub const &amp;</paramtype><description><para>The <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link></computeroutput> object. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>sub.str()</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1top" name="top"><purpose><computeroutput>top</computeroutput> is a PolymorphicFunctionObject for fetching the top element of a stack. </purpose><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1top_1_1result" name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization id="doxygen.structboost_1_1xpressive_1_1op_1_1top_1_1result_3_01This_07Sequence_08_4" name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>This(Sequence)</template-arg></specialization><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1top_1_1result_3_01This_07Sequence_08_4_1a80d497f65aaf2df1e8fed84cdd35c879" name="sequence_type"><type>remove_reference&lt; Sequence &gt;::type</type></typedef>
<typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1top_1_1result_3_01This_07Sequence_08_4_1ac4861bc62258808c78f31e70f1d4ed85" name="type"><type>mpl::if_c&lt; is_const&lt; sequence_type &gt;::value, typenamesequence_type::value_typeconst &amp;, typenamesequence_type::value_type &amp; &gt;::type</type></typedef>
</struct-specialization><method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1top_1a52e083246d6aaacd75f4f23711ad74c5" name="operator()" cv="const"><type><classname>result</classname>&lt; <classname>top</classname>(Sequence &amp;)&gt;::type</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype><description><para>The sequence from which to fetch the top. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>seq.top()</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1unwrap__reference" name="unwrap_reference"><purpose><computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1op_1_1unwrap__reference">unwrap_reference</link></computeroutput> is a PolymorphicFunctionObject for unwrapping a <computeroutput>boost::reference_wrapper&lt;&gt;</computeroutput>. </purpose><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1unwrap__reference_1_1result" name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization id="doxygen.structboost_1_1xpressive_1_1op_1_1unwrap__reference_1_1result_3_01This_07Ref_01_6_08_4" name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Ref"/>
    </template><specialization><template-arg>This(Ref &amp;)</template-arg></specialization><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1unwrap__reference_1_1result_3_01This_07Ref_01_6_08_4_1ae49ab4653eb32f07ee908987ba50a780" name="type"><type>boost::unwrap_reference&lt; Ref &gt;::type &amp;</type></typedef>
</struct-specialization><struct-specialization id="doxygen.structboost_1_1xpressive_1_1op_1_1unwrap__reference_1_1result_3_01This_07Ref_08_4" name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Ref"/>
    </template><specialization><template-arg>This(Ref)</template-arg></specialization><typedef id="doxygen.structboost_1_1xpressive_1_1op_1_1unwrap__reference_1_1result_3_01This_07Ref_08_4_1a472d3ec78c2596088bb5cdaeb9e1c08b" name="type"><type>boost::unwrap_reference&lt; Ref &gt;::type &amp;</type></typedef>
</struct-specialization><method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1unwrap__reference_1a014a85963cbd0397b568f2d43023cebf" name="operator()" cv="const"><type>T &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="r"><paramtype>boost::reference_wrapper&lt; T &gt;</paramtype><description><para>The <computeroutput>boost::reference_wrapper&lt;T&gt;</computeroutput> to unwrap. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>static_cast&lt;T &amp;&gt;(r)</computeroutput> </para>
</returns></method>
</method-group>
</struct></namespace>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a2c16da7dabbf3f6bc7488ba6d1bcec8e" name="at"><type><classname>function</classname>&lt; <classname>op::at</classname> &gt;::type const</type><purpose><computeroutput>at</computeroutput> is a lazy PolymorphicFunctionObject for indexing into a sequence in an xpressive semantic action. </purpose></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1aece9e54c3f8f56e64284428198b79211" name="push"><type><classname>function</classname>&lt; <classname>op::push</classname> &gt;::type const</type><purpose><computeroutput>push</computeroutput> is a lazy PolymorphicFunctionObject for pushing a value into a container in an xpressive semantic action. </purpose></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a9cec0d7e6ed05c5df3960a214c03af08" name="push_back"><type><classname>function</classname>&lt; <classname>op::push_back</classname> &gt;::type const</type><purpose><computeroutput>push_back</computeroutput> is a lazy PolymorphicFunctionObject for pushing a value into a container in an xpressive semantic action. </purpose></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a458b399db41274e7891a563c7922e57f" name="push_front"><type><classname>function</classname>&lt; <classname>op::push_front</classname> &gt;::type const</type><purpose><computeroutput>push_front</computeroutput> is a lazy PolymorphicFunctionObject for pushing a value into a container in an xpressive semantic action. </purpose></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1ab87fddb2943c2cec7ca59d7475b62032" name="pop"><type><classname>function</classname>&lt; <classname>op::pop</classname> &gt;::type const</type><purpose><computeroutput>pop</computeroutput> is a lazy PolymorphicFunctionObject for popping the top element from a sequence in an xpressive semantic action. </purpose></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a082e16edfd5875d43472625071c1542f" name="pop_back"><type><classname>function</classname>&lt; <classname>op::pop_back</classname> &gt;::type const</type><purpose><computeroutput>pop_back</computeroutput> is a lazy PolymorphicFunctionObject for popping the back element from a sequence in an xpressive semantic action. </purpose></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a8ba2fa8f9dbcf78407a54677fb0509ab" name="pop_front"><type><classname>function</classname>&lt; <classname>op::pop_front</classname> &gt;::type const</type><purpose><computeroutput>pop_front</computeroutput> is a lazy PolymorphicFunctionObject for popping the front element from a sequence in an xpressive semantic action. </purpose></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a7c054b6e4168e269ca86bc49413965d3" name="top"><type><classname>function</classname>&lt; <classname>op::top</classname> &gt;::type const</type><purpose><computeroutput>top</computeroutput> is a lazy PolymorphicFunctionObject for accessing the top element from a stack in an xpressive semantic action. </purpose></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a8cee5624463ce895387d5f93fd5f2151" name="back"><type><classname>function</classname>&lt; <classname>op::back</classname> &gt;::type const</type><purpose><computeroutput>back</computeroutput> is a lazy PolymorphicFunctionObject for fetching the back element of a sequence in an xpressive semantic action. </purpose></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a6b17cc7ac41d4ffc10345959fadf4e4b" name="front"><type><classname>function</classname>&lt; <classname>op::front</classname> &gt;::type const</type><purpose><computeroutput>front</computeroutput> is a lazy PolymorphicFunctionObject for fetching the front element of a sequence in an xpressive semantic action. </purpose></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1af70a1b83307efa3f71eec4e444b82a37" name="first"><type><classname>function</classname>&lt; <classname>op::first</classname> &gt;::type const</type><purpose><computeroutput>first</computeroutput> is a lazy PolymorphicFunctionObject for accessing the first element of a <computeroutput><link linkend="doxygen.structstd_1_1pair">std::pair</link>&lt;&gt;</computeroutput> in an xpressive semantic action. </purpose></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a901cc203279df1448dd1e0dd090e7bcf" name="second"><type><classname>function</classname>&lt; <classname>op::second</classname> &gt;::type const</type><purpose><computeroutput>second</computeroutput> is a lazy PolymorphicFunctionObject for accessing the second element of a <computeroutput><link linkend="doxygen.structstd_1_1pair">std::pair</link>&lt;&gt;</computeroutput> in an xpressive semantic action. </purpose></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a9ac3cac0f97c0d415f9e2f256e7a7ad0" name="matched"><type><classname>function</classname>&lt; <classname>op::matched</classname> &gt;::type const</type><purpose><computeroutput>matched</computeroutput> is a lazy PolymorphicFunctionObject for accessing the <computeroutput>matched</computeroutput> member of a <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">xpressive::sub_match</link>&lt;&gt;</computeroutput> in an xpressive semantic action. </purpose></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1ac007382aa804f2950e4b9d5087e11cc1" name="length"><type><classname>function</classname>&lt; <classname>op::length</classname> &gt;::type const</type><purpose><computeroutput>length</computeroutput> is a lazy PolymorphicFunctionObject for computing the length of a <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">xpressive::sub_match</link>&lt;&gt;</computeroutput> in an xpressive semantic action. </purpose></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a3359fafa9e5c7964a0bd5364de930e9c" name="str"><type><classname>function</classname>&lt; <classname>op::str</classname> &gt;::type const</type><purpose><computeroutput>str</computeroutput> is a lazy PolymorphicFunctionObject for converting a <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">xpressive::sub_match</link>&lt;&gt;</computeroutput> to a <computeroutput>std::basic_string&lt;&gt;</computeroutput> in an xpressive semantic action. </purpose></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a1592ad63ebb2bf13b8645af4d053be70" name="insert"><type><classname>function</classname>&lt; <classname>op::insert</classname> &gt;::type const</type><purpose><computeroutput>insert</computeroutput> is a lazy PolymorphicFunctionObject for inserting a value or a range of values into a sequence in an xpressive semantic action. </purpose></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a25ae3b3f289479ddef1e554aadca7fa5" name="make_pair"><type><classname>function</classname>&lt; <classname>op::make_pair</classname> &gt;::type const</type><purpose><computeroutput>make_pair</computeroutput> is a lazy PolymorphicFunctionObject for making a <computeroutput><link linkend="doxygen.structstd_1_1pair">std::pair</link>&lt;&gt;</computeroutput> in an xpressive semantic action. </purpose></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a35d53ac102b53e06ab032b4fa5db4ee9" name="unwrap_reference"><type><classname>function</classname>&lt; <classname>op::unwrap_reference</classname> &gt;::type const</type><purpose><computeroutput>unwrap_reference</computeroutput> is a lazy PolymorphicFunctionObject for unwrapping a <computeroutput>boost::reference_wrapper&lt;&gt;</computeroutput> in an xpressive semantic action. </purpose></data-member>














































































<function id="doxygen.namespaceboost_1_1xpressive_1a149e8cb8ad542bdabd5c1980bb584c21" name="as"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"><purpose><para>The type to which to lexically cast the parameter. </para></purpose></template-type-parameter>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype><description><para>The lazy value to lexically cast. </para></description></parameter><purpose><computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1a149e8cb8ad542bdabd5c1980bb584c21">as()</link></computeroutput> is a lazy funtion for lexically casting a parameter to a different type. </purpose><description><para>


</para></description><returns><para>A lazy object that, when evaluated, lexically casts its argument to the desired type. </para>
</returns></function>
<function id="doxygen.namespaceboost_1_1xpressive_1af12d0af0fbe18d67aea033a0664b585e" name="static_cast_"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"><purpose><para>The type to which to statically cast the parameter. </para></purpose></template-type-parameter>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype><description><para>The lazy value to statically cast. </para></description></parameter><purpose><computeroutput>static_cast_</computeroutput> is a lazy funtion for statically casting a parameter to a different type. </purpose><description><para>


</para></description><returns><para>A lazy object that, when evaluated, statically casts its argument to the desired type. </para>
</returns></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a86ecb58bb6a48e09d1d48cf40ee46390" name="dynamic_cast_"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"><purpose><para>The type to which to dynamically cast the parameter. </para></purpose></template-type-parameter>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype><description><para>The lazy value to dynamically cast. </para></description></parameter><purpose><computeroutput>dynamic_cast_</computeroutput> is a lazy funtion for dynamically casting a parameter to a different type. </purpose><description><para>


</para></description><returns><para>A lazy object that, when evaluated, dynamically casts its argument to the desired type. </para>
</returns></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a25e88a1624017fdbaf8fc780facbeb64" name="const_cast_"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"><purpose><para>The type to which to const-cast the parameter. </para></purpose></template-type-parameter>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype><description><para>The lazy value to const-cast. </para></description></parameter><purpose><computeroutput>dynamic_cast_</computeroutput> is a lazy funtion for const-casting a parameter to a different type. </purpose><description><para>


</para></description><returns><para>A lazy object that, when evaluated, const-casts its argument to the desired type. </para>
</returns></function>
<function id="doxygen.namespaceboost_1_1xpressive_1ab72f70c0cda654c76f868d568b2f68d0" name="val"><type><classname>value</classname>&lt; T &gt; const</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter><purpose>Helper for constructing <computeroutput>value&lt;&gt;</computeroutput> objects. </purpose><description><para>
</para></description><returns><para><computeroutput>value&lt;T&gt;(t)</computeroutput> </para>
</returns></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a4d217d91805c8a2ba56ca219cbfcb80c" name="ref"><type><classname>reference</classname>&lt; T &gt; const</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter><purpose>Helper for constructing <computeroutput>reference&lt;&gt;</computeroutput> objects. </purpose><description><para>
</para></description><returns><para><computeroutput>reference&lt;T&gt;(t)</computeroutput> </para>
</returns></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a8415abfefb8862953c93b567b98815a7" name="cref"><type><classname>reference</classname>&lt; T const &gt; const</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter><purpose>Helper for constructing <computeroutput>reference&lt;&gt;</computeroutput> objects that store a reference to const. </purpose><description><para>
</para></description><returns><para><computeroutput>reference&lt;T const&gt;(t)</computeroutput> </para>
</returns></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a98dd0902c3d29a502836077cfa6e0130" name="check"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype><description><para>The UnaryPredicate object or Boolean semantic action.</para></description></parameter><purpose>For adding user-defined assertions to your regular expressions. </purpose><description><para>
A  <link linkend="boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.user_defined_assertions">user-defined assertion</link> is a kind of semantic action that evaluates a Boolean lambda and, if it evaluates to false, causes the match to fail at that location in the string. This will cause backtracking, so the match may ultimately succeed.</para><para>To use <computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1a98dd0902c3d29a502836077cfa6e0130">check()</link></computeroutput> to specify a user-defined assertion in a regex, use the following syntax: <programlisting language="c++"><link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">sregex</link> s = (<link linkend="doxygen.namespaceboost_1_1xpressive_1afae3ed7c3a8ebd3c2f06a943ff974a58">_d</link> &gt;&gt; <link linkend="doxygen.namespaceboost_1_1xpressive_1afae3ed7c3a8ebd3c2f06a943ff974a58">_d</link>)[<link linkend="doxygen.namespaceboost_1_1xpressive_1a98dd0902c3d29a502836077cfa6e0130">check</link>( XXX )]; // XXX is a custom assertion
</programlisting> The assertion is evaluated with a <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link>&lt;&gt;</computeroutput> object that delineates what part of the string matched the sub-expression to which the assertion was attached.</para><para><computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1a98dd0902c3d29a502836077cfa6e0130">check()</link></computeroutput> can be used with an ordinary predicate that takes a <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link>&lt;&gt;</computeroutput> object as follows: <programlisting language="c++">// A predicate that is true IFF a sub-match is
// either 3 or 6 characters long.
struct three_or_six
{
    bool operator()(<link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">ssub_match</link> const &amp;sub) const
    {
        return sub.<link linkend="doxygen.structboost_1_1xpressive_1_1sub__match_1ac906824245509413049ff3b29471ca01">length</link>() == 3 || sub.<link linkend="doxygen.structboost_1_1xpressive_1_1sub__match_1ac906824245509413049ff3b29471ca01">length</link>() == 6;
    }
};

// match words of 3 characters or 6 characters.
<link linkend="doxygen.namespaceboost_1_1xpressive_1ad82b5700d5ba5eb195cfce6d4007f0b4">sregex</link> rx = (<link linkend="doxygen.namespaceboost_1_1xpressive_1a3b217185880e704131c77830f43af5cb">bow</link> &gt;&gt; +<link linkend="doxygen.namespaceboost_1_1xpressive_1a6d4422b6535a447d3eb0689827b0b8fe">_w</link> &gt;&gt; <link linkend="doxygen.namespaceboost_1_1xpressive_1a88a7a6bc37a07db67a44936c6e0a3313">eow</link>)[ <link linkend="doxygen.namespaceboost_1_1xpressive_1a98dd0902c3d29a502836077cfa6e0130">check</link>(three_or_six()) ] ;
</programlisting> Alternately, <computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1a98dd0902c3d29a502836077cfa6e0130">check()</link></computeroutput> can be used to define inline custom assertions with the same syntax as is used to define semantic actions. The following code is equivalent to above: <programlisting language="c++">// match words of 3 characters or 6 characters.
<link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">sregex</link> rx = (<link linkend="doxygen.namespaceboost_1_1xpressive_1a3b217185880e704131c77830f43af5cb">bow</link> &gt;&gt; +<link linkend="doxygen.namespaceboost_1_1xpressive_1a6d4422b6535a447d3eb0689827b0b8fe">_w</link> &gt;&gt; <link linkend="doxygen.namespaceboost_1_1xpressive_1a88a7a6bc37a07db67a44936c6e0a3313">eow</link>)[ <link linkend="doxygen.namespaceboost_1_1xpressive_1a98dd0902c3d29a502836077cfa6e0130">check</link>(<link linkend="doxygen.namespaceboost_1_1xpressive_1ac007382aa804f2950e4b9d5087e11cc1">length</link>(<link linkend="doxygen.namespaceboost_1_1xpressive_1a12ce0e9a6350027c3c11d11e54411e23">_</link>)==3 || <link linkend="doxygen.namespaceboost_1_1xpressive_1ac007382aa804f2950e4b9d5087e11cc1">length</link>(<link linkend="doxygen.namespaceboost_1_1xpressive_1a12ce0e9a6350027c3c11d11e54411e23">_</link>)==6) ] ;
</programlisting> Within a custom assertion, <computeroutput>_</computeroutput> is a placeholder for the <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link>&lt;&gt;</computeroutput> That delineates the part of the string matched by the sub-expression to which the custom assertion was attached. </para></description></function>
<function id="doxygen.namespaceboost_1_1xpressive_1ace777d41d9a728658b3569d818e70d52" name="let"><type><emphasis>unspecified</emphasis></type><template>
          <template-nontype-parameter name="ArgBindings"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>ArgBindings const &amp;...</paramtype><description><para>A set of argument bindings, where each argument binding is an assignment expression, the left hand side of which must be an instance of <computeroutput>placeholder&lt;X&gt;</computeroutput> for some <computeroutput>X</computeroutput>, and the right hand side is an lvalue of type <computeroutput>X</computeroutput>.</para></description></parameter><purpose>For binding local variables to placeholders in semantic actions when constructing a <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1regex__iterator">regex_iterator</link></computeroutput> or a <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1regex__token__iterator">regex_token_iterator</link></computeroutput>. </purpose><description><para>
<computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1ace777d41d9a728658b3569d818e70d52">xpressive::let()</link></computeroutput> serves the same purpose as <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1a0b5d9b054f18782e2e195dab5e39123a">match_results::let()</link></computeroutput>; that is, it binds a placeholder to a local value. The purpose is to allow a regex with semantic actions to be defined that refers to objects that do not yet exist. Rather than referring directly to an object, a semantic action can refer to a placeholder, and the value of the placeholder can be specified later with a <emphasis>let expression</emphasis>. The <emphasis>let expression</emphasis> created with <computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1ace777d41d9a728658b3569d818e70d52">let()</link></computeroutput> is passed to the constructor of either <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1regex__iterator">regex_iterator</link></computeroutput> or <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1regex__token__iterator">regex_token_iterator</link></computeroutput>.</para><para>See the section  <link linkend="boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.referring_to_non_local_variables"> "Referring to Non-Local Variables"</link> in the Users' Guide for more discussion.</para><para><emphasis>Example:</emphasis> <programlisting language="c++">// Define a placeholder for a map object:
<link linkend="doxygen.structboost_1_1xpressive_1_1placeholder">placeholder&lt;std::map&lt;std::string, int&gt;</link> &gt; _map;

// Match a word and an integer, separated by =&gt;,
// and then stuff the result into a std::map&lt;&gt;
<link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">sregex</link> pair = ( (<link linkend="doxygen.namespaceboost_1_1xpressive_1ad80f6f2e945d16adb777f6c5c05c32ba">s1</link>= +<link linkend="doxygen.namespaceboost_1_1xpressive_1a6d4422b6535a447d3eb0689827b0b8fe">_w</link>) &gt;&gt; "=&gt;" &gt;&gt; (<link linkend="doxygen.namespaceboost_1_1xpressive_1a1f240bb30623f86f70e07f05bbd7b086">s2</link>= +<link linkend="doxygen.namespaceboost_1_1xpressive_1afae3ed7c3a8ebd3c2f06a943ff974a58">_d</link>) )
    [ _map[<link linkend="doxygen.namespaceboost_1_1xpressive_1ad80f6f2e945d16adb777f6c5c05c32ba">s1</link>] = <link linkend="doxygen.namespaceboost_1_1xpressive_1a149e8cb8ad542bdabd5c1980bb584c21">as&lt;int&gt;</link>(<link linkend="doxygen.namespaceboost_1_1xpressive_1a1f240bb30623f86f70e07f05bbd7b086">s2</link>) ];

// The string to parse
std::string <link linkend="doxygen.namespaceboost_1_1xpressive_1a3359fafa9e5c7964a0bd5364de930e9c">str</link>("aaa=&gt;1 bbb=&gt;23 ccc=&gt;456");

// Here is the actual map to fill in:
std::map&lt;std::string, int&gt; result;

// Create a regex_iterator to find all the matches
<link linkend="doxygen.structboost_1_1xpressive_1_1regex__iterator">sregex_iterator</link> it(<link linkend="doxygen.namespaceboost_1_1xpressive_1a3359fafa9e5c7964a0bd5364de930e9c">str</link>.begin(), <link linkend="doxygen.namespaceboost_1_1xpressive_1a3359fafa9e5c7964a0bd5364de930e9c">str</link>.end(), pair, <link linkend="doxygen.namespaceboost_1_1xpressive_1ace777d41d9a728658b3569d818e70d52">let</link>(_map=result));
<link linkend="doxygen.structboost_1_1xpressive_1_1regex__iterator">sregex_iterator</link> end;

// step through all the matches, and fill in
// the result map
while(it != end)
    ++it;

std::cout &lt;&lt; result["aaa"] &lt;&lt; '\n';
std::cout &lt;&lt; result["bbb"] &lt;&lt; '\n';
std::cout &lt;&lt; result["ccc"] &lt;&lt; '\n';
</programlisting> The above code displays: <programlisting language="c++">1
23
456
</programlisting> </para></description></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a9b13a02afe3c536582202f4116f178ff" name="construct"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"><purpose><para>The type of object to construct. </para></purpose></template-type-parameter>
          <template-nontype-parameter name="Args"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args const &amp;...</paramtype><description><para>The arguments to the constructor. </para></description></parameter><purpose>A lazy funtion for constructing objects objects of the specified type. </purpose><description><para>


</para></description><returns><para>A lazy object that, when evaluated, returns <computeroutput>T(xs...)</computeroutput>, where <computeroutput>xs...</computeroutput> is the result of evaluating the lazy arguments <computeroutput>args...</computeroutput>. </para>
</returns></function>

</namespace>
</namespace>
</header>
<header id="doxygen.regex__algorithms_8hpp" name="boost/xpressive/regex_algorithms.hpp">
<para>Contains the regex_match(), regex_search() and regex_replace() algorithms. </para><namespace name="boost">
<namespace name="xpressive">






















































<overloaded-function id="doxygen.namespaceboost_1_1xpressive_1a7549c8bcd5ce2471d42aaad4e409d148" name="regex_match"><signature><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the sequence. </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the sequence. </para></description></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>The <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link></computeroutput> struct into which the sub_matches will be written </para></description></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regular expression object to use </para></description></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default><description><para>Optional match flags, used to control how the expression is matched against the sequence. (See <computeroutput>match_flag_type</computeroutput>.) </para></description></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype></parameter><parameter name="end"><paramtype>BidiIter</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="Char"/>
        </template><parameter name="begin"><paramtype>Char *</paramtype></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; Char * &gt; &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; Char * &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange &amp;</paramtype></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange const &amp;</paramtype></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="Char"/>
        </template><parameter name="begin"><paramtype>Char *</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; Char * &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange const &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><purpose>See if a regex matches a sequence from beginning to end. </purpose><description><para>Determines whether there is an exact match between the regular expression <computeroutput>re</computeroutput>, and all of the sequence <computeroutput>[begin, end)</computeroutput>.</para><para>




</para></description><requires><para>Type <computeroutput>BidiIter</computeroutput> meets the requirements of a Bidirectional Iterator (24.1.4). </para>
</requires><requires><para><computeroutput>[begin,end)</computeroutput> denotes a valid iterator range. </para>
</requires><returns><para><computeroutput>true</computeroutput> if a match is found, <computeroutput>false</computeroutput> otherwise </para>
</returns><throws><simpara><classname>regex_error</classname> on stack exhaustion </simpara>
</throws></overloaded-function>







<overloaded-function id="doxygen.namespaceboost_1_1xpressive_1a1194c854fb35ddb2d0b216a303263bb3" name="regex_search"><signature><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the sequence </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the sequence </para></description></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>The <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link></computeroutput> struct into which the sub_matches will be written </para></description></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regular expression object to use </para></description></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default><description><para>Optional match flags, used to control how the expression is matched against the sequence. (See <computeroutput>match_flag_type</computeroutput>.) </para></description></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype></parameter><parameter name="end"><paramtype>BidiIter</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="Char"/>
        </template><parameter name="begin"><paramtype>Char *</paramtype></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; Char * &gt; &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; Char * &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange &amp;</paramtype></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange const &amp;</paramtype></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="Char"/>
        </template><parameter name="begin"><paramtype>Char *</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; Char * &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange const &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><purpose>Determines whether there is some sub-sequence within <computeroutput>[begin,end)</computeroutput> that matches the regular expression <computeroutput>re</computeroutput>. </purpose><description><para>Determines whether there is some sub-sequence within <computeroutput>[begin,end)</computeroutput> that matches the regular expression <computeroutput>re</computeroutput>.</para><para>




</para></description><requires><para>Type <computeroutput>BidiIter</computeroutput> meets the requirements of a Bidirectional Iterator (24.1.4). </para>
</requires><requires><para><computeroutput>[begin,end)</computeroutput> denotes a valid iterator range. </para>
</requires><returns><para><computeroutput>true</computeroutput> if a match is found, <computeroutput>false</computeroutput> otherwise </para>
</returns><throws><simpara><classname>regex_error</classname> on stack exhaustion </simpara>
</throws></overloaded-function>







<overloaded-function id="doxygen.namespaceboost_1_1xpressive_1a53c66a9ef9dc507a2a89b06d4822aac2" name="regex_replace"><signature><type>OutIter</type><template>
          <template-type-parameter name="OutIter"/>
          <template-type-parameter name="BidiIter"/>
          <template-type-parameter name="Formatter"/>
        </template><parameter name="out"><paramtype>OutIter</paramtype><description><para>An output iterator into which the output sequence is written. </para></description></parameter><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the input sequence. </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the input sequence. </para></description></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regular expression object to use. </para></description></parameter><parameter name="format"><paramtype>Formatter const &amp;</paramtype><description><para>The format string used to format the replacement sequence, or a formatter function, function object, or expression. </para></description></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default><description><para>Optional match flags, used to control how the expression is matched against the sequence. (See <computeroutput>match_flag_type</computeroutput>.) </para></description></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>OutIter</type><template>
          <template-type-parameter name="OutIter"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="out"><paramtype>OutIter</paramtype></parameter><parameter name="begin"><paramtype>BidiIter</paramtype></parameter><parameter name="end"><paramtype>BidiIter</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>BidiContainer</type><template>
          <template-type-parameter name="BidiContainer"/>
          <template-type-parameter name="BidiIter"/>
          <template-type-parameter name="Formatter"/>
        </template><parameter name="str"><paramtype>BidiContainer &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype>Formatter const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>BidiContainer</type><template>
          <template-type-parameter name="BidiContainer"/>
          <template-type-parameter name="BidiIter"/>
          <template-type-parameter name="Formatter"/>
        </template><parameter name="str"><paramtype>BidiContainer const &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype>Formatter const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>std::basic_string&lt; typename remove_const&lt; Char &gt;::type &gt;</type><template>
          <template-type-parameter name="Char"/>
          <template-type-parameter name="Formatter"/>
        </template><parameter name="str"><paramtype>Char *</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; Char * &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype>Formatter const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>BidiContainer</type><template>
          <template-type-parameter name="BidiContainer"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="str"><paramtype>BidiContainer &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>BidiContainer</type><template>
          <template-type-parameter name="BidiContainer"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="str"><paramtype>BidiContainer const &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>std::basic_string&lt; typename remove_const&lt; Char &gt;::type &gt;</type><template>
          <template-type-parameter name="Char"/>
        </template><parameter name="str"><paramtype>Char *</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; Char * &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype>typename add_const&lt; Char &gt;::type *</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><purpose>Build an output sequence given an input sequence, a regex, and a format string or a formatter object, function, or expression. </purpose><description><para>Constructs a <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1regex__iterator">regex_iterator</link></computeroutput> object: <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1regex__iterator">regex_iterator</link>&lt; BidiIter &gt; i(begin, end, re, flags)</computeroutput>, and uses <computeroutput>i</computeroutput> to enumerate through all of the matches m of type <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link>&lt; BidiIter &gt;</computeroutput> that occur within the sequence <computeroutput>[begin, end)</computeroutput>. If no such matches are found and <computeroutput>!(flags &amp; format_no_copy)</computeroutput> then calls <computeroutput>std::copy(begin, end, out)</computeroutput>. Otherwise, for each match found, if <computeroutput>!(flags &amp; format_no_copy)</computeroutput> calls <computeroutput>std::copy(m.prefix().first, m.prefix().second, out)</computeroutput>, and then calls <computeroutput>m.format(out, format, flags)</computeroutput>. Finally if <computeroutput>!(flags &amp; format_no_copy)</computeroutput> calls <computeroutput>std::copy(last_m.suffix().first, last_m.suffix().second, out)</computeroutput> where <computeroutput>last_m</computeroutput> is a copy of the last match found.</para><para>If <computeroutput>flags &amp; format_first_only</computeroutput> is non-zero then only the first match found is replaced.</para><para>






</para></description><requires><para>Type <computeroutput>BidiIter</computeroutput> meets the requirements of a Bidirectional Iterator (24.1.4). </para>
</requires><requires><para>Type <computeroutput>OutIter</computeroutput> meets the requirements of an Output Iterator (24.1.2). </para>
</requires><requires><para>Type <computeroutput>Formatter</computeroutput> models <computeroutput>ForwardRange</computeroutput>, <computeroutput>Callable&lt;<link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link>&lt;BidiIter&gt; &gt;</computeroutput>, <computeroutput>Callable&lt;<link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link>&lt;BidiIter&gt;, OutIter&gt;</computeroutput>, or <computeroutput>Callable&lt;<link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link>&lt;BidiIter&gt;, OutIter, <link linkend="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084">regex_constants::match_flag_type</link>&gt;</computeroutput>; or else it is a null-terminated format string, or an expression template representing a formatter lambda expression. </para>
</requires><requires><para><computeroutput>[begin,end)</computeroutput> denotes a valid iterator range. </para>
</requires><returns><para>The value of the output iterator after the output sequence has been written to it. </para>
</returns><throws><simpara><classname>regex_error</classname> on stack exhaustion or invalid format string. </simpara>
</throws></overloaded-function>


















</namespace>
</namespace>
</header>
<header id="doxygen.regex__compiler_8hpp" name="boost/xpressive/regex_compiler.hpp">
<para>Contains the definition of regex_compiler, a factory for building regex objects from strings. </para><namespace name="boost">
<namespace name="xpressive">

























































































</namespace>
</namespace>
</header>
<header id="doxygen.regex__constants_8hpp" name="boost/xpressive/regex_constants.hpp">
<para>Contains definitions for the syntax_option_type, match_flag_type and error_type enumerations. </para><namespace name="boost">
<namespace name="xpressive">
<namespace name="regex_constants">
<enum id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a773de0740d5f082a26d11157f41c2fdb" name="syntax_option_type"><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a773de0740d5f082a26d11157f41c2fdba86cf6a029595e8c6b2eba6b64066b67e" name="ECMAScript"><default>0</default><description><para>Specifies that the grammar recognized by the regular expression engine uses its normal semantics: that is the same as that given in the ECMA-262, ECMAScript Language Specification, Chapter 15 part 10, RegExp (Regular Expression) Objects (FWD.1). </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a773de0740d5f082a26d11157f41c2fdbae38719a6c3e9455e1d05923e2f27b220" name="icase"><default>1 &lt;&lt; 1</default><description><para>Specifies that matching of regular expressions against a character container sequence shall be performed without regard to case. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a773de0740d5f082a26d11157f41c2fdbabd6157a3d0613374bfd04f73496be43a" name="nosubs"><default>1 &lt;&lt; 2</default><description><para>Specifies that when a regular expression is matched against a character container sequence, then no sub-expression matches are to be stored in the supplied <link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link> structure. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a773de0740d5f082a26d11157f41c2fdba55b1c01e2f998e9c0d5ab393ce5633e9" name="optimize"><default>1 &lt;&lt; 3</default><description><para>Specifies that the regular expression engine should pay more attention to the speed with which regular expressions are matched, and less to the speed with which regular expression objects are constructed. Otherwise it has no detectable effect on the program output. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a773de0740d5f082a26d11157f41c2fdbad1f7a650216e0ac2f2d86c4ae9637e50" name="collate"><default>1 &lt;&lt; 4</default><description><para>Specifies that character ranges of the form "[a-b]" should be locale sensitive. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a773de0740d5f082a26d11157f41c2fdbaf72ef099b21283a8752574a5a86e4427" name="single_line"><default>1 &lt;&lt; 10</default><description><para>Specifies that the ^ and $ metacharacters DO NOT match at internal line breaks. Note that this is the opposite of the perl default. It is the inverse of perl's /m (multi-line) modifier. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a773de0740d5f082a26d11157f41c2fdba750674b1ad85fd6cff123b672fce3e8a" name="not_dot_null"><default>1 &lt;&lt; 11</default><description><para>Specifies that the . metacharacter does not match the null character \0. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a773de0740d5f082a26d11157f41c2fdba46ff70f319dfe20fb72810d49e2ebb42" name="not_dot_newline"><default>1 &lt;&lt; 12</default><description><para>Specifies that the . metacharacter does not match the newline character \n. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a773de0740d5f082a26d11157f41c2fdba8acd1765b318de6859d909052deeee63" name="ignore_white_space"><default>1 &lt;&lt; 13</default><description><para>Specifies that non-escaped white-space is not significant. </para></description></enumvalue><description><para>Flags used to customize the regex syntax </para></description></enum>
<enum id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084" name="match_flag_type"><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084a62ffaf6ba7e0e57d3aa084135b3b0210" name="match_default"><default>0</default><description><para>Specifies that matching of regular expressions proceeds without any modification of the normal rules used in ECMA-262, ECMAScript Language Specification, Chapter 15 part 10, RegExp (Regular Expression) Objects (FWD.1) </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084a87602b5db450ece84dd73cd690af80d6" name="match_not_bol"><default>1 &lt;&lt; 1</default><description><para>Specifies that the expression "^" should not be matched against the sub-sequence [first,first). </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084afa4c6c0d177974c35476f9530996455b" name="match_not_eol"><default>1 &lt;&lt; 2</default><description><para>Specifies that the expression "\$" should not be matched against the sub-sequence [last,last). </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084a4196ffa33558f47e066b73473b3965f3" name="match_not_bow"><default>1 &lt;&lt; 3</default><description><para>Specifies that the expression "\\b" should not be matched against the sub-sequence [first,first). </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084a0d918d62928fc9dc6d9e95e780791dca" name="match_not_eow"><default>1 &lt;&lt; 4</default><description><para>Specifies that the expression "\\b" should not be matched against the sub-sequence [last,last). </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084abee719c0915bdef326f7b9a8fcd665f4" name="match_any"><default>1 &lt;&lt; 7</default><description><para>Specifies that if more than one match is possible then any match is an acceptable result. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084a53db465ab8bda2fcd2f2d63883601c59" name="match_not_null"><default>1 &lt;&lt; 8</default><description><para>Specifies that the expression can not be matched against an empty sequence. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084af1917b573f583585105c3f04effe9702" name="match_continuous"><default>1 &lt;&lt; 10</default><description><para>Specifies that the expression must match a sub-sequence that begins at first. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084aff1d999363c797c4b7c233c2ccbee063" name="match_partial"><default>1 &lt;&lt; 11</default><description><para>Specifies that if no match can be found, then it is acceptable to return a match [from, last) where from != last, if there exists some sequence of characters [from,to) of which [from,last) is a prefix, and which would result in a full match. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084a5d17674242837971cd5bcc2508bbce00" name="match_prev_avail"><default>1 &lt;&lt; 12</default><description><para>Specifies that first is a valid iterator position, when this flag is set then the flags match_not_bol and match_not_bow are ignored by the regular expression algorithms (RE.7) and iterators (RE.8). </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084a262f9f4b12f40ae992f83b420d6bffbe" name="format_default"><default>0</default><description><para>Specifies that when a regular expression match is to be replaced by a new string, that the new string is constructed using the rules used by the ECMAScript replace function in ECMA-262, ECMAScript Language Specification, Chapter 15 part 5.4.11 String.prototype.replace. (FWD.1). In addition during search and replace operations then all non-overlapping occurrences of the regular expression are located and replaced, and sections of the input that did not match the expression, are copied unchanged to the output string. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084acc5a78ef7f003f54ea98054fa6d61684" name="format_sed"><default>1 &lt;&lt; 13</default><description><para>Specifies that when a regular expression match is to be replaced by a new string, that the new string is constructed using the rules used by the Unix sed utility in IEEE Std 1003.1-2001, Portable Operating SystemInterface (POSIX), Shells and Utilities. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084aab4c133ad7d89e012e12b03b52e7cadc" name="format_perl"><default>1 &lt;&lt; 14</default><description><para>Specifies that when a regular expression match is to be replaced by a new string, that the new string is constructed using an implementation defined superset of the rules used by the ECMAScript replace function in ECMA-262, ECMAScript Language Specification, Chapter 15 part 5.4.11 String.prototype.replace (FWD.1). </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084ab34cad1e8d6e0408e769b395ed613405" name="format_no_copy"><default>1 &lt;&lt; 15</default><description><para>When specified during a search and replace operation, then sections of the character container sequence being searched that do match the regular expression, are not copied to the output string. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084a95f51dcb675cc4c00a451dcf8080dcea" name="format_first_only"><default>1 &lt;&lt; 16</default><description><para>When specified during a search and replace operation, then only the first occurrence of the regular expression is replaced. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084acbff6289ca08e19cd85303189e0e8927" name="format_literal"><default>1 &lt;&lt; 17</default><description><para>Treat the format string as a literal. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084a2dbf14481b95ec1acd4b7e1234439af2" name="format_all"><default>1 &lt;&lt; 18</default><description><para>Specifies that all syntax extensions are enabled, including conditional (?ddexpression1:expression2) replacements. </para></description></enumvalue><description><para>Flags used to customize the behavior of the regex algorithms </para></description></enum>
<enum id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594a" name="error_type"><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aa615320525c44d8602ff8b40220c50668" name="error_collate"><description><para>The expression contained an invalid collating element name. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aaba0a701895736dc0483b7db4722f9997" name="error_ctype"><description><para>The expression contained an invalid character class name. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aae69b0589598a5db955c9c7f63eafeba3" name="error_escape"><description><para>The expression contained an invalid escaped character, or a trailing escape. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aa90fd455f0eed70e84684d91203b0806b" name="error_subreg"><description><para>The expression contained an invalid back-reference. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aa6eb4d4a076a530597b29ac19f1bbe698" name="error_brack"><description><para>The expression contained mismatched [ and ]. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aa8123b763b6d6ad5ad589c3b6b4b5960e" name="error_paren"><description><para>The expression contained mismatched ( and ). </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aad54d81b2158b622dea66b810e28ed7c4" name="error_brace"><description><para>The expression contained mismatched { and }. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aaea163957d9757643637d24e3499d9779" name="error_badbrace"><description><para>The expression contained an invalid range in a {} expression. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aa2666624a6689f92185787224c115a417" name="error_range"><description><para>The expression contained an invalid character range, for example [b-a]. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aa6ee913fa8f65587ab99424ceffae92ae" name="error_space"><description><para>There was insufficient memory to convert the expression into a finite state machine. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aa31cf6bbad6c7ea6b7fa2efacfb7685a2" name="error_badrepeat"><description><para>One of *?+{ was not preceded by a valid regular expression. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aaa9a91c43dfa4dcced12b4e5d5be12ed6" name="error_complexity"><description><para>The complexity of an attempted match against a regular expression exceeded a pre-set level. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aa47cf9c8b07270fd4c2be198283d07ada" name="error_stack"><description><para>There was insufficient memory to determine whether the regular expression could match the specified character sequence. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aa70a88d85e3ddedc2d0c17ec9a6200b7c" name="error_badref"><description><para>An nested regex is uninitialized. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aa65dcbad831b78e11477a8edab8ea59fa" name="error_badmark"><description><para>An invalid use of a named capture. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aa7877ceffb1e288fab2344db57e8d5bad" name="error_badlookbehind"><description><para>An attempt to create a variable-width look-behind assertion was detected. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aa0cb2fcb7c6a8b165cad38f77e1b13df3" name="error_badrule"><description><para>An invalid use of a rule was detected. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aacaf0d5384d774db09e16edd8ff3c3a63" name="error_badarg"><description><para>An argument to an action was unbound. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aa762e6e94a4670bcd992344662fc80f49" name="error_badattr"><description><para>Tried to read from an uninitialized attribute. </para></description></enumvalue><enumvalue id="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a72b1fa97b4db010bdf2ecaa8d380594aa12558e42021acbe551dfd6e643703788" name="error_internal"><description><para>An internal error has occurred. </para></description></enumvalue><description><para>Error codes used by the <link linkend="doxygen.structboost_1_1xpressive_1_1regex__error">regex_error</link> type </para></description></enum>
</namespace>

























































































</namespace>
</namespace>
</header>
<header id="doxygen.regex__error_8hpp" name="boost/xpressive/regex_error.hpp">
<para>Contains the definition of the regex_error exception class. </para><namespace name="boost">
<namespace name="xpressive">
<struct id="doxygen.structboost_1_1xpressive_1_1regex__error" name="regex_error"><inherit access="public">std::runtime_error</inherit><inherit access="public">boost::exception</inherit><purpose>The class <link linkend="doxygen.structboost_1_1xpressive_1_1regex__error">regex_error</link> defines the type of objects thrown as exceptions to report errors during the conversion from a string representing a regular expression to a finite state machine. </purpose><method-group name="public member functions">
<constructor id="doxygen.structboost_1_1xpressive_1_1regex__error_1a01fcef32b98975919fac913b4749fd40" specifiers="explicit"><parameter name="code"><paramtype>regex_constants::error_type</paramtype><description><para>The error_type this <link linkend="doxygen.structboost_1_1xpressive_1_1regex__error">regex_error</link> represents. </para></description></parameter><parameter name="str"><paramtype>char const *</paramtype><default>""</default><description><para>The message string of this <link linkend="doxygen.structboost_1_1xpressive_1_1regex__error">regex_error</link>. </para></description></parameter><description><para>Constructs an object of class <link linkend="doxygen.structboost_1_1xpressive_1_1regex__error">regex_error</link>. 

</para></description><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1regex__error_1aa52d59afc48dfcb2905dbe2b87d2902c">code()</link> == code </para>
</postconditions></constructor>
<method id="doxygen.structboost_1_1xpressive_1_1regex__error_1aa52d59afc48dfcb2905dbe2b87d2902c" name="code" cv="const"><type>regex_constants::error_type</type><description><para>Accessor for the error_type value 

</para></description><returns><para>the error_type code passed to the constructor </para>
</returns><throws><simpara>Will not throw.</simpara>
</throws></method>
<destructor id="doxygen.structboost_1_1xpressive_1_1regex__error_1af2d2c1537cda9a27a01633fcdba05620" specifiers="virtual"><description><para>Destructor for class <link linkend="doxygen.structboost_1_1xpressive_1_1regex__error">regex_error</link> 
</para></description><throws><simpara>Will not throw.</simpara>
</throws></destructor>
</method-group>
</struct>
























































































</namespace>
</namespace>
<macro id="doxygen.regex__error_8hpp_1ad9fbdce117db110194d07a870f18e6ca" name="BOOST_XPR_ENSURE_" kind="functionlike"><macro-parameter name="pred"/><macro-parameter name="code"/><macro-parameter name="msg"/></macro>
</header>
<header id="doxygen.regex__iterator_8hpp" name="boost/xpressive/regex_iterator.hpp">
<para>Contains the definition of the regex_iterator type, an STL-compatible iterator for stepping through all the matches in a sequence. </para><namespace name="boost">
<namespace name="xpressive">

























































































</namespace>
</namespace>
</header>
<header id="doxygen.regex__primitives_8hpp" name="boost/xpressive/regex_primitives.hpp">
<para>Contains the syntax elements for writing static regular expressions. </para><namespace name="boost">
<namespace name="xpressive">
<struct id="doxygen.structboost_1_1xpressive_1_1mark__tag" name="mark_tag"><purpose>Sub-match placeholder type, used to create named captures in static regexes. </purpose><description><para><computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1mark__tag">mark_tag</link></computeroutput> is the type of the global sub-match placeholders <computeroutput>s0</computeroutput>, <computeroutput>s1</computeroutput>, etc.. You can use the <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1mark__tag">mark_tag</link></computeroutput> type to create your own sub-match placeholders with more meaningful names. This is roughly equivalent to the "named capture" feature of dynamic regular expressions.</para><para>To create a named sub-match placeholder, initialize it with a unique integer. The integer must only be unique within the regex in which the placeholder is used. Then you can use it within static regexes to created sub-matches by assigning a sub-expression to it, or to refer back to already created sub-matches.</para><para><programlisting language="c++"><link linkend="doxygen.structboost_1_1xpressive_1_1mark__tag_1a78ab116ff2abd8fa6dad473afb6aae16">mark_tag</link> number(1); // "number" is now equivalent to "s1"
// Match a number, followed by a space and the same number again
<link linkend="doxygen.namespaceboost_1_1xpressive_1ad82b5700d5ba5eb195cfce6d4007f0b4">sregex</link> rx = (number = +<link linkend="doxygen.namespaceboost_1_1xpressive_1afae3ed7c3a8ebd3c2f06a943ff974a58">_d</link>) &gt;&gt; ' ' &gt;&gt; number;
</programlisting></para><para>After a successful <computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1a7549c8bcd5ce2471d42aaad4e409d148">regex_match()</link></computeroutput> or <computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1a1194c854fb35ddb2d0b216a303263bb3">regex_search()</link></computeroutput>, the sub-match placeholder can be used to index into the <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link>&lt;&gt;</computeroutput> object to retrieve the corresponding sub-match. </para></description><method-group name="private static functions">
<method id="doxygen.structboost_1_1xpressive_1_1mark__tag_1a4a9a085db26713f575b2631e2c2bba09" name="make_tag" specifiers="static"><type><emphasis>unspecified</emphasis></type><parameter name="mark_nbr"><paramtype>int</paramtype></parameter></method>
</method-group>
<method-group name="public member functions">
<constructor id="doxygen.structboost_1_1xpressive_1_1mark__tag_1a78ab116ff2abd8fa6dad473afb6aae16"><parameter name="mark_nbr"><paramtype>int</paramtype><description><para>An integer that uniquely identifies this <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1mark__tag">mark_tag</link></computeroutput> within the static regexes in which this <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1mark__tag">mark_tag</link></computeroutput> will be used. </para></description></parameter><purpose>Initialize a <link linkend="doxygen.structboost_1_1xpressive_1_1mark__tag">mark_tag</link> placeholder. </purpose><description><para>

</para></description><requires><para><computeroutput>mark_nbr &gt; 0</computeroutput> </para>
</requires></constructor>
</method-group>
</struct><data-member id="doxygen.namespaceboost_1_1xpressive_1accf4bd793aeedcafb93fb2175fbfedb3" name="inf"><type>unsigned int const</type><purpose>For infinite repetition of a sub-expression. </purpose><description><para>Magic value used with the repeat&lt;&gt;() function template to specify an unbounded repeat. Use as: repeat&lt;17, inf&gt;('a'). The equivalent in perl is /a{17,}/. </para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a35e4b60579210418dcac6dc30234122c" name="nil"><type><emphasis>unspecified</emphasis></type><purpose>Successfully matches nothing. </purpose><description><para>Successfully matches a zero-width sequence. nil always succeeds and never consumes any characters. </para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a1b06a5da0d73cfb2409a5c5af2e39150" name="alnum"><type><emphasis>unspecified</emphasis></type><purpose>Matches an alpha-numeric character. </purpose><description><para>The regex traits are used to determine which characters are alpha-numeric. To match any character that is not alpha-numeric, use ~alnum.</para><para><important><para>alnum is equivalent to /[[:alnum:]]/ in perl. ~alnum is equivalent to /[[:^alnum:]]/ in perl. </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a1dc091385c7f62d5288156dd0b2a4baa" name="alpha"><type><emphasis>unspecified</emphasis></type><purpose>Matches an alphabetic character. </purpose><description><para>The regex traits are used to determine which characters are alphabetic. To match any character that is not alphabetic, use ~alpha.</para><para><important><para>alpha is equivalent to /[[:alpha:]]/ in perl. ~alpha is equivalent to /[[:^alpha:]]/ in perl. </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a24bee837e2074a12e85975a3e116546f" name="blank"><type><emphasis>unspecified</emphasis></type><purpose>Matches a blank (horizonal white-space) character. </purpose><description><para>The regex traits are used to determine which characters are blank characters. To match any character that is not blank, use ~blank.</para><para><important><para>blank is equivalent to /[[:blank:]]/ in perl. ~blank is equivalent to /[[:^blank:]]/ in perl. </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1ae1bc4f5d69c2d6b4bed6ffa201a2be9e" name="cntrl"><type><emphasis>unspecified</emphasis></type><purpose>Matches a control character. </purpose><description><para>The regex traits are used to determine which characters are control characters. To match any character that is not a control character, use ~cntrl.</para><para><important><para>cntrl is equivalent to /[[:cntrl:]]/ in perl. ~cntrl is equivalent to /[[:^cntrl:]]/ in perl. </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a9fcd67a5ef0c7420328550024473000b" name="digit"><type><emphasis>unspecified</emphasis></type><purpose>Matches a digit character. </purpose><description><para>The regex traits are used to determine which characters are digits. To match any character that is not a digit, use ~digit.</para><para><important><para>digit is equivalent to /[[:digit:]]/ in perl. ~digit is equivalent to /[[:^digit:]]/ in perl. </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a09612c753e15e35bc5655da7fe9c338f" name="graph"><type><emphasis>unspecified</emphasis></type><purpose>Matches a graph character. </purpose><description><para>The regex traits are used to determine which characters are graphable. To match any character that is not graphable, use ~graph.</para><para><important><para>graph is equivalent to /[[:graph:]]/ in perl. ~graph is equivalent to /[[:^graph:]]/ in perl. </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a7640f1908e0272cfc06dd9ccd10d926c" name="lower"><type><emphasis>unspecified</emphasis></type><purpose>Matches a lower-case character. </purpose><description><para>The regex traits are used to determine which characters are lower-case. To match any character that is not a lower-case character, use ~lower.</para><para><important><para>lower is equivalent to /[[:lower:]]/ in perl. ~lower is equivalent to /[[:^lower:]]/ in perl. </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a6ed6404fd01cc69cfb59fbd3189e4abd" name="print"><type><emphasis>unspecified</emphasis></type><purpose>Matches a printable character. </purpose><description><para>The regex traits are used to determine which characters are printable. To match any character that is not printable, use ~print.</para><para><important><para>print is equivalent to /[[:print:]]/ in perl. ~print is equivalent to /[[:^print:]]/ in perl. </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a557079c0471795432b282ff7acbbc197" name="punct"><type><emphasis>unspecified</emphasis></type><purpose>Matches a punctuation character. </purpose><description><para>The regex traits are used to determine which characters are punctuation. To match any character that is not punctuation, use ~punct.</para><para><important><para>punct is equivalent to /[[:punct:]]/ in perl. ~punct is equivalent to /[[:^punct:]]/ in perl. </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a976e5791f34ffdf20677b6576e3ff497" name="space"><type><emphasis>unspecified</emphasis></type><purpose>Matches a space character. </purpose><description><para>The regex traits are used to determine which characters are space characters. To match any character that is not white-space, use ~space.</para><para><important><para>space is equivalent to /[[:space:]]/ in perl. ~space is equivalent to /[[:^space:]]/ in perl. </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a715a71bac63ab1ed3ff513ae28ca5366" name="upper"><type><emphasis>unspecified</emphasis></type><purpose>Matches an upper-case character. </purpose><description><para>The regex traits are used to determine which characters are upper-case. To match any character that is not upper-case, use ~upper.</para><para><important><para>upper is equivalent to /[[:upper:]]/ in perl. ~upper is equivalent to /[[:^upper:]]/ in perl. </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a74cd04cf993cf27f955143952fc39f08" name="xdigit"><type><emphasis>unspecified</emphasis></type><purpose>Matches a hexadecimal digit character. </purpose><description><para>The regex traits are used to determine which characters are hex digits. To match any character that is not a hex digit, use ~xdigit.</para><para><important><para>xdigit is equivalent to /[[:xdigit:]]/ in perl. ~xdigit is equivalent to /[[:^xdigit:]]/ in perl. </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a8207a9ad7d4e618d7cb60b7ce6718f79" name="bos"><type><emphasis>unspecified</emphasis></type><purpose>Beginning of sequence assertion. </purpose><description><para>For the character sequence [begin, end), 'bos' matches the zero-width sub-sequence [begin, begin). </para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1ad594d7c0d24aa05509f921724107f76d" name="eos"><type><emphasis>unspecified</emphasis></type><purpose>End of sequence assertion. </purpose><description><para>For the character sequence [begin, end), 'eos' matches the zero-width sub-sequence [end, end).</para><para><important><para>Unlike the perl end of sequence assertion $, 'eos' will not match at the position [end-1, end-1) if *(end-1) is '\n'. To get that behavior, use (!_n &gt;&gt; eos). </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a31c1d184af761d5746281137d4da4773" name="bol"><type><emphasis>unspecified</emphasis></type><purpose>Beginning of line assertion. </purpose><description><para>'bol' matches the zero-width sub-sequence immediately following a logical newline sequence. The regex traits is used to determine what constitutes a logical newline sequence. </para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a23748b87b213f073281b1a1e69f14803" name="eol"><type><emphasis>unspecified</emphasis></type><purpose>End of line assertion. </purpose><description><para>'eol' matches the zero-width sub-sequence immediately preceeding a logical newline sequence. The regex traits is used to determine what constitutes a logical newline sequence. </para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a3b217185880e704131c77830f43af5cb" name="bow"><type><emphasis>unspecified</emphasis></type><purpose>Beginning of word assertion. </purpose><description><para>'bow' matches the zero-width sub-sequence immediately following a non-word character and preceeding a word character. The regex traits are used to determine what constitutes a word character. </para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a88a7a6bc37a07db67a44936c6e0a3313" name="eow"><type><emphasis>unspecified</emphasis></type><purpose>End of word assertion. </purpose><description><para>'eow' matches the zero-width sub-sequence immediately following a word character and preceeding a non-word character. The regex traits are used to determine what constitutes a word character. </para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a7569a3db3832a241c158e6c991afeac7" name="_b"><type><emphasis>unspecified</emphasis></type><purpose>Word boundary assertion. </purpose><description><para>'_b' matches the zero-width sub-sequence at the beginning or the end of a word. It is equivalent to (bow | eow). The regex traits are used to determine what constitutes a word character. To match a non-word boundary, use ~_b.</para><para><important><para>_b is like \b in perl. ~_b is like \B in perl. </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a6d4422b6535a447d3eb0689827b0b8fe" name="_w"><type><emphasis>unspecified</emphasis></type><purpose>Matches a word character. </purpose><description><para>'_w' matches a single word character. The regex traits are used to determine which characters are word characters. Use ~_w to match a character that is not a word character.</para><para><important><para>_w is like \w in perl. ~_w is like \W in perl. </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1afae3ed7c3a8ebd3c2f06a943ff974a58" name="_d"><type><emphasis>unspecified</emphasis></type><purpose>Matches a digit character. </purpose><description><para>'_d' matches a single digit character. The regex traits are used to determine which characters are digits. Use ~_d to match a character that is not a digit character.</para><para><important><para>_d is like \d in perl. ~_d is like \D in perl. </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1ab34b82560c0e1148b5c1748351711294" name="_s"><type><emphasis>unspecified</emphasis></type><purpose>Matches a space character. </purpose><description><para>'_s' matches a single space character. The regex traits are used to determine which characters are space characters. Use ~_s to match a character that is not a space character.</para><para><important><para>_s is like \s in perl. ~_s is like \S in perl. </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a36818a74c72b7cecab426b2bb4e9af50" name="_n"><type>proto::terminal&lt; char &gt;::type const</type><purpose>Matches a literal newline character, '\n'. </purpose><description><para>'_n' matches a single newline character, '\n'. Use ~_n to match a character that is not a newline.</para><para><important><para>~_n is like '.' in perl without the /s modifier. </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a3009a586650714142b0f5cd32b11c323" name="_ln"><type><emphasis>unspecified</emphasis></type><purpose>Matches a logical newline sequence. </purpose><description><para>'_ln' matches a logical newline sequence. This can be any character in the line separator class, as determined by the regex traits, or the '\r\n' sequence. For the purpose of back-tracking, '\r\n' is treated as a unit. To match any one character that is not a logical newline, use ~_ln. </para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a12ce0e9a6350027c3c11d11e54411e23" name="_"><type><emphasis>unspecified</emphasis></type><purpose>Matches any one character. </purpose><description><para>Match any character, similar to '.' in perl syntax with the /s modifier. '_' matches any one character, including the newline.</para><para><important><para>To match any character except the newline, use ~_n </para>
</important>
</para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a14b961aeefc46c936116aaeaf7b54cc2" name="self"><type><emphasis>unspecified</emphasis></type><purpose>Reference to the current regex object. </purpose><description><para>Useful when constructing recursive regular expression objects. The 'self' identifier is a short-hand for the current regex object. For instance, sregex rx = '(' &gt;&gt; (self | nil) &gt;&gt; ')'; will create a regex object that matches balanced parens such as "((()))". </para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a41aeb0b5257a91ac34d336aa86b59bae" name="set"><type><emphasis>unspecified</emphasis></type><purpose>Used to create character sets. </purpose><description><para>There are two ways to create character sets with the 'set' identifier. The easiest is to create a comma-separated list of the characters in the set, as in (set= 'a','b','c'). This set will match 'a', 'b', or 'c'. The other way is to define the set as an argument to the set subscript operator. For instance, set[ 'a' | range('b','c') | digit ] will match an 'a', 'b', 'c' or a digit character.</para><para>To complement a set, apply the '~' operator. For instance, ~(set= 'a','b','c') will match any character that is not an 'a', 'b', or 'c'.</para><para>Sets can be composed of other, possibly complemented, sets. For instance, set[ ~digit | ~(set= 'a','b','c') ]. </para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a13c6bb573901cb7e82386a4616ab4dd2" name="s0"><type><classname>mark_tag</classname> const</type><purpose>Sub-match placeholder, like $&amp; in Perl. </purpose></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1ad80f6f2e945d16adb777f6c5c05c32ba" name="s1"><type><classname>mark_tag</classname> const</type><purpose>Sub-match placeholder, like $1 in perl. </purpose><description><para>To create a sub-match, assign a sub-expression to the sub-match placeholder. For instance, (s1= _) will match any one character and remember which character was matched in the 1st sub-match. Later in the pattern, you can refer back to the sub-match. For instance, (s1= _) &gt;&gt; s1 will match any character, and then match the same character again.</para><para>After a successful <link linkend="doxygen.namespaceboost_1_1xpressive_1a7549c8bcd5ce2471d42aaad4e409d148">regex_match()</link> or <link linkend="doxygen.namespaceboost_1_1xpressive_1a1194c854fb35ddb2d0b216a303263bb3">regex_search()</link>, the sub-match placeholders can be used to index into the <link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link>&lt;&gt; object to retrieve the Nth sub-match. </para></description></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a1f240bb30623f86f70e07f05bbd7b086" name="s2"><type><classname>mark_tag</classname> const</type></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a20ab07d1e5440921d65a04bba00c6232" name="s3"><type><classname>mark_tag</classname> const</type></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a09bb31250936683527fd781e99ff7be1" name="s4"><type><classname>mark_tag</classname> const</type></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a1a43178816be29c2dd2f575a5673baba" name="s5"><type><classname>mark_tag</classname> const</type></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1af1404a01d281e684f1b0a144a47e9e0c" name="s6"><type><classname>mark_tag</classname> const</type></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a48256317fa5089344a878c4debcd0299" name="s7"><type><classname>mark_tag</classname> const</type></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a7b0147de8072ae60af6a8d35e0f2ed0a" name="s8"><type><classname>mark_tag</classname> const</type></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1abab77b1f72b302f314d81a05c716c94a" name="s9"><type><classname>mark_tag</classname> const</type></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a12bab4a62b564eb22b7d7765065d0164" name="a1"><type><emphasis>unspecified</emphasis></type></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1afe3768cc487ff856f6fac1aa19e08ca2" name="a2"><type><emphasis>unspecified</emphasis></type></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a31a4e648f1f5d4942954bffe3cffa43c" name="a3"><type><emphasis>unspecified</emphasis></type></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a2d9311e8ec8af975f27c2929f80cd43a" name="a4"><type><emphasis>unspecified</emphasis></type></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1ae7021a08d3c7633dfa99bfb8a046c5ec" name="a5"><type><emphasis>unspecified</emphasis></type></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a5ecf0dfea3c8e6dc7648a16ff49c566d" name="a6"><type><emphasis>unspecified</emphasis></type></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a498d88a344a02fcb8422c817acfd47ac" name="a7"><type><emphasis>unspecified</emphasis></type></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1a93d6a677024b11f1617ae3eb18b5f751" name="a8"><type><emphasis>unspecified</emphasis></type></data-member>
<data-member id="doxygen.namespaceboost_1_1xpressive_1ae4398360cd0666e932dc43535e37f5b1" name="a9"><type><emphasis>unspecified</emphasis></type></data-member>










































<function id="doxygen.namespaceboost_1_1xpressive_1a00581d37196c53cf8fe7c4f8bfe53391" name="icase"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><purpose>Makes a sub-expression case-insensitive. </purpose><description><para>Use <link linkend="doxygen.namespaceboost_1_1xpressive_1a00581d37196c53cf8fe7c4f8bfe53391">icase()</link> to make a sub-expression case-insensitive. For instance, "foo" &gt;&gt; icase(set['b'] &gt;&gt; "ar") will match "foo" exactly followed by "bar" irrespective of case. </para></description></function>
<function id="doxygen.namespaceboost_1_1xpressive_1afdf584f20302dd9bc5f8da88442f439b" name="as_xpr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Literal"/>
        </template><parameter name="literal"><paramtype>Literal const &amp;</paramtype></parameter><purpose>Makes a literal into a regular expression. </purpose><description><para>Use <link linkend="doxygen.namespaceboost_1_1xpressive_1afdf584f20302dd9bc5f8da88442f439b">as_xpr()</link> to turn a literal into a regular expression. For instance, "foo" &gt;&gt; "bar" will not compile because both operands to the right-shift operator are const char*, and no such operator exists. Use as_xpr("foo") &gt;&gt; "bar" instead.</para><para>You can use <link linkend="doxygen.namespaceboost_1_1xpressive_1afdf584f20302dd9bc5f8da88442f439b">as_xpr()</link> with character literals in addition to string literals. For instance, as_xpr('a') will match an 'a'. You can also complement a character literal, as with ~as_xpr('a'). This will match any one character that is not an 'a'. </para></description></function>
<function id="doxygen.namespaceboost_1_1xpressive_1ae55546d54e126ae3e7ae281216059e18" name="by_ref"><type>proto::terminal&lt; reference_wrapper&lt; <classname>basic_regex</classname>&lt; BidiIter &gt;const &gt; &gt;::type const</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> object to embed by reference. </para></description></parameter><purpose>Embed a regex object by reference. </purpose><description><para>
</para></description></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a2a2ecb8901da24e1cbcbb983133d5488" name="range"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Char"/>
        </template><parameter name="ch_min"><paramtype>Char</paramtype><description><para>The lower end of the range to match. </para></description></parameter><parameter name="ch_max"><paramtype>Char</paramtype><description><para>The upper end of the range to match. </para></description></parameter><purpose>Match a range of characters. </purpose><description><para>Match any character in the range [ch_min, ch_max].</para><para>
</para></description></function>
<function id="doxygen.namespaceboost_1_1xpressive_1af03d56e10dc6887930f2054fbe37d290" name="optional"><type>proto::result_of::make_expr&lt; proto::tag::logical_not, proto::default_domain, Exprconst &amp; &gt;::type const</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The sub-expression to make optional. </para></description></parameter><purpose>Make a sub-expression optional. Equivalent to !as_xpr(expr). </purpose><description><para>
</para></description></function>
<overloaded-function id="doxygen.namespaceboost_1_1xpressive_1a1f5c9bb3d4c1cc48754107bfa399de54" name="repeat"><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-nontype-parameter name="Min"><type>unsigned int</type></template-nontype-parameter>
          <template-nontype-parameter name="Max"><type>unsigned int</type></template-nontype-parameter>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The sub-expression to repeat. </para></description></parameter></signature><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-nontype-parameter name="Count"><type>unsigned int</type></template-nontype-parameter>
          <template-type-parameter name="Expr2"/>
        </template><parameter name="expr2"><paramtype>Expr2 const &amp;</paramtype></parameter></signature><purpose>Repeat a sub-expression multiple times. </purpose><description><para>There are two forms of the repeat&lt;&gt;() function template. To match a sub-expression N times, use repeat&lt;N&gt;(expr). To match a sub-expression from M to N times, use repeat&lt;M,N&gt;(expr).</para><para>The repeat&lt;&gt;() function creates a greedy quantifier. To make the quantifier non-greedy, apply the unary minus operator, as in -repeat&lt;M,N&gt;(expr).</para><para>
</para></description></overloaded-function>

<function id="doxygen.namespaceboost_1_1xpressive_1ad009f0422d798ec20af8c18bec5c8325" name="keep"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The sub-expression to modify. </para></description></parameter><purpose>Create an independent sub-expression. </purpose><description><para>Turn off back-tracking for a sub-expression. Any branches or repeats within the sub-expression will match only one way, and no other alternatives are tried.</para><para><important><para>keep(expr) is equivalent to the perl (?&gt;...) extension.</para>
</important>

</para></description></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a44362d391d7ca96bda0b3e75204a1f86" name="before"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The sub-expression to put in the look-ahead assertion. </para></description></parameter><purpose>Look-ahead assertion. </purpose><description><para>before(expr) succeeds if the expr sub-expression would match at the current position in the sequence, but expr is not included in the match. For instance, before("foo") succeeds if we are before a "foo". Look-ahead assertions can be negated with the bit-compliment operator.</para><para><important><para>before(expr) is equivalent to the perl (?=...) extension. ~before(expr) is a negative look-ahead assertion, equivalent to the perl (?!...) extension.</para>
</important>

</para></description></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a8c4a68addc9855a24f52344d67f58e18" name="after"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The sub-expression to put in the look-ahead assertion.</para></description></parameter><purpose>Look-behind assertion. </purpose><description><para>after(expr) succeeds if the expr sub-expression would match at the current position minus N in the sequence, where N is the width of expr. expr is not included in the match. For instance, after("foo") succeeds if we are after a "foo". Look-behind assertions can be negated with the bit-complement operator.</para><para><important><para>after(expr) is equivalent to the perl (?&lt;=...) extension. ~after(expr) is a negative look-behind assertion, equivalent to the perl (?&lt;!...) extension.</para>
</important>


</para></description><requires><para>expr cannot match a variable number of characters. </para>
</requires></function>
<function id="doxygen.namespaceboost_1_1xpressive_1ad58db5547a515b013bd1869db1ccaabf" name="imbue"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Locale"/>
        </template><parameter name="loc"><paramtype>Locale const &amp;</paramtype><description><para>The std::locale or regex traits object. </para></description></parameter><purpose>Specify a regex traits or a std::locale. </purpose><description><para><link linkend="doxygen.namespaceboost_1_1xpressive_1ad58db5547a515b013bd1869db1ccaabf">imbue()</link> instructs the regex engine to use the specified traits or locale when matching the regex. The entire expression must use the same traits/locale. For instance, the following specifies a locale for use with a regex: std::locale loc; sregex rx = imbue(loc)(+digit);</para><para>
</para></description></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a35b352ec2526d1d2427751ac4f834126" name="skip"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Skip"/>
        </template><parameter name="skip"><paramtype>Skip const &amp;</paramtype><description><para>A regex that specifies which characters to skip. </para></description></parameter><purpose>Specify which characters to skip when matching a regex. </purpose><description><para><computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1a35b352ec2526d1d2427751ac4f834126">skip()</link></computeroutput> instructs the regex engine to skip certain characters when matching a regex. It is most useful for writing regexes that ignore whitespace. For instance, the following specifies a regex that skips whitespace and punctuation:</para><para><programlisting language="c++">// A sentence is one or more words separated by whitespace
// and punctuation.
<link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">sregex</link> word = +<link linkend="doxygen.namespaceboost_1_1xpressive_1a1dc091385c7f62d5288156dd0b2a4baa">alpha</link>;
<link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">sregex</link> sentence = <link linkend="doxygen.namespaceboost_1_1xpressive_1a35b352ec2526d1d2427751ac4f834126">skip</link>(<link linkend="doxygen.namespaceboost_1_1xpressive_1a41aeb0b5257a91ac34d336aa86b59bae">set</link>[<link linkend="doxygen.namespaceboost_1_1xpressive_1ab34b82560c0e1148b5c1748351711294">_s</link> | <link linkend="doxygen.namespaceboost_1_1xpressive_1a557079c0471795432b282ff7acbbc197">punct</link>])( +word );
</programlisting></para><para>The way it works in the above example is to insert <computeroutput>keep(*set[_s | punct])</computeroutput> before each primitive within the regex. A "primitive" includes terminals like strings, character sets and nested regexes. A final <computeroutput>*set[_s | punct]</computeroutput> is added to the end of the regex. The regex <computeroutput>sentence</computeroutput> specified above is equivalent to the following:</para><para><programlisting language="c++"><link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">sregex</link> sentence = +( <link linkend="doxygen.namespaceboost_1_1xpressive_1ad009f0422d798ec20af8c18bec5c8325">keep</link>(*<link linkend="doxygen.namespaceboost_1_1xpressive_1a41aeb0b5257a91ac34d336aa86b59bae">set</link>[<link linkend="doxygen.namespaceboost_1_1xpressive_1ab34b82560c0e1148b5c1748351711294">_s</link> | <link linkend="doxygen.namespaceboost_1_1xpressive_1a557079c0471795432b282ff7acbbc197">punct</link>]) &gt;&gt; word )
                       &gt;&gt; *<link linkend="doxygen.namespaceboost_1_1xpressive_1a41aeb0b5257a91ac34d336aa86b59bae">set</link>[<link linkend="doxygen.namespaceboost_1_1xpressive_1ab34b82560c0e1148b5c1748351711294">_s</link> | <link linkend="doxygen.namespaceboost_1_1xpressive_1a557079c0471795432b282ff7acbbc197">punct</link>];
</programlisting></para><para><important><para>Skipping does not affect how nested regexes are handled because they are treated atomically. String literals are also treated atomically; that is, no skipping is done within a string literal. So <computeroutput>skip(_s)("this that")</computeroutput> is not the same as <computeroutput>skip(_s)("this" &gt;&gt; as_xpr("that"))</computeroutput>. The first will only match when there is only one space between "this" and "that". The second will skip any and all whitespace between "this" and "that".</para>
</important>

</para></description></function>



































</namespace>
</namespace>
</header>
<header id="doxygen.regex__token__iterator_8hpp" name="boost/xpressive/regex_token_iterator.hpp">
<para>Contains the definition of regex_token_iterator, and STL-compatible iterator for tokenizing a string using a regular expression. </para><namespace name="boost">
<namespace name="xpressive">

























































































</namespace>
</namespace>
</header>
<header id="doxygen.regex__traits_8hpp" name="boost/xpressive/regex_traits.hpp">
<para>Includes the C regex traits or the CPP regex traits header file depending on the BOOST_XPRESSIVE_USE_C_TRAITS macro. </para><namespace name="boost">
<namespace name="xpressive">
<struct id="doxygen.structboost_1_1xpressive_1_1regex__traits__version__1__tag" name="regex_traits_version_1_tag"><description><para>Tag used to denote that a traits class conforms to the version 1 traits interface. </para></description></struct><struct id="doxygen.structboost_1_1xpressive_1_1regex__traits__version__2__tag" name="regex_traits_version_2_tag"><inherit access="public">boost::xpressive::regex_traits_version_1_tag</inherit><description><para>Tag used to denote that a traits class conforms to the version 2 traits interface. </para></description></struct>
























































































</namespace>
</namespace>
</header>
<header id="doxygen.sub__match_8hpp" name="boost/xpressive/sub_match.hpp">
<para>Contains the definition of the class template sub_match&lt;&gt; and associated helper functions </para><namespace name="boost">
<namespace name="xpressive">
<overloaded-function id="doxygen.namespaceboost_1_1xpressive_1a018ce3d918e36913527e087e065ab92f" name="range_begin"><signature><type>BidiIter</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="sub"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>the <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link>&lt;&gt;</computeroutput> object denoting the range </para></description></parameter></signature><signature><type>BidiIter</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="sub"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></signature><purpose><computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1a018ce3d918e36913527e087e065ab92f">range_begin()</link></computeroutput> to make <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link>&lt;&gt;</computeroutput> a valid range </purpose><description><para>


</para></description><requires><para><computeroutput>sub.first</computeroutput> is not singular </para>
</requires><returns><para><computeroutput>sub.first</computeroutput> </para>
</returns></overloaded-function>

<overloaded-function id="doxygen.namespaceboost_1_1xpressive_1a382fd6ac3371da29548b9596638791da" name="range_end"><signature><type>BidiIter</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="sub"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>the <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link>&lt;&gt;</computeroutput> object denoting the range </para></description></parameter></signature><signature><type>BidiIter</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="sub"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></signature><purpose><computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1a382fd6ac3371da29548b9596638791da">range_end()</link></computeroutput> to make <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link>&lt;&gt;</computeroutput> a valid range </purpose><description><para>


</para></description><requires><para><computeroutput>sub.second</computeroutput> is not singular </para>
</requires><returns><para><computeroutput>sub.second</computeroutput> </para>
</returns></overloaded-function>

<function id="doxygen.namespaceboost_1_1xpressive_1a1e5f02aeb148c73341681727f388d063" name="operator&lt;&lt;"><type>std::basic_ostream&lt; Char, Traits &gt; &amp;</type><template>
          <template-type-parameter name="BidiIter"/>
          <template-type-parameter name="Char"/>
          <template-type-parameter name="Traits"/>
        </template><parameter name="sout"><paramtype>std::basic_ostream&lt; Char, Traits &gt; &amp;</paramtype><description><para>output stream. </para></description></parameter><parameter name="sub"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link> object to be written to the stream. </para></description></parameter><purpose>insertion operator for sending sub-matches to ostreams </purpose><description><para>

</para></description><returns><para>sout &lt;&lt; sub.str() </para>
</returns></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a3214e67fcbadcd1c467657c8fbf14c22" name="operator=="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a10dedc1ddee05a348c66cfb4caa306cd" name="operator!="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a83bac185c07e485830d9cd5ba29b7830" name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a7f7d7aa1686330d817e78135e783cd80" name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a292a2e8cd5a41a260a322353c7e21bfd" name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a2f3db68fd5e5ae5dcbf13e148253f645" name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1ad79cec3da7eb0b525aec1a8569ea98e5" name="operator=="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a0c29c9724f2d9c8dcb120080daa33b4d" name="operator!="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1ad0a1dc0e0c7570ebcf40ab33556f3bb1" name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a0e8e7ec1f3bec0d31ccb919a3ea733db" name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a1197830bd3ceb9da8bcb84bd87cfbbd6" name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a0c431f0f055167f8765ac1a3ba4f5023" name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a59bcceff4eb10ef2d5c2153611cc9a85" name="operator=="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a434cf53e7d51fe77988d112e027c0ba7" name="operator!="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a91f0e58fe3586241a1a728f5580b43b5" name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a7b1b37fd697d0cbffb7535d4c0af5491" name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a087bc672e7a5b26b73a59c13c03bae96" name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a823697132a881c677fb73b88cec405a3" name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a0333b201144ec4ca2396ccc167e72ee3" name="operator=="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1abb4ee3aea359427d7b41f86d62f46cd3" name="operator!="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1addf1f4d21f69551484f8ef937fbb33e8" name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a624ad6301801504016383403d2365133" name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a08a57e77b53700af91da23cbaf939b23" name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a717e1767d1995d81575837318b5ce1ab" name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1ae5bd5ea31433ccc453cf11a0ea3f88e3" name="operator=="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a48d01d0123e7c34616d7c3b37f697f14" name="operator!="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a88f89a2b9bf3f6330a110705bc35cea2" name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a69cf6ac2003830e8a79572409575dd14" name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a83d781ba7acf6b212747d7b265f7a158" name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a6cbb1ea310bb7031bcf4cdf456438211" name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1aee877bde23fac844c1f5da4593950aca" name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a3e3cd0dd99c03c11ace6d652966f01d1" name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1aa4d2e3b339ee6a7bf4eef00cba2212b7" name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1aa9745f502e8eed0bdf6b3d2f01366586" name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1aafba65760eff121e248689bdc8585b0b" name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a08711713c24fd2b86d4f99218ed85e01" name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename <classname>sub_match</classname>&lt; BidiIter &gt;::string_type const &amp;</paramtype></parameter></function>
<function id="doxygen.namespaceboost_1_1xpressive_1a33222c682be86f9dbc3cb36f712f303e" name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename <classname>sub_match</classname>&lt; BidiIter &gt;::string_type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>















































</namespace>
</namespace>
</header>
<header id="doxygen.c__regex__traits_8hpp" name="boost/xpressive/traits/c_regex_traits.hpp">
<para>Contains the definition of the c_regex_traits&lt;&gt; template, which is a wrapper for the C locale functions that can be used to customize the behavior of static and dynamic regexes. </para><namespace name="boost">
<namespace name="xpressive">
<struct-specialization id="doxygen.structboost_1_1xpressive_1_1has__fold__case_3_01c__regex__traits_3_01char_01_4_01_4" name="has_fold_case"><template>
    </template><specialization><template-arg>c_regex_traits&lt; char &gt;</template-arg></specialization><inherit access="public">mpl::true_</inherit></struct-specialization>
























































































</namespace>
</namespace>
</header>
<header id="doxygen.cpp__regex__traits_8hpp" name="boost/xpressive/traits/cpp_regex_traits.hpp">
<para>Contains the definition of the cpp_regex_traits&lt;&gt; template, which is a wrapper for std::locale that can be used to customize the behavior of static and dynamic regexes. </para><namespace name="boost">
<namespace name="xpressive">
<struct-specialization id="doxygen.structboost_1_1xpressive_1_1has__fold__case_3_01cpp__regex__traits_3_01char_01_4_01_4" name="has_fold_case"><template>
    </template><specialization><template-arg>cpp_regex_traits&lt; char &gt;</template-arg></specialization><inherit access="public">mpl::true_</inherit></struct-specialization>
























































































</namespace>
</namespace>
</header>
<header id="doxygen.null__regex__traits_8hpp" name="boost/xpressive/traits/null_regex_traits.hpp">
<para>Contains the definition of the null_regex_traits&lt;&gt; template, which is a stub regex traits implementation that can be used by static and dynamic regexes for searching non-character data. </para><namespace name="boost">
<namespace name="xpressive">

























































































</namespace>
</namespace>
</header>
<header id="doxygen.xpressive_8hpp" name="boost/xpressive/xpressive.hpp">
<para>Includes all of xpressive including support for both static and dynamic regular expressions. </para></header>
<header id="doxygen.xpressive__dynamic_8hpp" name="boost/xpressive/xpressive_dynamic.hpp">
<para>Includes everything you need to write and use dynamic regular expressions. </para></header>
<header id="doxygen.xpressive__fwd_8hpp" name="boost/xpressive/xpressive_fwd.hpp">
<para>Forward declarations for all of xpressive's public data types. </para><namespace name="boost">
<namespace name="xpressive">
<struct id="doxygen.structboost_1_1xpressive_1_1basic__regex" name="basic_regex"><template>
      <template-type-parameter name="BidiIter"/>
    </template><purpose>Class template <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link>&lt;&gt; is a class for holding a compiled regular expression. </purpose><method-group name="public member functions">
<constructor id="doxygen.structboost_1_1xpressive_1_1basic__regex_1a51c63a72326e2623387713b739e42261"><description><para>

</para></description><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex_1a1da1e3035ddb926697b3fd7a6fd0090b">regex_id()</link> == 0 </para>
</postconditions><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex_1a809ec5dff7aec842029ac9a024d330d8">mark_count()</link> == 0 </para>
</postconditions></constructor>
<constructor id="doxygen.structboost_1_1xpressive_1_1basic__regex_1ab447eb625de9a724d7b030d109fe60b4"><parameter name="that"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> object to copy. </para></description></parameter><description><para>


</para></description><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex_1a1da1e3035ddb926697b3fd7a6fd0090b">regex_id()</link> == that.regex_id() </para>
</postconditions><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex_1a809ec5dff7aec842029ac9a024d330d8">mark_count()</link> == that.mark_count() </para>
</postconditions></constructor>
<copy-assignment id="doxygen.structboost_1_1xpressive_1_1basic__regex_1ad9bf1c7784e478f9584c7fc3ea1cb805"><type><classname>basic_regex</classname>&lt; BidiIter &gt; &amp;</type><parameter name="that"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> object to copy. </para></description></parameter><description><para>



</para></description><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex_1a1da1e3035ddb926697b3fd7a6fd0090b">regex_id()</link> == that.regex_id() </para>
</postconditions><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex_1a809ec5dff7aec842029ac9a024d330d8">mark_count()</link> == that.mark_count() </para>
</postconditions><returns><para>*this </para>
</returns></copy-assignment>
<constructor id="doxygen.structboost_1_1xpressive_1_1basic__regex_1afe64aabf111437d26239d36ec4176dd9"><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The static regular expression </para></description></parameter><description><para>Construct from a static regular expression.</para><para>



</para></description><requires><para>Expr is the type of a static regular expression. </para>
</requires><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex_1a1da1e3035ddb926697b3fd7a6fd0090b">regex_id()</link> != 0 </para>
</postconditions><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex_1a809ec5dff7aec842029ac9a024d330d8">mark_count()</link> &gt;= 0 </para>
</postconditions></constructor>
<copy-assignment id="doxygen.structboost_1_1xpressive_1_1basic__regex_1a05c6a11a105cca6ac7d531e7c8808882"><type><classname>basic_regex</classname>&lt; BidiIter &gt; &amp;</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The static regular expression. </para></description></parameter><description><para>Construct from a static regular expression.</para><para>





</para></description><requires><para>Expr is the type of a static regular expression. </para>
</requires><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex_1a1da1e3035ddb926697b3fd7a6fd0090b">regex_id()</link> != 0 </para>
</postconditions><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex_1a809ec5dff7aec842029ac9a024d330d8">mark_count()</link> &gt;= 0 </para>
</postconditions><returns><para>*this </para>
</returns><throws><simpara><classname>std::bad_alloc</classname> on out of memory </simpara>
</throws></copy-assignment>
<method id="doxygen.structboost_1_1xpressive_1_1basic__regex_1a809ec5dff7aec842029ac9a024d330d8" name="mark_count" cv="const"><type>std::size_t</type><description><para>Returns the count of capturing sub-expressions in this regular expression </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1basic__regex_1a1da1e3035ddb926697b3fd7a6fd0090b" name="regex_id" cv="const"><type>regex_id_type</type><description><para>Returns a token which uniquely identifies this regular expression. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1basic__regex_1a6d901cbe5e15e0a2a214c6d19bbe08e8" name="swap"><type>void</type><parameter name="that"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>The other <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> object. </para></description></parameter><description><para>Swaps the contents of this <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> object with another.</para><para>
<important><para>This is a shallow swap that does not do reference tracking. If you embed a <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> object by reference in another regular expression and then swap its contents with another <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> object, the change will not be visible to the enclosing regular expression. It is done this way to ensure that <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex_1a6d901cbe5e15e0a2a214c6d19bbe08e8">swap()</link> cannot throw. </para>
</important>

</para></description><throws><simpara>Will not throw.</simpara>
</throws></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.structboost_1_1xpressive_1_1basic__regex_1a217b2b93cda1f66ee2d6395297525c91" name="compile" specifiers="static"><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type><template>
          <template-type-parameter name="InputIter"/>
        </template><parameter name="begin"><paramtype>InputIter</paramtype><description><para>The beginning of a range of characters representing the regular expression to compile. </para></description></parameter><parameter name="end"><paramtype>InputIter</paramtype><description><para>The end of a range of characters representing the regular expression to compile. </para></description></parameter><parameter name="flags"><paramtype>flag_type</paramtype><default>regex_constants::ECMAScript</default><description><para>Optional bitmask that determines how the pat string is interpreted. (See syntax_option_type.) </para></description></parameter><description><para>Factory method for building a regex object from a range of characters. Equivalent to <link linkend="doxygen.structboost_1_1xpressive_1_1regex__compiler">regex_compiler</link>&lt; BidiIter &gt;().compile(begin, end, flags);</para><para>




</para></description><requires><para>[begin,end) is a valid range. </para>
</requires><requires><para>The range of characters specified by [begin,end) contains a valid string-based representation of a regular expression. </para>
</requires><returns><para>A <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> object corresponding to the regular expression represented by the character range. </para>
</returns><throws><simpara><classname>regex_error</classname> when the range of characters has invalid regular expression syntax. </simpara>
</throws></method>
<method id="doxygen.structboost_1_1xpressive_1_1basic__regex_1abe326ce92e72f1afc866c81a1e52e637" name="compile" specifiers="static"><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type><template>
          <template-type-parameter name="InputRange"/>
        </template><parameter name="pat"><paramtype>InputRange const &amp;</paramtype></parameter><parameter name="flags"><paramtype>flag_type</paramtype><default>regex_constants::ECMAScript</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1basic__regex_1ab9e38b3139c0a8ec937967667f10d714" name="compile" specifiers="static"><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type><parameter name="begin"><paramtype>char_type const *</paramtype></parameter><parameter name="flags"><paramtype>flag_type</paramtype><default>regex_constants::ECMAScript</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1basic__regex_1a3d19dbf064f60a7a42e941838b1870f6" name="compile" specifiers="static"><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type><parameter name="begin"><paramtype>char_type const *</paramtype></parameter><parameter name="len"><paramtype>std::size_t</paramtype></parameter><parameter name="flags"><paramtype>flag_type</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
</method-group>
<method-group name="private member functions">
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1c__regex__traits" name="c_regex_traits"><template>
      <template-type-parameter name="Char"/>
    </template><purpose>Encapsaulates the standard C locale functions for use by the <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link>&lt;&gt;</computeroutput> class template. </purpose><method-group name="public member functions">
<constructor id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1ae5f8bb563b9143ad6b9a7e713a3d574c"><parameter name="loc"><paramtype>locale_type const &amp;</paramtype><default>locale_type()</default></parameter><description><para>Initialize a <link linkend="doxygen.structboost_1_1xpressive_1_1c__regex__traits">c_regex_traits</link> object to use the global C locale. </para></description></constructor>
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1a6d91aed834a133d1578e7dcff5d4e4c0" name="operator==" cv="const"><type>bool</type><parameter name=""><paramtype><classname>c_regex_traits</classname>&lt; char_type &gt; const &amp;</paramtype></parameter><description><para>Checks two <link linkend="doxygen.structboost_1_1xpressive_1_1c__regex__traits">c_regex_traits</link> objects for equality</para><para>
</para></description><returns><para>true. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1a569d586c97ccb137c0c8ac962472df71" name="operator!=" cv="const"><type>bool</type><parameter name=""><paramtype><classname>c_regex_traits</classname>&lt; char_type &gt; const &amp;</paramtype></parameter><description><para>Checks two <link linkend="doxygen.structboost_1_1xpressive_1_1c__regex__traits">c_regex_traits</link> objects for inequality</para><para>
</para></description><returns><para>false. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1a4e7bc08aa0ea143bdf8a1492a1bd0a1a" name="fold_case" cv="const"><type>string_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Returns a <computeroutput>string_type</computeroutput> containing all the characters that compare equal disregrarding case to the one passed in. This function can only be called if <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1has__fold__case">has_fold_case</link>&lt;<link linkend="doxygen.structboost_1_1xpressive_1_1c__regex__traits">c_regex_traits</link>&lt;Char&gt; &gt;<link linkend="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1a438ee1ca45895e74f7bee0ff8c089ff5">value</link></computeroutput> is <computeroutput>true</computeroutput>.</para><para>

</para></description><returns><para><computeroutput>string_type</computeroutput> containing all chars which are equal to <computeroutput>ch</computeroutput> when disregarding case </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1a69e16e45f9a2641b4b9719319ff487a9" name="imbue"><type>locale_type</type><parameter name="loc"><paramtype>locale_type</paramtype></parameter><description><para>No-op </para></description></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1ac97f9e57376d551652bc0b35c3a1c6d4" name="widen" specifiers="static"><type>char_type</type><parameter name="ch"><paramtype>char</paramtype><description><para>The source character. </para></description></parameter><description><para>Convert a char to a Char</para><para>

</para></description><returns><para>ch if Char is char, std::btowc(ch) if Char is wchar_t. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1a6c04ab5fe1cb32d4ea5c50c597e1cabb" name="hash" specifiers="static"><type>unsigned char</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Returns a hash value for a Char in the range [0, UCHAR_MAX]</para><para>

</para></description><returns><para>a value between 0 and UCHAR_MAX, inclusive. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1a0252e570650f2f861757366e5c5d659c" name="translate" specifiers="static"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>No-op</para><para>

</para></description><returns><para>ch </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1a5a84c366e83afd3eef709e3c361c81ba" name="translate_nocase" specifiers="static"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Converts a character to lower-case using the current global C locale.</para><para>

</para></description><returns><para>std::tolower(ch) if Char is char, std::towlower(ch) if Char is wchar_t. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1a65a73faa412ba38a8525fe2921c59122" name="tolower" specifiers="static"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Converts a character to lower-case using the current global C locale.</para><para>

</para></description><returns><para>std::tolower(ch) if Char is char, std::towlower(ch) if Char is wchar_t. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1a86cdde74c6d2d0ae857e0614d8233898" name="toupper" specifiers="static"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Converts a character to upper-case using the current global C locale.</para><para>

</para></description><returns><para>std::toupper(ch) if Char is char, std::towupper(ch) if Char is wchar_t. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1ad342ca4c058fba962d7ed4fbc040da36" name="in_range" specifiers="static"><type>bool</type><parameter name="first"><paramtype>char_type</paramtype><description><para>The bottom of the range, inclusive. </para></description></parameter><parameter name="last"><paramtype>char_type</paramtype><description><para>The top of the range, inclusive. </para></description></parameter><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Checks to see if a character is within a character range.</para><para>

</para></description><returns><para>first &lt;= ch &amp;&amp; ch &lt;= last. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1a1c8e5400da1831993a8c0392d3009b39" name="in_range_nocase" specifiers="static"><type>bool</type><parameter name="first"><paramtype>char_type</paramtype><description><para>The bottom of the range, inclusive. </para></description></parameter><parameter name="last"><paramtype>char_type</paramtype><description><para>The top of the range, inclusive. </para></description></parameter><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Checks to see if a character is within a character range, irregardless of case.</para><para>

<important><para>The default implementation doesn't do proper Unicode case folding, but this is the best we can do with the standard C locale functions. </para>
</important>
</para></description><returns><para>in_range(first, last, ch) || in_range(first, last, tolower(ch)) || in_range(first,
    last, toupper(ch)) </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1a5965958dcb1a2c822283b742bac59705" name="transform" specifiers="static"><type>string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) then v.transform(G1, G2) &lt; v.transform(H1, H2).</para><para><important><para>Not currently used </para>
</important>
</para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1abf1cdfe19e033b5f2db42a6e993e7ca8" name="transform_primary" specifiers="static"><type>string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) when character case is not considered then v.transform_primary(G1, G2) &lt; v.transform_primary(H1, H2).</para><para><important><para>Not currently used </para>
</important>
</para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1a792d8403cc3c4820675ccf8db65a8f43" name="lookup_collatename" specifiers="static"><type>string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sequence of characters that represents the collating element consisting of the character sequence designated by the iterator range [F1, F2). Returns an empty string if the character sequence is not a valid collating element.</para><para><important><para>Not currently used </para>
</important>
</para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1a086557e10ef7cf900d7c7298b1d744bc" name="lookup_classname" specifiers="static"><type>char_class_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype><description><para>A forward iterator to the start of the character sequence representing the name of the character class. </para></description></parameter><parameter name="end"><paramtype>FwdIter</paramtype><description><para>The end of the character sequence. </para></description></parameter><parameter name="icase"><paramtype>bool</paramtype><description><para>Specifies whether the returned bitmask should represent the case-insensitive version of the character class. </para></description></parameter><description><para>For the character class name represented by the specified character sequence, return the corresponding bitmask representation.</para><para>

</para></description><returns><para>A bitmask representing the character class. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1a3577ca6b0bfdd8166e9b12e6f4133962" name="isctype" specifiers="static"><type>bool</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The character to test. </para></description></parameter><parameter name="mask"><paramtype>char_class_type</paramtype><description><para>The character class bitmask against which to test. </para></description></parameter><description><para>Tests a character against a character class bitmask.</para><para>


</para></description><requires><para>mask is a bitmask returned by lookup_classname, or is several such masks bit-or'ed together. </para>
</requires><returns><para>true if the character is a member of any of the specified character classes, false otherwise. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1a438ee1ca45895e74f7bee0ff8c089ff5" name="value" specifiers="static"><type>int</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The digit character. </para></description></parameter><parameter name="radix"><paramtype>int</paramtype><description><para>The radix to use for the conversion. </para></description></parameter><description><para>Convert a digit character into the integer it represents.</para><para>


</para></description><requires><para>radix is one of 8, 10, or 16. </para>
</requires><returns><para>-1 if ch is not a digit character, the integer value of the character otherwise. If char_type is char, std::strtol is used for the conversion. If char_type is wchar_t, std::wcstol is used. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1c__regex__traits_1a3c88ef40bf79ecbc471298deea330b17" name="getloc" specifiers="static"><type>locale_type</type><description><para>No-op </para></description></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1compiler__traits" name="compiler_traits"><template>
      <template-type-parameter name="RegexTraits"/>
    </template></struct><struct id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits" name="cpp_regex_traits"><template>
      <template-type-parameter name="Char"/>
    </template><purpose>Encapsaulates a <computeroutput>std::locale</computeroutput> for use by the <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link>&lt;&gt;</computeroutput> class template. </purpose><method-group name="public member functions">
<constructor id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1a919c21f9d0c1633a00cbd9385a17a851"><parameter name="loc"><paramtype>locale_type const &amp;</paramtype><default>locale_type()</default></parameter><description><para>Initialize a <link linkend="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits">cpp_regex_traits</link> object to use the specified std::locale, or the global std::locale if none is specified. </para></description></constructor>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1a6f080be8c3e0c265b2ec53708f65cf3b" name="operator==" cv="const"><type>bool</type><parameter name="that"><paramtype><classname>cpp_regex_traits</classname>&lt; char_type &gt; const &amp;</paramtype></parameter><description><para>Checks two <link linkend="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits">cpp_regex_traits</link> objects for equality</para><para>
</para></description><returns><para>this-&gt;<link linkend="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1ab26541f07c1418fbb6ca30aa1a166540">getloc()</link> == that.getloc(). </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1a109f2db04e5759a13bf10636cfdde5a1" name="operator!=" cv="const"><type>bool</type><parameter name="that"><paramtype><classname>cpp_regex_traits</classname>&lt; char_type &gt; const &amp;</paramtype></parameter><description><para>Checks two <link linkend="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits">cpp_regex_traits</link> objects for inequality</para><para>
</para></description><returns><para>this-&gt;<link linkend="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1ab26541f07c1418fbb6ca30aa1a166540">getloc()</link> != that.getloc(). </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1a26017dda331bdb55f7b05b9593f21508" name="widen" cv="const"><type>char_type</type><parameter name="ch"><paramtype>char</paramtype><description><para>The source character. </para></description></parameter><description><para>Convert a char to a Char</para><para>

</para></description><returns><para>std::use_facet&lt;std::ctype&lt;char_type&gt; &gt;(this-&gt;<link linkend="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1ab26541f07c1418fbb6ca30aa1a166540">getloc()</link>).widen(ch). </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1aa08075100671bd4785e1de2813e4c4c7" name="translate_nocase" cv="const"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Converts a character to lower-case using the internally-stored std::locale.</para><para>

</para></description><returns><para>std::tolower(ch, this-&gt;<link linkend="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1ab26541f07c1418fbb6ca30aa1a166540">getloc()</link>). </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1ae37d0fd0e49e09c96025f8ae5caf9956" name="tolower" cv="const"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Converts a character to lower-case using the internally-stored std::locale.</para><para>

</para></description><returns><para>std::tolower(ch, this-&gt;<link linkend="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1ab26541f07c1418fbb6ca30aa1a166540">getloc()</link>). </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1aeefa81e2d8b05036c2faa6045eb44ac6" name="toupper" cv="const"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Converts a character to upper-case using the internally-stored std::locale.</para><para>

</para></description><returns><para>std::toupper(ch, this-&gt;<link linkend="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1ab26541f07c1418fbb6ca30aa1a166540">getloc()</link>). </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1a3ff6c0a4b3c1537fcd1b6b7c3d8f43ce" name="fold_case" cv="const"><type>string_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Returns a <computeroutput>string_type</computeroutput> containing all the characters that compare equal disregrarding case to the one passed in. This function can only be called if <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1has__fold__case">has_fold_case</link>&lt;<link linkend="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits">cpp_regex_traits</link>&lt;Char&gt; &gt;<link linkend="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1afb80e574453e7631e089f003f2561722">value</link></computeroutput> is <computeroutput>true</computeroutput>.</para><para>

</para></description><returns><para><computeroutput>string_type</computeroutput> containing all chars which are equal to <computeroutput>ch</computeroutput> when disregarding case </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1ac9ca09e0aa56a16afb6a9551186f0ae2" name="in_range_nocase" cv="const"><type>bool</type><parameter name="first"><paramtype>char_type</paramtype><description><para>The bottom of the range, inclusive. </para></description></parameter><parameter name="last"><paramtype>char_type</paramtype><description><para>The top of the range, inclusive. </para></description></parameter><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Checks to see if a character is within a character range, irregardless of case.</para><para>

<important><para>The default implementation doesn't do proper Unicode case folding, but this is the best we can do with the standard ctype facet. </para>
</important>
</para></description><returns><para>in_range(first, last, ch) || in_range(first, last, tolower(ch, this-&gt;<link linkend="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1ab26541f07c1418fbb6ca30aa1a166540">getloc()</link>)) || in_range(first, last, toupper(ch, this-&gt;<link linkend="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1ab26541f07c1418fbb6ca30aa1a166540">getloc()</link>)) </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1ad225d81807d1c24cf6f595a64894d078" name="transform_primary" cv="const"><type>string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name=""><paramtype>FwdIter</paramtype></parameter><parameter name=""><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) when character case is not considered then v.transform_primary(G1, G2) &lt; v.transform_primary(H1, H2).</para><para><important><para>Not currently used </para>
</important>
</para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1ac048d627fbee7a8e1f10f1a5354fc45e" name="lookup_collatename" cv="const"><type>string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name=""><paramtype>FwdIter</paramtype></parameter><parameter name=""><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sequence of characters that represents the collating element consisting of the character sequence designated by the iterator range [F1, F2). Returns an empty string if the character sequence is not a valid collating element.</para><para><important><para>Not currently used </para>
</important>
</para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1a52c33b318d6b72717c88ddb525760b36" name="lookup_classname" cv="const"><type>char_class_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype><description><para>A forward iterator to the start of the character sequence representing the name of the character class. </para></description></parameter><parameter name="end"><paramtype>FwdIter</paramtype><description><para>The end of the character sequence. </para></description></parameter><parameter name="icase"><paramtype>bool</paramtype><description><para>Specifies whether the returned bitmask should represent the case-insensitive version of the character class. </para></description></parameter><description><para>For the character class name represented by the specified character sequence, return the corresponding bitmask representation.</para><para>

</para></description><returns><para>A bitmask representing the character class. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1ab65f5abb540ac28c1d84095768d2d58f" name="isctype" cv="const"><type>bool</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The character to test. </para></description></parameter><parameter name="mask"><paramtype>char_class_type</paramtype><description><para>The character class bitmask against which to test. </para></description></parameter><description><para>Tests a character against a character class bitmask.</para><para>


</para></description><requires><para>mask is a bitmask returned by lookup_classname, or is several such masks bit-or'ed together. </para>
</requires><returns><para>true if the character is a member of any of the specified character classes, false otherwise. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1afb80e574453e7631e089f003f2561722" name="value" cv="const"><type>int</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The digit character. </para></description></parameter><parameter name="radix"><paramtype>int</paramtype><description><para>The radix to use for the conversion. </para></description></parameter><description><para>Convert a digit character into the integer it represents.</para><para>


</para></description><requires><para>radix is one of 8, 10, or 16. </para>
</requires><returns><para>-1 if ch is not a digit character, the integer value of the character otherwise. The conversion is performed by imbueing a std::stringstream with this-&gt;<link linkend="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1ab26541f07c1418fbb6ca30aa1a166540">getloc()</link>; setting the radix to one of oct, hex or dec; inserting ch into the stream; and extracting an int. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1abd1f60f4262f7808fcbeb87494ce538b" name="imbue"><type>locale_type</type><parameter name="loc"><paramtype>locale_type</paramtype><description><para>A std::locale. </para></description></parameter><description><para>Imbues *this with loc</para><para>

</para></description><returns><para>the previous std::locale used by *this. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1ab26541f07c1418fbb6ca30aa1a166540" name="getloc" cv="const"><type>locale_type</type><description><para>Returns the current std::locale used by *this. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1acea393195c6bc8e73abba27fc55e0d7f" name="hash"><type>unsigned char</type><parameter name="ch"><paramtype>unsigned char</paramtype></parameter></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1a587a5a645414f4597807cf527935265a" name="hash"><type>unsigned char</type><parameter name="ch"><paramtype>char</paramtype></parameter></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1a349090e217c52416bad90329a6738a8a" name="hash"><type>unsigned char</type><parameter name="ch"><paramtype>signed char</paramtype></parameter></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1a189150f91d66851d04661f758bf29308" name="hash"><type>unsigned char</type><parameter name="ch"><paramtype>wchar_t</paramtype></parameter></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1a58542f97ecf7478823e1a05e4a68ec4a" name="hash" specifiers="static"><type>unsigned char</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Returns a hash value for a Char in the range [0, UCHAR_MAX]</para><para>

</para></description><returns><para>a value between 0 and UCHAR_MAX, inclusive. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1a701b29c228ad13f6178a9d0b9c4f2f32" name="translate" specifiers="static"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>No-op</para><para>

</para></description><returns><para>ch </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits_1a97479f250e9d8985d1a98fc2b7011a9c" name="in_range" specifiers="static"><type>bool</type><parameter name="first"><paramtype>char_type</paramtype><description><para>The bottom of the range, inclusive. </para></description></parameter><parameter name="last"><paramtype>char_type</paramtype><description><para>The top of the range, inclusive. </para></description></parameter><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Checks to see if a character is within a character range.</para><para>

</para></description><returns><para>first &lt;= ch &amp;&amp; ch &lt;= last. </para>
</returns></method>
</method-group>
<method-group name="private static functions">
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1has__fold__case" name="has_fold_case"><template>
      <template-type-parameter name="Traits"/>
    </template><inherit access="public">is_convertible&lt; Traits::version_tag *, regex_traits_version_1_case_fold_tag * &gt;</inherit><purpose>Trait used to denote that a traits class has the fold_case member function. </purpose></struct><struct id="doxygen.structboost_1_1xpressive_1_1local" name="local"><template>
      <template-type-parameter name="T"><purpose><para>The type of the local variable.</para></purpose></template-type-parameter>
    </template><inherit access="public">proto::terminal::type</inherit><purpose><computeroutput>local&lt;&gt;</computeroutput> is a lazy wrapper for a reference to a value that is stored within the local itself. It is for use within xpressive semantic actions. </purpose><description><para>
Below is an example of how to use <computeroutput>local&lt;&gt;</computeroutput> in semantic actions. <programlisting language="c++">using namespace <link linkend="doxygen.namespaceboost_1_1xpressive">boost::xpressive</link>;
<link linkend="doxygen.structboost_1_1xpressive_1_1local">local&lt;int&gt;</link> i(0);
std::string <link linkend="doxygen.namespaceboost_1_1xpressive_1a3359fafa9e5c7964a0bd5364de930e9c">str</link>("1!2!3?");
// count the exciting digits, but not the
// questionable ones.
<link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">sregex</link> rex = +( <link linkend="doxygen.namespaceboost_1_1xpressive_1afae3ed7c3a8ebd3c2f06a943ff974a58">_d</link> [ ++i ] &gt;&gt; '!' );
<link linkend="doxygen.namespaceboost_1_1xpressive_1a1194c854fb35ddb2d0b216a303263bb3">regex_search</link>(<link linkend="doxygen.namespaceboost_1_1xpressive_1a3359fafa9e5c7964a0bd5364de930e9c">str</link>, rex);
assert( i.get() == 2 );
</programlisting> <note><para>As the name "local" suggests, <computeroutput>local&lt;&gt;</computeroutput> objects and the regexes that refer to them should never leave the local scope. The value stored within the local object will be destroyed at the end of the <computeroutput>local&lt;&gt;'s</computeroutput> lifetime, and any regex objects still holding the <computeroutput>local&lt;&gt;</computeroutput> will be left with a dangling reference. </para>
</note>
</para></description><method-group name="public member functions">
<constructor id="doxygen.structboost_1_1xpressive_1_1local_1a0b7b4f64dac5e8536bf270d8cde1ab13"><purpose>Store a default-constructed value of type <computeroutput>T</computeroutput>. </purpose></constructor>
<constructor id="doxygen.structboost_1_1xpressive_1_1local_1a14eda4067cba430bff82a80bc60cdff5" specifiers="explicit"><parameter name="t"><paramtype>T const &amp;</paramtype><description><para>The initial value. </para></description></parameter><purpose>Store a default-constructed value of type <computeroutput>T</computeroutput>. </purpose><description><para>
</para></description></constructor>
<method id="doxygen.structboost_1_1xpressive_1_1local_1a27e3537ffdfcd9478bb8d71e5159a467" name="get"><type>T &amp;</type><purpose>Fetch the wrapped value. </purpose></method>
<method id="doxygen.structboost_1_1xpressive_1_1local_1a67f4b68408f36264d70541b401573e9f" name="get" cv="const"><type>T const &amp;</type><purpose>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </purpose></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1match__results" name="match_results"><template>
      <template-type-parameter name="BidiIter"/>
    </template><purpose>Class template <link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link>&lt;&gt; holds the results of a <link linkend="doxygen.namespaceboost_1_1xpressive_1a7549c8bcd5ce2471d42aaad4e409d148">regex_match()</link> or a <link linkend="doxygen.namespaceboost_1_1xpressive_1a1194c854fb35ddb2d0b216a303263bb3">regex_search()</link> as a collection of <link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link> objects. </purpose><description><para>Class template <link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link>&lt;&gt; denotes a collection of sequences representing the result of a regular expression match. Storage for the collection is allocated and freed as necessary by the member functions of class <link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link>&lt;&gt;.</para><para>The class template <link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link>&lt;&gt; conforms to the requirements of a Sequence, as specified in (lib.sequence.reqmts), except that only operations defined for const-qualified Sequences are supported. </para></description><method-group name="public member functions">
<constructor id="doxygen.structboost_1_1xpressive_1_1match__results_1a6be22563474ea03b42a77bdd3eae633c"><description><para>



</para></description><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1a6c8192b66806890d65b5fade49bc639c">regex_id()</link> == 0 </para>
</postconditions><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1aaa956a09fc346a667dc2d8fc53f4d865">size()</link> == 0 </para>
</postconditions><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1a910c698d1014fc4a9a1fc999acd6895c">empty()</link> == true </para>
</postconditions><postconditions><para><link linkend="doxygen.namespaceboost_1_1xpressive_1a3359fafa9e5c7964a0bd5364de930e9c">str()</link> == <link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1acc4936b61ffd3dd28b7421475284eeb0">string_type()</link> </para>
</postconditions></constructor>
<constructor id="doxygen.structboost_1_1xpressive_1_1match__results_1ad1045ebfa8313dba278c26bad6c6acc6"><parameter name="that"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The <link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link> object to copy </para></description></parameter><description><para>









</para></description><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1a6c8192b66806890d65b5fade49bc639c">regex_id()</link> == that.regex_id(). </para>
</postconditions><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1aaa956a09fc346a667dc2d8fc53f4d865">size()</link> == that.size(). </para>
</postconditions><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1a910c698d1014fc4a9a1fc999acd6895c">empty()</link> == that.empty(). </para>
</postconditions><postconditions><para><link linkend="doxygen.namespaceboost_1_1xpressive_1a3359fafa9e5c7964a0bd5364de930e9c">str(n)</link> == that.str(n) for all positive integers n &lt; that.size(). </para>
</postconditions><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1a384dd5a758e71aaab17970a72762cf7c">prefix()</link> == that.prefix(). </para>
</postconditions><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1aa33bd2a5539f16645fa1fc257d1cdb66">suffix()</link> == that.suffix(). </para>
</postconditions><postconditions><para>(*this)[n] == that[n] for all positive integers n &lt; that.size(). </para>
</postconditions><postconditions><para><link linkend="doxygen.namespaceboost_1_1xpressive_1ac007382aa804f2950e4b9d5087e11cc1">length(n)</link> == that.length(n) for all positive integers n &lt; that.size(). </para>
</postconditions><postconditions><para>position(n) == that.position(n) for all positive integers n &lt; that.size(). </para>
</postconditions></constructor>
<destructor id="doxygen.structboost_1_1xpressive_1_1match__results_1a0601369b788fc6d8c4e8f8a718073b79"/>
<copy-assignment id="doxygen.structboost_1_1xpressive_1_1match__results_1a95b0ecdf1ae7f610985a9684ab05dd83"><type><classname>match_results</classname>&lt; BidiIter &gt; &amp;</type><parameter name="that"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The <link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link> object to copy. </para></description></parameter><description><para>









</para></description><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1a6c8192b66806890d65b5fade49bc639c">regex_id()</link> == that.regex_id(). </para>
</postconditions><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1aaa956a09fc346a667dc2d8fc53f4d865">size()</link> == that.size(). </para>
</postconditions><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1a910c698d1014fc4a9a1fc999acd6895c">empty()</link> == that.empty(). </para>
</postconditions><postconditions><para><link linkend="doxygen.namespaceboost_1_1xpressive_1a3359fafa9e5c7964a0bd5364de930e9c">str(n)</link> == that.str(n) for all positive integers n &lt; that.size(). </para>
</postconditions><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1a384dd5a758e71aaab17970a72762cf7c">prefix()</link> == that.prefix(). </para>
</postconditions><postconditions><para><link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1aa33bd2a5539f16645fa1fc257d1cdb66">suffix()</link> == that.suffix(). </para>
</postconditions><postconditions><para>(*this)[n] == that[n] for all positive integers n &lt; that.size(). </para>
</postconditions><postconditions><para><link linkend="doxygen.namespaceboost_1_1xpressive_1ac007382aa804f2950e4b9d5087e11cc1">length(n)</link> == that.length(n) for all positive integers n &lt; that.size(). </para>
</postconditions><postconditions><para>position(n) == that.position(n) for all positive integers n &lt; that.size(). </para>
</postconditions></copy-assignment>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1aaa956a09fc346a667dc2d8fc53f4d865" name="size" cv="const"><type>size_type</type><description><para>Returns one plus the number of marked sub-expressions in the regular expression that was matched if *this represents the result of a successful match. Otherwise returns 0. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1a910c698d1014fc4a9a1fc999acd6895c" name="empty" cv="const"><type>bool</type><description><para>Returns <link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1aaa956a09fc346a667dc2d8fc53f4d865">size()</link> == 0. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1aba6c60a81efe76e74f9f0ec3a9f38695" name="length" cv="const"><type>difference_type</type><parameter name="sub"><paramtype>size_type</paramtype><default>0</default></parameter><description><para>Returns (*this)[sub].<link linkend="doxygen.namespaceboost_1_1xpressive_1ac007382aa804f2950e4b9d5087e11cc1">length()</link>. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1a2061292cfca09270465316b6147d8826" name="position" cv="const"><type>difference_type</type><parameter name="sub"><paramtype>size_type</paramtype><default>0</default></parameter><description><para>If !(*this)[sub].matched then returns -1. Otherwise returns std::distance(base, (*this)[sub].first), where base is the start iterator of the sequence that was searched. [Note - unless this is part of a repeated search with a <link linkend="doxygen.structboost_1_1xpressive_1_1regex__iterator">regex_iterator</link> then base is the same as <link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1a384dd5a758e71aaab17970a72762cf7c">prefix()</link>.first - end note] </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1aa7536ad835012a993b38b1037d15b245" name="str" cv="const"><type>string_type</type><parameter name="sub"><paramtype>size_type</paramtype><default>0</default></parameter><description><para>Returns (*this)[sub].<link linkend="doxygen.namespaceboost_1_1xpressive_1a3359fafa9e5c7964a0bd5364de930e9c">str()</link>. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1a19e7c118f7f906d6a596de84416c990c" name="operator[]" cv="const"><type>const_reference</type><template>
          <template-type-parameter name="Sub"/>
        </template><parameter name="sub"><paramtype>Sub const &amp;</paramtype></parameter><description><para>Returns a reference to the <link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link> object representing the sequence that matched marked sub-expression sub. If sub == 0 then returns a reference to a <link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link> object representing the sequence that matched the whole regular expression. If sub &gt;= <link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1aaa956a09fc346a667dc2d8fc53f4d865">size()</link> then returns a <link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link> object representing an unmatched sub-expression. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1a384dd5a758e71aaab17970a72762cf7c" name="prefix" cv="const"><type>const_reference</type><description><para>Returns a reference to the <link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link> object representing the character sequence from the start of the string being matched/searched, to the start of the match found.</para><para>
</para></description><requires><para>(*this)[0].matched is true </para>
</requires></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1aa33bd2a5539f16645fa1fc257d1cdb66" name="suffix" cv="const"><type>const_reference</type><description><para>Returns a reference to the <link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link> object representing the character sequence from the end of the match found to the end of the string being matched/searched.</para><para>
</para></description><requires><para>(*this)[0].matched is true </para>
</requires></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1add11c3161b3cd65a4d083cd3997ccfa1" name="begin" cv="const"><type>const_iterator</type><description><para>Returns a starting iterator that enumerates over all the marked sub-expression matches stored in *this. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1a92ca9e59b8ef50f5d144dc3dcad505db" name="end" cv="const"><type>const_iterator</type><description><para>Returns a terminating iterator that enumerates over all the marked sub-expression matches stored in *this. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1a44c2eccd80a301a0255e1f1689c18c9e" name="conversion-operator" cv="const"><type>bool_type</type><description><para>Returns a true value if (*this)[0].matched, else returns a false value. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1a5415b39349b2c3e1a9d5641910c4fc02" name="operator!" cv="const"><type>bool</type><description><para>Returns true if <link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1a910c698d1014fc4a9a1fc999acd6895c">empty()</link> || !(*this)[0].matched, else returns false. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1a6c8192b66806890d65b5fade49bc639c" name="regex_id" cv="const"><type>regex_id_type</type><description><para>Returns the id of the <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> object most recently used with this <link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link> object. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1aae3f3d71947b4e3e16312d7eb7c6178e" name="nested_results" cv="const"><type>nested_results_type const &amp;</type><description><para>Returns a Sequence of nested <link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link> elements. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1a556bb72498a1b08d78bc23d86445f13b" name="format" cv="const"><type>OutputIterator</type><template>
          <template-type-parameter name="Format"/>
          <template-type-parameter name="OutputIterator"/>
        </template><parameter name="out"><paramtype>OutputIterator</paramtype></parameter><parameter name="fmt"><paramtype>Format const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::format_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>If <computeroutput>Format</computeroutput> models <computeroutput>ForwardRange</computeroutput> or is a null-terminated string, this function copies the character sequence in <computeroutput>fmt</computeroutput> to <computeroutput>OutputIterator</computeroutput> <computeroutput>out</computeroutput>. For each format specifier or escape sequence in <computeroutput>fmt</computeroutput>, replace that sequence with either the character(s) it represents, or the sequence within <computeroutput>*this</computeroutput> to which it refers. The bitmasks specified in flags determines what format specifiers or escape sequences are recognized. By default, this is the format used by ECMA-262, ECMAScript Language Specification, Chapter 15 part 5.4.11 String.prototype.replace.</para><para>Otherwise, if <computeroutput>Format</computeroutput> models <computeroutput>Callable&lt;<link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link>&lt;BidiIter&gt;, OutputIterator, <link linkend="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084">regex_constants::match_flag_type</link>&gt;</computeroutput>, this function returns <computeroutput>fmt(*this, out, flags)</computeroutput>.</para><para>Otherwise, if <computeroutput>Format</computeroutput> models <computeroutput>Callable&lt;<link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link>&lt;BidiIter&gt;, OutputIterator&gt;</computeroutput>, this function returns <computeroutput>fmt(*this, out)</computeroutput>.</para><para>Otherwise, if <computeroutput>Format</computeroutput> models <computeroutput>Callable&lt;<link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link>&lt;BidiIter&gt; &gt;</computeroutput>, this function returns <computeroutput>std::copy(x.begin(), x.end(), out)</computeroutput>, where <computeroutput>x</computeroutput> is the result of calling <computeroutput>fmt(*this)</computeroutput>. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1a3bc402f6f3f68ffee664ee27a0365848" name="format" cv="const"><type>OutputIterator</type><template>
          <template-type-parameter name="OutputIterator"/>
        </template><parameter name="out"><paramtype>OutputIterator</paramtype></parameter><parameter name="fmt"><paramtype>char_type const *</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::format_default</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1ae953529ad7fe9887f4dbe714d9d897e5" name="format" cv="const"><type>string_type</type><template>
          <template-type-parameter name="Format"/>
          <template-type-parameter name="OutputIterator"/>
        </template><parameter name="fmt"><paramtype>Format const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::format_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>If <computeroutput>Format</computeroutput> models <computeroutput>ForwardRange</computeroutput> or is a null-terminated string, this function returns a copy of the character sequence <computeroutput>fmt</computeroutput>. For each format specifier or escape sequence in <computeroutput>fmt</computeroutput>, replace that sequence with either the character(s) it represents, or the sequence within <computeroutput>*this</computeroutput> to which it refers. The bitmasks specified in <computeroutput>flags</computeroutput> determines what format specifiers or escape sequences are recognized. By default this is the format used by ECMA-262, ECMAScript Language Specification, Chapter 15 part 5.4.11 String.prototype.replace.</para><para>Otherwise, if <computeroutput>Format</computeroutput> models <computeroutput>Callable&lt;<link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link>&lt;BidiIter&gt;, OutputIterator, <link linkend="doxygen.namespaceboost_1_1xpressive_1_1regex__constants_1a1d1ca85be825c97268dc89c28fce4084">regex_constants::match_flag_type</link>&gt;</computeroutput>, this function returns a <computeroutput>string_type</computeroutput> object <computeroutput>x</computeroutput> populated by calling <computeroutput>fmt(*this, out, flags)</computeroutput>, where <computeroutput>out</computeroutput> is a <computeroutput>back_insert_iterator</computeroutput> into <computeroutput>x</computeroutput>.</para><para>Otherwise, if <computeroutput>Format</computeroutput> models <computeroutput>Callable&lt;<link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link>&lt;BidiIter&gt;, OutputIterator&gt;</computeroutput>, this function returns a <computeroutput>string_type</computeroutput> object <computeroutput>x</computeroutput> populated by calling <computeroutput>fmt(*this, out)</computeroutput>, where <computeroutput>out</computeroutput> is a <computeroutput>back_insert_iterator</computeroutput> into <computeroutput>x</computeroutput>.</para><para>Otherwise, if <computeroutput>Format</computeroutput> models <computeroutput>Callable&lt;<link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link>&lt;BidiIter&gt; &gt;</computeroutput>, this function returns <computeroutput>fmt(*this)</computeroutput>. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1a639c034ede34beb44357377fbda115f2" name="format" cv="const"><type>string_type</type><parameter name="fmt"><paramtype>char_type const *</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::format_default</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1aeabd8d33f39ae7cd3a6754b2a67d92b0" name="swap"><type>void</type><parameter name="that"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>The <link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link> object to swap with. </para></description></parameter><description><para>Swaps the contents of two <link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link> objects. Guaranteed not to throw. 


</para></description><postconditions><para>*this contains the sequence of matched sub-expressions that were in that, that contains the sequence of matched sub-expressions that were in *this. </para>
</postconditions><throws><simpara>Will not throw.</simpara>
</throws></method>
<method id="doxygen.structboost_1_1xpressive_1_1match__results_1a0b5d9b054f18782e2e195dab5e39123a" name="let"><type><classname>match_results</classname>&lt; BidiIter &gt; &amp;</type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter><description><para>TODO document me </para></description></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1null__regex__traits" name="null_regex_traits"><template>
      <template-type-parameter name="Elem"/>
    </template><purpose>stub <link linkend="doxygen.structboost_1_1xpressive_1_1regex__traits">regex_traits</link> for non-char data </purpose><method-group name="public member functions">
<constructor id="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1a191339ca7ca085cc4693c016d8cda119"><parameter name=""><paramtype>locale_type</paramtype><default>locale_type()</default></parameter><description><para>Initialize a <link linkend="doxygen.structboost_1_1xpressive_1_1null__regex__traits">null_regex_traits</link> object. </para></description></constructor>
<method id="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1a29ef7a1d3f73eb871166e3835409219c" name="operator==" cv="const"><type>bool</type><parameter name="that"><paramtype><classname>null_regex_traits</classname>&lt; char_type &gt; const &amp;</paramtype></parameter><description><para>Checks two <link linkend="doxygen.structboost_1_1xpressive_1_1null__regex__traits">null_regex_traits</link> objects for equality</para><para>
</para></description><returns><para>true. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1a73e75b7a946f5976308a3f12d1ed0338" name="operator!=" cv="const"><type>bool</type><parameter name="that"><paramtype><classname>null_regex_traits</classname>&lt; char_type &gt; const &amp;</paramtype></parameter><description><para>Checks two <link linkend="doxygen.structboost_1_1xpressive_1_1null__regex__traits">null_regex_traits</link> objects for inequality</para><para>
</para></description><returns><para>false. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1a677bf62a8dad29ad97e74f21a310477d" name="widen" cv="const"><type>char_type</type><parameter name="ch"><paramtype>char</paramtype><description><para>The source character. </para></description></parameter><description><para>Convert a char to a Elem</para><para>

</para></description><returns><para>Elem(ch). </para>
</returns></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1a47602c000e0d727984204c47f0bb6f6a" name="hash" specifiers="static"><type>unsigned char</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Returns a hash value for a Elem in the range [0, UCHAR_MAX]</para><para>

</para></description><returns><para>a value between 0 and UCHAR_MAX, inclusive. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1a75a334a35c58bbafc5b6ba2ed558c0f8" name="translate" specifiers="static"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>No-op</para><para>

</para></description><returns><para>ch </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1a08f077612aeab8ec37ef494eae607167" name="translate_nocase" specifiers="static"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>No-op</para><para>

</para></description><returns><para>ch </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1ace7b3e7e1ca295c0db065bbf9e2c4f41" name="in_range" specifiers="static"><type>bool</type><parameter name="first"><paramtype>char_type</paramtype><description><para>The bottom of the range, inclusive. </para></description></parameter><parameter name="last"><paramtype>char_type</paramtype><description><para>The top of the range, inclusive. </para></description></parameter><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Checks to see if a character is within a character range.</para><para>

</para></description><returns><para>first &lt;= ch &amp;&amp; ch &lt;= last. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1aa36d2cb059522411ea14da9a300abd1a" name="in_range_nocase" specifiers="static"><type>bool</type><parameter name="first"><paramtype>char_type</paramtype><description><para>The bottom of the range, inclusive. </para></description></parameter><parameter name="last"><paramtype>char_type</paramtype><description><para>The top of the range, inclusive. </para></description></parameter><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Checks to see if a character is within a character range.</para><para>

<important><para>Since the <link linkend="doxygen.structboost_1_1xpressive_1_1null__regex__traits">null_regex_traits</link> does not do case-folding, this function is equivalent to <link linkend="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1ace7b3e7e1ca295c0db065bbf9e2c4f41">in_range()</link>. </para>
</important>
</para></description><returns><para>first &lt;= ch &amp;&amp; ch &lt;= last. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1a351986e76800741b408922e94c3dde3d" name="transform" specifiers="static"><type>string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) then v.transform(G1, G2) &lt; v.transform(H1, H2).</para><para><important><para>Not currently used </para>
</important>
</para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1a60a27d11f8f14ed3d1d4b31a9ce74aef" name="transform_primary" specifiers="static"><type>string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) when character case is not considered then v.transform_primary(G1, G2) &lt; v.transform_primary(H1, H2).</para><para><important><para>Not currently used </para>
</important>
</para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1a194c3cba733d58ddb3bdc3590bbde25e" name="lookup_collatename" specifiers="static"><type>string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sequence of characters that represents the collating element consisting of the character sequence designated by the iterator range [F1, F2). Returns an empty string if the character sequence is not a valid collating element.</para><para><important><para>Not currently used </para>
</important>
</para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1a5ad757e8a34a9fa753e68aeb204da09d" name="lookup_classname" specifiers="static"><type>char_class_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype><description><para>not used </para></description></parameter><parameter name="end"><paramtype>FwdIter</paramtype><description><para>not used </para></description></parameter><parameter name="icase"><paramtype>bool</paramtype><description><para>not used </para></description></parameter><description><para>The <link linkend="doxygen.structboost_1_1xpressive_1_1null__regex__traits">null_regex_traits</link> does not have character classifications, so <link linkend="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1a5ad757e8a34a9fa753e68aeb204da09d">lookup_classname()</link> is unused.</para><para>

</para></description><returns><para>static_cast&lt;char_class_type&gt;(0) </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1aed3735c27586aad2b39e417dcf5d2d44" name="isctype" specifiers="static"><type>bool</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>not used </para></description></parameter><parameter name="mask"><paramtype>char_class_type</paramtype><description><para>not used </para></description></parameter><description><para>The <link linkend="doxygen.structboost_1_1xpressive_1_1null__regex__traits">null_regex_traits</link> does not have character classifications, so <link linkend="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1aed3735c27586aad2b39e417dcf5d2d44">isctype()</link> is unused.</para><para>

</para></description><returns><para>false </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1a830e0e388511d55743c96228546a9a3e" name="value" specifiers="static"><type>int</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>not used </para></description></parameter><parameter name="radix"><paramtype>int</paramtype><description><para>not used </para></description></parameter><description><para>The <link linkend="doxygen.structboost_1_1xpressive_1_1null__regex__traits">null_regex_traits</link> recognizes no elements as digits, so <link linkend="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1a830e0e388511d55743c96228546a9a3e">value()</link> is unused.</para><para>

</para></description><returns><para>-1 </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1a9f30dac76cd16ba6f2f6cfdfcd532302" name="imbue" specifiers="static"><type>locale_type</type><parameter name="loc"><paramtype>locale_type</paramtype><description><para>not used </para></description></parameter><description><para>Not used</para><para>

</para></description><returns><para>loc </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1a0e2c7e8275965e1d28382ae6266a7960" name="getloc" specifiers="static"><type>locale_type</type><description><para>Returns <link linkend="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1a2c104a4668806daea1a2b164eebb59d0">locale_type()</link>.</para><para>
</para></description><returns><para><link linkend="doxygen.structboost_1_1xpressive_1_1null__regex__traits_1a2c104a4668806daea1a2b164eebb59d0">locale_type()</link> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1placeholder" name="placeholder"><template>
      <template-type-parameter name="T"><purpose><para>The type of the object for which this placeholder stands in. </para></purpose></template-type-parameter>
      <template-nontype-parameter name="I"><type>int</type><default>0</default><purpose><para>An optional identifier that can be used to distinguish this placeholder from others that may be used in the same semantic action that happen to have the same type.</para></purpose></template-nontype-parameter>
    </template><purpose>For defining a placeholder to stand in for a variable a semantic action. </purpose><description><para>Use <computeroutput>placeholder&lt;&gt;</computeroutput> to define a placeholder for use in semantic actions to stand in for real objects. The use of placeholders allows regular expressions with actions to be defined once and reused in many contexts to read and write from objects which were not available when the regex was defined.</para><para>
You can use <computeroutput>placeholder&lt;&gt;</computeroutput> by creating an object of type <computeroutput>placeholder&lt;T&gt;</computeroutput> and using that object in a semantic action exactly as you intend an object of type <computeroutput>T</computeroutput> to be used. <programlisting language="c++">placeholder&lt;int&gt; _i;
placeholder&lt;double&gt; <link linkend="doxygen.namespaceboost_1_1xpressive_1afae3ed7c3a8ebd3c2f06a943ff974a58">_d</link>;

<link linkend="doxygen.namespaceboost_1_1xpressive_1ad82b5700d5ba5eb195cfce6d4007f0b4">sregex</link> rex = ( some &gt;&gt; regex &gt;&gt; here )
    [ ++_i, <link linkend="doxygen.namespaceboost_1_1xpressive_1afae3ed7c3a8ebd3c2f06a943ff974a58">_d</link> *= <link linkend="doxygen.namespaceboost_1_1xpressive_1afae3ed7c3a8ebd3c2f06a943ff974a58">_d</link> ];
</programlisting> Then, when doing a pattern match with either <computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1a1194c854fb35ddb2d0b216a303263bb3">regex_search()</link></computeroutput>, <computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1a7549c8bcd5ce2471d42aaad4e409d148">regex_match()</link></computeroutput> or <computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1a53c66a9ef9dc507a2a89b06d4822aac2">regex_replace()</link></computeroutput>, pass a <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1match__results">match_results</link>&lt;&gt;</computeroutput> object that contains bindings for the placeholders used in the regex object's semantic actions. You can create the bindings by calling <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1match__results_1a0b5d9b054f18782e2e195dab5e39123a">match_results::let</link></computeroutput> as follows: <programlisting language="c++">int i = 0;
double d = 3.14;

<link linkend="doxygen.namespaceboost_1_1xpressive_1a9abbae50995ee1162f681ed99477c0ed">smatch</link> what;
what.let(_i = i)
    .let(<link linkend="doxygen.namespaceboost_1_1xpressive_1afae3ed7c3a8ebd3c2f06a943ff974a58">_d</link> = d);

if(<link linkend="doxygen.namespaceboost_1_1xpressive_1a7549c8bcd5ce2471d42aaad4e409d148">regex_match</link>("some string", rex, what))
   // i and d mutated here
</programlisting> If a semantic action executes that contains an unbound placeholder, a exception of type <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1regex__error">regex_error</link></computeroutput> is thrown.</para><para>See the discussion for <computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1ace777d41d9a728658b3569d818e70d52">xpressive::let()</link></computeroutput> and the  <link linkend="boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.referring_to_non_local_variables"> "Referring to Non-Local Variables"</link> section in the Users' Guide for more information.</para><para><emphasis>Example:</emphasis> <programlisting language="c++">// Define a placeholder for a map object:
placeholder&lt;std::map&lt;std::string, int&gt; &gt; _map;

// Match a word and an integer, separated by =&gt;,
// and then stuff the result into a std::map&lt;&gt;
<link linkend="doxygen.namespaceboost_1_1xpressive_1ad82b5700d5ba5eb195cfce6d4007f0b4">sregex</link> pair = ( (<link linkend="doxygen.namespaceboost_1_1xpressive_1ad80f6f2e945d16adb777f6c5c05c32ba">s1</link>= +<link linkend="doxygen.namespaceboost_1_1xpressive_1a6d4422b6535a447d3eb0689827b0b8fe">_w</link>) &gt;&gt; "=&gt;" &gt;&gt; (<link linkend="doxygen.namespaceboost_1_1xpressive_1a1f240bb30623f86f70e07f05bbd7b086">s2</link>= +<link linkend="doxygen.namespaceboost_1_1xpressive_1afae3ed7c3a8ebd3c2f06a943ff974a58">_d</link>) )
    [ _map[<link linkend="doxygen.namespaceboost_1_1xpressive_1ad80f6f2e945d16adb777f6c5c05c32ba">s1</link>] = <link linkend="doxygen.namespaceboost_1_1xpressive_1a149e8cb8ad542bdabd5c1980bb584c21">as&lt;int&gt;</link>(<link linkend="doxygen.namespaceboost_1_1xpressive_1a1f240bb30623f86f70e07f05bbd7b086">s2</link>) ];

// Match one or more word/integer pairs, separated
// by whitespace.
<link linkend="doxygen.namespaceboost_1_1xpressive_1ad82b5700d5ba5eb195cfce6d4007f0b4">sregex</link> rx = pair &gt;&gt; *(+<link linkend="doxygen.namespaceboost_1_1xpressive_1ab34b82560c0e1148b5c1748351711294">_s</link> &gt;&gt; pair);

// The string to parse
std::string <link linkend="doxygen.namespaceboost_1_1xpressive_1a3359fafa9e5c7964a0bd5364de930e9c">str</link>("aaa=&gt;1 bbb=&gt;23 ccc=&gt;456");

// Here is the actual map to fill in:
std::map&lt;std::string, int&gt; result;

// Bind the _map placeholder to the actual map
<link linkend="doxygen.namespaceboost_1_1xpressive_1a9abbae50995ee1162f681ed99477c0ed">smatch</link> what;
what.let( _map = result );

// Execute the match and fill in result map
if(<link linkend="doxygen.namespaceboost_1_1xpressive_1a7549c8bcd5ce2471d42aaad4e409d148">regex_match</link>(<link linkend="doxygen.namespaceboost_1_1xpressive_1a3359fafa9e5c7964a0bd5364de930e9c">str</link>, what, rx))
{
    std::cout &lt;&lt; result["aaa"] &lt;&lt; '\n';
    std::cout &lt;&lt; result["bbb"] &lt;&lt; '\n';
    std::cout &lt;&lt; result["ccc"] &lt;&lt; '\n';
}
</programlisting> </para></description><method-group name="public member functions">
<copy-assignment id="doxygen.structboost_1_1xpressive_1_1placeholder_1ad172509c2232338ab291a164c7df40b7" cv="const"><type><emphasis>unspecified</emphasis></type><parameter name="t"><paramtype>T &amp;</paramtype><description><para>The object to associate with this placeholder </para></description></parameter><description><para>

</para></description><returns><para>An object of unspecified type that records the association of <computeroutput>t</computeroutput> with <computeroutput>*this</computeroutput>. </para>
</returns></copy-assignment>
<copy-assignment id="doxygen.structboost_1_1xpressive_1_1placeholder_1aadeff1977e9a2e8e63b227bacdcd9b7a" cv="const"><type><emphasis>unspecified</emphasis></type><parameter name="t"><paramtype>T const &amp;</paramtype></parameter><purpose>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </purpose></copy-assignment>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1reference" name="reference"><template>
      <template-type-parameter name="T"><purpose><para>The type of the referent.</para></purpose></template-type-parameter>
    </template><inherit access="public">proto::extends&lt; proto::terminal&lt; reference_wrapper&lt; T &gt; &gt;::type, reference&lt; T &gt; &gt;</inherit><purpose><computeroutput>reference&lt;&gt;</computeroutput> is a lazy wrapper for a reference that can be used in xpressive semantic actions. </purpose><description><para>
Here is an example of how to use <computeroutput>reference&lt;&gt;</computeroutput> to create a lazy reference to an existing object so it can be read and written in an xpressive semantic action. <programlisting language="c++">using namespace <link linkend="doxygen.namespaceboost_1_1xpressive">boost::xpressive</link>;
std::map&lt;std::string, int&gt; result;
<link linkend="doxygen.structboost_1_1xpressive_1_1reference">reference&lt;std::map&lt;std::string, int&gt;</link> &gt; result_ref(result);

// Match a word and an integer, separated by =&gt;,
// and then stuff the result into a std::map&lt;&gt;
<link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">sregex</link> pair = ( (<link linkend="doxygen.namespaceboost_1_1xpressive_1ad80f6f2e945d16adb777f6c5c05c32ba">s1</link>= +<link linkend="doxygen.namespaceboost_1_1xpressive_1a6d4422b6535a447d3eb0689827b0b8fe">_w</link>) &gt;&gt; "=&gt;" &gt;&gt; (<link linkend="doxygen.namespaceboost_1_1xpressive_1a1f240bb30623f86f70e07f05bbd7b086">s2</link>= +<link linkend="doxygen.namespaceboost_1_1xpressive_1afae3ed7c3a8ebd3c2f06a943ff974a58">_d</link>) )
    [ result_ref[<link linkend="doxygen.namespaceboost_1_1xpressive_1ad80f6f2e945d16adb777f6c5c05c32ba">s1</link>] = <link linkend="doxygen.namespaceboost_1_1xpressive_1a149e8cb8ad542bdabd5c1980bb584c21">as&lt;int&gt;</link>(<link linkend="doxygen.namespaceboost_1_1xpressive_1a1f240bb30623f86f70e07f05bbd7b086">s2</link>) ];
</programlisting> </para></description><method-group name="public member functions">
<constructor id="doxygen.structboost_1_1xpressive_1_1reference_1a395cd9f1385616caf4179a54ee8f4ffa" specifiers="explicit"><parameter name="t"><paramtype>T &amp;</paramtype><description><para>Reference to object </para></description></parameter><purpose>Store a reference to <computeroutput>t</computeroutput>. </purpose><description><para>
</para></description></constructor>
<method id="doxygen.structboost_1_1xpressive_1_1reference_1ae748610f1364e3117ae9848293b05f08" name="get" cv="const"><type>T &amp;</type><purpose>Fetch the stored value. </purpose></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1regex__compiler" name="regex_compiler"><template>
      <template-type-parameter name="BidiIter"/>
      <template-type-parameter name="RegexTraits"/>
      <template-type-parameter name="CompilerTraits"/>
    </template><purpose>Class template <link linkend="doxygen.structboost_1_1xpressive_1_1regex__compiler">regex_compiler</link> is a factory for building <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> objects from a string. </purpose><description><para>Class template <link linkend="doxygen.structboost_1_1xpressive_1_1regex__compiler">regex_compiler</link> is used to construct a <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> object from a string. The string should contain a valid regular expression. You can imbue a <link linkend="doxygen.structboost_1_1xpressive_1_1regex__compiler">regex_compiler</link> object with a locale, after which all <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> objects created with that <link linkend="doxygen.structboost_1_1xpressive_1_1regex__compiler">regex_compiler</link> object will use that locale. After creating a <link linkend="doxygen.structboost_1_1xpressive_1_1regex__compiler">regex_compiler</link> object, and optionally imbueing it with a locale, you can call the <link linkend="doxygen.structboost_1_1xpressive_1_1regex__compiler_1a093f2cd82be868e667318a86dac56453">compile()</link> method to construct a <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> object, passing it the string representing the regular expression. You can call <link linkend="doxygen.structboost_1_1xpressive_1_1regex__compiler_1a093f2cd82be868e667318a86dac56453">compile()</link> multiple times on the same <link linkend="doxygen.structboost_1_1xpressive_1_1regex__compiler">regex_compiler</link> object. Two <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> objects compiled from the same string will have different regex_id's. </para></description><method-group name="public member functions">
<constructor id="doxygen.structboost_1_1xpressive_1_1regex__compiler_1a9a5787e0624bd64a72c30f261267f267" specifiers="explicit"><parameter name="traits"><paramtype>RegexTraits const &amp;</paramtype><default>RegexTraits()</default></parameter></constructor>
<method id="doxygen.structboost_1_1xpressive_1_1regex__compiler_1a2bc2c429b1463c2724c5e1585bc098c4" name="imbue"><type>locale_type</type><parameter name="loc"><paramtype>locale_type</paramtype><description><para>The locale that this <link linkend="doxygen.structboost_1_1xpressive_1_1regex__compiler">regex_compiler</link> should use. </para></description></parameter><description><para>Specify the locale to be used by a <link linkend="doxygen.structboost_1_1xpressive_1_1regex__compiler">regex_compiler</link>.</para><para>

</para></description><returns><para>The previous locale. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1regex__compiler_1a4055215f008f0ce71fb67bd1ba8f17d4" name="getloc" cv="const"><type>locale_type</type><description><para>Get the locale used by a <link linkend="doxygen.structboost_1_1xpressive_1_1regex__compiler">regex_compiler</link>.</para><para>
</para></description><returns><para>The locale used by this <link linkend="doxygen.structboost_1_1xpressive_1_1regex__compiler">regex_compiler</link>. </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1regex__compiler_1a093f2cd82be868e667318a86dac56453" name="compile"><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type><template>
          <template-type-parameter name="InputIter"/>
        </template><parameter name="begin"><paramtype>InputIter</paramtype><description><para>The beginning of a range of characters representing the regular expression to compile. </para></description></parameter><parameter name="end"><paramtype>InputIter</paramtype><description><para>The end of a range of characters representing the regular expression to compile. </para></description></parameter><parameter name="flags"><paramtype>flag_type</paramtype><default>regex_constants::ECMAScript</default><description><para>Optional bitmask that determines how the pat string is interpreted. (See syntax_option_type.) </para></description></parameter><description><para>Builds a <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> object from a range of characters.</para><para>





</para></description><requires><para>InputIter is a model of the InputIterator concept. </para>
</requires><requires><para>[begin,end) is a valid range. </para>
</requires><requires><para>The range of characters specified by [begin,end) contains a valid string-based representation of a regular expression. </para>
</requires><returns><para>A <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">basic_regex</link> object corresponding to the regular expression represented by the character range. </para>
</returns><throws><simpara><classname>regex_error</classname> when the range of characters has invalid regular expression syntax. </simpara>
</throws></method>
<method id="doxygen.structboost_1_1xpressive_1_1regex__compiler_1a44a4594639eb13a738b09876bc55503e" name="compile"><type>disable_if&lt; is_pointer&lt; InputRange &gt;, <classname>basic_regex</classname>&lt; BidiIter &gt; &gt;::type</type><template>
          <template-type-parameter name="InputRange"/>
        </template><parameter name="pat"><paramtype>InputRange const &amp;</paramtype></parameter><parameter name="flags"><paramtype>flag_type</paramtype><default>regex_constants::ECMAScript</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1regex__compiler_1a72fb7f2652913c5c5fa71f495214130e" name="compile"><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type><parameter name="begin"><paramtype>char_type const *</paramtype></parameter><parameter name="flags"><paramtype>flag_type</paramtype><default>regex_constants::ECMAScript</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1regex__compiler_1a29be17e0664071dd2627a7151b62f94c" name="compile"><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type><parameter name="begin"><paramtype>char_type const *</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="flags"><paramtype>flag_type</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1regex__compiler_1a651ca16bb263c7392c05c761279a918a" name="operator[]"><type><classname>basic_regex</classname>&lt; BidiIter &gt; &amp;</type><parameter name="name"><paramtype>string_type const &amp;</paramtype><description><para>A std::string containing the name of the regular expression. </para></description></parameter><description><para>Return a reference to the named regular expression. If no such named regular expression exists, create a new regular expression and return a reference to it.</para><para>


</para></description><requires><para>The string is not empty. </para>
</requires><throws><simpara><classname>bad_alloc</classname> on allocation failure. </simpara>
</throws></method>
<method id="doxygen.structboost_1_1xpressive_1_1regex__compiler_1a1ed7a3fc9e85d080ef72a1a567c45f43" name="operator[]" cv="const"><type><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</type><parameter name="name"><paramtype>string_type const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
</method-group>
<method-group name="private member functions">
<method id="doxygen.structboost_1_1xpressive_1_1regex__compiler_1af6dbfaf502908e7bcff57845bdb7044b" name="is_upper_" cv="const"><type>bool</type><parameter name="ch"><paramtype>char_type</paramtype></parameter></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1regex__id__filter__predicate" name="regex_id_filter_predicate"><template>
      <template-type-parameter name="BidiIter"/>
    </template><method-group name="public member functions">
<constructor id="doxygen.structboost_1_1xpressive_1_1regex__id__filter__predicate_1a4b215682b181eb70280a10f009e39885"><parameter name="regex_id"><paramtype>regex_id_type</paramtype></parameter></constructor>
<method id="doxygen.structboost_1_1xpressive_1_1regex__id__filter__predicate_1a40e3e853dfe3e566159fc6a8e9485ab6" name="operator()" cv="const"><type>bool</type><parameter name="res"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1regex__iterator" name="regex_iterator"><template>
      <template-type-parameter name="BidiIter"/>
    </template><method-group name="public member functions">
<constructor id="doxygen.structboost_1_1xpressive_1_1regex__iterator_1a69158dc77298a78d5f45d9232b85249c"/>
<constructor id="doxygen.structboost_1_1xpressive_1_1regex__iterator_1a22558f6f6eb5d1e587873ef65d38832c"><parameter name="begin"><paramtype>BidiIter</paramtype></parameter><parameter name="end"><paramtype>BidiIter</paramtype></parameter><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></constructor>
<constructor id="doxygen.structboost_1_1xpressive_1_1regex__iterator_1ad4b0d8817c192df17d807a563a59d629"><template>
          <template-type-parameter name="LetExpr"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype></parameter><parameter name="end"><paramtype>BidiIter</paramtype></parameter><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="args"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></constructor>
<constructor id="doxygen.structboost_1_1xpressive_1_1regex__iterator_1a7894066a0349af5e0d9412b41d49e3d9"><parameter name="that"><paramtype><classname>regex_iterator</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></constructor>
<copy-assignment id="doxygen.structboost_1_1xpressive_1_1regex__iterator_1a769c99f5673f7cef992e9514b652efbe"><type><classname>regex_iterator</classname>&lt; BidiIter &gt; &amp;</type><parameter name="that"><paramtype><classname>regex_iterator</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></copy-assignment>
<method id="doxygen.structboost_1_1xpressive_1_1regex__iterator_1abd6b88adf7ba4ba07063ea6e043da691" name="operator*" cv="const"><type>value_type const &amp;</type></method>
<method id="doxygen.structboost_1_1xpressive_1_1regex__iterator_1ad2c3cb1b613c7b688f2bc2c99dec7fd6" name="operator-&gt;" cv="const"><type>value_type const *</type></method>
<method id="doxygen.structboost_1_1xpressive_1_1regex__iterator_1ae8ada039f3f88fc134c1ec6a789a38f1" name="operator++"><type><classname>regex_iterator</classname>&lt; BidiIter &gt; &amp;</type><description><para>If what.prefix().first != what[0].second and if the element match_prev_avail is not set in flags then sets it. Then behaves as if by calling regex_search(what[0].second, end, what, *pre, flags), with the following variation: in the event that the previous match found was of zero length (what[0].<link linkend="doxygen.namespaceboost_1_1xpressive_1ac007382aa804f2950e4b9d5087e11cc1">length()</link> == 0) then attempts to find a non-zero length match starting at what[0].second, only if that fails and provided what[0].second != suffix().second does it look for a (possibly zero length) match starting from what[0].second + 1. If no further match is found then sets *this equal to the end of sequence iterator. 














</para></description><postconditions><para>(*this)-&gt;size() == pre-&gt;mark_count() + 1 </para>
</postconditions><postconditions><para>(*this)-&gt;empty() == false </para>
</postconditions><postconditions><para>(*this)-&gt;prefix().first == An iterator denoting the end point of the previous match found </para>
</postconditions><postconditions><para>(*this)-&gt;prefix().last == (**this)[0].first </para>
</postconditions><postconditions><para>(*this)-&gt;prefix().matched == (*this)-&gt;prefix().first != (*this)-&gt;prefix().second </para>
</postconditions><postconditions><para>(*this)-&gt;suffix().first == (**this)[0].second </para>
</postconditions><postconditions><para>(*this)-&gt;suffix().last == end </para>
</postconditions><postconditions><para>(*this)-&gt;suffix().matched == (*this)-&gt;suffix().first != (*this)-&gt;suffix().second </para>
</postconditions><postconditions><para>(**this)[0].first == The starting iterator for this match. </para>
</postconditions><postconditions><para>(**this)[0].second == The ending iterator for this match. </para>
</postconditions><postconditions><para>(**this)[0].matched == true if a full match was found, and false if it was a partial match (found as a result of the match_partial flag being set). </para>
</postconditions><postconditions><para>(**this)[n].first == For all integers n &lt; (*this)-&gt;size(), the start of the sequence that matched sub-expression n. Alternatively, if sub-expression n did not participate in the match, then end. </para>
</postconditions><postconditions><para>(**this)[n].second == For all integers n &lt; (*this)-&gt;size(), the end of the sequence that matched sub-expression n. Alternatively, if sub-expression n did not participate in the match, then end. </para>
</postconditions><postconditions><para>(**this)[n].matched == For all integers n &lt; (*this)-&gt;size(), true if sub-expression n participated in the match, false otherwise. </para>
</postconditions><postconditions><para>(*this)-&gt;position() == The distance from the start of the original sequence being iterated, to the start of this match. </para>
</postconditions></method>
<method id="doxygen.structboost_1_1xpressive_1_1regex__iterator_1af401928455f5cecafe7663c6ba09d6a3" name="operator++"><type><classname>regex_iterator</classname>&lt; BidiIter &gt;</type><parameter name=""><paramtype>int</paramtype></parameter></method>
</method-group>
<method-group name="private member functions">
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1regex__token__iterator" name="regex_token_iterator"><template>
      <template-type-parameter name="BidiIter"/>
    </template><method-group name="public member functions">
<constructor id="doxygen.structboost_1_1xpressive_1_1regex__token__iterator_1a8e6bf04e90b0be2146703e7ac1f71ea4"><description><para>
</para></description><postconditions><para><computeroutput>*this</computeroutput> is the end of sequence iterator. </para>
</postconditions></constructor>
<constructor id="doxygen.structboost_1_1xpressive_1_1regex__token__iterator_1a2f82a5b47a1682aa56437d07709d3503"><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the character range to search. </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the character range to search. </para></description></parameter><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regex pattern to search for. </para></description></parameter><description><para>

</para></description><requires><para><computeroutput/>[begin,end) is a valid range. </para>
</requires></constructor>
<constructor id="doxygen.structboost_1_1xpressive_1_1regex__token__iterator_1a7d7fdf6583b28e006a0b1863d720cf6e"><template>
          <template-type-parameter name="LetExpr"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the character range to search. </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the character range to search. </para></description></parameter><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regex pattern to search for. </para></description></parameter><parameter name="args"><paramtype><emphasis>unspecified</emphasis></paramtype><description><para>A <link linkend="doxygen.namespaceboost_1_1xpressive_1ace777d41d9a728658b3569d818e70d52">let()</link> expression with argument bindings for semantic actions. </para></description></parameter><description><para>

</para></description><requires><para><computeroutput/>[begin,end) is a valid range. </para>
</requires></constructor>
<constructor id="doxygen.structboost_1_1xpressive_1_1regex__token__iterator_1ac49acd2f80c1ccf2bf47f75bb7d4cb25"><template>
          <template-type-parameter name="Subs"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the character range to search. </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the character range to search. </para></description></parameter><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regex pattern to search for. </para></description></parameter><parameter name="subs"><paramtype>Subs const &amp;</paramtype><description><para>A range of integers designating sub-matches to be treated as tokens. </para></description></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default><description><para>Optional match flags, used to control how the expression is matched against the sequence. (See match_flag_type.) </para></description></parameter><description><para>


</para></description><requires><para><computeroutput/>[begin,end) is a valid range. </para>
</requires><requires><para><computeroutput>subs</computeroutput> is either an integer greater or equal to -1, or else an array or non-empty <computeroutput>std::vector&lt;&gt;</computeroutput> of such integers. </para>
</requires></constructor>
<constructor id="doxygen.structboost_1_1xpressive_1_1regex__token__iterator_1a1461c27227050f1c0c51dca261ce2731"><template>
          <template-type-parameter name="Subs"/>
          <template-type-parameter name="LetExpr"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the character range to search. </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the character range to search. </para></description></parameter><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regex pattern to search for. </para></description></parameter><parameter name="subs"><paramtype>Subs const &amp;</paramtype><description><para>A range of integers designating sub-matches to be treated as tokens. </para></description></parameter><parameter name="args"><paramtype><emphasis>unspecified</emphasis></paramtype><description><para>A <link linkend="doxygen.namespaceboost_1_1xpressive_1ace777d41d9a728658b3569d818e70d52">let()</link> expression with argument bindings for semantic actions. </para></description></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default><description><para>Optional match flags, used to control how the expression is matched against the sequence. (See match_flag_type.) </para></description></parameter><description><para>


</para></description><requires><para><computeroutput/>[begin,end) is a valid range. </para>
</requires><requires><para><computeroutput>subs</computeroutput> is either an integer greater or equal to -1, or else an array or non-empty <computeroutput>std::vector&lt;&gt;</computeroutput> of such integers. </para>
</requires></constructor>
<constructor id="doxygen.structboost_1_1xpressive_1_1regex__token__iterator_1ad0996ce537ff8bebea834d6d49af7147"><parameter name="that"><paramtype><classname>regex_token_iterator</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><description><para>
</para></description><postconditions><para><computeroutput>*this == that</computeroutput> </para>
</postconditions></constructor>
<copy-assignment id="doxygen.structboost_1_1xpressive_1_1regex__token__iterator_1a17a77ad308eeca2b614a0a9e85c77a69"><type><classname>regex_token_iterator</classname>&lt; BidiIter &gt; &amp;</type><parameter name="that"><paramtype><classname>regex_token_iterator</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><description><para>
</para></description><postconditions><para><computeroutput>*this == that</computeroutput> </para>
</postconditions></copy-assignment>
<method id="doxygen.structboost_1_1xpressive_1_1regex__token__iterator_1a6e19b38195e8d7922b6a3c91197533f5" name="operator*" cv="const"><type>value_type const &amp;</type></method>
<method id="doxygen.structboost_1_1xpressive_1_1regex__token__iterator_1a043cb6d6164a1858e74fc337c6b4b0d5" name="operator-&gt;" cv="const"><type>value_type const *</type></method>
<method id="doxygen.structboost_1_1xpressive_1_1regex__token__iterator_1abcc176b9dfdf8276c24220cf8758c7e7" name="operator++"><type><classname>regex_token_iterator</classname>&lt; BidiIter &gt; &amp;</type><description><para>If N == -1 then sets *this equal to the end of sequence iterator. Otherwise if N+1 &lt; subs.size(), then increments N and sets result equal to ((subs[N] == -1) ? value_type(what.prefix().<link linkend="doxygen.namespaceboost_1_1xpressive_1a3359fafa9e5c7964a0bd5364de930e9c">str()</link>) : value_type(what[subs[N]].<link linkend="doxygen.namespaceboost_1_1xpressive_1a3359fafa9e5c7964a0bd5364de930e9c">str()</link>)). Otherwise if what.prefix().first != what[0].second and if the element match_prev_avail is not set in flags then sets it. Then locates the next match as if by calling regex_search(what[0].second, end, what, *pre, flags), with the following variation: in the event that the previous match found was of zero length (what[0].<link linkend="doxygen.namespaceboost_1_1xpressive_1ac007382aa804f2950e4b9d5087e11cc1">length()</link> == 0) then attempts to find a non-zero length match starting at what[0].second, only if that fails and provided what[0].second != suffix().second does it look for a (possibly zero length) match starting from what[0].second + 1. If such a match is found then sets N equal to zero, and sets result equal to ((subs[N] == -1) ? value_type(what.prefix().<link linkend="doxygen.namespaceboost_1_1xpressive_1a3359fafa9e5c7964a0bd5364de930e9c">str()</link>) : value_type(what[subs[N]].<link linkend="doxygen.namespaceboost_1_1xpressive_1a3359fafa9e5c7964a0bd5364de930e9c">str()</link>)). Otherwise if no further matches were found, then let last_end be the endpoint of the last match that was found. Then if last_end != end and subs[0] == -1 sets N equal to -1 and sets result equal to <link linkend="doxygen.structboost_1_1xpressive_1_1regex__token__iterator_1a6cd787846f25749d5a527b7141ec93dd">value_type(last_end, end)</link>. Otherwise sets *this equal to the end of sequence iterator. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1regex__token__iterator_1a109eb2116bfa78690f5b8e44c5a54ed7" name="operator++"><type><classname>regex_token_iterator</classname>&lt; BidiIter &gt;</type><parameter name=""><paramtype>int</paramtype></parameter></method>
</method-group>
<method-group name="private member functions">
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1regex__traits" name="regex_traits"><template>
      <template-type-parameter name="Char"/>
      <template-type-parameter name="Impl"/>
    </template><inherit access="public">Impl</inherit><description><para>Thin wrapper around the default <link linkend="doxygen.structboost_1_1xpressive_1_1regex__traits">regex_traits</link> implementation, either <link linkend="doxygen.structboost_1_1xpressive_1_1cpp__regex__traits">cpp_regex_traits</link> or <link linkend="doxygen.structboost_1_1xpressive_1_1c__regex__traits">c_regex_traits</link> </para></description><method-group name="public member functions">
<constructor id="doxygen.structboost_1_1xpressive_1_1regex__traits_1a2cebecd53a67accd62e94d177f1bd2c3"/>
<constructor id="doxygen.structboost_1_1xpressive_1_1regex__traits_1a88a6f76394bedeec2a7bd7d87d74b814" specifiers="explicit"><parameter name="loc"><paramtype>locale_type const &amp;</paramtype></parameter></constructor>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1sub__match" name="sub_match"><template>
      <template-type-parameter name="BidiIter"/>
    </template><inherit access="public">std::pair&lt; BidiIter, BidiIter &gt;</inherit><purpose>Class template <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link></computeroutput> denotes the sequence of characters matched by a particular marked sub-expression. </purpose><description><para>When the marked sub-expression denoted by an object of type <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link>&lt;&gt;</computeroutput> participated in a regular expression match then member <computeroutput>matched</computeroutput> evaluates to <computeroutput>true</computeroutput>, and members <computeroutput>first</computeroutput> and <computeroutput>second</computeroutput> denote the range of characters <computeroutput>[first,second)</computeroutput> which formed that match. Otherwise <computeroutput>matched</computeroutput> is <computeroutput>false</computeroutput>, and members <computeroutput>first</computeroutput> and <computeroutput>second</computeroutput> contained undefined values.</para><para>If an object of type <computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1sub__match">sub_match</link>&lt;&gt;</computeroutput> represents sub-expression 0 - that is to say the whole match - then member <computeroutput>matched</computeroutput> is always <computeroutput>true</computeroutput>, unless a partial match was obtained as a result of the flag <computeroutput>match_partial</computeroutput> being passed to a regular expression algorithm, in which case member <computeroutput>matched</computeroutput> is <computeroutput>false</computeroutput>, and members <computeroutput>first</computeroutput> and <computeroutput>second</computeroutput> represent the character range that formed the partial match. </para></description><method-group name="public member functions">
<constructor id="doxygen.structboost_1_1xpressive_1_1sub__match_1afa34b7467bb4b09c45007154586ea6ac"/>
<constructor id="doxygen.structboost_1_1xpressive_1_1sub__match_1a49e79d2b9ec3950a6f67530881810cbb"><parameter name="first"><paramtype>BidiIter</paramtype></parameter><parameter name="second"><paramtype>BidiIter</paramtype></parameter><parameter name="matched_"><paramtype>bool</paramtype><default>false</default></parameter></constructor>
<method id="doxygen.structboost_1_1xpressive_1_1sub__match_1a4e6ba2dafe6b5d04fea24e07882c7884" name="str" cv="const"><type>string_type</type></method>
<method id="doxygen.structboost_1_1xpressive_1_1sub__match_1a69dd4c91ebd6125b13e56ce3e73d5744" name="conversion-operator" cv="const"><type>string_type</type></method>
<method id="doxygen.structboost_1_1xpressive_1_1sub__match_1ac906824245509413049ff3b29471ca01" name="length" cv="const"><type>difference_type</type></method>
<method id="doxygen.structboost_1_1xpressive_1_1sub__match_1abed8216fc4b3186d9867d2a2d5b9ffbf" name="conversion-operator" cv="const"><type>bool_type</type></method>
<method id="doxygen.structboost_1_1xpressive_1_1sub__match_1a68d2522efad30660bb58370999a7b6ed" name="operator!" cv="const"><type>bool</type></method>
<method id="doxygen.structboost_1_1xpressive_1_1sub__match_1aed245dfde2b295b56fd188e3994bb2e4" name="compare" cv="const"><type>int</type><parameter name="str"><paramtype>string_type const &amp;</paramtype><description><para>the string against which to compare </para></description></parameter><purpose>Performs a lexicographic string comparison. </purpose><description><para>

</para></description><returns><para>the results of <computeroutput>(*this).<link linkend="doxygen.structboost_1_1xpressive_1_1sub__match_1a4e6ba2dafe6b5d04fea24e07882c7884">str()</link>.compare(str)</computeroutput> </para>
</returns></method>
<method id="doxygen.structboost_1_1xpressive_1_1sub__match_1aa5de39b7fb64f432bd55a06ae0ad421e" name="compare" cv="const"><type>int</type><parameter name="sub"><paramtype><classname>sub_match</classname> const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method id="doxygen.structboost_1_1xpressive_1_1sub__match_1a5c613eb25f4c641f4912be697591b6ad" name="compare" cv="const"><type>int</type><parameter name="ptr"><paramtype>value_type const *</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1value" name="value"><template>
      <template-type-parameter name="T"><purpose><para>The type of the value to store.</para></purpose></template-type-parameter>
    </template><inherit access="public">proto::extends&lt; proto::terminal&lt; T &gt;::type, value&lt; T &gt; &gt;</inherit><purpose><computeroutput>value&lt;&gt;</computeroutput> is a lazy wrapper for a value that can be used in xpressive semantic actions. </purpose><description><para>
Below is an example that shows where <computeroutput><computeroutput>value&lt;&gt;</computeroutput></computeroutput> is useful. <programlisting language="c++"><link linkend="doxygen.namespaceboost_1_1xpressive_1ad82b5700d5ba5eb195cfce6d4007f0b4">sregex</link> good_voodoo(boost::shared_ptr&lt;int&gt; pi)
{
    using namespace <link linkend="doxygen.namespaceboost_1_1xpressive">boost::xpressive</link>;
    // Use val() to hold the shared_ptr by value:
    <link linkend="doxygen.structboost_1_1xpressive_1_1basic__regex">sregex</link> rex = +( <link linkend="doxygen.namespaceboost_1_1xpressive_1afae3ed7c3a8ebd3c2f06a943ff974a58">_d</link> [ ++*<link linkend="doxygen.namespaceboost_1_1xpressive_1ab72f70c0cda654c76f868d568b2f68d0">val</link>(pi) ] &gt;&gt; '!' );
    // OK, rex holds a reference count to the integer.
    return rex;
}
</programlisting> In the above code, <computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1ab72f70c0cda654c76f868d568b2f68d0">xpressive::val()</link></computeroutput> is a function that returns a <computeroutput>value&lt;&gt;</computeroutput> object. Had <computeroutput><link linkend="doxygen.namespaceboost_1_1xpressive_1ab72f70c0cda654c76f868d568b2f68d0">val()</link></computeroutput> not been used here, the operation <computeroutput>++*pi</computeroutput> would have been evaluated eagerly once, instead of lazily when the regex match happens. </para></description><method-group name="public member functions">
<constructor id="doxygen.structboost_1_1xpressive_1_1value_1a2e7e2f986e9c3117f4dc81b7878f659a"><purpose>Store a default-constructed <computeroutput>T</computeroutput>. </purpose></constructor>
<constructor id="doxygen.structboost_1_1xpressive_1_1value_1af351663de346b545981a2f589bb7d89b" specifiers="explicit"><parameter name="t"><paramtype>T const &amp;</paramtype><description><para>The initial value. </para></description></parameter><purpose>Store a copy of <computeroutput>t</computeroutput>. </purpose><description><para>
</para></description></constructor>
<method id="doxygen.structboost_1_1xpressive_1_1value_1a30fbd9aba644afbf77ac1de2445a04c4" name="get"><type>T &amp;</type><purpose>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </purpose></method>
<method id="doxygen.structboost_1_1xpressive_1_1value_1a82ecd83a7dd3941faa450109ebe2a566" name="get" cv="const"><type>T const &amp;</type><purpose>Fetch the stored value. </purpose></method>
</method-group>
</struct><namespace name="op">
<struct id="doxygen.structboost_1_1xpressive_1_1op_1_1as" name="as"><template>
      <template-type-parameter name="T"><purpose><para>The type to which to lexically cast the parameter. </para></purpose></template-type-parameter>
    </template><purpose><computeroutput>as&lt;&gt;</computeroutput> is a PolymorphicFunctionObject for lexically casting a parameter to a different type. </purpose><description><para>
</para></description><method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1as_1ae25f61ab35d91be2701285645d459f54" name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="Value"/>
        </template><parameter name="val"><paramtype>Value const &amp;</paramtype><description><para>The value to lexically cast. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>boost::lexical_cast&lt;T&gt;(val)</computeroutput> </para>
</returns></method>
</method-group>
<method-group name="private member functions">
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1const__cast__" name="const_cast_"><template>
      <template-type-parameter name="T"><purpose><para>The type to which to const-cast the parameter. </para></purpose></template-type-parameter>
    </template><purpose><computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1op_1_1const__cast__">const_cast_</link>&lt;&gt;</computeroutput> is a PolymorphicFunctionObject for const-casting a parameter to a cv qualification. </purpose><description><para>
</para></description><method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1const__cast___1a2dca4614fa21b19bda008429ed7476b6" name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="Value"/>
        </template><parameter name="val"><paramtype>Value const &amp;</paramtype><description><para>The value to const-cast. </para></description></parameter><description><para>


</para></description><requires><para>Types <computeroutput>T</computeroutput> and <computeroutput>Value</computeroutput> differ only in cv-qualification. </para>
</requires><returns><para><computeroutput>const_cast&lt;T&gt;(val)</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1construct" name="construct"><template>
      <template-type-parameter name="T"><purpose><para>The type of the object to construct. </para></purpose></template-type-parameter>
    </template><purpose><computeroutput>construct&lt;&gt;</computeroutput> is a PolymorphicFunctionObject for constructing a new object. </purpose><description><para>
</para></description><method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1construct_1a8ce1cc37cbe589f20c75d935c29e6ad0" name="operator()" cv="const"><type>T</type><purpose>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </purpose></method>
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1construct_1abf7d86a828ae0355eb87ea0c4ace4c4b" name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><purpose>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </purpose></method>
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1construct_1a388c7e8cf410aa26e390b46814739e13" name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><purpose>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </purpose></method>
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1construct_1af18d265f509b53e19703e09d146f3dfb" name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype><description><para>The first argument to the constructor </para></description></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype><description><para>The second argument to the constructor </para></description></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype><description><para>The third argument to the constructor </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>T(a0,a1,...)</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1dynamic__cast__" name="dynamic_cast_"><template>
      <template-type-parameter name="T"><purpose><para>The type to which to dynamically cast the parameter. </para></purpose></template-type-parameter>
    </template><purpose><computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1op_1_1dynamic__cast__">dynamic_cast_</link>&lt;&gt;</computeroutput> is a PolymorphicFunctionObject for dynamically casting a parameter to a different type. </purpose><description><para>
</para></description><method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1dynamic__cast___1a1dfbe5098505f6dfb67dbdcec8042026" name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="Value"/>
        </template><parameter name="val"><paramtype>Value const &amp;</paramtype><description><para>The value to dynamically cast. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>dynamic_cast&lt;T&gt;(val)</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1static__cast__" name="static_cast_"><template>
      <template-type-parameter name="T"><purpose><para>The type to which to statically cast the parameter. </para></purpose></template-type-parameter>
    </template><purpose><computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1op_1_1static__cast__">static_cast_</link>&lt;&gt;</computeroutput> is a PolymorphicFunctionObject for statically casting a parameter to a different type. </purpose><description><para>
</para></description><method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1static__cast___1a0b08812eb56cd8591ae8aab1a886f940" name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="Value"/>
        </template><parameter name="val"><paramtype>Value const &amp;</paramtype><description><para>The value to statically cast. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>static_cast&lt;T&gt;(val)</computeroutput> </para>
</returns></method>
</method-group>
</struct><struct id="doxygen.structboost_1_1xpressive_1_1op_1_1throw__" name="throw_"><template>
      <template-type-parameter name="Except"><purpose><para>The type of the object to throw. </para></purpose></template-type-parameter>
    </template><purpose><computeroutput><link linkend="doxygen.structboost_1_1xpressive_1_1op_1_1throw__">throw_</link>&lt;&gt;</computeroutput> is a PolymorphicFunctionObject for throwing an exception. </purpose><description><para>
</para></description><method-group name="public member functions">
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1throw___1a3869d3c58811d0245ed69c8f0f7b754e" name="operator()" cv="const"><type>void</type><purpose>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </purpose></method>
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1throw___1a5e2adb390e99e02bc3397b5dc5decc30" name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><purpose>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </purpose></method>
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1throw___1a4844ea8cc536b3e13988b4347a7de99d" name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><purpose>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </purpose></method>
<method id="doxygen.structboost_1_1xpressive_1_1op_1_1throw___1adf503ae7302451af5cc7e43a104f0917" name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype><description><para>The first argument to the constructor </para></description></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype><description><para>The second argument to the constructor </para></description></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype><description><para>The third argument to the constructor </para></description></parameter><description><para>

<note><para>This function makes use of the <computeroutput>BOOST_THROW_EXCEPTION</computeroutput> macro to actually throw the exception. See the documentation for the Boost.Exception library. </para>
</note>
</para></description><throws><simpara><classname>&lt;tt&gt;Except(a0</classname> </simpara>
</throws></method>
</method-group>
</struct></namespace>
<typedef id="doxygen.namespaceboost_1_1xpressive_1ad70d9745380d59555ee65223a74ed6bd" name="regex_id_type"><type>void const *</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1ad82b5700d5ba5eb195cfce6d4007f0b4" name="sregex"><type><classname>basic_regex</classname>&lt; std::string::const_iterator &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1a6e069dd8a54947521ae94fb4341106d3" name="cregex"><type><classname>basic_regex</classname>&lt; char const * &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1ac375acc05e4039234a8b5c2c06aba4db" name="wsregex"><type><classname>basic_regex</classname>&lt; std::wstring::const_iterator &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1a0bfc90ecdbb5de147c8626e7986c0448" name="wcregex"><type><classname>basic_regex</classname>&lt; wchar_t const * &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1a9f21f29ad94ab7f94148feaa463b8760" name="ssub_match"><type><classname>sub_match</classname>&lt; std::string::const_iterator &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1abd14d4663dbb4918cb2970079dc6bba1" name="csub_match"><type><classname>sub_match</classname>&lt; char const * &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1a74bd99d0d475ab6cab63fd0db8717062" name="wssub_match"><type><classname>sub_match</classname>&lt; std::wstring::const_iterator &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1a38152b23d73fe5e5795358366ac04cef" name="wcsub_match"><type><classname>sub_match</classname>&lt; wchar_t const * &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1acc1c21eb86819cac87c285ac4ed0c8be" name="sregex_compiler"><type><classname>regex_compiler</classname>&lt; std::string::const_iterator &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1ad268b8fe8ff5ea7133da055022d2b6d6" name="cregex_compiler"><type><classname>regex_compiler</classname>&lt; char const * &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1aaf0addbdabd6883a14445d645141495e" name="wsregex_compiler"><type><classname>regex_compiler</classname>&lt; std::wstring::const_iterator &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1ab88d61bd9f9356aa5f6205a5ee617a5b" name="wcregex_compiler"><type><classname>regex_compiler</classname>&lt; wchar_t const * &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1a95a0202d1817ffce726d567996f3adf0" name="sregex_iterator"><type><classname>regex_iterator</classname>&lt; std::string::const_iterator &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1adb7d2b39002ce4cbef355aa1f9814a03" name="cregex_iterator"><type><classname>regex_iterator</classname>&lt; char const * &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1a9f5657febfa6d36e74983476ec878ad1" name="wsregex_iterator"><type><classname>regex_iterator</classname>&lt; std::wstring::const_iterator &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1a38673b010523957c8496b756e47e24f5" name="wcregex_iterator"><type><classname>regex_iterator</classname>&lt; wchar_t const * &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1ae97ad076135f923068577dd7d0b5c8ad" name="sregex_token_iterator"><type><classname>regex_token_iterator</classname>&lt; std::string::const_iterator &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1a7277d007112944c003fd46ad605cde3b" name="cregex_token_iterator"><type><classname>regex_token_iterator</classname>&lt; char const * &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1a1a2f0158c189361ffe1cda2bcf43af78" name="wsregex_token_iterator"><type><classname>regex_token_iterator</classname>&lt; std::wstring::const_iterator &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1ab1b87db74e845cc91634fb605f076ef8" name="wcregex_token_iterator"><type><classname>regex_token_iterator</classname>&lt; wchar_t const * &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1a9abbae50995ee1162f681ed99477c0ed" name="smatch"><type><classname>match_results</classname>&lt; std::string::const_iterator &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1a19ad29ae13b4cb531f613c136ae81c5b" name="cmatch"><type><classname>match_results</classname>&lt; char const * &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1ac6195019b6927aaa4499e752b81b5343" name="wsmatch"><type><classname>match_results</classname>&lt; std::wstring::const_iterator &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1aacdec563a4ab924c909f19ca50bd6107" name="wcmatch"><type><classname>match_results</classname>&lt; wchar_t const * &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1adb3331c9d48674dd40ea8aef74ccd8c9" name="sregex_id_filter_predicate"><type><classname>regex_id_filter_predicate</classname>&lt; std::string::const_iterator &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1a7ec6296db1612746708991ae120b0d67" name="cregex_id_filter_predicate"><type><classname>regex_id_filter_predicate</classname>&lt; char const * &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1abe61d7dd6f09a7c02e9c90985c7ce5bc" name="wsregex_id_filter_predicate"><type><classname>regex_id_filter_predicate</classname>&lt; std::wstring::const_iterator &gt;</type></typedef>
<typedef id="doxygen.namespaceboost_1_1xpressive_1a42ce9be7d4f2cd7408877d5c3469b3ce" name="wcregex_id_filter_predicate"><type><classname>regex_id_filter_predicate</classname>&lt; wchar_t const * &gt;</type></typedef>

























































































</namespace>
</namespace>
<macro id="doxygen.xpressive__fwd_8hpp_1aa63c79ca59f5c5d5cac28aabee9880c6" name="BOOST_XPRESSIVE_HAS_MS_STACK_GUARD"/>
</header>
<header id="doxygen.xpressive__static_8hpp" name="boost/xpressive/xpressive_static.hpp">
<para>Includes everything you need to write static regular expressions and use them. </para></header>
<header id="doxygen.xpressive__typeof_8hpp" name="boost/xpressive/xpressive_typeof.hpp">
<para>Type registrations so that xpressive can be used with the Boost.Typeof library. </para></header>
</library-reference>