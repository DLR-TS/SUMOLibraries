<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Implementation Rationale :: Boost.Unordered</title>
    <meta name="generator" content="Antora 3.1.10">
    <link rel="stylesheet" href="../unordered/_/css/site.css">
  </head>
  <body class="article">
<div class="body">
<div class="nav-container" data-component="unordered" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="intro.html">Boost.Unordered</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="intro.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="buckets.html">Basics of Hash Tables</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="hash_equality.html">Equality Predicates and Hash Functions</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="regular.html">Regular Containers</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="concurrent.html">Concurrent Containers</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="hash_quality.html">Hash Quality</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="compliance.html">Standard Compliance</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="structures.html">Data Structures</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="debuggability.html">Debuggability</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="benchmarks.html">Benchmarks</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="rationale.html">Implementation Rationale</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="ref.html">Reference</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_map_fwd.html"><code>&lt;boost/unordered/unordered_map_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_map_top.html"><code>&lt;boost/unordered_map.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_map.html"><code>&lt;boost/unordered/unordered_map.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/unordered_map.html"><code>unordered_map</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/unordered_multimap.html"><code>unordered_multimap</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_set_fwd.html"><code>&lt;boost/unordered/unordered_set_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_set_top.html"><code>&lt;boost/unordered_set.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_set.html"><code>&lt;boost/unordered/unordered_set.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/unordered_set.html"><code>unordered_set</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/unordered_multiset.html"><code>unordered_multiset</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/hash_traits.html">Hash Traits</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/stats.html">Statistics</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_flat_map_fwd.html"><code>&lt;boost/unordered/unordered_flat_map_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_flat_map.html"><code>&lt;boost/unordered/unordered_flat_map.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/unordered_flat_map.html"><code>unordered_flat_map</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_flat_set_fwd.html"><code>&lt;boost/unordered/unordered_flat_set_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_flat_set.html"><code>&lt;boost/unordered/unordered_flat_set.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/unordered_flat_set.html"><code>unordered_flat_set</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_node_map_fwd.html"><code>&lt;boost/unordered/unordered_node_map_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_node_map.html"><code>&lt;boost/unordered/unordered_node_map.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/unordered_node_map.html"><code>unordered_node_map</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_node_set_fwd.html"><code>&lt;boost/unordered/unordered_node_set_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_unordered_node_set.html"><code>&lt;boost/unordered/unordered_node_set.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/unordered_node_set.html"><code>unordered_node_set</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_concurrent_flat_map_fwd.html"><code>&lt;boost/unordered/concurrent_flat_map_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_concurrent_flat_map.html"><code>&lt;boost/unordered/concurrent_flat_map.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/concurrent_flat_map.html"><code>concurrent_flat_map</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_concurrent_flat_set_fwd.html"><code>&lt;boost/unordered/concurrent_flat_set_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_concurrent_flat_set.html"><code>&lt;boost/unordered/concurrent_flat_set.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/concurrent_flat_set.html"><code>concurrent_flat_set</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_concurrent_node_map_fwd.html"><code>&lt;boost/unordered/concurrent_node_map_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_concurrent_node_map.html"><code>&lt;boost/unordered/concurrent_node_map.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/concurrent_node_map.html"><code>concurrent_node_map</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_concurrent_node_set_fwd.html"><code>&lt;boost/unordered/concurrent_node_set_fwd.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/header_concurrent_node_set.html"><code>&lt;boost/unordered/concurrent_node_set.hpp&gt;</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="reference/concurrent_node_set.html"><code>concurrent_node_set</code></a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="changes.html">Change Log</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="bibliography.html">Bibliography</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="copyright.html">Copyright and License</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="intro.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="intro.html">Boost.Unordered</a></li>
    <li><a href="rationale.html">Implementation Rationale</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Implementation Rationale</h1>
<div class="sect1">
<h2 id="rationale_closed_addressing_containers"><a class="anchor" href="#rationale_closed_addressing_containers"></a>Closed-addressing Containers</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>boost::unordered_[multi]set</code> and <code>boost::unordered_[multi]map</code>
adhere to the standard requirements for unordered associative
containers, so the interface was fixed. But there are
still some implementation decisions to make. The priorities are
conformance to the standard and portability.</p>
</div>
<div class="paragraph">
<p>The <a href="http://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">Wikipedia article on hash tables</a>
has a good summary of the implementation issues for hash tables in general.</p>
</div>
<div class="sect2">
<h3 id="rationale_data_structure"><a class="anchor" href="#rationale_data_structure"></a>Data Structure</h3>
<div class="paragraph">
<p>By specifying an interface for accessing the buckets of the container the
standard pretty much requires that the hash table uses closed addressing.</p>
</div>
<div class="paragraph">
<p>It would be conceivable to write a hash table that uses another method. For
example, it could use open addressing, and use the lookup chain to act as a
bucket but there are some serious problems with this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The standard requires that pointers to elements aren&#8217;t invalidated, so
the elements can&#8217;t be stored in one array, but will need a layer of
indirection instead - losing the efficiency and most of the memory gain,
the main advantages of open addressing.</p>
</li>
<li>
<p>Local iterators would be very inefficient and may not be able to
meet the complexity requirements.</p>
</li>
<li>
<p>There are also the restrictions on when iterators can be invalidated. Since
open addressing degrades badly when there are a high number of collisions the
restrictions could prevent a rehash when it&#8217;s really needed. The maximum load
factor could be set to a fairly low value to work around this - but the
standard requires that it is initially set to 1.0.</p>
</li>
<li>
<p>And since the standard is written with a eye towards closed
addressing, users will be surprised if the performance doesn&#8217;t reflect that.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So closed addressing is used.</p>
</div>
</div>
<div class="sect2">
<h3 id="rationale_number_of_buckets"><a class="anchor" href="#rationale_number_of_buckets"></a>Number of Buckets</h3>
<div class="paragraph">
<p>There are two popular methods for choosing the number of buckets in a hash
table. One is to have a prime number of buckets, another is to use a power
of 2.</p>
</div>
<div class="paragraph">
<p>Using a prime number of buckets, and choosing a bucket by using the modulus
of the hash function&#8217;s result will usually give a good result. The downside
is that the required modulus operation is fairly expensive. This is what the
containers used to do in most cases.</p>
</div>
<div class="paragraph">
<p>Using a power of 2 allows for much quicker selection of the bucket to use,
but at the expense of losing the upper bits of the hash value. For some
specially designed hash functions it is possible to do this and still get a
good result but as the containers can take arbitrary hash functions this can&#8217;t
be relied on.</p>
</div>
<div class="paragraph">
<p>To avoid this a transformation could be applied to the hash function, for an
example see
<a href="http://web.archive.org/web/20121102023700/http://www.concentric.net/~Ttwang/tech/inthash.htm" target="_blank" rel="noopener">Thomas Wang&#8217;s article on integer hash functions</a>.
Unfortunately, a transformation like Wang&#8217;s requires knowledge of the number
of bits in the hash value, so it was only used when <code>size_t</code> was 64 bit.</p>
</div>
<div class="paragraph">
<p>Since release 1.79.0, <a href="https://en.wikipedia.org/wiki/Hash_function#Fibonacci_hashing">Fibonacci hashing</a>
is used instead. With this implementation, the bucket number is determined
by using <code>(h * m) &gt;&gt; (w - k)</code>, where <code>h</code> is the hash value, <code>m</code> is <code>2^w</code> divided
by the golden ratio, <code>w</code> is the word size (32 or 64), and <code>2^k</code> is the
number of buckets. This provides a good compromise between speed and
distribution.</p>
</div>
<div class="paragraph">
<p>Since release 1.80.0, prime numbers are chosen for the number of buckets in
tandem with sophisticated modulo arithmetic. This removes the need for "mixing"
the result of the user&#8217;s hash function as was used for release 1.79.0.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rationale_open_addresing_containers"><a class="anchor" href="#rationale_open_addresing_containers"></a>Open-addresing Containers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The C++ standard specification of unordered associative containers impose
severe limitations on permissible implementations, the most important being
that closed addressing is implicitly assumed. Slightly relaxing this specification
opens up the possibility of providing container variations taking full
advantage of open-addressing techniques.</p>
</div>
<div class="paragraph">
<p>The design of <code>boost::unordered_flat_set</code>/<code>unordered_node_set</code> and <code>boost::unordered_flat_map</code>/<code>unordered_node_map</code> has been
guided by Peter Dimov&#8217;s <a href="https://pdimov.github.io/articles/unordered_dev_plan.html" target="_blank" rel="noopener">Development Plan for Boost.Unordered</a>.
We discuss here the most relevant principles.</p>
</div>
<div class="sect2">
<h3 id="rationale_hash_function"><a class="anchor" href="#rationale_hash_function"></a>Hash Function</h3>
<div class="paragraph">
<p>Given its rich functionality and cross-platform interoperability,
<code>boost::hash</code> remains the default hash function of open-addressing containers.
As it happens, <code>boost::hash</code> for integral and other basic types does not possess
the statistical properties required by open addressing; to cope with this,
we implement a post-mixing stage:</p>
</div>
<div class="paragraph">
<p>&#160;&#160;&#160;&#160; <em>a</em> &#8592; <em>h</em> <strong>mulx</strong> <em>C</em>,<br>
&#160;&#160;&#160;&#160; <em>h</em> &#8592; <strong>high</strong>(<em>a</em>) <strong>xor</strong> <strong>low</strong>(<em>a</em>),</p>
</div>
<div class="paragraph">
<p>where <strong>mulx</strong> is an <em>extended multiplication</em> (128 bits in 64-bit architectures, 64 bits in 32-bit environments),
and <strong>high</strong> and <strong>low</strong> are the upper and lower halves of an extended word, respectively.
In 64-bit architectures, <em>C</em> is the integer part of 2<sup>64</sup>&#8725;<a href="https://en.wikipedia.org/wiki/Golden_ratio"><em>&phi;</em></a>,
whereas in 32 bits <em>C</em> = 0xE817FB2Du has been obtained from <a href="https://arxiv.org/abs/2001.05304" target="_blank" rel="noopener">Steele and Vigna (2021)</a>.</p>
</div>
<div class="paragraph">
<p>When using a hash function directly suitable for open addressing, post-mixing can be opted out of via a dedicated <code><a href="reference/hash_traits.html#hash_traits_hash_is_avalanching" class="xref page">hash_is_avalanching</a></code> trait.
<code>boost::hash</code> specializations for string types are marked as avalanching.</p>
</div>
</div>
<div class="sect2">
<h3 id="rationale_platform_interoperability"><a class="anchor" href="#rationale_platform_interoperability"></a>Platform Interoperability</h3>
<div class="paragraph">
<p>The observable behavior of <code>boost::unordered_flat_set</code>/<code>unordered_node_set</code> and <code>boost::unordered_flat_map</code>/<code>unordered_node_map</code> is deterministically
identical across different compilers as long as their <code>std::size_t</code>s are the same size and the user-provided
hash function and equality predicate are also interoperable
&#8212;this includes elements being ordered in exactly the same way for the same sequence of
operations.</p>
</div>
<div class="paragraph">
<p>Although the implementation internally uses SIMD technologies, such as <a href="https://en.wikipedia.org/wiki/SSE2" target="_blank" rel="noopener">SSE2</a>
and <a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Advanced_SIMD_(NEON)" target="_blank" rel="noopener">Neon</a>, when available,
this does not affect interoperatility. For instance, the behavior is the same
for Visual Studio on an x64-mode Intel CPU with SSE2 and for GCC on an IBM s390x without any supported SIMD technology.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rationale_concurrent_containers"><a class="anchor" href="#rationale_concurrent_containers"></a>Concurrent Containers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The same data structure used by Boost.Unordered open-addressing containers has been chosen
also as the foundation of <code>boost::concurrent_flat_set</code>/<code>boost::concurrent_node_set</code> and
<code>boost::concurrent_flat_map</code>/<code>boost::concurrent_node_map</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Open-addressing is faster than closed-addressing alternatives, both in non-concurrent and
concurrent scenarios.</p>
</li>
<li>
<p>Open-addressing layouts are eminently suitable for concurrent access and modification
with minimal locking. In particular, the metadata array can be used for implementations of
lookup that are lock-free up to the last step of actual element comparison.</p>
</li>
<li>
<p>Layout compatibility with Boost.Unordered flat containers allows for
<a href="concurrent.html#concurrent_interoperability_with_non_concurrent_containers" class="xref page">fast transfer</a>
of all elements between a concurrent container and its non-concurrent counterpart,
and vice versa.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="rationale_hash_function_and_platform_interoperability"><a class="anchor" href="#rationale_hash_function_and_platform_interoperability"></a>Hash Function and Platform Interoperability</h3>
<div class="paragraph">
<p>Concurrent containers make the same decisions and provide the same guarantees
as Boost.Unordered open-addressing containers with regards to
<a href="#rationale_hash_function">hash function defaults</a> and
<a href="#rationale_platform_interoperability">platform interoperability</a>.</p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../unordered/_/js/site.js" data-ui-root-path="../unordered/_"></script>
<script async src="../unordered/_/js/vendor/highlight.js"></script>
  </body>
</html>
