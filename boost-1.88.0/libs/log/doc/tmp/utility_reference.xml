<?xml version="1.0" standalone="yes"?>
<library-reference id="utilities"><title>Utilities</title><header id="doxygen.utilities.exception__handler_8hpp" name="boost/log/utility/exception_handler.hpp">
<para><para>Andrey Semashev </para>

<para>12.07.2009</para>

This header contains tools for exception handlers support in different parts of the library. </para><namespace name="boost">
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1exception__handler" name="exception_handler"><template>
      <template-type-parameter name="SequenceT"/>
      <template-type-parameter name="HandlerT"/>
    </template><inherit access="public">type</inherit><description><para>An exception handler functional object. The handler aggregates a user-defined functional object that will be called when one of the specified exception types is caught. </para></description><typedef id="doxygen.utilities.classboost_1_1log_1_1exception__handler_1a51a05a993b7db176e646180b281aaad0" name="handler_type"><purpose>The exception handler type. </purpose><type>HandlerT</type></typedef>
<typedef id="doxygen.utilities.classboost_1_1log_1_1exception__handler_1a64c66719f6f37caa0ce72b77538ec998" name="result_type"><purpose>The handler result type. </purpose><type>void</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1exception__handler_1acd81a9b2774f3edf1941158804a6c26d" specifiers="explicit"><parameter name="handler"><paramtype>handler_type const &amp;</paramtype></parameter><description><para>Initializing constructor. Creates an exception handler with the specified function object that will receive the exception. </para></description></constructor>
<method id="doxygen.utilities.classboost_1_1log_1_1exception__handler_1aacc48601e95af5d0dc277fcd4b7e059f" name="operator()" cv="const"><type>void</type><description><para>Exception launcher. Rethrows the current exception in order to detect its type and pass it to the aggregated function object.</para><para><note><para>Must be called from within a <computeroutput>catch</computeroutput> statement. </para>
</note>
</para></description></method>
</method-group>
</class><class id="doxygen.utilities.classboost_1_1log_1_1nothrow__exception__handler" name="nothrow_exception_handler"><template>
      <template-type-parameter name="SequenceT"/>
      <template-type-parameter name="HandlerT"/>
    </template><inherit access="public">boost::log::exception_handler&lt; SequenceT, HandlerT &gt;</inherit><description><para>A no-throw exception handler functional object. Acts similar to <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1exception__handler">exception_handler</link></computeroutput>, but in case if the exception cannot be handled the exception is not propagated from the handler. Instead the user-defined functional object is called with no parameters. </para></description><typedef id="doxygen.utilities.classboost_1_1log_1_1nothrow__exception__handler_1a51a05a993b7db176e646180b281aaad0" name="handler_type"><purpose>The exception handler type. </purpose><type>HandlerT</type></typedef>
<typedef id="doxygen.utilities.classboost_1_1log_1_1nothrow__exception__handler_1a64c66719f6f37caa0ce72b77538ec998" name="result_type"><purpose>The handler result type. </purpose><type>void</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1nothrow__exception__handler_1af6ba9df029e0471e5a05e02407dc2c4e" specifiers="explicit"><parameter name="handler"><paramtype>handler_type const &amp;</paramtype></parameter><description><para>Initializing constructor. Creates an exception handler with the specified function object that will receive the exception. </para></description></constructor>
<method id="doxygen.utilities.classboost_1_1log_1_1nothrow__exception__handler_1aacc48601e95af5d0dc277fcd4b7e059f" name="operator()" cv="const"><type>void</type><description><para>Exception launcher. Rethrows the current exception in order to detect its type and pass it to the aggregated function object. If the type of the exception could not be detected, the user-defined handler is called with no arguments.</para><para><note><para>Must be called from within a <computeroutput>catch</computeroutput> statement. </para>
</note>
</para></description></method>
</method-group>
</class>































<function id="doxygen.utilities.exception__handler_8hpp_1a9b532822f3addbdfeefd22fed7abe122" name="make_exception_suppressor"><type><classname>nop</classname></type><description><para>The function creates an empty exception handler that effectively suppresses any exception </para></description></function>
<function id="doxygen.utilities.exception__handler_8hpp_1a0a4a72ade16e555a04d3b168618adceb" name="make_exception_handler"><type><classname>exception_handler</classname>&lt; typename HandlerT::exception_types, HandlerT &gt;</type><template>
          <template-type-parameter name="HandlerT"/>
        </template><parameter name="handler"><paramtype>HandlerT const &amp;</paramtype><description><para>User-defined functional object that will receive exceptions. </para></description></parameter><description><para>The function creates an exception handler functional object. The handler will call to the user-specified functional object with an exception as its argument.</para><para>

<note><para>This form requires the user-defined functional object to have an <computeroutput>exception_types</computeroutput> nested type. This type should be an MPL sequence of all expected exception types. </para>
</note>
</para></description><returns><para>A nullary functional object that should be called from within a <computeroutput>catch</computeroutput> statement.</para>
</returns></function>
<function id="doxygen.utilities.exception__handler_8hpp_1aedc26ba50ed064fcdf2869d8b0cb4da6" name="make_exception_handler"><type><classname>nothrow_exception_handler</classname>&lt; typename HandlerT::exception_types, HandlerT &gt;</type><template>
          <template-type-parameter name="HandlerT"/>
        </template><parameter name="handler"><paramtype>HandlerT const &amp;</paramtype><description><para>User-defined functional object that will receive exceptions. </para></description></parameter><parameter name=""><paramtype>std::nothrow_t const &amp;</paramtype></parameter><description><para>The function creates an exception handler functional object. The handler will call to the user-specified functional object with an exception as its argument. If the exception type cannot be identified, the handler will call the user-defined functor with no arguments, instead of propagating exception to the caller.</para><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</para><para>

<note><para>This form requires the user-defined functional object to have an <computeroutput>exception_types</computeroutput> nested type. This type should be an MPL sequence of all expected exception types. </para>
</note>
</para></description><returns><para>A nullary functional object that should be called from within a <computeroutput>catch</computeroutput> statement.</para>
</returns></function>
<function id="doxygen.utilities.exception__handler_8hpp_1adcf097a07085f66941bff90adfa4eafe" name="make_exception_handler"><type><classname>exception_handler</classname>&lt; MPL_sequence_of_ExceptionsT, HandlerT &gt;</type><template>
          <template-nontype-parameter name="ExceptionsT"><type>typename...</type></template-nontype-parameter>
          <template-type-parameter name="HandlerT"/>
        </template><parameter name="handler"><paramtype>HandlerT const &amp;</paramtype><description><para>User-defined functional object that will receive exceptions. </para></description></parameter><description><para>The function creates an exception handler functional object. The handler will call to the user-specified functional object with an exception as its argument. All expected exception types should be specified as first template parameters explicitly, in the order they would be specified in a corresponding <computeroutput>try/catch</computeroutput> statement.</para><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</para><para>

</para></description><returns><para>A nullary functional object that should be called from within a <computeroutput>catch</computeroutput> statement. </para>
</returns></function>
<function id="doxygen.utilities.exception__handler_8hpp_1a368346209f9d20ee9c105257ace6cfea" name="make_exception_handler"><type><classname>nothrow_exception_handler</classname>&lt; MPL_sequence_of_ExceptionsT, HandlerT &gt;</type><template>
          <template-nontype-parameter name="ExceptionsT"><type>typename...</type></template-nontype-parameter>
          <template-type-parameter name="HandlerT"/>
        </template><parameter name="handler"><paramtype>HandlerT const &amp;</paramtype><description><para>User-defined functional object that will receive exceptions. </para></description></parameter><parameter name=""><paramtype>std::nothrow_t const &amp;</paramtype></parameter><description><para>The function creates an exception handler functional object. The handler will call to the user-specified functional object with an exception as its argument. If the exception type cannot be identified, the handler will call the user-defined functor with no arguments, instead of propagating exception to the caller. All expected exception types should be specified as first template parameters explicitly, in the order they would be specified in a corresponding <computeroutput>try/catch</computeroutput> statement.</para><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</para><para>

</para></description><returns><para>A nullary functional object that should be called from within a <computeroutput>catch</computeroutput> statement. </para>
</returns></function>














































































</namespace>
</namespace>
<macro id="doxygen.utilities.exception__handler_8hpp_1adf6128012eee2a0eca1fb3a282dcbeca" name="BOOST_LOG_MAX_EXCEPTION_TYPES"><purpose>Maximum number of exception types that can be specified for exception handlers. </purpose></macro>
</header>
<header id="doxygen.utilities.formatting__ostream_8hpp" name="boost/log/utility/formatting_ostream.hpp">
<para><para>Andrey Semashev </para>

<para>11.07.2012</para>

The header contains implementation of a string stream used for log record formatting. </para><namespace name="boost">
<namespace name="log">


























<function id="doxygen.utilities.formatting__ostream_8hpp_1a0efdbef0668b8825e49520e80a0f64a9" name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="T"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter><parameter name="value"><paramtype>T</paramtype></parameter></function>
<function id="doxygen.utilities.formatting__ostream_8hpp_1a9f813fe36aa0a9f8d93a173968da65e0" name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="T"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter><parameter name="value"><paramtype>T const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.formatting__ostream_8hpp_1a3e3c81025f41751cfdadb65cf4ba0555" name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="T"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter><parameter name="value"><paramtype>T &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.formatting__ostream_8hpp_1a6b9fe0204e724169ca20634969c6c63a" name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="T"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;&amp;</paramtype></parameter><parameter name="value"><paramtype>T</paramtype></parameter></function>
<function id="doxygen.utilities.formatting__ostream_8hpp_1a681165fd3787b3ff44b1298d569637f5" name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="T"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;&amp;</paramtype></parameter><parameter name="value"><paramtype>T const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.formatting__ostream_8hpp_1aa2e332e659c51472738f4b90c9805236" name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="T"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;&amp;</paramtype></parameter><parameter name="value"><paramtype>T &amp;</paramtype></parameter></function>



















































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.formatting__ostream__fwd_8hpp" name="boost/log/utility/formatting_ostream_fwd.hpp">
<para><para>Andrey Semashev </para>

<para>11.07.2012</para>

The header contains forward declaration of a string stream used for log record formatting. </para><namespace name="boost">
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream" name="basic_formatting_ostream"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="TraitsT"/>
      <template-type-parameter name="AllocatorT"/>
    </template><purpose>Stream for log records formatting. </purpose><description><para>Stream wrapper for log records formatting.</para><para>This stream wrapper is used by the library for log record formatting. It implements the standard string stream interface with a few differences:</para><para><itemizedlist>
<listitem><para>It does not derive from standard types <computeroutput>std::basic_ostream</computeroutput>, <computeroutput>std::basic_ios</computeroutput> and <computeroutput>std::ios_base</computeroutput>, although it tries to implement their interfaces closely. There are a few small differences, mostly regarding <computeroutput>rdbuf</computeroutput> and <computeroutput>str</computeroutput> signatures, as well as the supported insertion operator overloads. The actual wrapped stream can be accessed through the <computeroutput>stream</computeroutput> methods. </para>
</listitem>
<listitem><para>By default, <computeroutput>bool</computeroutput> values are formatted using alphabetical representation rather than numeric. </para>
</listitem>
<listitem><para>The stream supports writing strings of character types different from the stream character type. The stream will perform character code conversion as needed using the imbued locale. </para>
</listitem>
<listitem><para>The stream operates on an external string object rather than on the embedded one. The string can be attached or detached from the stream dynamically.</para>
</listitem>
</itemizedlist>
Although <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream">basic_formatting_ostream</link></computeroutput> does not derive from <computeroutput>std::basic_ostream</computeroutput>, users are not required to add special overloads of <computeroutput>operator&lt;&lt;</computeroutput> for it since the stream will by default reuse the operators for <computeroutput>std::basic_ostream</computeroutput>. However, one can define special overloads of <computeroutput>operator&lt;&lt;</computeroutput> for <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream">basic_formatting_ostream</link></computeroutput> if a certain type needs special formatting when output to log. </para></description><method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1ad55b6f48e43dfb079b893f0d5b223966"><description><para>Default constructor. Creates an empty record that is equivalent to the invalid record handle. The stream capability is not available after construction.</para><para>
</para></description><postconditions><para><computeroutput>!*this == true</computeroutput> </para>
</postconditions></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1afafc9fec1fda4208758e6b23ace90b83" specifiers="explicit"><parameter name="str"><paramtype>string_type &amp;</paramtype><description><para>The string buffer to attach. </para></description></parameter><description><para>Initializing constructor. Attaches the string to the constructed stream. The string will be used to store the formatted characters.</para><para>

</para></description><postconditions><para><computeroutput>!*this == false</computeroutput> </para>
</postconditions></constructor>
<destructor id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1afb10cd3ce4ce0e87e715b8b8626e7060"><description><para>Destructor. Destroys the record, releases any sinks and attribute values that were involved in processing this record. </para></description></destructor>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1ada5264b5a6bc3450db3153c63576c355" name="attach"><type>void</type><parameter name="str"><paramtype>string_type &amp;</paramtype><description><para>The string buffer to attach. </para></description></parameter><description><para>Attaches the stream to the string. The string will be used to store the formatted characters.</para><para>
</para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1ac295bade8aee589f6718dfa79edc2a34" name="detach"><type>void</type><description><para>Detaches the stream from the string. Any buffered data is flushed to the string. </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1ad6e08df5a6ee4c0a8fc84bc52a34213a" name="str" cv="const"><type>string_type const &amp;</type><description><para>
</para></description><returns><para>Reference to the attached string. The string must be attached before calling this method. </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1ac710d248bb9a96af22d569bef3107381" name="stream"><type>ostream_type &amp;</type><description><para>
</para></description><returns><para>Reference to the wrapped stream </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a532361ce4aa1ebe20af3036db3ac024e" name="stream" cv="const"><type>ostream_type const &amp;</type><description><para>
</para></description><returns><para>Reference to the wrapped stream </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1abfb2a3f6cd6016e227b82f5f663149f4" name="flags" cv="const"><type>fmtflags</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a5d91a0b09cdf078ba4b19b8139be31eb" name="flags"><type>fmtflags</type><parameter name="f"><paramtype>fmtflags</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a41ae8d6435e52641461c5b0b2fb2ba52" name="setf"><type>fmtflags</type><parameter name="f"><paramtype>fmtflags</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1ab9c47819c305a5ad147c898acf33fc4b" name="setf"><type>fmtflags</type><parameter name="f"><paramtype>fmtflags</paramtype></parameter><parameter name="mask"><paramtype>fmtflags</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1ab7d91bee03537a103fc141ce0426c505" name="unsetf"><type>void</type><parameter name="f"><paramtype>fmtflags</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a4fee6d4ecefecd0ef91d39b48c649b72" name="precision" cv="const"><type>std::streamsize</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1ad56b3a052bf7ef22644831377940e1f2" name="precision"><type>std::streamsize</type><parameter name="p"><paramtype>std::streamsize</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1ab094c545519888d6066125b5eb4de501" name="width" cv="const"><type>std::streamsize</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1af19945de5daa7ac17528f6e44a0c830b" name="width"><type>std::streamsize</type><parameter name="w"><paramtype>std::streamsize</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1af7e628427bf12626b97f1eec12b2250d" name="getloc" cv="const"><type>std::locale</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a382d4fe97c47d1e6325bbe0242e55cba" name="imbue"><type>std::locale</type><parameter name="loc"><paramtype>std::locale const &amp;</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a445dbeacc64a824503b1fba939824071" name="iword"><type>long &amp;</type><parameter name="index"><paramtype>int</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a67a296d6cdfed70351cd376643a41a15" name="pword"><type>void *&amp;</type><parameter name="index"><paramtype>int</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1afd3bee73b4afb16b8f33bf3a70e52f6a" name="register_callback"><type>void</type><parameter name="fn"><paramtype>event_callback</paramtype></parameter><parameter name="index"><paramtype>int</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a67b76affb3b5d35fa419ac234144038b" name="conversion-operator" cv="const" specifiers="explicit"><type>bool</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a61efd4196a96540ee018fee8791f3f10" name="operator!" cv="const"><type>bool</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a7aca40645ed0e93b7e33b9bc2b4ef7e9" name="rdstate" cv="const"><type>iostate</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a1978eec476ebfeed466b5ce921853720" name="clear"><type>void</type><parameter name="state"><paramtype>iostate</paramtype><default>goodbit</default></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1ae3c59834ea2d5cfd6945e77eac466b16" name="setstate"><type>void</type><parameter name="state"><paramtype>iostate</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1abdcc7f96f487faadc7769afcf58fe992" name="good" cv="const"><type>bool</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1af3418ac60d0d7a303478f29a387feb3c" name="eof" cv="const"><type>bool</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a48de1a2345c4519dd5d19c67dcce62ed" name="fail" cv="const"><type>bool</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a9f7290a5d70f30e1b1b42c8ac4a6082d" name="bad" cv="const"><type>bool</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1ade315aaeca7389586b5e3a4b2925faf8" name="exceptions" cv="const"><type>iostate</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a6e14394efdf4490589740dac5744b698" name="exceptions"><type>void</type><parameter name="s"><paramtype>iostate</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a66c38f0099307d51fc357a6ad4d14911" name="tie" cv="const"><type>ostream_type *</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a1efc6e4a4d8b2ad5dcaee5097e4a8579" name="tie"><type>ostream_type *</type><parameter name="strm"><paramtype>ostream_type *</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a21b864f3eaf1b6b9c7981178591ea5bf" name="rdbuf" cv="const"><type>streambuf_type *</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a14492d65a850215762f6c5123a095a4b" name="copyfmt"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="rhs"><paramtype>std::basic_ios&lt; char_type, traits_type &gt; &amp;</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a93d0230723dd317fb87721ceaa874261" name="copyfmt"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="rhs"><paramtype><classname>basic_formatting_ostream</classname> &amp;</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a27621751d5c6b54d95f2b49796531bc4" name="fill" cv="const"><type>char_type</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1aae13ff5f7a07451f58ba56fb27f4c371" name="fill"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a0db37695fee4fafc85a261b2759b874a" name="narrow" cv="const"><type>char</type><parameter name="ch"><paramtype>char_type</paramtype></parameter><parameter name="def"><paramtype>char</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a4ff49b7dd9323736b3f7ebc174b701f6" name="widen" cv="const"><type>char_type</type><parameter name="ch"><paramtype>char</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1aa36a8fc231e1674a250315954e03ada7" name="flush"><type><classname>basic_formatting_ostream</classname> &amp;</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a3ae98dcca805c28cc310b04e75fed78e" name="tellp"><type>pos_type</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a5e1ca32248ae5bd779a76c87042b736c" name="seekp"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="pos"><paramtype>pos_type</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a591330eb8297846cfb50c8407486d4ea" name="seekp"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="off"><paramtype>off_type</paramtype></parameter><parameter name="dir"><paramtype>std::ios_base::seekdir</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a5e26a040b73a2fb1a8a5aaa14c394b8f" name="put"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="c"><paramtype>char_type</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1aa5dd1585b4be949934b14070cfdebcfc" name="put"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="OtherCharT"/>
        </template><parameter name="c"><paramtype>OtherCharT</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a7ac97ecacbdd9a60ce07e9abfafe3924" name="write"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="p"><paramtype>const char_type *</paramtype></parameter><parameter name="size"><paramtype>std::streamsize</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a83384c6e128dc66665438015b6051f01" name="write"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="OtherCharT"/>
        </template><parameter name="p"><paramtype>const OtherCharT *</paramtype></parameter><parameter name="size"><paramtype>std::streamsize</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a4373415d9e36847460c80c794346fd44" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="manip"><paramtype>ios_base_manip</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a5e120df053e3b45ee522ffe7867ee091" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="manip"><paramtype>basic_ios_manip</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a65645015d5650038fbd7d52d4ee70d0f" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="manip"><paramtype>stream_manip</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1ac5b5a9464978c463131622839cbfd479" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="c"><paramtype>char</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a4d07b667d6d2fd94bdc8b8d119536c9e" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="p"><paramtype>const char *</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1ad0501d1eea44456ab8b8bd68cfb0af01" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="c"><paramtype>wchar_t</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a08e269bad78fc9dcd3b5902f6c22a968" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="p"><paramtype>const wchar_t *</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a9b2318bf8e3b505cabd5210736cdca99" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="c"><paramtype>char16_t</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1ae9a1535b4d19cf5a3a162801326a80de" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="p"><paramtype>const char16_t *</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1ad221e7baf68e837532a316950ad43efe" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="c"><paramtype>char32_t</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1af9f1abb9ce2ebf145ae5bb1e7a2b7cf6" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="p"><paramtype>const char32_t *</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a39a63635e5cc91b887bb5dbcbb662cea" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>bool</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1adc33870efe1db8054bc33ceca7dc7de4" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>signed char</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a26fe8ae1f083c78727d32c1e6384d3ad" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>unsigned char</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a5e2a5b3d991d0a60932880ad38aa4e7f" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>short</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a07df08445ab20386c6d1ca37fdcbda35" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>unsigned short</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a3c2a5a4d1ede0215a6bd181db257cbeb" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>int</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a7f0dbebe298024efa6ad7a1b468a9cfd" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>unsigned int</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a479082bfa73ffee7299b10b57e831c5e" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>long</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1ad2e934fc2846f859ebf8de12ce113919" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>unsigned long</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1aa8348f2154bca8ef08e6fa6ee58b1c54" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>long long</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a3cb0fef060a31619b1b009beb4626aa7" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>unsigned long long</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1aa626ca518a026b349b956699442bc6a8" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>float</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a1d971411bc0fc38df30f12aad1eead42" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>double</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a9a3c8394c4d196c2649f7e81cf2afdd6" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="value"><paramtype>long double</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a4df7e6eb5324d0c78267553fe55b1b9c" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="buf"><paramtype>std::basic_streambuf&lt; char_type, traits_type &gt; *</paramtype></parameter></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1ab4bd301a5dbb0e8eb3104c48dd7f319a" name="xalloc" specifiers="static"><type>int</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a4cee42c0ce35088388c048e5ce0c94eb" name="sync_with_stdio" specifiers="static"><type>bool</type><parameter name="sync"><paramtype>bool</paramtype><default>true</default></parameter></method>
</method-group>
<method-group name="protected member functions">
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a236ffa4b3537bb6977ed6acf52fac5c3" name="init_stream"><type>void</type></method>
</method-group>
<method-group name="private member functions">
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1ad84e786d62f04fcde8096469ac3a9320" name="formatted_write"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="p"><paramtype>const char_type *</paramtype></parameter><parameter name="size"><paramtype>std::streamsize</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1af09815235e870e9593435523a8638caa" name="formatted_write"><type><classname>basic_formatting_ostream</classname> &amp;</type><template>
          <template-type-parameter name="OtherCharT"/>
        </template><parameter name="p"><paramtype>const OtherCharT *</paramtype></parameter><parameter name="size"><paramtype>std::streamsize</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a25ca95bb8c5fb75480f52283d17a30b3" name="aligned_write"><type>void</type><parameter name="p"><paramtype>const char_type *</paramtype></parameter><parameter name="size"><paramtype>std::streamsize</paramtype></parameter></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1aeda56ac76fe80a5ce90ba133a421888c" name="aligned_write"><type>void</type><template>
          <template-type-parameter name="OtherCharT"/>
        </template><parameter name="p"><paramtype>const OtherCharT *</paramtype></parameter><parameter name="size"><paramtype>std::streamsize</paramtype></parameter></method>
<constructor id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a7974f6c454e4e658c951092a75699408" cv="= delete"><parameter name="that"><paramtype><classname>basic_formatting_ostream</classname> const &amp;</paramtype></parameter><purpose>Copy constructor (closed) </purpose></constructor>
<copy-assignment id="doxygen.utilities.classboost_1_1log_1_1basic__formatting__ostream_1a47022a7ba0b769f49288a93e0fbcd86a" cv="= delete"><type><classname>basic_formatting_ostream</classname> &amp;</type><parameter name="that"><paramtype><classname>basic_formatting_ostream</classname> const &amp;</paramtype></parameter><purpose>Assignment (closed) </purpose></copy-assignment>
</method-group>
</class><typedef id="doxygen.utilities.formatting__ostream__fwd_8hpp_1a9fe3d0905a53331022aff0e2a66f4971" name="formatting_ostream"><type><classname>basic_formatting_ostream</classname>&lt; char &gt;</type></typedef>
<typedef id="doxygen.utilities.formatting__ostream__fwd_8hpp_1a736f9ab33aef01d24304338dc3d8a023" name="wformatting_ostream"><type><classname>basic_formatting_ostream</classname>&lt; wchar_t &gt;</type></typedef>



















































































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.functional_8hpp" name="boost/log/utility/functional.hpp">
<para><para>Andrey Semashev </para>

<para>30.03.2008</para>

This header includes all functional helpers. </para></header>
<header id="doxygen.utilities.as__action_8hpp" name="boost/log/utility/functional/as_action.hpp">
<para><para>Andrey Semashev </para>

<para>30.03.2008</para>

This header contains function object adapter for compatibility with Boost.Spirit actions interface requirements. </para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1as__action__adapter" name="as_action_adapter"><template>
      <template-type-parameter name="FunT"/>
    </template><purpose>Function object adapter for Boost.Spirit actions. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1as__action__adapter_1a3bb9c98606d7ed9068d1457587bb9ba2" name="result_type"><type>FunT::result_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.structboost_1_1log_1_1as__action__adapter_1ad57e3f97fd07ae2a6230e7a051310767" cv="= default"/>
<constructor id="doxygen.utilities.structboost_1_1log_1_1as__action__adapter_1a6f1f9cc4218e088b44f926cc7a31cc1e" specifiers="explicit"><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter></constructor>
<method id="doxygen.utilities.structboost_1_1log_1_1as__action__adapter_1ae8bdd3dda6a4720404d162179df3b732" name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="AttributeT"/>
          <template-type-parameter name="ContextT"/>
        </template><parameter name="attr"><paramtype>AttributeT const &amp;</paramtype></parameter><parameter name="ctx"><paramtype>ContextT const &amp;</paramtype></parameter><parameter name="pass"><paramtype>bool &amp;</paramtype></parameter></method>
</method-group>
</struct>













































































<function id="doxygen.utilities.as__action_8hpp_1a4d9836e4bb62b12b668ac8aa8035f610" name="as_action"><type><classname>as_action_adapter</classname>&lt; FunT &gt;</type><template>
          <template-type-parameter name="FunT"/>
        </template><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter></function>




































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.begins__with_8hpp" name="boost/log/utility/functional/begins_with.hpp">
<para><para>Andrey Semashev </para>

<para>30.03.2008</para>

This header contains a predicate for checking if the provided string begins with a substring. </para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1begins__with__fun" name="begins_with_fun"><purpose>The <computeroutput>begins_with</computeroutput> functor. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1begins__with__fun_1af9f060e1c6d6e7343f3ecb7627c01a78" name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method id="doxygen.utilities.structboost_1_1log_1_1begins__with__fun_1a7212aefc4147edccb0fe5efaaaabd27d" name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></method>
</method-group>
</struct>


















































































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.bind_8hpp" name="boost/log/utility/functional/bind.hpp">
<para><para>Andrey Semashev </para>

<para>30.03.2008</para>

This header contains function object adapters. This is a lightweight alternative to what Boost.Phoenix and Boost.Bind provides. </para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1binder1st" name="binder1st"><template>
      <template-type-parameter name="FunT"/>
      <template-type-parameter name="FirstArgT"/>
    </template><inherit access="private">FunT</inherit><purpose>First argument binder. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1binder1st_1a3bb9c98606d7ed9068d1457587bb9ba2" name="result_type"><type>FunT::result_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.structboost_1_1log_1_1binder1st_1ad291aa08adb4e6d5c903416627b0391f"><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter><parameter name="arg"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></constructor>
<method id="doxygen.utilities.structboost_1_1log_1_1binder1st_1a1e14c6cd3702ba19fecfe52c496e382e" name="operator()" cv="const"><type>result_type</type></method>
<method id="doxygen.utilities.structboost_1_1log_1_1binder1st_1a4114f2ce0d458526aa7b89f08a4fba10" name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T0"/>
        </template><parameter name="arg0"><paramtype>T0 const &amp;</paramtype></parameter></method>
<method id="doxygen.utilities.structboost_1_1log_1_1binder1st_1ab7bbef1d6eb5b9767340cc1ba722224a" name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T0"/>
          <template-type-parameter name="T1"/>
        </template><parameter name="arg0"><paramtype>T0 const &amp;</paramtype></parameter><parameter name="arg1"><paramtype>T1 const &amp;</paramtype></parameter></method>
</method-group>
</struct><struct-specialization id="doxygen.utilities.structboost_1_1log_1_1binder1st_3_01FunT_01_6_00_01FirstArgT_01_4" name="binder1st"><template>
      <template-type-parameter name="FunT"/>
      <template-type-parameter name="FirstArgT"/>
    </template><specialization><template-arg>FunT &amp;</template-arg><template-arg>FirstArgT</template-arg></specialization><purpose>First argument binder. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1binder1st_3_01FunT_01_6_00_01FirstArgT_01_4_1a9c75f3db533806d1fff18d6d761fb52c" name="result_type"><type>remove_cv&lt; FunT &gt;::type::result_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.structboost_1_1log_1_1binder1st_3_01FunT_01_6_00_01FirstArgT_01_4_1a57f663044bdc0cffacaaf986aab03b3a"><parameter name="fun"><paramtype>FunT &amp;</paramtype></parameter><parameter name="arg"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></constructor>
<method id="doxygen.utilities.structboost_1_1log_1_1binder1st_3_01FunT_01_6_00_01FirstArgT_01_4_1a1e14c6cd3702ba19fecfe52c496e382e" name="operator()" cv="const"><type>result_type</type></method>
<method id="doxygen.utilities.structboost_1_1log_1_1binder1st_3_01FunT_01_6_00_01FirstArgT_01_4_1a4114f2ce0d458526aa7b89f08a4fba10" name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T0"/>
        </template><parameter name="arg0"><paramtype>T0 const &amp;</paramtype></parameter></method>
<method id="doxygen.utilities.structboost_1_1log_1_1binder1st_3_01FunT_01_6_00_01FirstArgT_01_4_1ab7bbef1d6eb5b9767340cc1ba722224a" name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T0"/>
          <template-type-parameter name="T1"/>
        </template><parameter name="arg0"><paramtype>T0 const &amp;</paramtype></parameter><parameter name="arg1"><paramtype>T1 const &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct id="doxygen.utilities.structboost_1_1log_1_1binder2nd" name="binder2nd"><template>
      <template-type-parameter name="FunT"/>
      <template-type-parameter name="SecondArgT"/>
    </template><inherit access="private">FunT</inherit><purpose>Second argument binder. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1binder2nd_1a3bb9c98606d7ed9068d1457587bb9ba2" name="result_type"><type>FunT::result_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.structboost_1_1log_1_1binder2nd_1aa966c165c6eb0997d8061e4a0e3940b2"><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter><parameter name="arg"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></constructor>
<method id="doxygen.utilities.structboost_1_1log_1_1binder2nd_1adbe451fac0e3e8e10e49966c52d11fec" name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="arg"><paramtype>T const &amp;</paramtype></parameter></method>
<method id="doxygen.utilities.structboost_1_1log_1_1binder2nd_1ab7bbef1d6eb5b9767340cc1ba722224a" name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T0"/>
          <template-type-parameter name="T1"/>
        </template><parameter name="arg0"><paramtype>T0 const &amp;</paramtype></parameter><parameter name="arg1"><paramtype>T1 const &amp;</paramtype></parameter></method>
</method-group>
</struct><struct-specialization id="doxygen.utilities.structboost_1_1log_1_1binder2nd_3_01FunT_01_6_00_01SecondArgT_01_4" name="binder2nd"><template>
      <template-type-parameter name="FunT"/>
      <template-type-parameter name="SecondArgT"/>
    </template><specialization><template-arg>FunT &amp;</template-arg><template-arg>SecondArgT</template-arg></specialization><purpose>Second argument binder. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1binder2nd_3_01FunT_01_6_00_01SecondArgT_01_4_1a9c75f3db533806d1fff18d6d761fb52c" name="result_type"><type>remove_cv&lt; FunT &gt;::type::result_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.structboost_1_1log_1_1binder2nd_3_01FunT_01_6_00_01SecondArgT_01_4_1a573f0c009ac649ead3dcb2fe72515c98"><parameter name="fun"><paramtype>FunT &amp;</paramtype></parameter><parameter name="arg"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></constructor>
<method id="doxygen.utilities.structboost_1_1log_1_1binder2nd_3_01FunT_01_6_00_01SecondArgT_01_4_1adbe451fac0e3e8e10e49966c52d11fec" name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="arg"><paramtype>T const &amp;</paramtype></parameter></method>
<method id="doxygen.utilities.structboost_1_1log_1_1binder2nd_3_01FunT_01_6_00_01SecondArgT_01_4_1ab7bbef1d6eb5b9767340cc1ba722224a" name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T0"/>
          <template-type-parameter name="T1"/>
        </template><parameter name="arg0"><paramtype>T0 const &amp;</paramtype></parameter><parameter name="arg1"><paramtype>T1 const &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct id="doxygen.utilities.structboost_1_1log_1_1binder3rd" name="binder3rd"><template>
      <template-type-parameter name="FunT"/>
      <template-type-parameter name="ThirdArgT"/>
    </template><inherit access="private">FunT</inherit><purpose>Third argument binder. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1binder3rd_1a3bb9c98606d7ed9068d1457587bb9ba2" name="result_type"><type>FunT::result_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.structboost_1_1log_1_1binder3rd_1af858548b2219d85e4c763cdebb6f365c"><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter><parameter name="arg"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></constructor>
<method id="doxygen.utilities.structboost_1_1log_1_1binder3rd_1ab7bbef1d6eb5b9767340cc1ba722224a" name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T0"/>
          <template-type-parameter name="T1"/>
        </template><parameter name="arg0"><paramtype>T0 const &amp;</paramtype></parameter><parameter name="arg1"><paramtype>T1 const &amp;</paramtype></parameter></method>
</method-group>
</struct><struct-specialization id="doxygen.utilities.structboost_1_1log_1_1binder3rd_3_01FunT_01_6_00_01ThirdArgT_01_4" name="binder3rd"><template>
      <template-type-parameter name="FunT"/>
      <template-type-parameter name="ThirdArgT"/>
    </template><specialization><template-arg>FunT &amp;</template-arg><template-arg>ThirdArgT</template-arg></specialization><purpose>Third argument binder. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1binder3rd_3_01FunT_01_6_00_01ThirdArgT_01_4_1a9c75f3db533806d1fff18d6d761fb52c" name="result_type"><type>remove_cv&lt; FunT &gt;::type::result_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.structboost_1_1log_1_1binder3rd_3_01FunT_01_6_00_01ThirdArgT_01_4_1af821aa452d311e4ddc37a5425e567f7d"><parameter name="fun"><paramtype>FunT &amp;</paramtype></parameter><parameter name="arg"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></constructor>
<method id="doxygen.utilities.structboost_1_1log_1_1binder3rd_3_01FunT_01_6_00_01ThirdArgT_01_4_1ab7bbef1d6eb5b9767340cc1ba722224a" name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T0"/>
          <template-type-parameter name="T1"/>
        </template><parameter name="arg0"><paramtype>T0 const &amp;</paramtype></parameter><parameter name="arg1"><paramtype>T1 const &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization>







































































<function id="doxygen.utilities.bind_8hpp_1a1a1802ff2d117e0894f773b9425cdfd9" name="bind1st"><type><classname>binder1st</classname>&lt; FunT, FirstArgT &gt;</type><template>
          <template-type-parameter name="FunT"/>
          <template-type-parameter name="FirstArgT"/>
        </template><parameter name="fun"><paramtype>FunT</paramtype></parameter><parameter name="arg"><paramtype>FirstArgT const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.bind_8hpp_1a1c264f2fdff630c5c664bf66e93376de" name="bind1st"><type><classname>binder1st</classname>&lt; FunT, FirstArgT &gt;</type><template>
          <template-type-parameter name="FunT"/>
          <template-type-parameter name="FirstArgT"/>
        </template><parameter name="fun"><paramtype>FunT</paramtype></parameter><parameter name="arg"><paramtype>FirstArgT &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.bind_8hpp_1a4da16e405071477d661e98d0ebff68a6" name="bind2nd"><type><classname>binder2nd</classname>&lt; FunT, SecondArgT &gt;</type><template>
          <template-type-parameter name="FunT"/>
          <template-type-parameter name="SecondArgT"/>
        </template><parameter name="fun"><paramtype>FunT</paramtype></parameter><parameter name="arg"><paramtype>SecondArgT const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.bind_8hpp_1ad5c4a5a95301074e9ec6186778600db1" name="bind2nd"><type><classname>binder2nd</classname>&lt; FunT, SecondArgT &gt;</type><template>
          <template-type-parameter name="FunT"/>
          <template-type-parameter name="SecondArgT"/>
        </template><parameter name="fun"><paramtype>FunT</paramtype></parameter><parameter name="arg"><paramtype>SecondArgT &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.bind_8hpp_1af67337967b9d29aab4ff360d1c7897d7" name="bind3rd"><type><classname>binder3rd</classname>&lt; FunT, ThirdArgT &gt;</type><template>
          <template-type-parameter name="FunT"/>
          <template-type-parameter name="ThirdArgT"/>
        </template><parameter name="fun"><paramtype>FunT</paramtype></parameter><parameter name="arg"><paramtype>ThirdArgT const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.bind_8hpp_1ae8fb3180c932676647892e6633c87df9" name="bind3rd"><type><classname>binder3rd</classname>&lt; FunT, ThirdArgT &gt;</type><template>
          <template-type-parameter name="FunT"/>
          <template-type-parameter name="ThirdArgT"/>
        </template><parameter name="fun"><paramtype>FunT</paramtype></parameter><parameter name="arg"><paramtype>ThirdArgT &amp;</paramtype></parameter></function>





































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.bind__assign_8hpp" name="boost/log/utility/functional/bind_assign.hpp">
<para><para>Andrey Semashev </para>

<para>30.03.2008</para>

This header contains a function object that assigns the received value to the bound object. This is a lightweight alternative to what Boost.Phoenix and Boost.Lambda provides. </para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1assign__fun" name="assign_fun"><purpose>The function object that assigns its second operand to the first one. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1assign__fun_1a64c66719f6f37caa0ce72b77538ec998" name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method id="doxygen.utilities.structboost_1_1log_1_1assign__fun_1af9ec5c456ce9ebde8d50e0b4dabf1ed0" name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="LeftT"/>
          <template-type-parameter name="RightT"/>
        </template><parameter name="assignee"><paramtype>LeftT &amp;</paramtype></parameter><parameter name="val"><paramtype>RightT const &amp;</paramtype></parameter></method>
</method-group>
</struct>






































































<function id="doxygen.utilities.bind__assign_8hpp_1a8b111854aaa2bc07d05b507bd63315cd" name="bind_assign"><type><classname>binder1st</classname>&lt; <classname>assign_fun</classname>, AssigneeT &amp; &gt;</type><template>
          <template-type-parameter name="AssigneeT"/>
        </template><parameter name="assignee"><paramtype>AssigneeT &amp;</paramtype></parameter></function>











































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.bind__output_8hpp" name="boost/log/utility/functional/bind_output.hpp">
<para><para>Andrey Semashev </para>

<para>30.03.2008</para>

This header contains a function object that puts the received value to the bound stream. This is a lightweight alternative to what Boost.Phoenix and Boost.Lambda provides. </para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1output__fun" name="output_fun"><purpose>The function object that outputs its second operand to the first one. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1output__fun_1a64c66719f6f37caa0ce72b77538ec998" name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method id="doxygen.utilities.structboost_1_1log_1_1output__fun_1a582f178b39850c54c1e5503812972813" name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="T"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter><parameter name="val"><paramtype>T const &amp;</paramtype></parameter></method>
</method-group>
</struct>





































































<function id="doxygen.utilities.bind__output_8hpp_1aede6dc69e66fe2f65cbbbbe8387f7429" name="bind_output"><type><classname>binder1st</classname>&lt; <classname>output_fun</classname>, StreamT &amp; &gt;</type><template>
          <template-type-parameter name="StreamT"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter></function>












































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.bind__to__log_8hpp" name="boost/log/utility/functional/bind_to_log.hpp">
<para><para>Andrey Semashev </para>

<para>06.11.2012</para>

This header contains a function object that puts the received value to the bound stream using the <computeroutput>to_log</computeroutput> manipulator. This is a lightweight alternative to what Boost.Phoenix and Boost.Lambda provides. </para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1to__log__fun" name="to_log_fun"><template>
      <template-type-parameter name="TagT"><default>void</default></template-type-parameter>
    </template><purpose>The function object that outputs its second operand to the first one. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1to__log__fun_1a64c66719f6f37caa0ce72b77538ec998" name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method id="doxygen.utilities.structboost_1_1log_1_1to__log__fun_1a582f178b39850c54c1e5503812972813" name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="T"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter><parameter name="val"><paramtype>T const &amp;</paramtype></parameter></method>
</method-group>
</struct><struct-specialization id="doxygen.utilities.structboost_1_1log_1_1to__log__fun_3_01void_01_4" name="to_log_fun"><template>
    </template><specialization><template-arg>void</template-arg></specialization><purpose>The function object that outputs its second operand to the first one. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1to__log__fun_3_01void_01_4_1a64c66719f6f37caa0ce72b77538ec998" name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method id="doxygen.utilities.structboost_1_1log_1_1to__log__fun_3_01void_01_4_1a582f178b39850c54c1e5503812972813" name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="T"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter><parameter name="val"><paramtype>T const &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization>



































































<function id="doxygen.utilities.bind__to__log_8hpp_1addca821dbbe8147a6b68b328e4889675" name="bind_to_log"><type><classname>binder1st</classname>&lt; <classname>to_log_fun</classname>&lt; &gt;, StreamT &amp; &gt;</type><template>
          <template-type-parameter name="StreamT"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.bind__to__log_8hpp_1ae912ec0746807c1603e3e299dd6a06b9" name="bind_to_log"><type><classname>binder1st</classname>&lt; <classname>to_log_fun</classname>&lt; TagT &gt;, StreamT &amp; &gt;</type><template>
          <template-type-parameter name="TagT"/>
          <template-type-parameter name="StreamT"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter></function>













































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.contains_8hpp" name="boost/log/utility/functional/contains.hpp">
<para><para>Andrey Semashev </para>

<para>30.03.2008</para>

This header contains a predicate for checking if the provided string contains a substring. </para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1contains__fun" name="contains_fun"><purpose>The <computeroutput>contains</computeroutput> functor. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1contains__fun_1af9f060e1c6d6e7343f3ecb7627c01a78" name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method id="doxygen.utilities.structboost_1_1log_1_1contains__fun_1a7212aefc4147edccb0fe5efaaaabd27d" name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></method>
</method-group>
</struct>


















































































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.ends__with_8hpp" name="boost/log/utility/functional/ends_with.hpp">
<para><para>Andrey Semashev </para>

<para>30.03.2008</para>

This header contains a predicate for checking if the provided string ends with a substring. </para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1ends__with__fun" name="ends_with_fun"><purpose>The <computeroutput>ends_with</computeroutput> functor. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1ends__with__fun_1af9f060e1c6d6e7343f3ecb7627c01a78" name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method id="doxygen.utilities.structboost_1_1log_1_1ends__with__fun_1a7212aefc4147edccb0fe5efaaaabd27d" name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></method>
</method-group>
</struct>


















































































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.fun__ref_8hpp" name="boost/log/utility/functional/fun_ref.hpp">
<para><para>Andrey Semashev </para>

<para>30.03.2008</para>

This header contains function object reference adapter. The adapter stores a reference to external function object and forwards all calls to the referred function. </para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1function__reference__wrapper" name="function_reference_wrapper"><template>
      <template-type-parameter name="FunT"/>
    </template><purpose>Reference wrapper for function objects. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1function__reference__wrapper_1a3bb9c98606d7ed9068d1457587bb9ba2" name="result_type"><type>FunT::result_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.structboost_1_1log_1_1function__reference__wrapper_1ad18157c2a92b593013636e3ea9942b23" specifiers="explicit"><parameter name="fun"><paramtype>FunT &amp;</paramtype></parameter></constructor>
<method id="doxygen.utilities.structboost_1_1log_1_1function__reference__wrapper_1a1e14c6cd3702ba19fecfe52c496e382e" name="operator()" cv="const"><type>result_type</type></method>
<method id="doxygen.utilities.structboost_1_1log_1_1function__reference__wrapper_1a9927a76894deb3636f4cc02bf52f94fc" name="operator()" cv="const"><type>result_type</type><template>
          <template-nontype-parameter name="ArgsT"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>ArgsT const &amp;...</paramtype></parameter></method>
</method-group>
</struct>


































































<function id="doxygen.utilities.fun__ref_8hpp_1a228def93c2332cde783968df3047bde6" name="fun_ref"><type><classname>function_reference_wrapper</classname>&lt; FunT &gt;</type><template>
          <template-type-parameter name="FunT"/>
        </template><parameter name="fun"><paramtype>FunT &amp;</paramtype></parameter></function>















































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.in__range_8hpp" name="boost/log/utility/functional/in_range.hpp">
<para><para>Andrey Semashev </para>

<para>30.03.2008</para>

This header contains a predicate for checking if the provided value is within a half-open range. </para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1in__range__fun" name="in_range_fun"><purpose>The in_range functor. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1in__range__fun_1af9f060e1c6d6e7343f3ecb7627c01a78" name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method id="doxygen.utilities.structboost_1_1log_1_1in__range__fun_1a4c87e142e8c33724c9d6aa387aa4493d" name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="value"><paramtype>T const &amp;</paramtype></parameter><parameter name="rng"><paramtype>std::pair&lt; U, U &gt; const &amp;</paramtype></parameter></method>
</method-group>
<method-group name="private static functions">
<method id="doxygen.utilities.structboost_1_1log_1_1in__range__fun_1ac018e7ceb3d1ab5c3e231ddb03721607" name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="value"><paramtype>T const &amp;</paramtype></parameter><parameter name="rng"><paramtype>std::pair&lt; U, U &gt; const &amp;</paramtype></parameter><parameter name=""><paramtype>false_type</paramtype></parameter></method>
<method id="doxygen.utilities.structboost_1_1log_1_1in__range__fun_1a59f823faf4be78e51a59ecf0a25dba2b" name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="value"><paramtype>T const &amp;</paramtype></parameter><parameter name="rng"><paramtype>std::pair&lt; U, U &gt; const &amp;</paramtype></parameter><parameter name=""><paramtype>true_type</paramtype></parameter></method>
</method-group>
</struct>


















































































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.logical_8hpp" name="boost/log/utility/functional/logical.hpp">
<para><para>Andrey Semashev </para>

<para>30.03.2008</para>

This header contains logical predicates for value comparison, analogous to <computeroutput>std::less</computeroutput>, <computeroutput>std::greater</computeroutput> and others. The main difference from the standard equivalents is that the predicates defined in this header are not templates and therefore do not require a fixed argument type. Furthermore, both arguments may have different types, in which case the comparison is performed without type conversion.</para><para><note><para>In case if arguments are integral, the conversion is performed according to the standard C++ rules in order to avoid warnings from the compiler. </para>
</note>
</para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1equal__to" name="equal_to"><purpose>Equality predicate. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1equal__to_1af9f060e1c6d6e7343f3ecb7627c01a78" name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method id="doxygen.utilities.structboost_1_1log_1_1equal__to_1a7212aefc4147edccb0fe5efaaaabd27d" name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></method>
</method-group>
<method-group name="private static functions">
<method id="doxygen.utilities.structboost_1_1log_1_1equal__to_1a4c20036ab8e80f0c57330b573229bcd6" name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>false_type</paramtype></parameter></method>
<method id="doxygen.utilities.structboost_1_1log_1_1equal__to_1adb75cbbdaf56d6459a04adc826508b37" name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>true_type</paramtype></parameter></method>
</method-group>
</struct><struct id="doxygen.utilities.structboost_1_1log_1_1greater" name="greater"><purpose>Greater predicate. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1greater_1af9f060e1c6d6e7343f3ecb7627c01a78" name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method id="doxygen.utilities.structboost_1_1log_1_1greater_1a7212aefc4147edccb0fe5efaaaabd27d" name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></method>
</method-group>
<method-group name="private static functions">
<method id="doxygen.utilities.structboost_1_1log_1_1greater_1a4c20036ab8e80f0c57330b573229bcd6" name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>false_type</paramtype></parameter></method>
<method id="doxygen.utilities.structboost_1_1log_1_1greater_1adb75cbbdaf56d6459a04adc826508b37" name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>true_type</paramtype></parameter></method>
</method-group>
</struct><struct id="doxygen.utilities.structboost_1_1log_1_1greater__equal" name="greater_equal"><purpose>Greater or equal predicate. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1greater__equal_1af9f060e1c6d6e7343f3ecb7627c01a78" name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method id="doxygen.utilities.structboost_1_1log_1_1greater__equal_1a7212aefc4147edccb0fe5efaaaabd27d" name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></method>
</method-group>
<method-group name="private static functions">
<method id="doxygen.utilities.structboost_1_1log_1_1greater__equal_1a4c20036ab8e80f0c57330b573229bcd6" name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>false_type</paramtype></parameter></method>
<method id="doxygen.utilities.structboost_1_1log_1_1greater__equal_1adb75cbbdaf56d6459a04adc826508b37" name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>true_type</paramtype></parameter></method>
</method-group>
</struct><struct id="doxygen.utilities.structboost_1_1log_1_1less" name="less"><purpose>Less predicate. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1less_1af9f060e1c6d6e7343f3ecb7627c01a78" name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method id="doxygen.utilities.structboost_1_1log_1_1less_1a7212aefc4147edccb0fe5efaaaabd27d" name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></method>
</method-group>
<method-group name="private static functions">
<method id="doxygen.utilities.structboost_1_1log_1_1less_1a4c20036ab8e80f0c57330b573229bcd6" name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>false_type</paramtype></parameter></method>
<method id="doxygen.utilities.structboost_1_1log_1_1less_1adb75cbbdaf56d6459a04adc826508b37" name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>true_type</paramtype></parameter></method>
</method-group>
</struct><struct id="doxygen.utilities.structboost_1_1log_1_1less__equal" name="less_equal"><purpose>Less or equal predicate. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1less__equal_1af9f060e1c6d6e7343f3ecb7627c01a78" name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method id="doxygen.utilities.structboost_1_1log_1_1less__equal_1a7212aefc4147edccb0fe5efaaaabd27d" name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></method>
</method-group>
<method-group name="private static functions">
<method id="doxygen.utilities.structboost_1_1log_1_1less__equal_1a4c20036ab8e80f0c57330b573229bcd6" name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>false_type</paramtype></parameter></method>
<method id="doxygen.utilities.structboost_1_1log_1_1less__equal_1adb75cbbdaf56d6459a04adc826508b37" name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>true_type</paramtype></parameter></method>
</method-group>
</struct><struct id="doxygen.utilities.structboost_1_1log_1_1not__equal__to" name="not_equal_to"><purpose>Inequality predicate. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1not__equal__to_1af9f060e1c6d6e7343f3ecb7627c01a78" name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method id="doxygen.utilities.structboost_1_1log_1_1not__equal__to_1a7212aefc4147edccb0fe5efaaaabd27d" name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></method>
</method-group>
<method-group name="private static functions">
<method id="doxygen.utilities.structboost_1_1log_1_1not__equal__to_1a4c20036ab8e80f0c57330b573229bcd6" name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>false_type</paramtype></parameter></method>
<method id="doxygen.utilities.structboost_1_1log_1_1not__equal__to_1adb75cbbdaf56d6459a04adc826508b37" name="op" specifiers="static"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype>T const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter><parameter name=""><paramtype>true_type</paramtype></parameter></method>
</method-group>
</struct>


















































































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.matches_8hpp" name="boost/log/utility/functional/matches.hpp">
<para><para>Andrey Semashev </para>

<para>30.03.2008</para>

This header contains a predicate for checking if the provided string matches a regular expression. </para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1matches__fun" name="matches_fun"><purpose>The regex matching functor. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1matches__fun_1af9f060e1c6d6e7343f3ecb7627c01a78" name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method id="doxygen.utilities.structboost_1_1log_1_1matches__fun_1a9a5539f2809050164f4c53ce800266cb" name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="StringT"/>
          <template-type-parameter name="ExpressionT"/>
        </template><parameter name="str"><paramtype>StringT const &amp;</paramtype></parameter><parameter name="expr"><paramtype>ExpressionT const &amp;</paramtype></parameter></method>
<method id="doxygen.utilities.structboost_1_1log_1_1matches__fun_1a034b7c6b1b303143007828416d530777" name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="StringT"/>
          <template-type-parameter name="ExpressionT"/>
          <template-type-parameter name="ArgT"/>
        </template><parameter name="str"><paramtype>StringT const &amp;</paramtype></parameter><parameter name="expr"><paramtype>ExpressionT const &amp;</paramtype></parameter><parameter name="arg"><paramtype>ArgT const &amp;</paramtype></parameter></method>
</method-group>
</struct>


















































































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.nop_8hpp" name="boost/log/utility/functional/nop.hpp">
<para><para>Andrey Semashev </para>

<para>30.03.2008</para>

This header contains a function object that does nothing. </para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1nop" name="nop"><purpose>The function object that does nothing. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1nop_1a64c66719f6f37caa0ce72b77538ec998" name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method id="doxygen.utilities.structboost_1_1log_1_1nop_1abea379ccda17340ba0ea237bbb535b28" name="operator()" cv="const noexcept"><type>void</type></method>
<method id="doxygen.utilities.structboost_1_1log_1_1nop_1a60d4973aa8fabb8f8693a04817130a8d" name="operator()" cv="const noexcept"><type>void</type><template>
          <template-nontype-parameter name="ArgsT"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="..."><paramtype>ArgsT const &amp;</paramtype></parameter></method>
</method-group>
</struct>


















































































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.save__result_8hpp" name="boost/log/utility/functional/save_result.hpp">
<para><para>Andrey Semashev </para>

<para>19.01.2013</para>

This header contains function object adapter that saves the result of the adopted function to an external variable. </para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1save__result__wrapper" name="save_result_wrapper"><template>
      <template-type-parameter name="FunT"/>
      <template-type-parameter name="AssigneeT"/>
    </template><purpose>Function object wrapper for saving the adopted function object result. </purpose><typedef id="doxygen.utilities.structboost_1_1log_1_1save__result__wrapper_1a64c66719f6f37caa0ce72b77538ec998" name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.structboost_1_1log_1_1save__result__wrapper_1a7b5b8dd05faa5ec33f864b178c408e05"><parameter name="fun"><paramtype>FunT</paramtype></parameter><parameter name="assignee"><paramtype>AssigneeT &amp;</paramtype></parameter></constructor>
<method id="doxygen.utilities.structboost_1_1log_1_1save__result__wrapper_1a8189f01f8c3841f3554100cee5568fa9" name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="ArgT"/>
        </template><parameter name="arg"><paramtype>ArgT const &amp;</paramtype></parameter></method>
</method-group>
</struct>

































































<function id="doxygen.utilities.save__result_8hpp_1ac15572ffdf47842429b8b5833e61f712" name="save_result"><type><classname>save_result_wrapper</classname>&lt; FunT, AssigneeT &gt;</type><template>
          <template-type-parameter name="FunT"/>
          <template-type-parameter name="AssigneeT"/>
        </template><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter><parameter name="assignee"><paramtype>AssigneeT &amp;</paramtype></parameter></function>
















































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.object__name_8hpp" name="boost/log/utility/ipc/object_name.hpp">
<para><para>Andrey Semashev </para>

<para>05.03.2016</para>

The header contains declaration of a system object name wrapper. </para><namespace name="boost">
<namespace name="log">
<namespace name="ipc">
<class id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name" name="object_name"><purpose>A system object name class. </purpose><description><para>In order to identify a system-wide object such as a shared memory segment or a named synchronization primitive the object has to be given a name. The format of the name is specific to the operating system and the <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name">object_name</link></computeroutput> class provides an abstraction for names of objects. It also provides means for scoping, which allows to avoid name clashes between different processes.</para><para>The object name is a UTF-8 encoded string. The portable object name should consist of the following characters:</para><programlisting>
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
a b c d e f g h i j k l m n o p q r s t u v w x y z
0 1 2 3 4 5 6 7 8 9 . _ -
</programlisting><para><note><para>The character set corresponds to the POSIX Portable Filename Character Set (<ulink url="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_278">http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_278</ulink>).</para>
</note>
Use of other characters may result in non-portable system-specific behavior.</para><para>The name can have one of the following scopes:</para><para><itemizedlist>
<listitem><para><computeroutput>global</computeroutput> - objects within this scope are visible to any process on the system. In order to use this scope the process may need to have extended privileges. This scope is not available for Windows Store applications. </para>
</listitem>
<listitem><para><computeroutput>user</computeroutput> - objects within this scope can be opened by processes running under the same user as the current process. </para>
</listitem>
<listitem><para><computeroutput>session</computeroutput> - objects within this scope are visible to processes within the session of the current process. The definition of a session may vary between operating systems. On POSIX, a session is typically a group of processes attached to a single virtual terminal device. On Windows a session is started when a user logs into the system. There is also a separate session for Windows services. </para>
</listitem>
<listitem><para><computeroutput>process_group</computeroutput> - objects within this scope are visible to processes within the process group of the current process. Currently, on Windows all processes running in the current session are considered members of the same process group. This may change in future.</para>
</listitem>
</itemizedlist>
The scopes are not overlapping. For instance, if an object is created in the global scope, the object cannot be opened with the same name but in user's scope.</para><para>Note that name scoping is not a security feature. On some systems any process on the system has technical capability to open objects within any scope. The scope is only used to help avoid name clashes between processes using <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name">object_name</link></computeroutput> to identify objects. </para></description><enum id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1a6e0326b60f0bd67c213b500f753f83b0" name="scope"><enumvalue id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1a6e0326b60f0bd67c213b500f753f83b0ac0848296a9510c4fc803b4553e6f75f9" name="global"><purpose>The name has global scope; any process in the system has the potential to open the resource identified by the name. </purpose></enumvalue><enumvalue id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1a6e0326b60f0bd67c213b500f753f83b0a04981b8c09a50ccfb1d92fc11b81c36a" name="user"><purpose>The name is limited to processes running under the current user. </purpose></enumvalue><enumvalue id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1a6e0326b60f0bd67c213b500f753f83b0a2131d0c383ea106da6d751ba0457aa32" name="session"><purpose>The name is limited to processes running in the current login session. </purpose></enumvalue><enumvalue id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1a6e0326b60f0bd67c213b500f753f83b0a7d61e3d61a7c1dafd8b4639e01f3db7f" name="process_group"><purpose>The name is limited to processes running in the current process group. </purpose></enumvalue><purpose>Name scopes. </purpose></enum>
<method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1a7369fb7b4ceb6a9678602116713df0ee" cv="noexcept"><description><para>Default constructor. The method creates an empty object name.</para><para>
</para></description><postconditions><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1a3f6fc5de06a318920d84f3c3742db07f">empty()</link> == true</computeroutput> </para>
</postconditions></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1a6eae1542aa851ea5a6928a831f3ea92a" cv="noexcept"><parameter name="that"><paramtype><classname>object_name</classname> &amp;&amp;</paramtype></parameter><description><para>Move constructor. </para></description></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1aaa15b5fff8f5bf2349c2e0516eec37f3"><parameter name="that"><paramtype><classname>object_name</classname> const &amp;</paramtype></parameter><description><para>Copy constructor. </para></description></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1a416759fa4d1591613664444226f49224"><parameter name="ns"><paramtype>scope</paramtype><description><para>The scope of the object name </para></description></parameter><parameter name="str"><paramtype>const char *</paramtype><description><para>The object name, must not be NULL. </para></description></parameter><description><para>Constructor from the object name 
</para></description></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1aa1493dee97992946354a9e83dbdbb44b"><parameter name="ns"><paramtype>scope</paramtype><description><para>The scope of the object name </para></description></parameter><parameter name="str"><paramtype>std::string const &amp;</paramtype><description><para>The object name </para></description></parameter><description><para>Constructor from the object name 
</para></description></constructor>
<copy-assignment id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1aab4ff832734e08c8598436f66fcde9de" cv="noexcept"><type><classname>object_name</classname> &amp;</type><parameter name="that"><paramtype><classname>object_name</classname> &amp;&amp;</paramtype></parameter><description><para>Move assignment </para></description></copy-assignment>
<copy-assignment id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1a3bb753ab082bbcc29ef2e0fdb2845237"><type><classname>object_name</classname> &amp;</type><parameter name="that"><paramtype><classname>object_name</classname> const &amp;</paramtype></parameter><description><para>Copy assignment </para></description></copy-assignment>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1a3f6fc5de06a318920d84f3c3742db07f" name="empty" cv="const noexcept"><type>bool</type><description><para>Returns <computeroutput>true</computeroutput> if the object name is empty </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1a4f7434932a5e343fc55ba86506da43c7" name="size" cv="const noexcept"><type>std::size_t</type><description><para>Returns length of the name, in bytes </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1ac6fc748755afeff2345561921cfaddcd" name="c_str" cv="const noexcept"><type>const char *</type><description><para>Returns the name string </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1ac29d2aa4b2a8fb1c659d85d5f4fb2e4c" name="swap" cv="noexcept"><type>void</type><parameter name="that"><paramtype><classname>object_name</classname> &amp;</paramtype></parameter><description><para>Swaps the object name with another object name </para></description></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1a2c57b6838901c2f1c938decc29ea39f1" name="from_native" specifiers="static"><type><classname>object_name</classname></type><parameter name="str"><paramtype>const char *</paramtype><description><para>The object name string, must not be <computeroutput>NULL</computeroutput>. The string format is specific to the operating system. </para></description></parameter><description><para>Constructor from the native string.</para><para>
</para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1ab84354421b1d68e9fae6c0f11db5f982" name="from_native" specifiers="static"><type><classname>object_name</classname></type><parameter name="str"><paramtype>std::string const &amp;</paramtype><description><para>The object name string. The string format is specific to the operating system. </para></description></parameter><description><para>Constructor from the native string.</para><para>
</para></description></method>
</method-group>
<method-group name="friend functions">
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1a9c6e63cfae035e22ee289f42fc83cd02" name="swap" cv="noexcept"><type>void</type><parameter name="left"><paramtype><classname>object_name</classname> &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>object_name</classname> &amp;</paramtype></parameter><description><para>Swaps two object names </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1abf453548b47e71098a3445381f7a35d2" name="to_string"><type>std::string</type><parameter name="name"><paramtype><classname>object_name</classname> const &amp;</paramtype></parameter><description><para>Returns string representation of the object name </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1aa199d1c37f288a7d2e60914e2399c5c2" name="operator==" cv="noexcept"><type>bool</type><parameter name="left"><paramtype><classname>object_name</classname> const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>object_name</classname> const &amp;</paramtype></parameter><description><para>Equality operator </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1a2230eafcc8eadd6c362c7228c7b60a67" name="operator!=" cv="noexcept"><type>bool</type><parameter name="left"><paramtype><classname>object_name</classname> const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>object_name</classname> const &amp;</paramtype></parameter><description><para>Inequality operator </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1a7d35ba5ec58f49473e698fff3b4a9738" name="operator&lt;" cv="noexcept"><type>bool</type><parameter name="left"><paramtype><classname>object_name</classname> const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>object_name</classname> const &amp;</paramtype></parameter><description><para>Less operator </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1a1b42e6f1a3d7a8caed742822386caea9" name="operator&gt;" cv="noexcept"><type>bool</type><parameter name="left"><paramtype><classname>object_name</classname> const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>object_name</classname> const &amp;</paramtype></parameter><description><para>Greater operator </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1aadeb5186a821bbe3d03df431e5ad5fa4" name="operator&lt;=" cv="noexcept"><type>bool</type><parameter name="left"><paramtype><classname>object_name</classname> const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>object_name</classname> const &amp;</paramtype></parameter><description><para>Less or equal operator </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1ad62c64c19a0caebead7586a4d234d4a3" name="operator&gt;=" cv="noexcept"><type>bool</type><parameter name="left"><paramtype><classname>object_name</classname> const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>object_name</classname> const &amp;</paramtype></parameter><description><para>Greater or equal operator </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name_1aa0fdedc278affba5a95b2b6d742a91ef" name="operator&lt;&lt;"><type>std::basic_ostream&lt; CharT, TraitsT &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TraitsT"/>
        </template><parameter name="strm"><paramtype>std::basic_ostream&lt; CharT, TraitsT &gt; &amp;</paramtype></parameter><parameter name="name"><paramtype><classname>object_name</classname> const &amp;</paramtype></parameter><description><para>Stream ouput operator </para></description></method>
</method-group>
</class></namespace>



















































































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.reliable__message__queue_8hpp" name="boost/log/utility/ipc/reliable_message_queue.hpp">
<para><para>Lingxi Li </para>

<para>Andrey Semashev </para>

<para>01.01.2016</para>

The header contains declaration of a reliable interprocess message queue. </para><namespace name="boost">
<namespace name="log">
<namespace name="ipc">
<class id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue" name="reliable_message_queue"><purpose>A reliable interprocess message queue. </purpose><description><para>The queue implements a reliable one-way channel of passing messages from one or multiple writers to a single reader. The format of the messages is user-defined and must be consistent across all writers and the reader. The queue does not enforce any specific format of the messages, other than they should be supplied as a contiguous array of bytes.</para><para>The queue internally uses a process-shared storage identified by an <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name">object_name</link></computeroutput> (the queue name). Refer to <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1object__name">object_name</link></computeroutput> documentation for details on restrictions imposed on object names.</para><para>The queue storage is organized as a fixed number of blocks of a fixed size. The block size must be an integer power of 2 and is expressed in bytes. Each written message, together with some metadata added by the queue, consumes an integer number of blocks. Each read message received by the reader releases the blocks allocated for that message. As such the maximum size of a message is slightly less than block size times capacity of the queue. For efficiency, it is recommended to choose block size large enough to accommodate most of the messages to be passed through the queue.</para><para>The queue is considered empty when no messages are enqueued (all blocks are free). The queue is considered full at the point of enqueueing a message when there is not enough free blocks to accommodate the message.</para><para>The queue is reliable in that it will not drop successfully sent messages that are not received by the reader, other than the case when a non-empty queue is destroyed by the last user. If a message cannot be enqueued by the writer because the queue is full, the queue can either block the writer or return an error or throw an exception, depending on the policy specified at the queue creation. The policy is object local, i.e. different writers and the reader can have different overflow policies.</para><para>If the queue is empty and the reader attempts to dequeue a message, it will block until a message is enqueued by a writer.</para><para>A blocked reader or writer can be unblocked by calling <computeroutput>stop_local</computeroutput>. After this method is called, all threads blocked on this particular object are released and return <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a27cc657b4b0e49579ba47c9950341b66aaf2b197bcf14794c85c5f313dab0ca31">operation_result::aborted</link></computeroutput>. The other instances of the queue (in the current or other processes) are unaffected. In order to restore the normal functioning of the queue instance after the <computeroutput>stop_local</computeroutput> call the user has to invoke <computeroutput>reset_local</computeroutput>.</para><para>The queue does not guarantee any particular order of received messages from different writer threads. Messages sent by a particular writer thread will be received in the order of sending.</para><para>Methods of this class are not thread-safe, unless otherwise specified. </para></description><enum id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a27cc657b4b0e49579ba47c9950341b66" name="operation_result"><enumvalue id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a27cc657b4b0e49579ba47c9950341b66a636c76696d01424d4298b205b985abe6" name="succeeded"><purpose>The operation has completed successfully. </purpose></enumvalue><enumvalue id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a27cc657b4b0e49579ba47c9950341b66ae50ba62fda0c4eedf3d7fdb48ceaeba4" name="no_space"><purpose>The message could not be sent because the queue is full. </purpose></enumvalue><enumvalue id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a27cc657b4b0e49579ba47c9950341b66aaf2b197bcf14794c85c5f313dab0ca31" name="aborted"><purpose>The operation has been aborted because the queue method <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad6c62c7386cfdc5a3d6e4c3c5561ddde">stop_local()</link></computeroutput> has been called. </purpose></enumvalue><purpose>Result codes for various operations on the queue. </purpose></enum>
<enum id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1aa9239ded28f36d3a3033b9fb271fe2c2" name="overflow_policy"><enumvalue id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1aa9239ded28f36d3a3033b9fb271fe2c2a2c3d16d8842a28b11c135e599011bdc3" name="block_on_overflow"><purpose>Block the send operation when the queue is full. </purpose></enumvalue><enumvalue id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1aa9239ded28f36d3a3033b9fb271fe2c2adc5ebc2c8baa8c8fb333c9e19e1c841d" name="fail_on_overflow"><purpose>Return <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a27cc657b4b0e49579ba47c9950341b66ae50ba62fda0c4eedf3d7fdb48ceaeba4">operation_result::no_space</link></computeroutput> when the queue is full. </purpose></enumvalue><enumvalue id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1aa9239ded28f36d3a3033b9fb271fe2c2a624dbd9da6294be29899e65f97aeb309" name="throw_on_overflow"><purpose>Throw <computeroutput>capacity_limit_reached</computeroutput> exception when the queue is full. </purpose></enumvalue><purpose>Interprocess queue overflow policies. </purpose></enum>
<typedef id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ac246e3150ce7f5a7ba2abcbb2ff1638a" name="size_type"><purpose>Queue message size type. </purpose><type>uint32_t</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1aa663fec051972e3ee803580fcc0eab59" cv="noexcept"><description><para>Default constructor. The method constructs an object that is not associated with any message queue.</para><para>
</para></description><postconditions><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == false</computeroutput> </para>
</postconditions></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a1d1a63d5147b9399f3c5b086890a6053"><parameter name=""><paramtype><classname>open_mode::create_only_tag</classname></paramtype></parameter><parameter name="name"><paramtype><classname>object_name</classname> const &amp;</paramtype><description><para>Name of the message queue to be associated with. </para></description></parameter><parameter name="capacity"><paramtype>uint32_t</paramtype><description><para>Maximum number of allocation blocks the queue can hold. </para></description></parameter><parameter name="block_size"><paramtype>size_type</paramtype><description><para>Size in bytes of allocation block. Must be a power of 2. </para></description></parameter><parameter name="oflow_policy"><paramtype>overflow_policy</paramtype><default>block_on_overflow</default><description><para>Queue behavior policy in case of overflow. </para></description></parameter><parameter name="perms"><paramtype><classname>permissions</classname> const &amp;</paramtype><default>permissions()</default><description><para>Access permissions for the associated message queue. </para></description></parameter><description><para>Constructor. The method is used to construct an object and create the associated message queue. The constructed object will be in running state if the message queue is successfully created.</para><para>

</para></description><postconditions><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput></para>
</postconditions></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a967c3b0b63b94e351f03d5b5425cb4f7"><parameter name=""><paramtype><classname>open_mode::open_or_create_tag</classname></paramtype></parameter><parameter name="name"><paramtype><classname>object_name</classname> const &amp;</paramtype><description><para>Name of the message queue to be associated with. </para></description></parameter><parameter name="capacity"><paramtype>uint32_t</paramtype><description><para>Maximum number of allocation blocks the queue can hold. </para></description></parameter><parameter name="block_size"><paramtype>size_type</paramtype><description><para>Size in bytes of allocation block. Must be a power of 2. </para></description></parameter><parameter name="oflow_policy"><paramtype>overflow_policy</paramtype><default>block_on_overflow</default><description><para>Queue behavior policy in case of overflow. </para></description></parameter><parameter name="perms"><paramtype><classname>permissions</classname> const &amp;</paramtype><default>permissions()</default><description><para>Access permissions for the associated message queue. </para></description></parameter><description><para>Constructor. The method is used to construct an object and create or open the associated message queue. The constructed object will be in running state if the message queue is successfully created or opened. If the message queue that is identified by the name already exists then the other queue parameters are ignored. The actual queue parameters can be obtained with accessors from the constructed object.</para><para>

</para></description><postconditions><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput></para>
</postconditions></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a16302f12081bb986118534c8bbe98db6"><parameter name=""><paramtype><classname>open_mode::open_only_tag</classname></paramtype></parameter><parameter name="name"><paramtype><classname>object_name</classname> const &amp;</paramtype><description><para>Name of the message queue to be associated with. </para></description></parameter><parameter name="oflow_policy"><paramtype>overflow_policy</paramtype><default>block_on_overflow</default><description><para>Queue behavior policy in case of overflow. </para></description></parameter><parameter name="perms"><paramtype><classname>permissions</classname> const &amp;</paramtype><default>permissions()</default><description><para>Access permissions for the associated message queue. The permissions will only be used if the queue implementation has to create system objects while operating. This parameter is currently not used on POSIX systems. </para></description></parameter><description><para>Constructor. The method is used to construct an object and open the existing message queue. The constructed object will be in running state if the message queue is successfully opened.</para><para>

</para></description><postconditions><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput></para>
</postconditions></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad8371c3ddd2d097ccad893ebc3f20c3f" specifiers="explicit"><template>
          <template-nontype-parameter name="Args"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args const &amp;...</paramtype></parameter><description><para>Constructor with named parameters. The method is used to construct an object and create or open the associated message queue. The constructed object will be in running state if the message queue is successfully created.</para><para>The following named parameters are accepted:</para><para><itemizedlist>
<listitem><para>open_mode - One of the open mode tags: <computeroutput>open_mode::create_only</computeroutput>, <computeroutput>open_mode::open_only</computeroutput> or <computeroutput>open_mode::open_or_create</computeroutput>.</para>
</listitem><listitem><para>name - Name of the message queue to be associated with.</para>
</listitem><listitem><para>capacity - Maximum number of allocation blocks the queue can hold. Used only if the queue is created.</para>
</listitem><listitem><para>block_size - Size in bytes of allocation block. Must be a power of 2. Used only if the queue is created.</para>
</listitem><listitem><para>overflow_policy - Queue behavior policy in case of overflow, see <computeroutput>overflow_policy</computeroutput>.</para>
</listitem><listitem><para>permissions - Access permissions for the associated message queue.</para>
</listitem></itemizedlist>
</para><para>
</para></description><postconditions><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput> </para>
</postconditions></constructor>
<destructor id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ab72b19f35040d47d29a4b1ca223a7eb4" cv="noexcept"><description><para>Destructor. Calls <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a2ead8fad3dd09d3a8b03e6c948f14e46">close()</link></computeroutput>. </para></description></destructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a43e4f8dd494fd40e14484b4a2ddc7674" cv="noexcept"><parameter name="that"><paramtype><classname>reliable_message_queue</classname> &amp;&amp;</paramtype><description><para>The object to be moved. </para></description></parameter><description><para>Move constructor. The method move-constructs an object from <computeroutput>other</computeroutput>. After the call, the constructed object becomes <computeroutput>other</computeroutput>, while <computeroutput>other</computeroutput> is left in default constructed state.</para><para>
</para></description></constructor>
<copy-assignment id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a4f4eccf895aa8c5a99135c61993d6d88" cv="noexcept"><type><classname>reliable_message_queue</classname> &amp;</type><parameter name="that"><paramtype><classname>reliable_message_queue</classname> &amp;&amp;</paramtype><description><para>The object to be moved.</para></description></parameter><description><para>Move assignment operator. If the object is associated with a message queue, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a2ead8fad3dd09d3a8b03e6c948f14e46">close()</link></computeroutput> is first called and the precondition to calling <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a2ead8fad3dd09d3a8b03e6c948f14e46">close()</link></computeroutput> applies. After the call, the object becomes <emphasis>that</emphasis> while <emphasis>that</emphasis> is left in default constructed state.</para><para>

</para></description><returns><para>A reference to the assigned object. </para>
</returns></copy-assignment>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad38467778f8bb4a2d8daa02b0c676fb3" name="swap" cv="noexcept"><type>void</type><parameter name="that"><paramtype><classname>reliable_message_queue</classname> &amp;</paramtype><description><para>The other object to swap with. </para></description></parameter><description><para>The method swaps the object with <emphasis>that</emphasis>.</para><para>
</para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ae52ac90539d5986c8b917b76cd8fed56" name="create"><type>void</type><parameter name="name"><paramtype><classname>object_name</classname> const &amp;</paramtype><description><para>Name of the message queue to be associated with. </para></description></parameter><parameter name="capacity"><paramtype>uint32_t</paramtype><description><para>Maximum number of allocation blocks the queue can hold. </para></description></parameter><parameter name="block_size"><paramtype>size_type</paramtype><description><para>Size in bytes of allocation block. Must be a power of 2. </para></description></parameter><parameter name="oflow_policy"><paramtype>overflow_policy</paramtype><default>block_on_overflow</default><description><para>Queue behavior policy in case of overflow. </para></description></parameter><parameter name="perms"><paramtype><classname>permissions</classname> const &amp;</paramtype><default>permissions()</default><description><para>Access permissions for the associated message queue. </para></description></parameter><description><para>The method creates the message queue to be associated with the object. After the call, the object will be in running state if a message queue is successfully created.</para><para>


</para></description><requires><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == false</computeroutput> </para>
</requires><postconditions><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput></para>
</postconditions></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad024cfeb3b94ec48e80d9fc8d93f60b5" name="open_or_create"><type>void</type><parameter name="name"><paramtype><classname>object_name</classname> const &amp;</paramtype><description><para>Name of the message queue to be associated with. </para></description></parameter><parameter name="capacity"><paramtype>uint32_t</paramtype><description><para>Maximum number of allocation blocks the queue can hold. </para></description></parameter><parameter name="block_size"><paramtype>size_type</paramtype><description><para>Size in bytes of allocation block. Must be a power of 2. </para></description></parameter><parameter name="oflow_policy"><paramtype>overflow_policy</paramtype><default>block_on_overflow</default><description><para>Queue behavior policy in case of overflow. </para></description></parameter><parameter name="perms"><paramtype><classname>permissions</classname> const &amp;</paramtype><default>permissions()</default><description><para>Access permissions for the associated message queue. </para></description></parameter><description><para>The method creates or opens the message queue to be associated with the object. After the call, the object will be in running state if a message queue is successfully created or opened. If the message queue that is identified by the name already exists then the other queue parameters are ignored. The actual queue parameters can be obtained with accessors from this object after this method returns.</para><para>


</para></description><requires><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == false</computeroutput> </para>
</requires><postconditions><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput></para>
</postconditions></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a2c0c2bafac143e0e006548f862f0c8e8" name="open"><type>void</type><parameter name="name"><paramtype><classname>object_name</classname> const &amp;</paramtype><description><para>Name of the message queue to be associated with. </para></description></parameter><parameter name="oflow_policy"><paramtype>overflow_policy</paramtype><default>block_on_overflow</default><description><para>Queue behavior policy in case of overflow. </para></description></parameter><parameter name="perms"><paramtype><classname>permissions</classname> const &amp;</paramtype><default>permissions()</default><description><para>Access permissions for the associated message queue. The permissions will only be used if the queue implementation has to create system objects while operating. This parameter is currently not used on POSIX systems. </para></description></parameter><description><para>The method opens the existing message queue to be associated with the object. After the call, the object will be in running state if a message queue is successfully opened.</para><para>


</para></description><requires><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == false</computeroutput> </para>
</requires><postconditions><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput></para>
</postconditions></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858" name="is_open" cv="const noexcept"><type>bool</type><description><para>Tests whether the object is associated with any message queue.</para><para>
</para></description><returns><para><computeroutput>true</computeroutput> if the object is associated with a message queue, and <computeroutput>false</computeroutput> otherwise. </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ac8bb3912a3ce86b15842e79d0b421204" name="clear"><type>void</type><description><para>This method empties the associated message queue. Concurrent calls to this method, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a955dfe737edb543fee14bb02063819f9">send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a5a27f67ad735d6f533f9487a77975acd">try_send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a05c8f0dfc8ada1ef0cf6f682bd63f83a">receive()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1aa120bcc08d01104e75243321a569ea9a">try_receive()</link></computeroutput>, and <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad6c62c7386cfdc5a3d6e4c3c5561ddde">stop_local()</link></computeroutput> are allowed.</para><para>
</para></description><requires><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput> </para>
</requires></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a66f837fdf970eab3be09a2d44b54514f" name="name" cv="const"><type><classname>object_name</classname> const &amp;</type><description><para>The method returns the name of the associated message queue.</para><para>

</para></description><requires><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput></para>
</requires><returns><para>Name of the associated message queue </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1af730bdc33eb32c3b349e102190eec0e9" name="capacity" cv="const"><type>uint32_t</type><description><para>The method returns the maximum number of allocation blocks the associated message queue can hold. Note that the returned value may be different from the corresponding value passed to the constructor or <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad024cfeb3b94ec48e80d9fc8d93f60b5">open_or_create()</link></computeroutput>, for the message queue may not have been created by this object.</para><para>

</para></description><requires><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput></para>
</requires><returns><para>Maximum number of allocation blocks the associated message queue can hold. </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1aaade09593f3b84f58d64da18343330a0" name="block_size" cv="const"><type>size_type</type><description><para>The method returns the allocation block size, in bytes. Each message in the associated message queue consumes an integer number of allocation blocks. Note that the returned value may be different from the corresponding value passed to the constructor or <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad024cfeb3b94ec48e80d9fc8d93f60b5">open_or_create()</link></computeroutput>, for the message queue may not have been created by this object.</para><para>

</para></description><requires><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput></para>
</requires><returns><para>Allocation block size, in bytes. </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad6c62c7386cfdc5a3d6e4c3c5561ddde" name="stop_local"><type>void</type><description><para>The method wakes up all threads that are blocked in calls to <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a955dfe737edb543fee14bb02063819f9">send()</link></computeroutput> or <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a05c8f0dfc8ada1ef0cf6f682bd63f83a">receive()</link></computeroutput>. Those calls would then return <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a27cc657b4b0e49579ba47c9950341b66aaf2b197bcf14794c85c5f313dab0ca31">operation_result::aborted</link></computeroutput>. Note that, the method does not block until the woken-up threads have actually returned from <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a955dfe737edb543fee14bb02063819f9">send()</link></computeroutput> or <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a05c8f0dfc8ada1ef0cf6f682bd63f83a">receive()</link></computeroutput>. Other means is needed to ensure that calls to <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a955dfe737edb543fee14bb02063819f9">send()</link></computeroutput> or <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a05c8f0dfc8ada1ef0cf6f682bd63f83a">receive()</link></computeroutput> have returned, e.g., joining the threads that might be blocking on the calls.</para><para>The method also puts the object in stopped state. When in stopped state, calls to <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a955dfe737edb543fee14bb02063819f9">send()</link></computeroutput> or <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a05c8f0dfc8ada1ef0cf6f682bd63f83a">receive()</link></computeroutput> will return immediately with return value <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a27cc657b4b0e49579ba47c9950341b66aaf2b197bcf14794c85c5f313dab0ca31">operation_result::aborted</link></computeroutput> when they would otherwise block in running state.</para><para>Concurrent calls to this method, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a955dfe737edb543fee14bb02063819f9">send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a5a27f67ad735d6f533f9487a77975acd">try_send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a05c8f0dfc8ada1ef0cf6f682bd63f83a">receive()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1aa120bcc08d01104e75243321a569ea9a">try_receive()</link></computeroutput>, and <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ac8bb3912a3ce86b15842e79d0b421204">clear()</link></computeroutput> are allowed.</para><para>
</para></description><requires><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput> </para>
</requires></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a62bd7673395f3eb09306bbb1caa7b675" name="reset_local"><type>void</type><description><para>The method puts the object in running state where calls to <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a955dfe737edb543fee14bb02063819f9">send()</link></computeroutput> or <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a05c8f0dfc8ada1ef0cf6f682bd63f83a">receive()</link></computeroutput> may block. This method is not thread-safe.</para><para>
</para></description><requires><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput> </para>
</requires></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a2ead8fad3dd09d3a8b03e6c948f14e46" name="close" cv="noexcept"><type>void</type><description><para>The method disassociates the associated message queue, if any. No other threads should be using this object before calling this method. The <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad6c62c7386cfdc5a3d6e4c3c5561ddde">stop_local()</link></computeroutput> method can be used to have any threads currently blocked in <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a955dfe737edb543fee14bb02063819f9">send()</link></computeroutput> or <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a05c8f0dfc8ada1ef0cf6f682bd63f83a">receive()</link></computeroutput> return, and prevent further calls to them from blocking. Typically, before calling this method, one would first call <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad6c62c7386cfdc5a3d6e4c3c5561ddde">stop_local()</link></computeroutput> and then join all threads that might be blocking on <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a955dfe737edb543fee14bb02063819f9">send()</link></computeroutput> or <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a05c8f0dfc8ada1ef0cf6f682bd63f83a">receive()</link></computeroutput> to ensure that they have returned from the calls. The associated message queue is destroyed if the object represents the last outstanding reference to it.</para><para>
</para></description><postconditions><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == false</computeroutput> </para>
</postconditions></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a955dfe737edb543fee14bb02063819f9" name="send"><type>operation_result</type><parameter name="message_data"><paramtype>void const *</paramtype><description><para>The message data to send. Ignored when <computeroutput>message_size</computeroutput> is <computeroutput>0</computeroutput>. </para></description></parameter><parameter name="message_size"><paramtype>size_type</paramtype><description><para>Size of the message data in bytes. If the size is larger than the associated message queue capacity, an <computeroutput>std::logic_error</computeroutput> exception is thrown.</para></description></parameter><description><para>The method sends a message to the associated message queue. When the object is in running state and the queue has no free space for the message, the method either blocks or throws an exception, depending on the overflow policy that was specified on the queue opening/creation. If blocking policy is in effect, the blocking can be interrupted by calling <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad6c62c7386cfdc5a3d6e4c3c5561ddde">stop_local()</link></computeroutput>, in which case the method returns <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a27cc657b4b0e49579ba47c9950341b66aaf2b197bcf14794c85c5f313dab0ca31">operation_result::aborted</link></computeroutput>. When the object is already in the stopped state, the method does not block but returns immediately with return value <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a27cc657b4b0e49579ba47c9950341b66aaf2b197bcf14794c85c5f313dab0ca31">operation_result::aborted</link></computeroutput>.</para><para>It is possible to send an empty message by passing <computeroutput>0</computeroutput> to the parameter <computeroutput>message_size</computeroutput>.</para><para>Concurrent calls to <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a955dfe737edb543fee14bb02063819f9">send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a5a27f67ad735d6f533f9487a77975acd">try_send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a05c8f0dfc8ada1ef0cf6f682bd63f83a">receive()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1aa120bcc08d01104e75243321a569ea9a">try_receive()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad6c62c7386cfdc5a3d6e4c3c5561ddde">stop_local()</link></computeroutput>, and <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ac8bb3912a3ce86b15842e79d0b421204">clear()</link></computeroutput> are allowed.</para><para>


<emphasis role="bold">Throws:</emphasis> <computeroutput>std::logic_error</computeroutput> in case if the message size exceeds the queue capacity, <computeroutput>system_error</computeroutput> in case if a native OS method fails. </para></description><requires><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput></para>
</requires></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a5a27f67ad735d6f533f9487a77975acd" name="try_send"><type>bool</type><parameter name="message_data"><paramtype>void const *</paramtype><description><para>The message data to send. Ignored when <computeroutput>message_size</computeroutput> is <computeroutput>0</computeroutput>. </para></description></parameter><parameter name="message_size"><paramtype>size_type</paramtype><description><para>Size of the message data in bytes. If the size is larger than the maximum size allowed by the associated message queue, an <computeroutput>std::logic_error</computeroutput> exception is thrown.</para></description></parameter><description><para>The method performs an attempt to send a message to the associated message queue. The method is non-blocking, and always returns immediately. <computeroutput>boost::system::system_error</computeroutput> is thrown for errors resulting from native operating system calls. Note that it is possible to send an empty message by passing <computeroutput>0</computeroutput> to the parameter <computeroutput>message_size</computeroutput>. Concurrent calls to <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a955dfe737edb543fee14bb02063819f9">send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a5a27f67ad735d6f533f9487a77975acd">try_send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a05c8f0dfc8ada1ef0cf6f682bd63f83a">receive()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1aa120bcc08d01104e75243321a569ea9a">try_receive()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad6c62c7386cfdc5a3d6e4c3c5561ddde">stop_local()</link></computeroutput>, and <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ac8bb3912a3ce86b15842e79d0b421204">clear()</link></computeroutput> are allowed.</para><para>


<emphasis role="bold">Throws:</emphasis> <computeroutput>std::logic_error</computeroutput> in case if the message size exceeds the queue capacity, <computeroutput>system_error</computeroutput> in case if a native OS method fails. </para></description><requires><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput></para>
</requires><returns><para><computeroutput>true</computeroutput> if the message is successfully sent, and <computeroutput>false</computeroutput> otherwise (e.g., when the queue is full).</para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a05c8f0dfc8ada1ef0cf6f682bd63f83a" name="receive"><type>operation_result</type><parameter name="buffer"><paramtype>void *</paramtype><description><para>The memory buffer to store the received message in. </para></description></parameter><parameter name="buffer_size"><paramtype>size_type</paramtype><description><para>The size of the buffer, in bytes. </para></description></parameter><parameter name="message_size"><paramtype>size_type &amp;</paramtype><description><para>Receives the size of the received message, in bytes.</para></description></parameter><description><para>The method takes a message from the associated message queue. When the object is in running state and the queue is empty, the method blocks. The blocking is interrupted when <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad6c62c7386cfdc5a3d6e4c3c5561ddde">stop_local()</link></computeroutput> is called, in which case the method returns <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a27cc657b4b0e49579ba47c9950341b66aaf2b197bcf14794c85c5f313dab0ca31">operation_result::aborted</link></computeroutput>. When the object is already in the stopped state and the queue is empty, the method does not block but returns immediately with return value <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a27cc657b4b0e49579ba47c9950341b66aaf2b197bcf14794c85c5f313dab0ca31">operation_result::aborted</link></computeroutput>.</para><para>Concurrent calls to <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a955dfe737edb543fee14bb02063819f9">send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a5a27f67ad735d6f533f9487a77975acd">try_send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a05c8f0dfc8ada1ef0cf6f682bd63f83a">receive()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1aa120bcc08d01104e75243321a569ea9a">try_receive()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad6c62c7386cfdc5a3d6e4c3c5561ddde">stop_local()</link></computeroutput>, and <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ac8bb3912a3ce86b15842e79d0b421204">clear()</link></computeroutput> are allowed.</para><para>


</para></description><requires><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput></para>
</requires></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad62e5ec40c41837673fab4030a654f7c" name="receive"><type>operation_result</type><template>
          <template-type-parameter name="ElementT"/>
          <template-nontype-parameter name="SizeV"><type>size_type</type></template-nontype-parameter>
        </template><parameter name="buffer"><paramtype>ElementT(&amp;)</paramtype><description><para>The memory buffer to store the received message in. </para></description></parameter><parameter name="message_size"><paramtype>size_type &amp;</paramtype><description><para>Receives the size of the received message, in bytes.</para></description></parameter><description><para>The method takes a message from the associated message queue. When the object is in running state and the queue is empty, the method blocks. The blocking is interrupted when <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad6c62c7386cfdc5a3d6e4c3c5561ddde">stop_local()</link></computeroutput> is called, in which case the method returns <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a27cc657b4b0e49579ba47c9950341b66aaf2b197bcf14794c85c5f313dab0ca31">operation_result::aborted</link></computeroutput>. When the object is already in the stopped state and the queue is empty, the method does not block but returns immediately with return value <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a27cc657b4b0e49579ba47c9950341b66aaf2b197bcf14794c85c5f313dab0ca31">operation_result::aborted</link></computeroutput>.</para><para>Concurrent calls to <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a955dfe737edb543fee14bb02063819f9">send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a5a27f67ad735d6f533f9487a77975acd">try_send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a05c8f0dfc8ada1ef0cf6f682bd63f83a">receive()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1aa120bcc08d01104e75243321a569ea9a">try_receive()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad6c62c7386cfdc5a3d6e4c3c5561ddde">stop_local()</link></computeroutput>, and <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ac8bb3912a3ce86b15842e79d0b421204">clear()</link></computeroutput> are allowed.</para><para>


</para></description><requires><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput></para>
</requires></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a87dd18252939a2d9e1e7098061710323" name="receive"><type>operation_result</type><template>
          <template-type-parameter name="ContainerT"/>
        </template><parameter name="container"><paramtype>ContainerT &amp;</paramtype><description><para>The container to store the received message in. The container should have value type of <computeroutput>char</computeroutput>, <computeroutput>signed char</computeroutput> or <computeroutput>unsigned char</computeroutput> and support inserting elements at the end.</para></description></parameter><description><para>The method takes a message from the associated message queue. When the object is in running state and the queue is empty, the method blocks. The blocking is interrupted when <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad6c62c7386cfdc5a3d6e4c3c5561ddde">stop_local()</link></computeroutput> is called, in which case the method returns <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a27cc657b4b0e49579ba47c9950341b66aaf2b197bcf14794c85c5f313dab0ca31">operation_result::aborted</link></computeroutput>. When the object is already in the stopped state and the queue is empty, the method does not block but returns immediately with return value <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a27cc657b4b0e49579ba47c9950341b66aaf2b197bcf14794c85c5f313dab0ca31">operation_result::aborted</link></computeroutput>.</para><para>Concurrent calls to <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a955dfe737edb543fee14bb02063819f9">send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a5a27f67ad735d6f533f9487a77975acd">try_send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a05c8f0dfc8ada1ef0cf6f682bd63f83a">receive()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1aa120bcc08d01104e75243321a569ea9a">try_receive()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad6c62c7386cfdc5a3d6e4c3c5561ddde">stop_local()</link></computeroutput>, and <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ac8bb3912a3ce86b15842e79d0b421204">clear()</link></computeroutput> are allowed.</para><para>


</para></description><requires><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput></para>
</requires></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1aa120bcc08d01104e75243321a569ea9a" name="try_receive"><type>bool</type><parameter name="buffer"><paramtype>void *</paramtype><description><para>The memory buffer to store the received message in. </para></description></parameter><parameter name="buffer_size"><paramtype>size_type</paramtype><description><para>The size of the buffer, in bytes. </para></description></parameter><parameter name="message_size"><paramtype>size_type &amp;</paramtype><description><para>Receives the size of the received message, in bytes.</para></description></parameter><description><para>The method performs an attempt to take a message from the associated message queue. The method is non-blocking, and always returns immediately.</para><para>Concurrent calls to <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a955dfe737edb543fee14bb02063819f9">send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a5a27f67ad735d6f533f9487a77975acd">try_send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a05c8f0dfc8ada1ef0cf6f682bd63f83a">receive()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1aa120bcc08d01104e75243321a569ea9a">try_receive()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad6c62c7386cfdc5a3d6e4c3c5561ddde">stop_local()</link></computeroutput>, and <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ac8bb3912a3ce86b15842e79d0b421204">clear()</link></computeroutput> are allowed.</para><para>


</para></description><requires><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput></para>
</requires><returns><para><computeroutput>true</computeroutput> if a message is successfully received, and <computeroutput>false</computeroutput> otherwise (e.g., when the queue is empty). </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1aa980e22f7baca8a3a3932d76843e87d1" name="try_receive"><type>bool</type><template>
          <template-type-parameter name="ElementT"/>
          <template-nontype-parameter name="SizeV"><type>size_type</type></template-nontype-parameter>
        </template><parameter name="buffer"><paramtype>ElementT(&amp;)</paramtype><description><para>The memory buffer to store the received message in. </para></description></parameter><parameter name="message_size"><paramtype>size_type &amp;</paramtype><description><para>Receives the size of the received message, in bytes.</para></description></parameter><description><para>The method performs an attempt to take a message from the associated message queue. The method is non-blocking, and always returns immediately.</para><para>Concurrent calls to <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a955dfe737edb543fee14bb02063819f9">send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a5a27f67ad735d6f533f9487a77975acd">try_send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a05c8f0dfc8ada1ef0cf6f682bd63f83a">receive()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1aa120bcc08d01104e75243321a569ea9a">try_receive()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad6c62c7386cfdc5a3d6e4c3c5561ddde">stop_local()</link></computeroutput>, and <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ac8bb3912a3ce86b15842e79d0b421204">clear()</link></computeroutput> are allowed.</para><para>


</para></description><requires><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput></para>
</requires><returns><para><computeroutput>true</computeroutput> if a message is successfully received, and <computeroutput>false</computeroutput> otherwise (e.g., when the queue is empty). </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a485f9e9cd0c239a47ada4a0d038c2bd8" name="try_receive"><type>bool</type><template>
          <template-type-parameter name="ContainerT"/>
        </template><parameter name="container"><paramtype>ContainerT &amp;</paramtype><description><para>The container to store the received message in. The container should have value type of <computeroutput>char</computeroutput>, <computeroutput>signed char</computeroutput> or <computeroutput>unsigned char</computeroutput> and support inserting elements at the end.</para></description></parameter><description><para>The method performs an attempt to take a message from the associated message queue. The method is non-blocking, and always returns immediately.</para><para>Concurrent calls to <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a955dfe737edb543fee14bb02063819f9">send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a5a27f67ad735d6f533f9487a77975acd">try_send()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a05c8f0dfc8ada1ef0cf6f682bd63f83a">receive()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1aa120bcc08d01104e75243321a569ea9a">try_receive()</link></computeroutput>, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad6c62c7386cfdc5a3d6e4c3c5561ddde">stop_local()</link></computeroutput>, and <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ac8bb3912a3ce86b15842e79d0b421204">clear()</link></computeroutput> are allowed.</para><para>


</para></description><requires><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a7c9a4b086ca31f15d16f4004a0c12858">is_open()</link> == true</computeroutput></para>
</requires><returns><para><computeroutput>true</computeroutput> if a message is successfully received, and <computeroutput>false</computeroutput> otherwise (e.g., when the queue is empty). </para>
</returns></method>
</method-group>
<method-group name="friend functions">
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1ad4848f6fb9e2eb0f52c36aabbbc474e7" name="swap" cv="noexcept"><type>void</type><parameter name="a"><paramtype><classname>reliable_message_queue</classname> &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>reliable_message_queue</classname> &amp;</paramtype></parameter><purpose>Swaps the two <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue">reliable_message_queue</link></computeroutput> objects. </purpose></method>
</method-group>
<method-group name="public static functions">
<method id="doxygen.utilities.classboost_1_1log_1_1ipc_1_1reliable__message__queue_1a3fe6a33676ecfe68062edf50dcc956be" name="remove" specifiers="static"><type>void</type><parameter name="name"><paramtype><classname>object_name</classname> const &amp;</paramtype><description><para>Name of the message queue to be removed. </para></description></parameter><description><para>The method frees system-wide resources, associated with the interprocess queue with the supplied name. The queue referred to by the specified name must not be opened in any process at the point of this call. After this call succeeds a new queue with the specified name can be created.</para><para>This call can be useful to recover from an earlier process misbehavior (e.g. a crash without properly closing the message queue). In this case resources allocated for the interprocess queue may remain allocated after the last process closed the queue, which in turn may prevent creating a new queue with the same name. By calling this method before creating a queue the application can attempt to ensure it starts with a clean slate.</para><para>On some platforms resources associated with the queue are automatically reclaimed by the operating system when the last process using those resources terminates (even if it terminates abnormally). On these platforms this call may be a no-op. However, portable code should still call this method at appropriate places to ensure compatibility with other platforms and future library versions, which may change implementation of the queue.</para><para>
</para></description></method>
</method-group>
</class></namespace>



















































































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.manipulators_8hpp" name="boost/log/utility/manipulators.hpp">
<para><para>Andrey Semashev </para>

<para>06.11.2012</para>

This header includes all manipulators. </para></header>
<header id="doxygen.utilities.add__value_8hpp" name="boost/log/utility/manipulators/add_value.hpp">
<para><para>Andrey Semashev </para>

<para>26.11.2012</para>

This header contains the <computeroutput>add_value</computeroutput> manipulator. </para><namespace name="boost">
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1add__value__manip" name="add_value_manip"><template>
      <template-type-parameter name="RefT"/>
    </template><purpose>Attribute value manipulator. </purpose><typedef id="doxygen.utilities.classboost_1_1log_1_1add__value__manip_1a76c85b0ec62cced0da896e3bb2d4501f" name="reference_type"><purpose>Stored reference type. </purpose><type>RefT</type></typedef>
<typedef id="doxygen.utilities.classboost_1_1log_1_1add__value__manip_1a96c1d19a2052314e55139f538e7b0429" name="value_type"><purpose>Attribute value type. </purpose><type>remove_cv&lt; typenameremove_reference&lt; reference_type &gt;::type &gt;::type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1add__value__manip_1adbe352f4daf7b79dc34152ea03379cd7"><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="value"><paramtype>reference_type</paramtype></parameter><purpose>Initializing constructor. </purpose></constructor>
<method id="doxygen.utilities.classboost_1_1log_1_1add__value__manip_1ab4930a89e24e98e354a4803de84f0dc5" name="get_name" cv="const"><type>attribute_name</type><purpose>Returns attribute name. </purpose></method>
<method id="doxygen.utilities.classboost_1_1log_1_1add__value__manip_1ad8399cb7a7c9649358ceef7de4454159" name="get_value" cv="const"><type>get_value_result_type</type><purpose>Returns attribute value. </purpose></method>
</method-group>
</class>













































































































<function id="doxygen.utilities.add__value_8hpp_1abf678b468a082268438638280e51aa9b" name="operator&lt;&lt;"><type>basic_record_ostream&lt; CharT &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="RefT"/>
        </template><parameter name="strm"><paramtype>basic_record_ostream&lt; CharT &gt; &amp;</paramtype></parameter><parameter name="manip"><paramtype><classname>add_value_manip</classname>&lt; RefT &gt; const &amp;</paramtype></parameter><purpose>The operator attaches an attribute value to the log record. </purpose></function>
<function id="doxygen.utilities.add__value_8hpp_1a871eb938cb52e5e485973671d768a327" name="add_value"><type><classname>add_value_manip</classname>&lt; T &amp;&amp; &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="value"><paramtype>T &amp;&amp;</paramtype></parameter><purpose>The function creates a manipulator that attaches an attribute value to a log record. </purpose></function>
<function id="doxygen.utilities.add__value_8hpp_1a91838311efeddd91644e5b9a2b4895d4" name="add_value"><type><classname>add_value_manip</classname>&lt; typename DescriptorT::value_type &amp;&amp; &gt;</type><template>
          <template-type-parameter name="DescriptorT"/>
          <template-nontype-parameter name="ActorT"><type>template&lt; typename &gt; class</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>expressions::attribute_keyword&lt; DescriptorT, ActorT &gt; const &amp;</paramtype></parameter><parameter name="value"><paramtype>typename DescriptorT::value_type &amp;&amp;</paramtype></parameter><purpose>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </purpose></function>
<function id="doxygen.utilities.add__value_8hpp_1a13042ddb68cf68a38c891009045512fc" name="add_value"><type><classname>add_value_manip</classname>&lt; typename DescriptorT::value_type &amp; &gt;</type><template>
          <template-type-parameter name="DescriptorT"/>
          <template-nontype-parameter name="ActorT"><type>template&lt; typename &gt; class</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>expressions::attribute_keyword&lt; DescriptorT, ActorT &gt; const &amp;</paramtype></parameter><parameter name="value"><paramtype>typename DescriptorT::value_type &amp;</paramtype></parameter><purpose>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </purpose></function>
<function id="doxygen.utilities.add__value_8hpp_1a5cfff6da4200d9313e4001bdad3eb490" name="add_value"><type><classname>add_value_manip</classname>&lt; typename DescriptorT::value_type const &amp; &gt;</type><template>
          <template-type-parameter name="DescriptorT"/>
          <template-nontype-parameter name="ActorT"><type>template&lt; typename &gt; class</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>expressions::attribute_keyword&lt; DescriptorT, ActorT &gt; const &amp;</paramtype></parameter><parameter name="value"><paramtype>typename DescriptorT::value_type const &amp;</paramtype></parameter><purpose>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </purpose></function>
</namespace>
</namespace>
</header>
<header id="doxygen.utilities.auto__newline_8hpp" name="boost/log/utility/manipulators/auto_newline.hpp">
<para><para>Andrey Semashev </para>

<para>23.06.2019</para>

The header contains implementation of a stream manipulator for inserting a newline, unless there is already one inserted. </para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1auto__newline__manip" name="auto_newline_manip"><description><para>Stream manipulator for inserting a newline character, unless the last character inserted into the stream is already a newline. </para></description></struct><data-member id="doxygen.utilities.auto__newline_8hpp_1a6defc6a2c58085837c49558365d0d6a9" name="auto_newline"><type>struct <classname>boost::log::auto_newline_manip</classname></type></data-member>













































































































<function id="doxygen.utilities.auto__newline_8hpp_1ad8140e30e6f51e60de07075c21f805de" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TraitsT"/>
          <template-type-parameter name="AllocatorT"/>
        </template><parameter name="strm"><paramtype><classname>basic_formatting_ostream</classname>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><classname>auto_newline_manip</classname></paramtype></parameter><description><para>Stream output operator for the <computeroutput>auto_newline</computeroutput> manipulator </para></description></function>





</namespace>
</namespace>
</header>
<header id="doxygen.utilities.dump_8hpp" name="boost/log/utility/manipulators/dump.hpp">
<para><para>Andrey Semashev </para>

<para>03.05.2013</para>

This header contains the <computeroutput>dump</computeroutput> output manipulator. </para><namespace name="boost">
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1bounded__dump__manip" name="bounded_dump_manip"><inherit access="public">dump_manip</inherit><purpose>Manipulator for printing binary representation of the data with a size limit. </purpose><method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1bounded__dump__manip_1a9406fc413b7f9481eccfdab67b1d36c7" cv="noexcept"><parameter name="data"><paramtype>const void *</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="max_size"><paramtype>std::size_t</paramtype></parameter></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1bounded__dump__manip_1aa7f52c63adb838114957d16a2b2e932e" cv="noexcept"><parameter name="that"><paramtype><classname>bounded_dump_manip</classname> const &amp;</paramtype></parameter></constructor>
<method id="doxygen.utilities.classboost_1_1log_1_1bounded__dump__manip_1a45ad52f1247ce052c07c1129cfcee804" name="get_max_size" cv="const noexcept"><type>std::size_t</type></method>
</method-group>
</class><class id="doxygen.utilities.classboost_1_1log_1_1dump__manip" name="dump_manip"><purpose>Manipulator for printing binary representation of the data. </purpose><method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1dump__manip_1affe3c0e3cf02f871c9ee9f5a86807eda" cv="noexcept"><parameter name="data"><paramtype>const void *</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1dump__manip_1ad5695b0974bc81a49e9d2a839270fe0e" cv="noexcept"><parameter name="that"><paramtype><classname>dump_manip</classname> const &amp;</paramtype></parameter></constructor>
<method id="doxygen.utilities.classboost_1_1log_1_1dump__manip_1aded20fad9cb4a601a59c982f3ebcb479" name="get_data" cv="const noexcept"><type>const void *</type></method>
<method id="doxygen.utilities.classboost_1_1log_1_1dump__manip_1a862b474971485d541cde55bb6c8df36f" name="get_size" cv="const noexcept"><type>std::size_t</type></method>
</method-group>
</class>






































































































<function id="doxygen.utilities.dump_8hpp_1a5c4de378f55800481cc22bf1c03f78f3" name="operator&lt;&lt;"><type>std::basic_ostream&lt; CharT, TraitsT &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TraitsT"/>
        </template><parameter name="strm"><paramtype>std::basic_ostream&lt; CharT, TraitsT &gt; &amp;</paramtype></parameter><parameter name="manip"><paramtype><classname>dump_manip</classname> const &amp;</paramtype></parameter><purpose>The operator outputs binary data to a stream. </purpose></function>
<function id="doxygen.utilities.dump_8hpp_1af659cbbf3f17fb64c43d7fb667d6aba0" name="operator&lt;&lt;"><type>std::basic_ostream&lt; CharT, TraitsT &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TraitsT"/>
        </template><parameter name="strm"><paramtype>std::basic_ostream&lt; CharT, TraitsT &gt; &amp;</paramtype></parameter><parameter name="manip"><paramtype><classname>bounded_dump_manip</classname> const &amp;</paramtype></parameter><purpose>The operator outputs binary data to a stream. </purpose></function>
<function id="doxygen.utilities.dump_8hpp_1a421e94ed37b696c8f37d7815e1794485" name="dump"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="data"><paramtype>T *</paramtype><description><para>The pointer to the beginning of the region </para></description></parameter><parameter name="size"><paramtype>std::size_t</paramtype><description><para>The size of the region, in bytes </para></description></parameter><purpose>Creates a stream manipulator that will output contents of a memory region in hexadecimal form. </purpose><description><para>

</para></description><returns><para>The manipulator that is to be put to a stream </para>
</returns></function>
<function id="doxygen.utilities.dump_8hpp_1ac4d58b8546fe288b29b692e2075d287d" name="dump_elements"><type><classname>dump_manip</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="data"><paramtype>T *</paramtype><description><para>The pointer to the beginning of the array </para></description></parameter><parameter name="count"><paramtype>std::size_t</paramtype><description><para>The size of the region, in number of <computeroutput>T</computeroutput> elements </para></description></parameter><purpose>Creates a stream manipulator that will dump elements of an array in hexadecimal form. </purpose><description><para>

</para></description><returns><para>The manipulator that is to be put to a stream </para>
</returns></function>
<function id="doxygen.utilities.dump_8hpp_1ad0c8c4eb62e1e0e697dfae13f0a6ff2d" name="dump"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="data"><paramtype>T *</paramtype><description><para>The pointer to the beginning of the region </para></description></parameter><parameter name="size"><paramtype>std::size_t</paramtype><description><para>The size of the region, in bytes </para></description></parameter><parameter name="max_size"><paramtype>std::size_t</paramtype><description><para>The maximum number of bytes of the region to output </para></description></parameter><purpose>Creates a stream manipulator that will output contents of a memory region in hexadecimal form. </purpose><description><para>

</para></description><returns><para>The manipulator that is to be put to a stream </para>
</returns></function>
<function id="doxygen.utilities.dump_8hpp_1a4a3b9005a9cefcdcc91bfce01ed92cca" name="dump_elements"><type><classname>bounded_dump_manip</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="data"><paramtype>T *</paramtype><description><para>The pointer to the beginning of the array </para></description></parameter><parameter name="count"><paramtype>std::size_t</paramtype><description><para>The size of the region, in number of <computeroutput>T</computeroutput> elements </para></description></parameter><parameter name="max_count"><paramtype>std::size_t</paramtype><description><para>The maximum number of elements to output </para></description></parameter><purpose>Creates a stream manipulator that will dump elements of an array in hexadecimal form. </purpose><description><para>

</para></description><returns><para>The manipulator that is to be put to a stream </para>
</returns></function>






</namespace>
</namespace>
</header>
<header id="doxygen.utilities.invoke_8hpp" name="boost/log/utility/manipulators/invoke.hpp">
<para><para>Andrey Semashev </para>

<para>27.02.2022</para>

The header contains implementation of a stream manipulator for invoking a user-defined function. </para><namespace name="boost">
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1invoke__manipulator" name="invoke_manipulator"><template>
      <template-type-parameter name="FunctionT"/>
    </template><description><para>Stream manipulator for invoking a user-defined function as part of stream output. </para></description><method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1invoke__manipulator_1a91f77d7997659d977dc542beab3a335a" specifiers="explicit"><parameter name="func"><paramtype>FunctionT const &amp;</paramtype></parameter><purpose>Initializing constructor. </purpose></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1invoke__manipulator_1a547be8fc43764280c06794d365c6cb96" specifiers="explicit"><parameter name="func"><paramtype>FunctionT &amp;&amp;</paramtype></parameter><purpose>Initializing constructor. </purpose></constructor>
<method id="doxygen.utilities.classboost_1_1log_1_1invoke__manipulator_1af1286d797863f31398792fb0fae32954" name="output" cv="const"><type>void</type><template>
          <template-type-parameter name="StreamT"/>
        </template><parameter name="stream"><paramtype>StreamT &amp;</paramtype></parameter><purpose>The method invokes the saved function with the output stream. </purpose></method>
</method-group>
</class>




































































































<function id="doxygen.utilities.invoke_8hpp_1a448759efeb68fa85605dec04f8d80046" name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="FunctionT"/>
        </template><parameter name="stream"><paramtype>StreamT &amp;</paramtype></parameter><parameter name="manip"><paramtype><classname>invoke_manipulator</classname>&lt; FunctionT &gt; const &amp;</paramtype></parameter><description><para>Stream output operator for <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1invoke__manipulator">invoke_manipulator</link></computeroutput>. Invokes the function saved in the manipulator. </para></description></function>
<function id="doxygen.utilities.invoke_8hpp_1a842715c8d51f1902a4ae772d0f59c4b7" name="invoke_manip"><type><classname>invoke_manipulator</classname>&lt; unspecified &gt;</type><template>
          <template-type-parameter name="FunctionT"/>
          <template-nontype-parameter name="Args"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="func"><paramtype>FunctionT &amp;&amp;</paramtype><description><para>User-defined function to invoke on output. The function must be callable with a reference to the output stream as the first argument, followed by <emphasis>args</emphasis>. </para></description></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype><description><para>Additional arguments to pass to <emphasis>func</emphasis>. </para></description></parameter><description><para>Invoke manipulator generator function.</para><para>

<note><para><emphasis>args</emphasis> are only supported since C++14. </para>
</note>
</para></description><returns><para>Manipulator to be inserted into the stream.</para>
</returns></function>












</namespace>
</namespace>
</header>
<header id="doxygen.utilities.optional_8hpp" name="boost/log/utility/manipulators/optional.hpp">
<para><para>Andrey Semashev </para>

<para>12.05.2020</para>

The header contains implementation of a stream manipulator for inserting an optional value. </para><namespace name="boost">
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1optional__manipulator" name="optional_manipulator"><template>
      <template-type-parameter name="OptionalT"/>
      <template-type-parameter name="NoneT"/>
    </template><description><para>Stream manipulator for inserting an optional value. </para></description><method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1optional__manipulator_1a4e339fcbbe063013c0e47ac12c1bef44" cv="noexcept"><parameter name="opt"><paramtype>stored_optional_type</paramtype></parameter><parameter name="none"><paramtype>stored_none_type</paramtype></parameter><purpose>Initializing constructor. </purpose></constructor>
<method id="doxygen.utilities.classboost_1_1log_1_1optional__manipulator_1af1286d797863f31398792fb0fae32954" name="output" cv="const"><type>void</type><template>
          <template-type-parameter name="StreamT"/>
        </template><parameter name="stream"><paramtype>StreamT &amp;</paramtype></parameter><purpose>The method outputs the value, if it is present, otherwise outputs the "none" marker. </purpose></method>
</method-group>
</class><class-specialization id="doxygen.utilities.classboost_1_1log_1_1optional__manipulator_3_01OptionalT_00_01void_01_4" name="optional_manipulator"><template>
      <template-type-parameter name="OptionalT"/>
    </template><specialization><template-arg>OptionalT</template-arg><template-arg>void</template-arg></specialization><description><para>Stream manipulator for inserting an optional value. Specialization for no "none" marker. </para></description><method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1optional__manipulator_3_01OptionalT_00_01void_01_4_1a9475cc99b9cc632f7a6b08500af06897" cv="noexcept"><parameter name="opt"><paramtype>stored_optional_type</paramtype></parameter><purpose>Initializing constructor. </purpose></constructor>
<method id="doxygen.utilities.classboost_1_1log_1_1optional__manipulator_3_01OptionalT_00_01void_01_4_1af1286d797863f31398792fb0fae32954" name="output" cv="const"><type>void</type><template>
          <template-type-parameter name="StreamT"/>
        </template><parameter name="stream"><paramtype>StreamT &amp;</paramtype></parameter><purpose>The method outputs the value, if it is present. </purpose></method>
</method-group>
</class-specialization>



























































































<function id="doxygen.utilities.optional_8hpp_1a7636bbc0e601d37a04fa8234f2498395" name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="OptionalT"/>
          <template-type-parameter name="NoneT"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter><parameter name="manip"><paramtype><classname>optional_manipulator</classname>&lt; OptionalT, NoneT &gt; const &amp;</paramtype></parameter><description><para>Stream output operator for <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1optional__manipulator">optional_manipulator</link></computeroutput>. Outputs the optional value or the "none" marker, if one was specified on manipulator construction. </para></description></function>
<function id="doxygen.utilities.optional_8hpp_1acc8f075c203481115d27052b56130246" name="optional_manip"><type>boost::enable_if_c&lt; is_scalar&lt; OptionalT &gt;::value &amp;&amp;is_scalar&lt; NoneT &gt;::value, <classname>optional_manipulator</classname>&lt; OptionalT, NoneT &gt; &gt;::type</type><template>
          <template-type-parameter name="OptionalT"/>
          <template-type-parameter name="NoneT"/>
        </template><parameter name="opt"><paramtype>OptionalT</paramtype><description><para>Optional value to output. The optional value must support contextual conversion to <computeroutput>bool</computeroutput> and dereferencing, and its dereferencing result must support stream output. </para></description></parameter><parameter name="none"><paramtype>NoneT</paramtype><description><para>Marker used to indicate when the value is not present. Optional. If not specified, nothing is output if the value is not present. </para></description></parameter><description><para>Optional manipulator generator function.</para><para>

<note><para>Both <emphasis>opt</emphasis> and <emphasis>none</emphasis> objects must outlive the created manipulator object. </para>
</note>
</para></description><returns><para>Manipulator to be inserted into the stream.</para>
</returns></function>
<function id="doxygen.utilities.optional_8hpp_1a23c272041f68f6a079b2f901c87d735d" name="optional_manip"><type>boost::enable_if_c&lt; is_scalar&lt; OptionalT &gt;::value &amp;&amp;!is_scalar&lt; NoneT &gt;::value, <classname>optional_manipulator</classname>&lt; OptionalT, NoneT &gt; &gt;::type</type><template>
          <template-type-parameter name="OptionalT"/>
          <template-type-parameter name="NoneT"/>
        </template><parameter name="opt"><paramtype>OptionalT</paramtype><description><para>Optional value to output. The optional value must support contextual conversion to <computeroutput>bool</computeroutput> and dereferencing, and its dereferencing result must support stream output. </para></description></parameter><parameter name="none"><paramtype>NoneT const &amp;</paramtype><description><para>Marker used to indicate when the value is not present. Optional. If not specified, nothing is output if the value is not present. </para></description></parameter><description><para>Optional manipulator generator function.</para><para>

<note><para>Both <emphasis>opt</emphasis> and <emphasis>none</emphasis> objects must outlive the created manipulator object. </para>
</note>
</para></description><returns><para>Manipulator to be inserted into the stream.</para>
</returns></function>
<function id="doxygen.utilities.optional_8hpp_1aff82c94efc4a77bb794bfb4eaee89b1d" name="optional_manip"><type>boost::enable_if_c&lt; is_scalar&lt; OptionalT &gt;::value, <classname>optional_manipulator</classname>&lt; OptionalT, NoneElementT * &gt; &gt;::type</type><template>
          <template-type-parameter name="OptionalT"/>
          <template-type-parameter name="NoneElementT"/>
          <template-nontype-parameter name="N"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="opt"><paramtype>OptionalT</paramtype><description><para>Optional value to output. The optional value must support contextual conversion to <computeroutput>bool</computeroutput> and dereferencing, and its dereferencing result must support stream output. </para></description></parameter><parameter name="none"><paramtype>NoneElementT(&amp;)</paramtype><description><para>Marker used to indicate when the value is not present. Optional. If not specified, nothing is output if the value is not present. </para></description></parameter><description><para>Optional manipulator generator function.</para><para>

<note><para>Both <emphasis>opt</emphasis> and <emphasis>none</emphasis> objects must outlive the created manipulator object. </para>
</note>
</para></description><returns><para>Manipulator to be inserted into the stream.</para>
</returns></function>
<function id="doxygen.utilities.optional_8hpp_1ad7dc2a0a142ac08185d6866cdca5344c" name="optional_manip"><type>boost::enable_if_c&lt;!is_scalar&lt; OptionalT &gt;::value &amp;&amp;!is_array&lt; OptionalT &gt;::value &amp;&amp;is_scalar&lt; NoneT &gt;::value, <classname>optional_manipulator</classname>&lt; OptionalT, NoneT &gt; &gt;::type</type><template>
          <template-type-parameter name="OptionalT"/>
          <template-type-parameter name="NoneT"/>
        </template><parameter name="opt"><paramtype>OptionalT const &amp;</paramtype><description><para>Optional value to output. The optional value must support contextual conversion to <computeroutput>bool</computeroutput> and dereferencing, and its dereferencing result must support stream output. </para></description></parameter><parameter name="none"><paramtype>NoneT</paramtype><description><para>Marker used to indicate when the value is not present. Optional. If not specified, nothing is output if the value is not present. </para></description></parameter><description><para>Optional manipulator generator function.</para><para>

<note><para>Both <emphasis>opt</emphasis> and <emphasis>none</emphasis> objects must outlive the created manipulator object. </para>
</note>
</para></description><returns><para>Manipulator to be inserted into the stream.</para>
</returns></function>
<function id="doxygen.utilities.optional_8hpp_1a08e40c05ddd584e6c1ad571fc8304e27" name="optional_manip"><type>boost::enable_if_c&lt;!is_scalar&lt; OptionalT &gt;::value &amp;&amp;!is_array&lt; OptionalT &gt;::value &amp;&amp;!is_scalar&lt; NoneT &gt;::value, <classname>optional_manipulator</classname>&lt; OptionalT, NoneT &gt; &gt;::type</type><template>
          <template-type-parameter name="OptionalT"/>
          <template-type-parameter name="NoneT"/>
        </template><parameter name="opt"><paramtype>OptionalT const &amp;</paramtype><description><para>Optional value to output. The optional value must support contextual conversion to <computeroutput>bool</computeroutput> and dereferencing, and its dereferencing result must support stream output. </para></description></parameter><parameter name="none"><paramtype>NoneT const &amp;</paramtype><description><para>Marker used to indicate when the value is not present. Optional. If not specified, nothing is output if the value is not present. </para></description></parameter><description><para>Optional manipulator generator function.</para><para>

<note><para>Both <emphasis>opt</emphasis> and <emphasis>none</emphasis> objects must outlive the created manipulator object. </para>
</note>
</para></description><returns><para>Manipulator to be inserted into the stream.</para>
</returns></function>
<function id="doxygen.utilities.optional_8hpp_1aaedbe86189bf193641acd2b75be7a4a8" name="optional_manip"><type>boost::enable_if_c&lt;!is_scalar&lt; OptionalT &gt;::value &amp;&amp;!is_array&lt; OptionalT &gt;::value, <classname>optional_manipulator</classname>&lt; OptionalT, NoneElementT * &gt; &gt;::type</type><template>
          <template-type-parameter name="OptionalT"/>
          <template-type-parameter name="NoneElementT"/>
          <template-nontype-parameter name="N"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="opt"><paramtype>OptionalT const &amp;</paramtype><description><para>Optional value to output. The optional value must support contextual conversion to <computeroutput>bool</computeroutput> and dereferencing, and its dereferencing result must support stream output. </para></description></parameter><parameter name="none"><paramtype>NoneElementT(&amp;)</paramtype><description><para>Marker used to indicate when the value is not present. Optional. If not specified, nothing is output if the value is not present. </para></description></parameter><description><para>Optional manipulator generator function.</para><para>

<note><para>Both <emphasis>opt</emphasis> and <emphasis>none</emphasis> objects must outlive the created manipulator object. </para>
</note>
</para></description><returns><para>Manipulator to be inserted into the stream.</para>
</returns></function>
<function id="doxygen.utilities.optional_8hpp_1a9cd3c996d4b0228257d960a56460c367" name="optional_manip"><type>boost::enable_if_c&lt; is_scalar&lt; OptionalT &gt;::value, <classname>optional_manipulator</classname>&lt; OptionalT, void &gt; &gt;::type</type><template>
          <template-type-parameter name="OptionalT"/>
        </template><parameter name="opt"><paramtype>OptionalT</paramtype><description><para>Optional value to output. The optional value must support contextual conversion to <computeroutput>bool</computeroutput> and dereferencing, and its dereferencing result must support stream output. </para></description></parameter><description><para>Optional manipulator generator function.</para><para>

<note><para><emphasis>opt</emphasis> object must outlive the created manipulator object. </para>
</note>
</para></description><returns><para>Manipulator to be inserted into the stream.</para>
</returns></function>
<function id="doxygen.utilities.optional_8hpp_1ac3a1ba264dbd518cec730263ccca41b3" name="optional_manip"><type>boost::enable_if_c&lt;!is_scalar&lt; OptionalT &gt;::value &amp;&amp;!is_array&lt; OptionalT &gt;::value, <classname>optional_manipulator</classname>&lt; OptionalT, void &gt; &gt;::type</type><template>
          <template-type-parameter name="OptionalT"/>
        </template><parameter name="opt"><paramtype>OptionalT const &amp;</paramtype><description><para>Optional value to output. The optional value must support contextual conversion to <computeroutput>bool</computeroutput> and dereferencing, and its dereferencing result must support stream output. </para></description></parameter><description><para>Optional manipulator generator function.</para><para>

<note><para><emphasis>opt</emphasis> object must outlive the created manipulator object. </para>
</note>
</para></description><returns><para>Manipulator to be inserted into the stream.</para>
</returns></function>














</namespace>
</namespace>
</header>
<header id="doxygen.utilities.range_8hpp" name="boost/log/utility/manipulators/range.hpp">
<para><para>Andrey Semashev </para>

<para>11.05.2020</para>

The header contains implementation of a stream manipulator for inserting a range of elements, optionally separated with a delimiter. </para><namespace name="boost">
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1range__manipulator" name="range_manipulator"><template>
      <template-type-parameter name="RangeT"/>
      <template-type-parameter name="DelimiterT"/>
    </template><description><para>Stream manipulator for inserting a range of elements, optionally separated with a delimiter. </para></description><method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1range__manipulator_1a2901db163b4b1b9940e0bf0da45ef14d" cv="noexcept"><parameter name="range"><paramtype>RangeT const &amp;</paramtype></parameter><parameter name="delimiter"><paramtype>stored_delimiter_type</paramtype></parameter><purpose>Initializing constructor. </purpose></constructor>
<method id="doxygen.utilities.classboost_1_1log_1_1range__manipulator_1af1286d797863f31398792fb0fae32954" name="output" cv="const"><type>void</type><template>
          <template-type-parameter name="StreamT"/>
        </template><parameter name="stream"><paramtype>StreamT &amp;</paramtype></parameter><purpose>The method outputs elements of the range separated with delimiter. </purpose></method>
</method-group>
</class><class-specialization id="doxygen.utilities.classboost_1_1log_1_1range__manipulator_3_01RangeT_00_01void_01_4" name="range_manipulator"><template>
      <template-type-parameter name="RangeT"/>
    </template><specialization><template-arg>RangeT</template-arg><template-arg>void</template-arg></specialization><description><para>Stream manipulator for inserting a range of elements. Specialization for when there is no delimiter. </para></description><method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1range__manipulator_3_01RangeT_00_01void_01_4_1ac6e2da2cf2df5241dd6bd5f0425765ca" specifiers="explicit" cv="noexcept"><parameter name="range"><paramtype>RangeT const &amp;</paramtype></parameter><purpose>Initializing constructor. </purpose></constructor>
<method id="doxygen.utilities.classboost_1_1log_1_1range__manipulator_3_01RangeT_00_01void_01_4_1af1286d797863f31398792fb0fae32954" name="output" cv="const"><type>void</type><template>
          <template-type-parameter name="StreamT"/>
        </template><parameter name="stream"><paramtype>StreamT &amp;</paramtype></parameter><purpose>The method outputs elements of the range. </purpose></method>
</method-group>
</class-specialization>






















































































<function id="doxygen.utilities.range_8hpp_1a5440c7dae4dfe1e89ad96bf9aea2fc95" name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="RangeT"/>
          <template-type-parameter name="DelimiterT"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter><parameter name="manip"><paramtype><classname>range_manipulator</classname>&lt; RangeT, DelimiterT &gt; const &amp;</paramtype></parameter><description><para>Stream output operator for <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1range__manipulator">range_manipulator</link></computeroutput>. Outputs every element of the range, separated with a delimiter, if one was specified on manipulator construction. </para></description></function>
<function id="doxygen.utilities.range_8hpp_1a1e8293cbbed40c4850bde8462047bc25" name="range_manip"><type>boost::enable_if_c&lt; is_scalar&lt; DelimiterT &gt;::value, <classname>range_manipulator</classname>&lt; RangeT, DelimiterT &gt; &gt;::type</type><template>
          <template-type-parameter name="RangeT"/>
          <template-type-parameter name="DelimiterT"/>
        </template><parameter name="range"><paramtype>RangeT const &amp;</paramtype><description><para>Range of elements to output. The range must support begin and end iterators, and its elements must support stream output. </para></description></parameter><parameter name="delimiter"><paramtype>DelimiterT</paramtype><description><para>Delimiter to separate elements in the output. Optional. If not specified, elements are output without separation. </para></description></parameter><description><para>Range manipulator generator function.</para><para>

<note><para>Both <emphasis>range</emphasis> and <emphasis>delimiter</emphasis> objects must outlive the created manipulator object. </para>
</note>
</para></description><returns><para>Manipulator to be inserted into the stream.</para>
</returns></function>
<function id="doxygen.utilities.range_8hpp_1a2b110640833714e5bd2a1b687b0e8d3c" name="range_manip"><type>boost::disable_if_c&lt; is_scalar&lt; DelimiterT &gt;::value, <classname>range_manipulator</classname>&lt; RangeT, DelimiterT &gt; &gt;::type</type><template>
          <template-type-parameter name="RangeT"/>
          <template-type-parameter name="DelimiterT"/>
        </template><parameter name="range"><paramtype>RangeT const &amp;</paramtype><description><para>Range of elements to output. The range must support begin and end iterators, and its elements must support stream output. </para></description></parameter><parameter name="delimiter"><paramtype>DelimiterT const &amp;</paramtype><description><para>Delimiter to separate elements in the output. Optional. If not specified, elements are output without separation. </para></description></parameter><description><para>Range manipulator generator function.</para><para>

<note><para>Both <emphasis>range</emphasis> and <emphasis>delimiter</emphasis> objects must outlive the created manipulator object. </para>
</note>
</para></description><returns><para>Manipulator to be inserted into the stream.</para>
</returns></function>
<function id="doxygen.utilities.range_8hpp_1a01770834006aa6ba31e9eb3f4ee6a07b" name="range_manip"><type><classname>range_manipulator</classname>&lt; RangeT, DelimiterElementT * &gt;</type><template>
          <template-type-parameter name="RangeT"/>
          <template-type-parameter name="DelimiterElementT"/>
          <template-nontype-parameter name="N"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="range"><paramtype>RangeT const &amp;</paramtype><description><para>Range of elements to output. The range must support begin and end iterators, and its elements must support stream output. </para></description></parameter><parameter name="delimiter"><paramtype>DelimiterElementT(&amp;)</paramtype><description><para>Delimiter to separate elements in the output. Optional. If not specified, elements are output without separation. </para></description></parameter><description><para>Range manipulator generator function.</para><para>

<note><para>Both <emphasis>range</emphasis> and <emphasis>delimiter</emphasis> objects must outlive the created manipulator object. </para>
</note>
</para></description><returns><para>Manipulator to be inserted into the stream.</para>
</returns></function>
<function id="doxygen.utilities.range_8hpp_1a29f1ef6aa20be1968d0c9a342be074a7" name="range_manip"><type><classname>range_manipulator</classname>&lt; RangeT, void &gt;</type><template>
          <template-type-parameter name="RangeT"/>
        </template><parameter name="range"><paramtype>RangeT const &amp;</paramtype><description><para>Range of elements to output. The range must support begin and end iterators, and its elements must support stream output. </para></description></parameter><description><para>Range manipulator generator function.</para><para>

<note><para><emphasis>delimiter</emphasis> object must outlive the created manipulator object. </para>
</note>
</para></description><returns><para>Manipulator to be inserted into the stream.</para>
</returns></function>























</namespace>
</namespace>
</header>
<header id="doxygen.utilities.to__log_8hpp" name="boost/log/utility/manipulators/to_log.hpp">
<para><para>Andrey Semashev </para>

<para>06.11.2012</para>

This header contains the <computeroutput>to_log</computeroutput> output manipulator. </para><namespace name="boost">
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1to__log__manip" name="to_log_manip"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="TagT"><default>void</default></template-type-parameter>
    </template><purpose>Generic manipulator for customizing output to log. </purpose><typedef id="doxygen.utilities.classboost_1_1log_1_1to__log__manip_1a1bb7b4a35643ef79447e08e975edc592" name="value_type"><purpose>Output value type. </purpose><type>T</type></typedef>
<typedef id="doxygen.utilities.classboost_1_1log_1_1to__log__manip_1a6e62ce531b253f3fd3fe5b5d159a88af" name="tag_type"><purpose>Value tag type. </purpose><type>TagT</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1to__log__manip_1a29e715f6d032a486a70825f4f3651e23" specifiers="explicit" cv="noexcept"><parameter name="value"><paramtype>value_type const &amp;</paramtype></parameter></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1to__log__manip_1a6cf3834dbd0a2581ac0ebbe4349210c9" cv="noexcept"><parameter name="that"><paramtype><classname>to_log_manip</classname> const &amp;</paramtype></parameter></constructor>
<method id="doxygen.utilities.classboost_1_1log_1_1to__log__manip_1a6c7c5ca98af68e942373f9b2896b9a3e" name="get" cv="const noexcept"><type>value_type const &amp;</type></method>
</method-group>
</class>



















































































<function id="doxygen.utilities.to__log_8hpp_1af1f690c445538a89a999c9d4b4c457ae" name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter><parameter name="manip"><paramtype><classname>to_log_manip</classname>&lt; T, TagT &gt;</paramtype></parameter></function>
<function id="doxygen.utilities.to__log_8hpp_1a9ec99b926575131eb7f2c9a15d9cf217" name="to_log"><type><classname>to_log_manip</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="value"><paramtype>T const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.to__log_8hpp_1aeaa686887a2a07ba6d293140371dc435" name="to_log"><type><classname>to_log_manip</classname>&lt; T, TagT &gt;</type><template>
          <template-type-parameter name="TagT"/>
          <template-type-parameter name="T"/>
        </template><parameter name="value"><paramtype>T const &amp;</paramtype></parameter></function>




























</namespace>
</namespace>
</header>
<header id="doxygen.utilities.tuple_8hpp" name="boost/log/utility/manipulators/tuple.hpp">
<para><para>Andrey Semashev </para>

<para>11.05.2020</para>

The header contains implementation of a stream manipulator for inserting a tuple or any heterogeneous sequence of elements, optionally separated with a delimiter. </para><namespace name="boost">
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1tuple__manipulator" name="tuple_manipulator"><template>
      <template-type-parameter name="TupleT"/>
      <template-type-parameter name="DelimiterT"/>
    </template><description><para>Stream manipulator for inserting a heterogeneous sequence of elements, optionally separated with a delimiter. </para></description><struct id="doxygen.utilities.structboost_1_1log_1_1tuple__manipulator_1_1output__visitor" name="output_visitor"><template>
      <template-type-parameter name="StreamT"/>
    </template><typedef id="doxygen.utilities.structboost_1_1log_1_1tuple__manipulator_1_1output__visitor_1a9d4c119cc1059e285b5dee983f986432" name="result_type"><type>boost::true_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.structboost_1_1log_1_1tuple__manipulator_1_1output__visitor_1a5867a2c4513c334dcdaf0c66835af867" cv="noexcept"><parameter name="stream"><paramtype>StreamT &amp;</paramtype></parameter><parameter name="delimiter"><paramtype>stored_delimiter_type</paramtype></parameter></constructor>
<method id="doxygen.utilities.structboost_1_1log_1_1tuple__manipulator_1_1output__visitor_1a2aea046313d635134e21f39f6192ff5d" name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>boost::true_type</paramtype></parameter><parameter name="elem"><paramtype>T const &amp;</paramtype></parameter></method>
<method id="doxygen.utilities.structboost_1_1log_1_1tuple__manipulator_1_1output__visitor_1a3ae5981734975f3ddc240104c725024f" name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>boost::false_type</paramtype></parameter><parameter name="elem"><paramtype>T const &amp;</paramtype></parameter></method>
</method-group>
</struct><method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1tuple__manipulator_1a7b7e2912825215c0bd89777bf82224f7" cv="noexcept"><parameter name="tuple"><paramtype>TupleT const &amp;</paramtype></parameter><parameter name="delimiter"><paramtype>stored_delimiter_type</paramtype></parameter><purpose>Initializing constructor. </purpose></constructor>
<method id="doxygen.utilities.classboost_1_1log_1_1tuple__manipulator_1af1286d797863f31398792fb0fae32954" name="output" cv="const"><type>void</type><template>
          <template-type-parameter name="StreamT"/>
        </template><parameter name="stream"><paramtype>StreamT &amp;</paramtype></parameter><purpose>The method outputs elements of the sequence separated with delimiter. </purpose></method>
</method-group>
</class><class-specialization id="doxygen.utilities.classboost_1_1log_1_1tuple__manipulator_3_01TupleT_00_01void_01_4" name="tuple_manipulator"><template>
      <template-type-parameter name="TupleT"/>
    </template><specialization><template-arg>TupleT</template-arg><template-arg>void</template-arg></specialization><description><para>Stream manipulator for inserting a heterogeneous sequence of elements. Specialization for when there is no delimiter. </para></description><struct id="doxygen.utilities.structboost_1_1log_1_1tuple__manipulator_3_01TupleT_00_01void_01_4_1_1output__visitor" name="output_visitor"><template>
      <template-type-parameter name="StreamT"/>
    </template><typedef id="doxygen.utilities.structboost_1_1log_1_1tuple__manipulator_3_01TupleT_00_01void_01_4_1_1output__visitor_1a64c66719f6f37caa0ce72b77538ec998" name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.structboost_1_1log_1_1tuple__manipulator_3_01TupleT_00_01void_01_4_1_1output__visitor_1aad2beadd47d6ee858c640643b8b64691" specifiers="explicit" cv="noexcept"><parameter name="stream"><paramtype>StreamT &amp;</paramtype></parameter></constructor>
<method id="doxygen.utilities.structboost_1_1log_1_1tuple__manipulator_3_01TupleT_00_01void_01_4_1_1output__visitor_1a49b08303303afd64f43c333a0f661cc8" name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="elem"><paramtype>T const &amp;</paramtype></parameter></method>
</method-group>
</struct><method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1tuple__manipulator_3_01TupleT_00_01void_01_4_1a69ed655302f82d9705eb9b01bf40d979" specifiers="explicit" cv="noexcept"><parameter name="tuple"><paramtype>TupleT const &amp;</paramtype></parameter><purpose>Initializing constructor. </purpose></constructor>
<method id="doxygen.utilities.classboost_1_1log_1_1tuple__manipulator_3_01TupleT_00_01void_01_4_1af1286d797863f31398792fb0fae32954" name="output" cv="const"><type>void</type><template>
          <template-type-parameter name="StreamT"/>
        </template><parameter name="stream"><paramtype>StreamT &amp;</paramtype></parameter><purpose>The method outputs elements of the sequence. </purpose></method>
</method-group>
</class-specialization>














































































<function id="doxygen.utilities.tuple_8hpp_1a91f6f462f4a8732872907930fe79c939" name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="StreamT"/>
          <template-type-parameter name="TupleT"/>
          <template-type-parameter name="DelimiterT"/>
        </template><parameter name="strm"><paramtype>StreamT &amp;</paramtype></parameter><parameter name="manip"><paramtype><classname>tuple_manipulator</classname>&lt; TupleT, DelimiterT &gt; const &amp;</paramtype></parameter><description><para>Stream output operator for <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1tuple__manipulator">tuple_manipulator</link></computeroutput>. Outputs every element of the sequence, separated with a delimiter, if one was specified on manipulator construction. </para></description></function>
<function id="doxygen.utilities.tuple_8hpp_1a2cdcff5027eb61ada91869f103f5dcd0" name="tuple_manip"><type>boost::enable_if_c&lt; is_scalar&lt; DelimiterT &gt;::value, <classname>tuple_manipulator</classname>&lt; TupleT, DelimiterT &gt; &gt;::type</type><template>
          <template-type-parameter name="TupleT"/>
          <template-type-parameter name="DelimiterT"/>
        </template><parameter name="tuple"><paramtype>TupleT const &amp;</paramtype><description><para>Heterogeneous sequence of elements to output. The sequence must be supported by Boost.Fusion, and its elements must support stream output. </para></description></parameter><parameter name="delimiter"><paramtype>DelimiterT</paramtype><description><para>Delimiter to separate elements in the output. Optional. If not specified, elements are output without separation. </para></description></parameter><description><para>Tuple manipulator generator function.</para><para>

<note><para>Both <emphasis>tuple</emphasis> and <emphasis>delimiter</emphasis> objects must outlive the created manipulator object. </para>
</note>
</para></description><returns><para>Manipulator to be inserted into the stream.</para>
</returns></function>
<function id="doxygen.utilities.tuple_8hpp_1aa57d12c47be1e7a801954fee1fa5ab17" name="tuple_manip"><type>boost::disable_if_c&lt; is_scalar&lt; DelimiterT &gt;::value, <classname>tuple_manipulator</classname>&lt; TupleT, DelimiterT &gt; &gt;::type</type><template>
          <template-type-parameter name="TupleT"/>
          <template-type-parameter name="DelimiterT"/>
        </template><parameter name="tuple"><paramtype>TupleT const &amp;</paramtype><description><para>Heterogeneous sequence of elements to output. The sequence must be supported by Boost.Fusion, and its elements must support stream output. </para></description></parameter><parameter name="delimiter"><paramtype>DelimiterT const &amp;</paramtype><description><para>Delimiter to separate elements in the output. Optional. If not specified, elements are output without separation. </para></description></parameter><description><para>Tuple manipulator generator function.</para><para>

<note><para>Both <emphasis>tuple</emphasis> and <emphasis>delimiter</emphasis> objects must outlive the created manipulator object. </para>
</note>
</para></description><returns><para>Manipulator to be inserted into the stream.</para>
</returns></function>
<function id="doxygen.utilities.tuple_8hpp_1a4b74c6a45b7e0a0bf2f53a40f94067c2" name="tuple_manip"><type><classname>tuple_manipulator</classname>&lt; TupleT, DelimiterElementT * &gt;</type><template>
          <template-type-parameter name="TupleT"/>
          <template-type-parameter name="DelimiterElementT"/>
          <template-nontype-parameter name="N"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="tuple"><paramtype>TupleT const &amp;</paramtype><description><para>Heterogeneous sequence of elements to output. The sequence must be supported by Boost.Fusion, and its elements must support stream output. </para></description></parameter><parameter name="delimiter"><paramtype>DelimiterElementT(&amp;)</paramtype><description><para>Delimiter to separate elements in the output. Optional. If not specified, elements are output without separation. </para></description></parameter><description><para>Tuple manipulator generator function.</para><para>

<note><para>Both <emphasis>tuple</emphasis> and <emphasis>delimiter</emphasis> objects must outlive the created manipulator object. </para>
</note>
</para></description><returns><para>Manipulator to be inserted into the stream.</para>
</returns></function>
<function id="doxygen.utilities.tuple_8hpp_1ac5b4dcd4b1d44c3cbcfe8b76ade38373" name="tuple_manip"><type><classname>tuple_manipulator</classname>&lt; TupleT, void &gt;</type><template>
          <template-type-parameter name="TupleT"/>
        </template><parameter name="tuple"><paramtype>TupleT const &amp;</paramtype><description><para>Heterogeneous sequence of elements to output. The sequence must be supported by Boost.Fusion, and its elements must support stream output. </para></description></parameter><description><para>Tuple manipulator generator function.</para><para>

<note><para><emphasis>tuple</emphasis> object must outlive the created manipulator object. </para>
</note>
</para></description><returns><para>Manipulator to be inserted into the stream.</para>
</returns></function>































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.once__block_8hpp" name="boost/log/utility/once_block.hpp">
<para>The header defines classes and macros for once-blocks. </para><para><para>Andrey Semashev </para>

<para>23.06.2010 </para>

</para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1once__block__flag" name="once_block_flag"><purpose>A flag to detect if a code block has already been executed. </purpose><description><para>This structure should be used in conjunction with the <computeroutput>BOOST_LOG_ONCE_BLOCK_FLAG</computeroutput> macro. Usage example:</para><para><computeroutput> <link linkend="doxygen.utilities.structboost_1_1log_1_1once__block__flag">once_block_flag</link> flag = BOOST_LOG_ONCE_BLOCK_INIT;</computeroutput></para><para><computeroutput>void foo() { <link linkend="doxygen.utilities.once__block_8hpp_1a6931b9ebc5c9e5ee82ae17092fa27181">BOOST_LOG_ONCE_BLOCK_FLAG(flag)</link> { puts("Hello, world once!"); } } </computeroutput> </para></description></struct>


















































































































</namespace>
</namespace>
<macro id="doxygen.utilities.once__block_8hpp_1a753dbc6b40b3a30dc6c82056dcfd3b0f" name="BOOST_LOG_ONCE_BLOCK_INIT"><description><para>The static initializer for <computeroutput>once_block_flag</computeroutput>. </para></description></macro>
<macro id="doxygen.utilities.once__block_8hpp_1a6931b9ebc5c9e5ee82ae17092fa27181" name="BOOST_LOG_ONCE_BLOCK_FLAG" kind="functionlike"><macro-parameter name="flag_var"/><description><para>Begins a code block to be executed only once, with protection against thread concurrency. User has to provide the flag variable that controls whether the block has already been executed. </para></description></macro>
<macro id="doxygen.utilities.once__block_8hpp_1add70d5269e92aa84b07fd63e9a4675e7" name="BOOST_LOG_ONCE_BLOCK" kind="functionlike"><macro-parameter name=""/><description><para>Begins a code block to be executed only once, with protection against thread concurrency. </para></description></macro>
</header>
<header id="doxygen.utilities.open__mode_8hpp" name="boost/log/utility/open_mode.hpp">
<para><para>Andrey Semashev </para>

<para>01.01.2016</para>

The header defines resource opening modes. </para><namespace name="boost">
<namespace name="log">
<namespace name="open_mode">
<struct id="doxygen.utilities.structboost_1_1log_1_1open__mode_1_1create__only__tag" name="create_only_tag"><purpose>Create a new resource; fail if exists already. </purpose></struct><struct id="doxygen.utilities.structboost_1_1log_1_1open__mode_1_1open__only__tag" name="open_only_tag"><purpose>Opens an existing resource; fail if not exist. </purpose></struct><struct id="doxygen.utilities.structboost_1_1log_1_1open__mode_1_1open__or__create__tag" name="open_or_create_tag"><purpose>Creates a new resource or opens an existing one. </purpose></struct><data-member id="doxygen.utilities.open__mode_8hpp_1a4f7e9e01f356a0c040d0ccf2d4962893" name="create_only"><type>struct <classname>boost::log::open_mode::create_only_tag</classname></type></data-member>
<data-member id="doxygen.utilities.open__mode_8hpp_1a056c339d0f98be6a96dfbf334ef481f7" name="open_only"><type>struct <classname>boost::log::open_mode::open_only_tag</classname></type></data-member>
<data-member id="doxygen.utilities.open__mode_8hpp_1a30ccf60e2265bf4359bce18d3800f084" name="open_or_create"><type>struct <classname>boost::log::open_mode::open_or_create_tag</classname></type></data-member>
</namespace>



















































































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.permissions_8hpp" name="boost/log/utility/permissions.hpp">
<para><para>Lingxi Li </para>

<para>Andrey Semashev </para>

<para>14.10.2015</para>

The header contains an abstraction wrapper for security permissions. </para><namespace name="boost">
<namespace name="interprocess">
</namespace>
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1permissions" name="permissions"><purpose>Access permissions wrapper. </purpose><description><para>On Windows platforms, it represents a pointer to <computeroutput>SECURITY_ATTRIBUTES</computeroutput>. The user is responsible for allocating and reclaiming resources associated with the pointer, <computeroutput>permissions</computeroutput> instance does not own them.</para><para>On POSIX platforms, it represents a <computeroutput>mode_t</computeroutput> value. </para></description><typedef id="doxygen.utilities.classboost_1_1log_1_1permissions_1a62dc765d0f8ac56ee5a0a406b1a4504c" name="native_type"><purpose>The type of security permissions, specific to the operating system. </purpose><type>implementation_defined</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1permissions_1a767370bb0e8c390f105666be0dcc22cf" cv="noexcept"><description><para>Default constructor. The method constructs an object that represents a null <computeroutput>SECURITY_ATTRIBUTES</computeroutput> pointer on Windows platforms, and a <computeroutput>mode_t</computeroutput> value <computeroutput>0644</computeroutput> on POSIX platforms. </para></description></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1permissions_1a14b8828fbc90fb52c75a8aae13ee5220" cv="noexcept"><parameter name="that"><paramtype><classname>permissions</classname> const &amp;</paramtype></parameter><description><para>Copy constructor. </para></description></constructor>
<copy-assignment id="doxygen.utilities.classboost_1_1log_1_1permissions_1a14d3d2e83d1342f5a0aec20b89ae187a" cv="noexcept"><type><classname>permissions</classname> &amp;</type><parameter name="that"><paramtype><classname>permissions</classname> const &amp;</paramtype></parameter><description><para>Copy assignment. </para></description></copy-assignment>
<constructor id="doxygen.utilities.classboost_1_1log_1_1permissions_1ae2cbee17335e9888db53a0f06f26f0d8" cv="noexcept"><parameter name="perms"><paramtype>native_type</paramtype></parameter><description><para>Initializing constructor. </para></description></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1permissions_1aaebcf4b09c86cef46c6d7c01a25980d8" cv="noexcept"><parameter name="perms"><paramtype>boost::interprocess::permissions const &amp;</paramtype></parameter><description><para>Initializing constructor. </para></description></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1permissions_1a0b338a6e788332c5351d0fdb3e3a3389" cv="noexcept"><parameter name="that"><paramtype><classname>permissions</classname> &amp;&amp;</paramtype></parameter><description><para>Move constructor. </para></description></constructor>
<copy-assignment id="doxygen.utilities.classboost_1_1log_1_1permissions_1a8d3e4144d7af8dd004affc9b7175553d" cv="noexcept"><type><classname>permissions</classname> &amp;</type><parameter name="that"><paramtype><classname>permissions</classname> &amp;&amp;</paramtype></parameter><description><para>Move assignment. </para></description></copy-assignment>
<method id="doxygen.utilities.classboost_1_1log_1_1permissions_1a01de52b1fd21d79524f6d319dd968693" name="set_native" cv="noexcept"><type>void</type><parameter name="perms"><paramtype>native_type</paramtype></parameter><description><para>Sets permissions from the OS-specific permissions. </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1permissions_1a8d4a4680f749cdd7068e22d76639bf10" name="get_native" cv="const noexcept"><type>native_type</type><description><para>Returns the underlying OS-specific permissions. </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1permissions_1affdeccd5db9b699e11edc23d69632e77" name="set_default" cv="noexcept"><type>void</type><description><para>Sets the default permissions, which are equivalent to <computeroutput>NULL</computeroutput> <computeroutput>SECURITY_ATTRIBUTES</computeroutput> on Windows and <computeroutput>0644</computeroutput> on POSIX platforms. </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1permissions_1a4ef9e1c8429ae6bfefe37ec852efafc4" name="set_unrestricted"><type>void</type><description><para>Sets unrestricted permissions, which are equivalent to <computeroutput>SECURITY_ATTRIBUTES</computeroutput> with <computeroutput>NULL</computeroutput> DACL on Windows and <computeroutput>0666</computeroutput> on POSIX platforms. </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1permissions_1ae53a358fd95486a18bd726766812d62c" name="swap" cv="noexcept"><type>void</type><parameter name="that"><paramtype><classname>permissions</classname> &amp;</paramtype><description><para>The other object to swap with. </para></description></parameter><description><para>The method swaps the object with <emphasis>that</emphasis>.</para><para>
</para></description></method>
</method-group>
<method-group name="friend functions">
<method id="doxygen.utilities.classboost_1_1log_1_1permissions_1a148835f1120cdd7989c52023b91113af" name="swap" cv="noexcept"><type>void</type><parameter name="a"><paramtype><classname>permissions</classname> &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>permissions</classname> &amp;</paramtype></parameter><purpose>Swaps the two <computeroutput>permissions</computeroutput> objects. </purpose></method>
</method-group>
</class>


















































































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.record__ordering_8hpp" name="boost/log/utility/record_ordering.hpp">
<para><para>Andrey Semashev </para>

<para>23.08.2009</para>

This header contains ordering predicates for logging records. </para><namespace name="boost">
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1abstract__ordering" name="abstract_ordering"><template>
      <template-type-parameter name="FunT"><default>less</default></template-type-parameter>
    </template><inherit access="private">less</inherit><purpose>Ordering predicate, based on opaque pointers to the record view implementation data. </purpose><description><para>Since record views only refer to a shared implementation data, this predicate is able to order the views by comparing the pointers to the data. Therefore two views are considered to be equivalent if they refer to the same implementation data. Otherwise it is not specified whether one record is ordered before the other until the predicate is applied. Note that the ordering may change every time the application runs.</para><para>This kind of ordering may be useful if log records are to be stored in an associative container with as least performance overhead as possible, when the particular order is not important.</para><para>The <computeroutput>FunT</computeroutput> template argument is the predicate that is used to actually compare pointers. It should be able to compare <computeroutput>const void*</computeroutput> pointers. The compared pointers may refer to distinct memory regions, the pointers must not be interpreted in any way. </para></description><typedef id="doxygen.utilities.classboost_1_1log_1_1abstract__ordering_1af9f060e1c6d6e7343f3ecb7627c01a78" name="result_type"><purpose>Result type. </purpose><type>bool</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1abstract__ordering_1a421002694577251568f649f6da17de45"><description><para>Default constructor. Requires <computeroutput>FunT</computeroutput> to be default constructible. </para></description></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1abstract__ordering_1a38731a2ceeaac51a7060b4440690ef7a" specifiers="explicit"><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter><description><para>Initializing constructor. Constructs <computeroutput>FunT</computeroutput> instance as a copy of the <emphasis>fun</emphasis> argument. </para></description></constructor>
<method id="doxygen.utilities.classboost_1_1log_1_1abstract__ordering_1a02f3fb787c6aaab966f12345208b988b" name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>record_view const &amp;</paramtype></parameter><parameter name="right"><paramtype>record_view const &amp;</paramtype></parameter><description><para>Ordering operator </para></description></method>
</method-group>
</class><class id="doxygen.utilities.classboost_1_1log_1_1attribute__value__ordering" name="attribute_value_ordering"><template>
      <template-type-parameter name="ValueT"/>
      <template-type-parameter name="FunT"><default>less</default></template-type-parameter>
    </template><inherit access="private">less</inherit><purpose>Ordering predicate, based on attribute values associated with records. </purpose><description><para>This predicate allows to order log records based on values of a specifically named attribute associated with them. Two given log records being compared should both have the specified attribute value of the specified type to be able to be ordered properly. As a special case, if neither of the records have the value, these records are considered equivalent. Otherwise, the ordering results are unspecified. </para></description><struct id="doxygen.utilities.structboost_1_1log_1_1attribute__value__ordering_1_1l1__visitor" name="l1_visitor"><typedef id="doxygen.utilities.structboost_1_1log_1_1attribute__value__ordering_1_1l1__visitor_1a64c66719f6f37caa0ce72b77538ec998" name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.structboost_1_1log_1_1attribute__value__ordering_1_1l1__visitor_1a658253f32a797b97fbf6217c93858e49"><parameter name="owner"><paramtype><classname>attribute_value_ordering</classname> const &amp;</paramtype></parameter><parameter name="right"><paramtype>record_view const &amp;</paramtype></parameter><parameter name="result"><paramtype>bool &amp;</paramtype></parameter></constructor>
<method id="doxygen.utilities.structboost_1_1log_1_1attribute__value__ordering_1_1l1__visitor_1aa5a9f847b17d9a24cc17ed9d0a020ccf" name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="LeftT"/>
        </template><parameter name="left"><paramtype>LeftT const &amp;</paramtype></parameter></method>
</method-group>
</struct><struct id="doxygen.utilities.structboost_1_1log_1_1attribute__value__ordering_1_1l2__visitor" name="l2_visitor"><template>
      <template-type-parameter name="LeftT"/>
    </template><typedef id="doxygen.utilities.structboost_1_1log_1_1attribute__value__ordering_1_1l2__visitor_1a64c66719f6f37caa0ce72b77538ec998" name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.structboost_1_1log_1_1attribute__value__ordering_1_1l2__visitor_1af49a8754a22afb9fe162a81f22b33876"><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter><parameter name="left"><paramtype>LeftT const &amp;</paramtype></parameter><parameter name="result"><paramtype>bool &amp;</paramtype></parameter></constructor>
<method id="doxygen.utilities.structboost_1_1log_1_1attribute__value__ordering_1_1l2__visitor_1a1c7644763f5b3c3bbc2eee70d325c3d0" name="operator()" cv="const"><type>result_type</type><template>
          <template-type-parameter name="RightT"/>
        </template><parameter name="right"><paramtype>RightT const &amp;</paramtype></parameter></method>
</method-group>
</struct><typedef id="doxygen.utilities.classboost_1_1log_1_1attribute__value__ordering_1af9f060e1c6d6e7343f3ecb7627c01a78" name="result_type"><purpose>Result type. </purpose><type>bool</type></typedef>
<typedef id="doxygen.utilities.classboost_1_1log_1_1attribute__value__ordering_1a57f46f84e99a3dff37c065c41289c177" name="value_type"><purpose>Compared attribute value type. </purpose><type>ValueT</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1attribute__value__ordering_1a4d8544cace52c007ebea601c24b65a89" specifiers="explicit"><parameter name="name"><paramtype>attribute_name const &amp;</paramtype><description><para>The attribute value name to be compared </para></description></parameter><parameter name="fun"><paramtype>FunT const &amp;</paramtype><default>FunT()</default><description><para>The ordering functor </para></description></parameter><description><para>Initializing constructor.</para><para>
</para></description></constructor>
<method id="doxygen.utilities.classboost_1_1log_1_1attribute__value__ordering_1a02f3fb787c6aaab966f12345208b988b" name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>record_view const &amp;</paramtype></parameter><parameter name="right"><paramtype>record_view const &amp;</paramtype></parameter><description><para>Ordering operator </para></description></method>
</method-group>
</class>























<function id="doxygen.utilities.record__ordering_8hpp_1a43e65645f0c5d48831f21de8187bf57a" name="make_attr_ordering"><type><classname>attribute_value_ordering</classname>&lt; ValueT, FunT &gt;</type><template>
          <template-type-parameter name="ValueT"/>
          <template-type-parameter name="FunT"/>
        </template><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter><description><para>The function constructs a log record ordering predicate </para></description></function>
<function id="doxygen.utilities.record__ordering_8hpp_1a00707a6244128c148cce3383e491f926" name="make_attr_ordering"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="FunT"/>
        </template><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="fun"><paramtype>FunT const &amp;</paramtype></parameter><description><para>The function constructs a log record ordering predicate </para></description></function>

























































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.setup_8hpp" name="boost/log/utility/setup.hpp">
<para><para>Andrey Semashev </para>

<para>16.02.2013</para>

This header includes all library setup helpers. </para></header>
<header id="doxygen.utilities.common__attributes_8hpp" name="boost/log/utility/setup/common_attributes.hpp">
<para><para>Andrey Semashev </para>

<para>16.05.2008</para>

The header contains implementation of convenience functions for registering commonly used attributes. </para><namespace name="boost">
<namespace name="log">
































































<function id="doxygen.utilities.common__attributes_8hpp_1af92a587e54f1b77d1fceb21fb829dae0" name="add_common_attributes"><type>void</type><purpose>Simple attribute initialization routine. </purpose><description><para>The function adds commonly used attributes to the logging system. Specifically, the following attributes are registered globally:</para><para><itemizedlist>
<listitem><para>LineID - logging records counter with value type <computeroutput>unsigned int</computeroutput> </para>
</listitem>
<listitem><para>TimeStamp - local time generator with value type <computeroutput>boost::posix_time::ptime</computeroutput> </para>
</listitem>
<listitem><para>ProcessID - current process identifier with value type <computeroutput>attributes::current_process_id::value_type</computeroutput> </para>
</listitem>
<listitem><para>ThreadID - in multithreaded builds, current thread identifier with value type <computeroutput>attributes::current_thread_id::value_type</computeroutput> </para>
</listitem>
</itemizedlist>
</para></description></function>


















































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.console_8hpp" name="boost/log/utility/setup/console.hpp">
<para><para>Andrey Semashev </para>

<para>16.05.2008</para>

The header contains implementation of convenience functions for enabling logging to console. </para><namespace name="boost">
<namespace name="log">




























































<function id="doxygen.utilities.console_8hpp_1afdca648e6eaf2357182095fdf2aec4da" name="add_console_log"><type>shared_ptr&lt; sinks::synchronous_sink&lt; sinks::basic_text_ostream_backend&lt; CharT &gt; &gt; &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-nontype-parameter name="ArgsT"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="strm"><paramtype>std::basic_ostream&lt; CharT &gt; &amp;</paramtype><description><para>One of the standard console streams: <computeroutput>std::cout</computeroutput>, <computeroutput>std::cerr</computeroutput> or <computeroutput>std::clog</computeroutput> (or the corresponding wide-character analogues). </para></description></parameter><parameter name="args"><paramtype>ArgsT... const &amp;</paramtype><description><para>Optional additional named arguments for the sink initialization. The following arguments are supported: <itemizedlist>
<listitem><para><computeroutput>filter</computeroutput> Specifies a filter to install into the sink. May be a string that represents a filter, or a filter lambda expression. </para>
</listitem>
<listitem><para><computeroutput>format</computeroutput> Specifies a formatter to install into the sink. May be a string that represents a formatter, or a formatter lambda expression (either streaming or Boost.Format-like notation). </para>
</listitem>
<listitem><para><computeroutput>auto_flush</computeroutput> A boolean flag that shows whether the sink should automatically flush the stream after each written record. </para>
</listitem>
<listitem><para><computeroutput>auto_newline_mode</computeroutput> - Specifies automatic trailing newline insertion mode. Must be a value of the <computeroutput>auto_newline_mode</computeroutput> enum. By default, is <computeroutput>auto_newline_mode::insert_if_missing</computeroutput>. </para>
</listitem>
</itemizedlist>
</para></description></parameter><description><para>The function constructs sink for the specified console stream and adds it to the core</para><para>

</para></description><returns><para>Pointer to the constructed sink. </para>
</returns></function>
<function id="doxygen.utilities.console_8hpp_1a5df5d4fae46e7edb29f1dfd614d918ce" name="add_console_log"><type>shared_ptr&lt; sinks::synchronous_sink&lt; sinks::basic_text_ostream_backend&lt; CharT &gt; &gt; &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-nontype-parameter name="ArgsT"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>ArgsT... const &amp;</paramtype></parameter><description><para>Equivalent to: <computeroutput>add_console_log(std::clog);</computeroutput> or <computeroutput>add_console_log(std::wclog);</computeroutput>, depending on the <computeroutput>CharT</computeroutput> type.</para><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></function>
<function id="doxygen.utilities.console_8hpp_1af892772cbeaf96d6182151b95726b9f4" name="add_console_log"><type>shared_ptr&lt; sinks::synchronous_sink&lt; sinks::text_ostream_backend &gt; &gt;</type><description><para>The function constructs sink for the <computeroutput>std::clog</computeroutput> stream and adds it to the core</para><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</para><para>
</para></description><returns><para>Pointer to the constructed sink. </para>
</returns></function>
<function id="doxygen.utilities.console_8hpp_1a2ec21e70cf90d73bc086826d27f8c2d2" name="wadd_console_log"><type>shared_ptr&lt; sinks::synchronous_sink&lt; sinks::wtext_ostream_backend &gt; &gt;</type><description><para>The function constructs sink for the <computeroutput>std::wclog</computeroutput> stream and adds it to the core</para><para>
</para></description><returns><para>Pointer to the constructed sink. </para>
</returns></function>



















































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.file_8hpp" name="boost/log/utility/setup/file.hpp">
<para><para>Andrey Semashev </para>

<para>16.05.2008</para>

The header contains implementation of convenience functions for enabling logging to a file. </para><namespace name="boost">
<namespace name="log">



























































<function id="doxygen.utilities.file_8hpp_1afc3eb3a7e41f72d4ac64647d393756bf" name="add_file_log"><type>shared_ptr&lt; sinks::synchronous_sink&lt; sinks::text_file_backend &gt; &gt;</type><template>
          <template-nontype-parameter name="ArgsT"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>ArgsT... const &amp;</paramtype><description><para>A number of named arguments. The following parameters are supported: <itemizedlist>
<listitem><para><computeroutput>file_name</computeroutput> The active file name or its pattern. This parameter is mandatory. </para>
</listitem>
<listitem><para><computeroutput>target_file_name</computeroutput> - Specifies the target file name pattern to use to rename the log file on rotation, before passing it to the file collector. The pattern may contain the same placeholders as the <computeroutput>file_name</computeroutput> parameter. By default, no renaming is done, i.e. the written log file keeps its name according to <computeroutput>file_name</computeroutput>. </para>
</listitem>
<listitem><para><computeroutput>open_mode</computeroutput> The mask that describes the open mode for the file. See <computeroutput>std::ios_base::openmode</computeroutput>. </para>
</listitem>
<listitem><para><computeroutput>rotation_size</computeroutput> The size of the file at which rotation should occur. See <computeroutput>basic_text_file_backend</computeroutput>. </para>
</listitem>
<listitem><para><computeroutput>time_based_rotation</computeroutput> The predicate for time-based file rotations. See <computeroutput>basic_text_file_backend</computeroutput>. </para>
</listitem>
<listitem><para><computeroutput>auto_flush</computeroutput> A boolean flag that shows whether the sink should automatically flush the file after each written record. </para>
</listitem>
<listitem><para><computeroutput>auto_newline_mode</computeroutput> - Specifies automatic trailing newline insertion mode. Must be a value of the <computeroutput>auto_newline_mode</computeroutput> enum. By default, is <computeroutput>auto_newline_mode::insert_if_missing</computeroutput>. </para>
</listitem>
<listitem><para><computeroutput>target</computeroutput> The target directory to store rotated files in. Enables file collector and, if specified, limits associated with the target directory. See <computeroutput>sinks::file::make_collector</computeroutput>. </para>
</listitem>
<listitem><para><computeroutput>max_size</computeroutput> The maximum total size of rotated files in the target directory. See <computeroutput>sinks::file::make_collector</computeroutput>. </para>
</listitem>
<listitem><para><computeroutput>min_free_space</computeroutput> Minimum free space in the target directory. See <computeroutput>sinks::file::make_collector</computeroutput>. </para>
</listitem>
<listitem><para><computeroutput>max_files</computeroutput> The maximum total number of rotated files in the target directory. See <computeroutput>sinks::file::make_collector</computeroutput>. </para>
</listitem>
<listitem><para><computeroutput>scan_method</computeroutput> The method of scanning the target directory for log files. See <computeroutput>sinks::file::scan_method</computeroutput>. </para>
</listitem>
<listitem><para><computeroutput>filter</computeroutput> Specifies a filter to install into the sink. May be a string that represents a filter, or a filter lambda expression. </para>
</listitem>
<listitem><para><computeroutput>format</computeroutput> Specifies a formatter to install into the sink. May be a string that represents a formatter, or a formatter lambda expression (either streaming or Boost.Format-like notation).</para>
</listitem>
</itemizedlist>
</para></description></parameter><description><para>The function initializes the logging library to write logs to a file stream.</para><para>

<note><para>The <computeroutput>target</computeroutput> named argument is required to enable the file collector and the limits associated with the target directory. If the parameter is not specified, the file collector will not be created and the limits will not be maintained. </para>
</note>
</para></description><returns><para>Pointer to the constructed sink.</para>
</returns></function>























































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.filter__parser_8hpp" name="boost/log/utility/setup/filter_parser.hpp">
<para><para>Andrey Semashev </para>

<para>31.03.2008</para>

The header contains definition of a filter parser function. </para><namespace name="boost">
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1basic__filter__factory" name="basic_filter_factory"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="AttributeValueT"/>
    </template><inherit access="public">boost::log::filter_factory&lt; CharT &gt;</inherit><description><para>The base class for filter factories. The class defines default implementations for most filter expressions. In order to be able to construct filters, the attribute value type must support reading from a stream. Also, the default filters will rely on relational operators for the type, so these operators must also be defined. </para></description><typedef id="doxygen.utilities.classboost_1_1log_1_1basic__filter__factory_1af8b7253e43637ed1f6565b5beddf23ae" name="value_type"><purpose>The type(s) of the attribute value expected. </purpose><type>AttributeValueT</type></typedef>
<typedef id="doxygen.utilities.classboost_1_1log_1_1basic__filter__factory_1a089c2a2d33a3bda6b890cec0b31bda95" name="string_type"><type>base_type::string_type</type></typedef>
<method-group name="public member functions">
<method id="doxygen.utilities.classboost_1_1log_1_1basic__filter__factory_1a1f605c766d82ed86f911eef7427df63a" name="on_exists_test" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><description><para>The callback for filter for the attribute existence test </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__filter__factory_1a9e06058a8a231f2e3c26ed7eab7a0963" name="on_equality_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for equality relation filter </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__filter__factory_1af7d1e0f4815d18b41d33fd0ffc0cc610" name="on_inequality_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for inequality relation filter </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__filter__factory_1a44e3890de276d297131101518198746b" name="on_less_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for less relation filter </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__filter__factory_1aae2448617794e57c5514c9daef1ab51f" name="on_greater_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for greater relation filter </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__filter__factory_1aa4d4cefb70bc6c07a24fd9d5e9373e37" name="on_less_or_equal_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for less or equal relation filter </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__filter__factory_1aa0a757bef301c2457a02ca60303bb4a9" name="on_greater_or_equal_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for greater or equal relation filter </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__filter__factory_1aa1ff29edbb133a682bac57b27a5ad401" name="on_custom_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="rel"><paramtype>string_type const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for custom relation filter </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__filter__factory_1a7ee0cc7b984a347fca2b40ce7e779d38" name="parse_argument" specifiers="virtual"><type>value_type</type><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The function parses the argument value for a binary relation </para></description></method>
</method-group>
</class><struct id="doxygen.utilities.structboost_1_1log_1_1filter__factory" name="filter_factory"><template>
      <template-type-parameter name="CharT"/>
    </template><description><para>The interface class for all filter factories. </para></description><typedef id="doxygen.utilities.structboost_1_1log_1_1filter__factory_1ad92b506e190e93f1c2bda230aeb199a9" name="char_type"><purpose>Character type. </purpose><type>CharT</type></typedef>
<typedef id="doxygen.utilities.structboost_1_1log_1_1filter__factory_1acf1108866212127ae0e2171bc69be3f5" name="string_type"><purpose>String type. </purpose><type>std::basic_string&lt; char_type &gt;</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.structboost_1_1log_1_1filter__factory_1ac755172a93d674c358f39d67c7bbe001" cv="= default"><description><para>Default constructor </para></description></constructor>
<destructor id="doxygen.utilities.structboost_1_1log_1_1filter__factory_1a22fec1860e241a06c76348ecf6f4db73" specifiers="virtual"><description><para>Virtual destructor </para></description></destructor>
<method id="doxygen.utilities.structboost_1_1log_1_1filter__factory_1a1f605c766d82ed86f911eef7427df63a" name="on_exists_test" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><description><para>The callback for filter for the attribute existence test </para></description></method>
<method id="doxygen.utilities.structboost_1_1log_1_1filter__factory_1a9e06058a8a231f2e3c26ed7eab7a0963" name="on_equality_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for equality relation filter </para></description></method>
<method id="doxygen.utilities.structboost_1_1log_1_1filter__factory_1af7d1e0f4815d18b41d33fd0ffc0cc610" name="on_inequality_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for inequality relation filter </para></description></method>
<method id="doxygen.utilities.structboost_1_1log_1_1filter__factory_1a44e3890de276d297131101518198746b" name="on_less_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for less relation filter </para></description></method>
<method id="doxygen.utilities.structboost_1_1log_1_1filter__factory_1aae2448617794e57c5514c9daef1ab51f" name="on_greater_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for greater relation filter </para></description></method>
<method id="doxygen.utilities.structboost_1_1log_1_1filter__factory_1aa4d4cefb70bc6c07a24fd9d5e9373e37" name="on_less_or_equal_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for less or equal relation filter </para></description></method>
<method id="doxygen.utilities.structboost_1_1log_1_1filter__factory_1aa0a757bef301c2457a02ca60303bb4a9" name="on_greater_or_equal_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for greater or equal relation filter </para></description></method>
<method id="doxygen.utilities.structboost_1_1log_1_1filter__factory_1aa1ff29edbb133a682bac57b27a5ad401" name="on_custom_relation" specifiers="virtual"><type>filter</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype></parameter><parameter name="rel"><paramtype>string_type const &amp;</paramtype></parameter><parameter name="arg"><paramtype>string_type const &amp;</paramtype></parameter><description><para>The callback for custom relation filter </para></description></method>
<constructor id="doxygen.utilities.structboost_1_1log_1_1filter__factory_1a26306d05a9c15fe0a4bc240326f7d150" cv="= delete"><parameter name=""><paramtype><classname>filter_factory</classname> const &amp;</paramtype></parameter></constructor>
<copy-assignment id="doxygen.utilities.structboost_1_1log_1_1filter__factory_1aea2ec86e6fa7db2b84b462391b1fb259" cv="= delete"><type><classname>filter_factory</classname> &amp;</type><parameter name=""><paramtype><classname>filter_factory</classname> const &amp;</paramtype></parameter></copy-assignment>
</method-group>
</struct>


















































<function id="doxygen.utilities.filter__parser_8hpp_1a2ee2fc65f02a4f6d9c08789393f13963" name="register_filter_factory"><type>void</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="name"><paramtype>attribute_name const &amp;</paramtype><description><para>Attribute name to associate the factory with </para></description></parameter><parameter name="factory"><paramtype>shared_ptr&lt; <classname>filter_factory</classname>&lt; CharT &gt; &gt; const &amp;</paramtype><description><para>The filter factory </para></description></parameter><description><para>The function registers a filter factory object for the specified attribute name. The factory will be used to construct a filter during parsing the filter string.</para><para>

</para></description><requires><para><computeroutput>name != NULL &amp;&amp; factory != NULL</computeroutput>, <computeroutput>name</computeroutput> points to a zero-terminated string </para>
</requires></function>
<function id="doxygen.utilities.filter__parser_8hpp_1a99b4a0b97949165d0fbe8c2ebc49c9e2" name="register_filter_factory"><type>boost::enable_if_c&lt; is_base_and_derived&lt; <classname>filter_factory</classname>&lt; typenameFactoryT::char_type &gt;, FactoryT &gt;::value &gt;::type</type><template>
          <template-type-parameter name="FactoryT"/>
        </template><parameter name="name"><paramtype>attribute_name const &amp;</paramtype><description><para>Attribute name to associate the factory with </para></description></parameter><parameter name="factory"><paramtype>shared_ptr&lt; FactoryT &gt; const &amp;</paramtype><description><para>The filter factory </para></description></parameter><description><para>The function registers a filter factory object for the specified attribute name. The factory will be used to construct a filter during parsing the filter string.</para><para>

</para></description><requires><para><computeroutput>name != NULL &amp;&amp; factory != NULL</computeroutput>, <computeroutput>name</computeroutput> points to a zero-terminated string </para>
</requires></function>
<function id="doxygen.utilities.filter__parser_8hpp_1ac51d84558f9ea1a975d28eae4e9b7380" name="register_simple_filter_factory"><type>void</type><template>
          <template-type-parameter name="AttributeValueT"/>
          <template-type-parameter name="CharT"/>
        </template><parameter name="name"><paramtype>attribute_name const &amp;</paramtype><description><para>Attribute name to associate the factory with </para></description></parameter><description><para>The function registers a simple filter factory object for the specified attribute name. The factory will support attribute values of type <computeroutput>AttributeValueT</computeroutput>, which must support all relation operations, such as equality comparison and less/greater ordering, and also extraction from stream.</para><para>

</para></description><requires><para><computeroutput>name != NULL</computeroutput>, <computeroutput>name</computeroutput> points to a zero-terminated string </para>
</requires></function>
<function id="doxygen.utilities.filter__parser_8hpp_1a0e8f82d14f2567c8e4099d0a95322688" name="register_simple_filter_factory"><type>void</type><template>
          <template-type-parameter name="AttributeValueT"/>
        </template><parameter name="name"><paramtype>attribute_name const &amp;</paramtype><description><para>Attribute name to associate the factory with </para></description></parameter><description><para>The function registers a simple filter factory object for the specified attribute name. The factory will support attribute values of type <computeroutput>AttributeValueT</computeroutput>, which must support all relation operations, such as equality comparison and less/greater ordering, and also extraction from stream.</para><para>

</para></description><requires><para><computeroutput>name != NULL</computeroutput>, <computeroutput>name</computeroutput> points to a zero-terminated string </para>
</requires></function>
<function id="doxygen.utilities.filter__parser_8hpp_1a7f6cc27228d763b478ee468adae0de6d" name="register_simple_filter_factory"><type>void</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="DescriptorT"/>
          <template-nontype-parameter name="ActorT"><type>template&lt; typename &gt; class</type></template-nontype-parameter>
        </template><parameter name="keyword"><paramtype>expressions::attribute_keyword&lt; DescriptorT, ActorT &gt; const &amp;</paramtype><description><para>Attribute keyword to associate the factory with </para></description></parameter><description><para>The function registers a simple filter factory object for the specified attribute keyword. The factory will support attribute values described by the keyword. The values must support all relation operations, such as equality comparison and less/greater ordering, and also extraction from stream.</para><para>

</para></description><requires><para><computeroutput>name != NULL</computeroutput>, <computeroutput>name</computeroutput> points to a zero-terminated string </para>
</requires></function>
<function id="doxygen.utilities.filter__parser_8hpp_1aa66faf5c229a64e17c5368c649243fb0" name="parse_filter"><type>filter</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="begin"><paramtype>const CharT *</paramtype><description><para>Pointer to the first character of the sequence </para></description></parameter><parameter name="end"><paramtype>const CharT *</paramtype><description><para>Pointer to the after-the-last character of the sequence </para></description></parameter><description><para>The function parses a filter from the sequence of characters</para><para>


<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception, if a filter cannot be recognized in the character sequence. </para></description><requires><para><computeroutput>begin &lt;= end</computeroutput>, both pointers must not be <computeroutput>NULL</computeroutput> </para>
</requires><returns><para>A function object that can be used as a filter.</para>
</returns></function>
<function id="doxygen.utilities.filter__parser_8hpp_1ac0588cd3bbdb30332410de939a89699b" name="parse_filter"><type>filter</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TraitsT"/>
          <template-type-parameter name="AllocatorT"/>
        </template><parameter name="str"><paramtype>std::basic_string&lt; CharT, TraitsT, AllocatorT &gt; const &amp;</paramtype><description><para>A string that contains filter description </para></description></parameter><description><para>The function parses a filter from the string</para><para>

<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception, if a filter cannot be recognized in the character sequence. </para></description><returns><para>A function object that can be used as a filter.</para>
</returns></function>
<function id="doxygen.utilities.filter__parser_8hpp_1aac16b1fc017fa3c63538ad5c645acf86" name="parse_filter"><type>filter</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="str"><paramtype>const CharT *</paramtype><description><para>A string that contains filter description. </para></description></parameter><description><para>The function parses a filter from the string</para><para>


<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception, if a filter cannot be recognized in the character sequence. </para></description><requires><para><computeroutput>str != NULL</computeroutput>, <computeroutput>str</computeroutput> points to a zero-terminated string. </para>
</requires><returns><para>A function object that can be used as a filter.</para>
</returns></function>
























































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.formatter__parser_8hpp" name="boost/log/utility/setup/formatter_parser.hpp">
<para><para>Andrey Semashev </para>

<para>07.04.2008</para>

The header contains definition of a formatter parser function, along with facilities to add support for custom formatters. </para><namespace name="boost">
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1basic__formatter__factory" name="basic_formatter_factory"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="AttributeValueT"/>
    </template><inherit access="public">boost::log::formatter_factory&lt; CharT &gt;</inherit><description><para>Base class for formatter factories. This class provides default implementation of formatter expressions for types supporting stream output. The factory does not take into account any additional parameters that may be specified. </para></description><typedef id="doxygen.utilities.classboost_1_1log_1_1basic__formatter__factory_1af8b7253e43637ed1f6565b5beddf23ae" name="value_type"><purpose>Attribute value type. </purpose><type>AttributeValueT</type></typedef>
<typedef id="doxygen.utilities.classboost_1_1log_1_1basic__formatter__factory_1a9b77e72ac90367ea74216413bba76cdc" name="formatter_type"><type>base_type::formatter_type</type></typedef>
<typedef id="doxygen.utilities.classboost_1_1log_1_1basic__formatter__factory_1ad673ee249cbe54fb6cace78e38b4c249" name="args_map"><type>base_type::args_map</type></typedef>
<method-group name="public member functions">
<method id="doxygen.utilities.classboost_1_1log_1_1basic__formatter__factory_1a91a093554381b8c543104cf1a875ff41" name="create_formatter" specifiers="virtual"><type>formatter_type</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype><description><para>Attribute name </para></description></parameter><parameter name="args"><paramtype>args_map const &amp;</paramtype><description><para>Formatter arguments </para></description></parameter><description><para>The function creates a formatter for the specified attribute.</para><para>
</para></description></method>
</method-group>
</class><struct id="doxygen.utilities.structboost_1_1log_1_1formatter__factory" name="formatter_factory"><template>
      <template-type-parameter name="CharT"/>
    </template><description><para>Formatter factory base interface. </para></description><typedef id="doxygen.utilities.structboost_1_1log_1_1formatter__factory_1ad92b506e190e93f1c2bda230aeb199a9" name="char_type"><purpose>Character type. </purpose><type>CharT</type></typedef>
<typedef id="doxygen.utilities.structboost_1_1log_1_1formatter__factory_1acf1108866212127ae0e2171bc69be3f5" name="string_type"><purpose>String type. </purpose><type>std::basic_string&lt; char_type &gt;</type></typedef>
<typedef id="doxygen.utilities.structboost_1_1log_1_1formatter__factory_1a0495aadc96e9b7912e62741f2c8a94aa" name="formatter_type"><purpose>The formatter function object. </purpose><type>basic_formatter&lt; char_type &gt;</type></typedef>
<typedef id="doxygen.utilities.structboost_1_1log_1_1formatter__factory_1ab0a79ad9b7256de8b22e32f822980107" name="args_map"><description><para>Type of the map of formatter factory arguments [argument name -&gt; argument value]. This type of maps will be passed to formatter factories on attempt to create a formatter. </para></description><type>std::map&lt; string_type, string_type &gt;</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.structboost_1_1log_1_1formatter__factory_1ac8b0affe1770ffc3f9e798ff9823e306" cv="= default"><description><para>Default constructor </para></description></constructor>
<destructor id="doxygen.utilities.structboost_1_1log_1_1formatter__factory_1a6c285cb30a0851427b2c85d25017e662" specifiers="virtual"><description><para>Virtual destructor </para></description></destructor>
<method id="doxygen.utilities.structboost_1_1log_1_1formatter__factory_1a7e0dda93c6e9d7770aaa9781ac197e81" name="create_formatter" cv="= 0" specifiers="virtual"><type>formatter_type</type><parameter name="name"><paramtype>attribute_name const &amp;</paramtype><description><para>Attribute name </para></description></parameter><parameter name="args"><paramtype>args_map const &amp;</paramtype><description><para>Formatter arguments </para></description></parameter><description><para>The function creates a formatter for the specified attribute.</para><para>
</para></description></method>
<constructor id="doxygen.utilities.structboost_1_1log_1_1formatter__factory_1af707e76474afc2b2a9caea3af5a437f1" cv="= delete"><parameter name=""><paramtype><classname>formatter_factory</classname> const &amp;</paramtype></parameter></constructor>
<copy-assignment id="doxygen.utilities.structboost_1_1log_1_1formatter__factory_1a37bb2349408df701369db99e401543f5" cv="= delete"><type><classname>formatter_factory</classname> &amp;</type><parameter name=""><paramtype><classname>formatter_factory</classname> const &amp;</paramtype></parameter></copy-assignment>
</method-group>
</struct>












































<function id="doxygen.utilities.formatter__parser_8hpp_1a2e3498cdf00b77254237285df231f61d" name="register_formatter_factory"><type>void</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="attr_name"><paramtype>attribute_name const &amp;</paramtype><description><para>Attribute name </para></description></parameter><parameter name="factory"><paramtype>shared_ptr&lt; <classname>formatter_factory</classname>&lt; CharT &gt; &gt; const &amp;</paramtype><description><para>Pointer to the formatter factory </para></description></parameter><purpose>The function registers a user-defined formatter factory. </purpose><description><para>The function registers a user-defined formatter factory. The registered factory function will be called when the formatter parser detects the specified attribute name in the formatter string.</para><para>

</para></description><requires><para><computeroutput>!!attr_name &amp;&amp; !!factory</computeroutput>.</para>
</requires></function>
<function id="doxygen.utilities.formatter__parser_8hpp_1aaea845671dbcdd66d72aede95a959210" name="register_formatter_factory"><type>boost::enable_if_c&lt; is_base_and_derived&lt; <classname>formatter_factory</classname>&lt; typenameFactoryT::char_type &gt;, FactoryT &gt;::value &gt;::type</type><template>
          <template-type-parameter name="FactoryT"/>
        </template><parameter name="attr_name"><paramtype>attribute_name const &amp;</paramtype><description><para>Attribute name </para></description></parameter><parameter name="factory"><paramtype>shared_ptr&lt; FactoryT &gt; const &amp;</paramtype><description><para>Pointer to the formatter factory </para></description></parameter><purpose>The function registers a user-defined formatter factory. </purpose><description><para>The function registers a user-defined formatter factory. The registered factory function will be called when the formatter parser detects the specified attribute name in the formatter string.</para><para>

</para></description><requires><para><computeroutput>!!attr_name &amp;&amp; !!factory</computeroutput>.</para>
</requires></function>
<function id="doxygen.utilities.formatter__parser_8hpp_1ad29d50464e0a8fecd2d5573f11bb9ea9" name="register_simple_formatter_factory"><type>void</type><template>
          <template-type-parameter name="AttributeValueT"/>
          <template-type-parameter name="CharT"/>
        </template><parameter name="attr_name"><paramtype>attribute_name const &amp;</paramtype><description><para>Attribute name </para></description></parameter><purpose>The function registers a simple formatter factory. </purpose><description><para>The function registers a simple formatter factory. The registered factory will generate formatters that will be equivalent to the <computeroutput>log::expressions::attr</computeroutput> formatter (i.e. that will use the native <computeroutput>operator&lt;&lt;</computeroutput> to format the attribute value). The factory does not use any arguments from the format string, if specified.</para><para>

</para></description><requires><para><computeroutput>!!attr_name</computeroutput>.</para>
</requires></function>
<function id="doxygen.utilities.formatter__parser_8hpp_1ade9355e9dad8d901f7309b2563fda50d" name="parse_formatter"><type>basic_formatter&lt; CharT &gt;</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="begin"><paramtype>const CharT *</paramtype><description><para>Pointer to the first character of the sequence </para></description></parameter><parameter name="end"><paramtype>const CharT *</paramtype><description><para>Pointer to the after-the-last character of the sequence </para></description></parameter><description><para>The function parses a formatter from the sequence of characters</para><para>


<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception, if a formatter cannot be recognized in the character sequence. </para></description><requires><para><computeroutput>begin &lt;= end</computeroutput>, both pointers must not be NULL </para>
</requires><returns><para>The parsed formatter.</para>
</returns></function>
<function id="doxygen.utilities.formatter__parser_8hpp_1a3f7b040d85018ab274e13a91b48f75a4" name="parse_formatter"><type>basic_formatter&lt; CharT &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TraitsT"/>
          <template-type-parameter name="AllocatorT"/>
        </template><parameter name="str"><paramtype>std::basic_string&lt; CharT, TraitsT, AllocatorT &gt; const &amp;</paramtype><description><para>A string that contains format description </para></description></parameter><description><para>The function parses a formatter from the string</para><para>

<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception, if a formatter cannot be recognized in the character sequence. </para></description><returns><para>The parsed formatter.</para>
</returns></function>
<function id="doxygen.utilities.formatter__parser_8hpp_1a826603d34bcefee92635fabfb35f282b" name="parse_formatter"><type>basic_formatter&lt; CharT &gt;</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="str"><paramtype>const CharT *</paramtype><description><para>A string that contains format description. </para></description></parameter><description><para>The function parses a formatter from the string</para><para>


<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception, if a formatter cannot be recognized in the character sequence. </para></description><requires><para><computeroutput>str != NULL</computeroutput>, <computeroutput>str</computeroutput> points to a zero-terminated string </para>
</requires><returns><para>The parsed formatter.</para>
</returns></function>
































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.from__settings_8hpp" name="boost/log/utility/setup/from_settings.hpp">
<para><para>Andrey Semashev </para>

<para>11.10.2009</para>

The header contains definition of facilities that allows to initialize the library from settings. </para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1sink__factory" name="sink_factory"><template>
      <template-type-parameter name="CharT"/>
    </template><description><para>Sink factory base interface </para></description><typedef id="doxygen.utilities.structboost_1_1log_1_1sink__factory_1ad92b506e190e93f1c2bda230aeb199a9" name="char_type"><purpose>Character type. </purpose><type>CharT</type></typedef>
<typedef id="doxygen.utilities.structboost_1_1log_1_1sink__factory_1acf1108866212127ae0e2171bc69be3f5" name="string_type"><purpose>String type. </purpose><type>std::basic_string&lt; char_type &gt;</type></typedef>
<typedef id="doxygen.utilities.structboost_1_1log_1_1sink__factory_1a3c192c03ce9892387b1a6e851f38fbb4" name="settings_section"><purpose>Settings section type. </purpose><type><classname>basic_settings_section</classname>&lt; char_type &gt;</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.structboost_1_1log_1_1sink__factory_1a6bcb7bc1f8753e4161bfabfb4840106a" cv="= default"><description><para>Default constructor </para></description></constructor>
<destructor id="doxygen.utilities.structboost_1_1log_1_1sink__factory_1ac60e7ab7ae2f3a7950d237f7f8a9d8d7" specifiers="virtual"><description><para>Virtual destructor </para></description></destructor>
<method id="doxygen.utilities.structboost_1_1log_1_1sink__factory_1ad234550ddd0e9866ab389d1b265513b2" name="create_sink" cv="= 0" specifiers="virtual"><type>shared_ptr&lt; sinks::sink &gt;</type><parameter name="settings"><paramtype>settings_section const &amp;</paramtype><description><para>Sink parameters </para></description></parameter><description><para>The function creates a formatter for the specified attribute.</para><para>
</para></description></method>
<constructor id="doxygen.utilities.structboost_1_1log_1_1sink__factory_1adad87ec854424f96db432d62c14f8988" cv="= delete"><parameter name=""><paramtype><classname>sink_factory</classname> const &amp;</paramtype></parameter></constructor>
<copy-assignment id="doxygen.utilities.structboost_1_1log_1_1sink__factory_1a90cbc6d7437b34cf47e72c07f8883f6f" cv="= delete"><type><classname>sink_factory</classname> &amp;</type><parameter name=""><paramtype><classname>sink_factory</classname> const &amp;</paramtype></parameter></copy-assignment>
</method-group>
</struct>







































<function id="doxygen.utilities.from__settings_8hpp_1a51ea769e19852b75a809d5cebde82f78" name="init_from_settings"><type>void</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="setts"><paramtype><classname>basic_settings_section</classname>&lt; CharT &gt; const &amp;</paramtype><description><para>Library settings container</para></description></parameter><description><para>The function initializes the logging library from a settings container</para><para>
<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception if the provided settings are not valid. </para></description></function>
<function id="doxygen.utilities.from__settings_8hpp_1af9d9752ee6712b8f75529913db3d4bec" name="register_sink_factory"><type>void</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="sink_name"><paramtype>const char *</paramtype><description><para>The custom sink name. Must point to a zero-terminated sequence of characters, must not be NULL. </para></description></parameter><parameter name="factory"><paramtype>shared_ptr&lt; <classname>sink_factory</classname>&lt; CharT &gt; &gt; const &amp;</paramtype><description><para>Pointer to the custom sink factory. Must not be NULL. </para></description></parameter><purpose>The function registers a factory for a custom sink. </purpose><description><para>The function registers a factory for a sink. The factory will be called to create sink instance when the parser discovers the specified sink type in the settings file. The factory must accept a map of parameters [parameter name -&gt; parameter value] that it may use to initialize the sink. The factory must return a non-NULL pointer to the constructed sink instance.</para><para>
</para></description></function>
<function id="doxygen.utilities.from__settings_8hpp_1af24b07c64998c803ba2b959a80d00ea6" name="register_sink_factory"><type>void</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="sink_name"><paramtype>std::string const &amp;</paramtype><description><para>The custom sink name </para></description></parameter><parameter name="factory"><paramtype>shared_ptr&lt; <classname>sink_factory</classname>&lt; CharT &gt; &gt; const &amp;</paramtype><description><para>Pointer to the custom sink factory. Must not be NULL. </para></description></parameter><purpose>The function registers a factory for a custom sink. </purpose><description><para>The function registers a factory for a sink. The factory will be called to create sink instance when the parser discovers the specified sink type in the settings file. The factory must accept a map of parameters [parameter name -&gt; parameter value] that it may use to initialize the sink. The factory must return a non-NULL pointer to the constructed sink instance.</para><para>
</para></description></function>
<function id="doxygen.utilities.from__settings_8hpp_1af2e4c643b45508b51e63427939c9141c" name="register_sink_factory"><type>boost::enable_if_c&lt; is_base_and_derived&lt; <classname>sink_factory</classname>&lt; typenameFactoryT::char_type &gt;, FactoryT &gt;::value &gt;::type</type><template>
          <template-type-parameter name="FactoryT"/>
        </template><parameter name="sink_name"><paramtype>const char *</paramtype><description><para>The custom sink name. Must point to a zero-terminated sequence of characters, must not be NULL. </para></description></parameter><parameter name="factory"><paramtype>shared_ptr&lt; FactoryT &gt; const &amp;</paramtype><description><para>Pointer to the custom sink factory. Must not be NULL. </para></description></parameter><purpose>The function registers a factory for a custom sink. </purpose><description><para>The function registers a factory for a sink. The factory will be called to create sink instance when the parser discovers the specified sink type in the settings file. The factory must accept a map of parameters [parameter name -&gt; parameter value] that it may use to initialize the sink. The factory must return a non-NULL pointer to the constructed sink instance.</para><para>
</para></description></function>
<function id="doxygen.utilities.from__settings_8hpp_1a741300deaecda7bbc44d4feef6afb722" name="register_sink_factory"><type>boost::enable_if_c&lt; is_base_and_derived&lt; <classname>sink_factory</classname>&lt; typenameFactoryT::char_type &gt;, FactoryT &gt;::value &gt;::type</type><template>
          <template-type-parameter name="FactoryT"/>
        </template><parameter name="sink_name"><paramtype>std::string const &amp;</paramtype><description><para>The custom sink name </para></description></parameter><parameter name="factory"><paramtype>shared_ptr&lt; FactoryT &gt; const &amp;</paramtype><description><para>Pointer to the custom sink factory. Must not be NULL. </para></description></parameter><purpose>The function registers a factory for a custom sink. </purpose><description><para>The function registers a factory for a sink. The factory will be called to create sink instance when the parser discovers the specified sink type in the settings file. The factory must accept a map of parameters [parameter name -&gt; parameter value] that it may use to initialize the sink. The factory must return a non-NULL pointer to the constructed sink instance.</para><para>
</para></description></function>






































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.from__stream_8hpp" name="boost/log/utility/setup/from_stream.hpp">
<para><para>Andrey Semashev </para>

<para>22.03.2008</para>

The header contains definition of facilities that allows to initialize the library from a settings file. </para><namespace name="boost">
<namespace name="log">







































<function id="doxygen.utilities.from__stream_8hpp_1a3483a67c3684ceee8bb3ebecb638787d" name="init_from_stream"><type>void</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="strm"><paramtype>std::basic_istream&lt; CharT &gt; &amp;</paramtype><description><para>Stream, that provides library settings</para></description></parameter><description><para>The function initializes the logging library from a stream containing logging settings</para><para>
<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception if the read data cannot be interpreted as the library settings </para></description></function>











































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.settings_8hpp" name="boost/log/utility/setup/settings.hpp">
<para><para>Andrey Semashev </para>

<para>11.10.2009</para>

The header contains definition of the library settings container. </para><namespace name="boost">
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1basic__settings" name="basic_settings"><template>
      <template-type-parameter name="CharT"/>
    </template><inherit access="public">boost::log::basic_settings_section&lt; CharT &gt;</inherit><purpose>The class represents settings container. </purpose><description><para>All settings are presented as a number of named parameters divided into named sections. The parameters values are stored as strings. Individual parameters may be queried via subscript operators, like this:</para><para><computeroutput><programlisting>
optional&lt; string &gt; param = settings["Section1"]["Param1"]; // reads parameter "Param1" in section "Section1"
                                                           // returns an empty value if no such parameter exists
settings["Section2"]["Param2"] = 10; // sets the parameter "Param2" in section "Section2"
                                     // to value "10"
</programlisting></computeroutput></para><para>There are also other methods to work with parameters. </para></description><typedef id="doxygen.utilities.classboost_1_1log_1_1basic__settings_1a1ed1e6ae46281d7403d623b71a9f6077" name="section"><purpose>Section type. </purpose><type><classname>basic_settings_section</classname>&lt; CharT &gt;</type></typedef>
<typedef id="doxygen.utilities.classboost_1_1log_1_1basic__settings_1a4a93969510fef1885c98dc43bdd7d0af" name="property_tree_type"><purpose>Property tree type. </purpose><type>section::property_tree_type</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1basic__settings_1a67b4fcb77dc2e14e12a761216c6298e2"><description><para>Default constructor. Creates an empty settings container. </para></description></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1basic__settings_1a7c3b22c0da4a37afa828605ee1c9cfd5"><parameter name="that"><paramtype><classname>basic_settings</classname> const &amp;</paramtype></parameter><description><para>Copy constructor. </para></description></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1basic__settings_1ab3e6ab621ed104f6563d52cf55d28113" cv="noexcept"><parameter name="that"><paramtype><classname>this_type</classname> &amp;&amp;</paramtype></parameter><description><para>Move constructor. </para></description></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1basic__settings_1a1017fa05b7d09977b0e55a1ff488238a" specifiers="explicit"><parameter name="tree"><paramtype>property_tree_type const &amp;</paramtype></parameter><description><para>Initializing constructor. Creates a settings container with the copy of the specified property tree. </para></description></constructor>
<destructor id="doxygen.utilities.classboost_1_1log_1_1basic__settings_1a86df01c6f8309e65dc2b7565d33b1e5b" cv="noexcept"><description><para>Destructor </para></description></destructor>
<copy-assignment id="doxygen.utilities.classboost_1_1log_1_1basic__settings_1a404aed0a7a6d65168b4cae68c92ec8b1"><type><classname>basic_settings</classname> &amp;</type><parameter name="that"><paramtype><classname>basic_settings</classname> const &amp;</paramtype></parameter><description><para>Copy assignment operator. </para></description></copy-assignment>
<copy-assignment id="doxygen.utilities.classboost_1_1log_1_1basic__settings_1a734c3c6efe1685a4c5584830b0658f80" cv="noexcept"><type><classname>basic_settings</classname> &amp;</type><parameter name="that"><paramtype><classname>basic_settings</classname> &amp;&amp;</paramtype></parameter><description><para>Move assignment operator. </para></description></copy-assignment>
</method-group>
</class><class id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section" name="basic_settings_section"><template>
      <template-type-parameter name="CharT"/>
    </template><purpose>The class represents a reference to the settings container section. </purpose><description><para>The section refers to a sub-tree of the library settings container. It does not own the referred sub-tree but allows for convenient access to parameters within the subsection. </para></description><typedef id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1ad92b506e190e93f1c2bda230aeb199a9" name="char_type"><purpose>Character type. </purpose><type>CharT</type></typedef>
<typedef id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1acf1108866212127ae0e2171bc69be3f5" name="string_type"><purpose>String type. </purpose><type>std::basic_string&lt; char_type &gt;</type></typedef>
<typedef id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1abeaf3f65589a3266a91a972ee8fb6bcd" name="property_tree_type"><purpose>Property tree type. </purpose><type>property_tree::basic_ptree&lt; std::string, string_type &gt;</type></typedef>
<typedef id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1a2a675a4bb705eff9996593e3d6ef60e6" name="path_type"><purpose>Property tree path type. </purpose><type>property_tree_type::path_type</type></typedef>
<typedef id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1aab4031cbf61029df67ba9605fcd7f792" name="const_reference"><description><para>Constant reference to the parameter value </para></description><type>implementation_defined</type></typedef>
<typedef id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1aeb2d495fef9f2209a738ac59800d7682" name="reference"><description><para>Mutable reference to the parameter value </para></description><type>implementation_defined</type></typedef>
<typedef id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1a20cfb0458c5f7684b1f0a48dc497f2e1" name="const_iterator"><description><para>Constant iterator over nested parameters and subsections </para></description><type>implementation_defined</type></typedef>
<typedef id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1afad66e3d9397095b51a512606ed4e45b" name="iterator"><description><para>Mutable iterator over nested parameters and subsections </para></description><type>implementation_defined</type></typedef>
<method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1aea9ad7aa13d15a810e19fceff3983695" cv="noexcept"><description><para>Default constructor. Creates an empty settings container. </para></description></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1aa13ed0211bfa6ae529e6d7201facebfb" cv="noexcept"><parameter name="that"><paramtype><classname>basic_settings_section</classname> const &amp;</paramtype></parameter><description><para>Copy constructor. </para></description></constructor>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1a420e60e9788bfa3b52aa3aab72ea3a5e" name="conversion-operator" cv="const noexcept" specifiers="explicit"><type>bool</type><description><para>Checks if the section refers to the container. </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1aa781ac6ac5a122ef2e89325c84d51f5a" name="operator!" cv="const noexcept"><type>bool</type><description><para>Checks if the section refers to the container. </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1ad69bd11391be1a1dba5c8202259664f8" name="begin"><type>iterator</type><description><para>Returns an iterator over the nested subsections and parameters. </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1acad38d52497a975bfb6f2f6acd76631f" name="end"><type>iterator</type><description><para>Returns an iterator over the nested subsections and parameters. </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1a29305669b60ca1680752e2fc3592ba99" name="begin" cv="const"><type>const_iterator</type><description><para>Returns an iterator over the nested subsections and parameters. </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1accf9a4bd0c34d4a5f6a7dab66ea10cdc" name="end" cv="const"><type>const_iterator</type><description><para>Returns an iterator over the nested subsections and parameters. </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1acea44ed500a54b2bb93e16b86e81afa8" name="rbegin"><type>reverse_iterator</type><description><para>Returns a reverse iterator over the nested subsections and parameters. </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1a68c599ddcbfddc65170de524ac165e44" name="rend"><type>reverse_iterator</type><description><para>Returns a reverse iterator over the nested subsections and parameters. </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1af086cceac199bd735c7a97c2a8d7ed21" name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para>Returns a reverse iterator over the nested subsections and parameters. </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1a07da1fdc890b6949f1a20a1961c6fc44" name="rend" cv="const"><type>const_reverse_iterator</type><description><para>Returns a reverse iterator over the nested subsections and parameters. </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1a644718bb2fb240de962dc3c9a1fdf0dc" name="empty" cv="const"><type>bool</type><description><para>Checks if the container is empty (i.e. contains no sections and parameters). </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1a72e5389800522cdf575f4e4148e5f62f" name="operator[]"><type>reference</type><parameter name="section_name"><paramtype>std::string const &amp;</paramtype><description><para>The name of the section in which the parameter resides </para></description></parameter><description><para>Accessor to a single parameter. This operator should be used in conjunction with the subsequent subscript operator that designates the parameter name.</para><para>

</para></description><returns><para>An unspecified reference type that can be used for parameter name specifying </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1a15de1a639340c4f0691aeeea459fdd0c" name="operator[]" cv="const"><type>const_reference</type><parameter name="section_name"><paramtype>std::string const &amp;</paramtype><description><para>The name of the section in which the parameter resides </para></description></parameter><description><para>Accessor to a single parameter. This operator should be used in conjunction with the subsequent subscript operator that designates the parameter name.</para><para>

</para></description><returns><para>An unspecified reference type that can be used for parameter name specifying </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1aad0ed7b2733dfce8297ecba46c117908" name="operator[]"><type>reference</type><parameter name="section_name"><paramtype>const char *</paramtype><description><para>The name of the section in which the parameter resides </para></description></parameter><description><para>Accessor to a single parameter. This operator should be used in conjunction with the subsequent subscript operator that designates the parameter name.</para><para>

</para></description><returns><para>An unspecified reference type that can be used for parameter name specifying </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1aeb6991c7e592b68c62d935662fc6744b" name="operator[]" cv="const"><type>const_reference</type><parameter name="section_name"><paramtype>const char *</paramtype><description><para>The name of the section in which the parameter resides </para></description></parameter><description><para>Accessor to a single parameter. This operator should be used in conjunction with the subsequent subscript operator that designates the parameter name.</para><para>

</para></description><returns><para>An unspecified reference type that can be used for parameter name specifying </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1a30c61b20ebea0b6c16c877552dd13399" name="property_tree" cv="const"><type>property_tree_type const &amp;</type><description><para>Accessor for the embedded property tree </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1a158b5cab399fc0898bfb9eed2dbdd764" name="property_tree"><type>property_tree_type &amp;</type><description><para>Accessor for the embedded property tree </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1a808d0da74f9a604e9b6b4d347c538f50" name="has_section" cv="const"><type>bool</type><parameter name="section_name"><paramtype>string_type const &amp;</paramtype><description><para>The name of the section </para></description></parameter><description><para>Checks if the specified section is present in the container.</para><para>
</para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1af53fc2bac601f62dc8cf107d7746a6b5" name="has_parameter" cv="const"><type>bool</type><parameter name="section_name"><paramtype>string_type const &amp;</paramtype><description><para>The name of the section in which the parameter resides </para></description></parameter><parameter name="param_name"><paramtype>string_type const &amp;</paramtype><description><para>The name of the parameter </para></description></parameter><description><para>Checks if the specified parameter is present in the container.</para><para>
</para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1a0a4526c2b4b930ccaf5dcc2dcbd6794b" name="swap" cv="noexcept"><type>void</type><parameter name="that"><paramtype><classname>basic_settings_section</classname> &amp;</paramtype></parameter><description><para>Swaps two references to settings sections. </para></description></method>
</method-group>
<method-group name="protected member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1basic__settings__section_1a2b48129cc4612aa21f3bad69a1cb5873" specifiers="explicit" cv="noexcept"><parameter name="tree"><paramtype>property_tree_type *</paramtype></parameter></constructor>
</method-group>
</class><typedef id="doxygen.utilities.settings_8hpp_1a883b1c9a897e3f1e583a4b78a94dd54c" name="settings"><purpose>Convenience typedef for narrow-character logging. </purpose><type><classname>basic_settings</classname>&lt; char &gt;</type></typedef>
<typedef id="doxygen.utilities.settings_8hpp_1aeea7f4a4e545e0376244a9f7deeee4c0" name="settings_section"><purpose>Convenience typedef for narrow-character logging. </purpose><type><classname>basic_settings_section</classname>&lt; char &gt;</type></typedef>
<typedef id="doxygen.utilities.settings_8hpp_1a08ced24f19133ad95348a6bed6b3cc01" name="wsettings"><purpose>Convenience typedef for wide-character logging. </purpose><type><classname>basic_settings</classname>&lt; wchar_t &gt;</type></typedef>
<typedef id="doxygen.utilities.settings_8hpp_1a83ae0f28517861b58edf531a15764200" name="wsettings_section"><purpose>Convenience typedef for wide-character logging. </purpose><type><classname>basic_settings_section</classname>&lt; wchar_t &gt;</type></typedef>






































<function id="doxygen.utilities.settings_8hpp_1a2c2b0ee965cb8d22625f75ef5012b675" name="swap"><type>void</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="left"><paramtype><classname>basic_settings_section</classname>&lt; CharT &gt; &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>basic_settings_section</classname>&lt; CharT &gt; &amp;</paramtype></parameter></function>












































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.settings__parser_8hpp" name="boost/log/utility/setup/settings_parser.hpp">
<para><para>Andrey Semashev </para>

<para>20.07.2012</para>

The header contains definition of a settings parser function. </para><namespace name="boost">
<namespace name="log">





































<function id="doxygen.utilities.settings__parser_8hpp_1abf0a895dddeff6a3fcaea299a5e27356" name="parse_settings"><type><classname>basic_settings</classname>&lt; CharT &gt;</type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="strm"><paramtype>std::basic_istream&lt; CharT &gt; &amp;</paramtype><description><para>Stream, that provides library settings</para></description></parameter><description><para>The function parses library settings from an input stream</para><para>
<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception if the read data cannot be interpreted as the library settings </para></description></function>













































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.strictest__lock_8hpp" name="boost/log/utility/strictest_lock.hpp">
<para><para>Andrey Semashev </para>

<para>30.05.2010</para>

The header contains definition of the <computeroutput>strictest_lock</computeroutput> metafunction that allows to select a lock with the strictest access requirements. </para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1strictest__lock" name="strictest_lock"><template>
      <template-nontype-parameter name="LocksT"><type>typename...</type></template-nontype-parameter>
    </template><purpose>The metafunction selects the most strict lock type of the specified. </purpose><description><para>The template supports all lock types provided by the Boost.Thread library (except for <computeroutput>upgrade_to_unique_lock</computeroutput>), plus additional pseudo-lock <computeroutput>no_lock</computeroutput> that indicates no locking at all. Exclusive locks are considered the strictest, shared locks are weaker, and <computeroutput>no_lock</computeroutput> is the weakest. </para></description><typedef id="doxygen.utilities.structboost_1_1log_1_1strictest__lock_1adb48fb3a4145ff6aebc0480d3d134241" name="type"><type>implementation_defined</type></typedef>
</struct><struct id="doxygen.utilities.structboost_1_1log_1_1thread__access__mode__of" name="thread_access_mode_of"><template>
      <template-type-parameter name="LockT"/>
    </template><purpose>The trait allows to select an access mode by the lock type. </purpose></struct><struct-specialization id="doxygen.utilities.structboost_1_1log_1_1thread__access__mode__of_3_01boost_1_1log_1_1aux_1_1exclusive__lock__guard_3_01MutexT_01_4_01_4" name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT"/>
    </template><specialization><template-arg>boost::log::aux::exclusive_lock_guard&lt; MutexT &gt;</template-arg></specialization><inherit access="public">boost::integral_constant&lt; lock_access_mode, exclusive_access &gt;</inherit></struct-specialization><struct-specialization id="doxygen.utilities.structboost_1_1log_1_1thread__access__mode__of_3_01boost_1_1log_1_1aux_1_1multiple__unique__lock36f5de336f7bf77c0ec8848f52d0c3a5" name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT1"/>
      <template-type-parameter name="MutexT2"/>
    </template><specialization><template-arg>boost::log::aux::multiple_unique_lock2&lt; MutexT1</template-arg><template-arg>MutexT2 &gt;</template-arg></specialization><inherit access="public">boost::integral_constant&lt; lock_access_mode, exclusive_access &gt;</inherit></struct-specialization><struct-specialization id="doxygen.utilities.structboost_1_1log_1_1thread__access__mode__of_3_01boost_1_1log_1_1aux_1_1shared__lock__guard_3_01MutexT_01_4_01_4" name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT"/>
    </template><specialization><template-arg>boost::log::aux::shared_lock_guard&lt; MutexT &gt;</template-arg></specialization><inherit access="public">boost::integral_constant&lt; lock_access_mode, shared_access &gt;</inherit></struct-specialization><struct-specialization id="doxygen.utilities.structboost_1_1log_1_1thread__access__mode__of_3_01lock__guard_3_01MutexT_01_4_01_4" name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT"/>
    </template><specialization><template-arg>lock_guard&lt; MutexT &gt;</template-arg></specialization><inherit access="public">boost::integral_constant&lt; lock_access_mode, exclusive_access &gt;</inherit></struct-specialization><struct-specialization id="doxygen.utilities.structboost_1_1log_1_1thread__access__mode__of_3_01no__lock_3_01MutexT_01_4_01_4" name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT"/>
    </template><specialization><template-arg>no_lock&lt; MutexT &gt;</template-arg></specialization><inherit access="public">boost::integral_constant&lt; lock_access_mode, unlocked_access &gt;</inherit></struct-specialization><struct-specialization id="doxygen.utilities.structboost_1_1log_1_1thread__access__mode__of_3_01shared__lock_3_01MutexT_01_4_01_4" name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT"/>
    </template><specialization><template-arg>shared_lock&lt; MutexT &gt;</template-arg></specialization><inherit access="public">boost::integral_constant&lt; lock_access_mode, shared_access &gt;</inherit></struct-specialization><struct-specialization id="doxygen.utilities.structboost_1_1log_1_1thread__access__mode__of_3_01shared__lock__guard_3_01MutexT_01_4_01_4" name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT"/>
    </template><specialization><template-arg>shared_lock_guard&lt; MutexT &gt;</template-arg></specialization><inherit access="public">boost::integral_constant&lt; lock_access_mode, shared_access &gt;</inherit></struct-specialization><struct-specialization id="doxygen.utilities.structboost_1_1log_1_1thread__access__mode__of_3_01std_1_1lock__guard_3_01MutexT_01_4_01_4" name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT"/>
    </template><specialization><template-arg>std::lock_guard&lt; MutexT &gt;</template-arg></specialization><inherit access="public">boost::integral_constant&lt; lock_access_mode, exclusive_access &gt;</inherit></struct-specialization><struct-specialization id="doxygen.utilities.structboost_1_1log_1_1thread__access__mode__of_3_01std_1_1shared__lock_3_01MutexT_01_4_01_4" name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT"/>
    </template><specialization><template-arg>std::shared_lock&lt; MutexT &gt;</template-arg></specialization><inherit access="public">boost::integral_constant&lt; lock_access_mode, shared_access &gt;</inherit></struct-specialization><struct-specialization id="doxygen.utilities.structboost_1_1log_1_1thread__access__mode__of_3_01std_1_1unique__lock_3_01MutexT_01_4_01_4" name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT"/>
    </template><specialization><template-arg>std::unique_lock&lt; MutexT &gt;</template-arg></specialization><inherit access="public">boost::integral_constant&lt; lock_access_mode, exclusive_access &gt;</inherit></struct-specialization><struct-specialization id="doxygen.utilities.structboost_1_1log_1_1thread__access__mode__of_3_01unique__lock_3_01MutexT_01_4_01_4" name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT"/>
    </template><specialization><template-arg>unique_lock&lt; MutexT &gt;</template-arg></specialization><inherit access="public">boost::integral_constant&lt; lock_access_mode, exclusive_access &gt;</inherit></struct-specialization><struct-specialization id="doxygen.utilities.structboost_1_1log_1_1thread__access__mode__of_3_01upgrade__lock_3_01MutexT_01_4_01_4" name="thread_access_mode_of"><template>
      <template-type-parameter name="MutexT"/>
    </template><specialization><template-arg>upgrade_lock&lt; MutexT &gt;</template-arg></specialization><inherit access="public">boost::integral_constant&lt; lock_access_mode, shared_access &gt;</inherit></struct-specialization><enum id="doxygen.utilities.strictest__lock_8hpp_1a7963e379a015c693e7756301e4106786" name="lock_access_mode"><enumvalue id="doxygen.utilities.strictest__lock_8hpp_1a7963e379a015c693e7756301e4106786abe6fddef9ac917a9896cc45d9878379b" name="unlocked_access"><purpose>A thread that owns this kind of lock doesn't restrict other threads in any way. </purpose></enumvalue><enumvalue id="doxygen.utilities.strictest__lock_8hpp_1a7963e379a015c693e7756301e4106786a7157768d8b59920344b36dd716f0c948" name="shared_access"><purpose>A thread that owns this kind of lock requires that no other thread modify the locked data. </purpose></enumvalue><enumvalue id="doxygen.utilities.strictest__lock_8hpp_1a7963e379a015c693e7756301e4106786ab0ed26fe971d2664437f7b2f7f1da02a" name="exclusive_access"><purpose>A thread that owns this kind of lock requires that no other thread has access to the locked data. </purpose></enumvalue><purpose>Access modes for different types of locks. </purpose></enum>



















































































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.string__literal_8hpp" name="boost/log/utility/string_literal.hpp">
<para><para>Andrey Semashev </para>

<para>24.06.2007</para>

The header contains implementation of a constant string literal wrapper. </para><namespace name="boost">
<namespace name="log">





















<function id="doxygen.utilities.string__literal_8hpp_1a13ee84b48f483b5fda514612e27e96db" name="operator&lt;&lt;"><type>std::basic_ostream&lt; CharT, StrmTraitsT &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="StrmTraitsT"/>
          <template-type-parameter name="LitTraitsT"/>
        </template><parameter name="strm"><paramtype>std::basic_ostream&lt; CharT, StrmTraitsT &gt; &amp;</paramtype></parameter><parameter name="lit"><paramtype><classname>basic_string_literal</classname>&lt; CharT, LitTraitsT &gt; const &amp;</paramtype></parameter><purpose>Output operator. </purpose></function>
<function id="doxygen.utilities.string__literal_8hpp_1a5a40a9c24e1d1bb70af81247c86274bd" name="swap"><type>void</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TraitsT"/>
        </template><parameter name="left"><paramtype><classname>basic_string_literal</classname>&lt; CharT, TraitsT &gt; &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>basic_string_literal</classname>&lt; CharT, TraitsT &gt; &amp;</paramtype></parameter><purpose>External swap. </purpose></function>
<function id="doxygen.utilities.string__literal_8hpp_1a258f4ad81fa179013a7fa9d33427d119" name="str_literal"><type><classname>basic_string_literal</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="LenV"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>T(&amp;)</paramtype></parameter><purpose>Creates a string literal wrapper from a constant string literal. </purpose></function>



























































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.string__literal__fwd_8hpp" name="boost/log/utility/string_literal_fwd.hpp">
<para><para>Andrey Semashev </para>

<para>24.06.2007</para>

The header contains forward declaration of a constant string literal wrapper. </para><namespace name="boost">
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal" name="basic_string_literal"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="TraitsT"/>
    </template><purpose>String literal wrapper. </purpose><description><para>The <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1basic__string__literal">basic_string_literal</link></computeroutput> is a thin wrapper around a constant string literal. It provides interface similar to STL strings, but because of read-only nature of string literals, lacks ability to modify string contents. However, <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1basic__string__literal">basic_string_literal</link></computeroutput> objects can be assigned to and cleared.</para><para>The main advantage of this class comparing to other string classes is that it doesn't dynamically allocate memory and therefore is fast, thin and exception safe. </para></description><method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1af4ea4b28b1767541617cf0d40b3bd4b4" cv="noexcept"><description><para>Constructor</para><para>
</para></description><postconditions><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1af34f0f34e77bda4a88ebd9b127634992">empty()</link> == true</computeroutput> </para>
</postconditions></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a40ed708e8bdff36d5d43fc34e9e7e0dc" cv="noexcept"><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="LenV"><type>size_type</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>T(&amp;)</paramtype><description><para>A zero-terminated constant sequence of characters </para></description></parameter><description><para>Constructor from a string literal</para><para>

</para></description><postconditions><para><computeroutput>*this == p</computeroutput> </para>
</postconditions></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a28b5b683a344699e8c61390916003ea3" cv="noexcept"><parameter name="that"><paramtype><classname>basic_string_literal</classname> const &amp;</paramtype><description><para>Source literal to copy string from </para></description></parameter><description><para>Copy constructor</para><para>

</para></description><postconditions><para><computeroutput>*this == that</computeroutput> </para>
</postconditions></constructor>
<copy-assignment id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1af7a8bf37e35024224214d92a0e521beb" cv="noexcept"><type><classname>this_type</classname> &amp;</type><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype><description><para>Source literal to copy string from </para></description></parameter><description><para>Assignment operator</para><para>

</para></description><postconditions><para><computeroutput>*this == that</computeroutput> </para>
</postconditions></copy-assignment>
<copy-assignment id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1ab34f6f21bc3f504d4a9f4b0331a27c13" cv="noexcept"><type><classname>this_type</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="LenV"><type>size_type</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>T(&amp;)</paramtype><description><para>A zero-terminated constant sequence of characters </para></description></parameter><description><para>Assignment from a string literal</para><para>

</para></description><postconditions><para><computeroutput>*this == p</computeroutput> </para>
</postconditions></copy-assignment>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1add1d8134bf15c0f188ed2b5a4d840c79" name="operator==" cv="const noexcept"><type>bool</type><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographical comparison (equality)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if the comparand string equals to this string, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a68cf281db003d66c22f9b2b25123b7c4" name="operator==" cv="const noexcept"><type>bool</type><parameter name="str"><paramtype>const_pointer</paramtype><description><para>Comparand. Must point to a zero-terminated sequence of characters, must not be NULL. </para></description></parameter><description><para>Lexicographical comparison (equality)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if the comparand string equals to this string, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a0fda58753a2b88faf80254d67f25d0d5" name="operator==" cv="const noexcept"><type>bool</type><parameter name="that"><paramtype>string_type const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographical comparison (equality)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if the comparand string equals to this string, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1af415384f2e84bfe331f16de5dfdaeb55" name="operator!=" cv="const noexcept"><type>bool</type><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographical comparison (inequality)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if the comparand string is not equal to this string, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a973efa033d1f2f5352d958b053298f49" name="operator!=" cv="const noexcept"><type>bool</type><parameter name="str"><paramtype>const_pointer</paramtype><description><para>Comparand. Must point to a zero-terminated sequence of characters, must not be NULL. </para></description></parameter><description><para>Lexicographical comparison (inequality)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if the comparand string is not equal to this string, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1abec879fe4aa778a2927e55829ad56985" name="operator!=" cv="const noexcept"><type>bool</type><parameter name="that"><paramtype>string_type const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographical comparison (inequality)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if the comparand string is not equal to this string, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a0fc461aa7dc9e1f8f1a46ee1904c9cd5" name="operator&lt;" cv="const noexcept"><type>bool</type><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographical comparison (less ordering)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if this string is less than the comparand, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a9be438164e900c092ac9ee9ea3fbe0cb" name="operator&lt;" cv="const noexcept"><type>bool</type><parameter name="str"><paramtype>const_pointer</paramtype><description><para>Comparand. Must point to a zero-terminated sequence of characters, must not be NULL. </para></description></parameter><description><para>Lexicographical comparison (less ordering)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if this string is less than the comparand, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a8ad4a5055031ddff53d7b788e83214db" name="operator&lt;" cv="const noexcept"><type>bool</type><parameter name="that"><paramtype>string_type const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographical comparison (less ordering)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if this string is less than the comparand, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1ab749fe4ab2fcc736da32274a2615e367" name="operator&lt;=" cv="const noexcept"><type>bool</type><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographical comparison (less or equal ordering)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if this string is less or equal to the comparand, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a28728854c55cd2740f5b4e50b3cf3ec7" name="operator&lt;=" cv="const noexcept"><type>bool</type><parameter name="str"><paramtype>const_pointer</paramtype><description><para>Comparand. Must point to a zero-terminated sequence of characters, must not be NULL. </para></description></parameter><description><para>Lexicographical comparison (less or equal ordering)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if this string is less or equal to the comparand, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1af986159b68812fdda28d87c5d7453a28" name="operator&lt;=" cv="const noexcept"><type>bool</type><parameter name="that"><paramtype>string_type const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographical comparison (less or equal ordering)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if this string is less or equal to the comparand, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a4ddfc9951196225ec6b6199535673cf0" name="operator&gt;" cv="const noexcept"><type>bool</type><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographical comparison (greater ordering)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if this string is greater than the comparand, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1ad642cebf26a0750f512a286b3c94ff65" name="operator&gt;" cv="const noexcept"><type>bool</type><parameter name="str"><paramtype>const_pointer</paramtype><description><para>Comparand. Must point to a zero-terminated sequence of characters, must not be NULL. </para></description></parameter><description><para>Lexicographical comparison (greater ordering)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if this string is greater than the comparand, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a868362f24a433fbb4e6f53a5211f9b3e" name="operator&gt;" cv="const noexcept"><type>bool</type><parameter name="that"><paramtype>string_type const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographical comparison (greater ordering)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if this string is greater than the comparand, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a3be3923236f6a86343bd8f08708b91c1" name="operator&gt;=" cv="const noexcept"><type>bool</type><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographical comparison (greater or equal ordering)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if this string is greater or equal to the comparand, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a5a6038af84c16ac63bacd1dc6f193da2" name="operator&gt;=" cv="const noexcept"><type>bool</type><parameter name="str"><paramtype>const_pointer</paramtype><description><para>Comparand. Must point to a zero-terminated sequence of characters, must not be NULL. </para></description></parameter><description><para>Lexicographical comparison (greater or qual ordering)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if this string is greater or equal to the comparand, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1ac6b75d580fc4a83cf087650dc68eda05" name="operator&gt;=" cv="const noexcept"><type>bool</type><parameter name="that"><paramtype>string_type const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographical comparison (greater or equal ordering)</para><para>

</para></description><returns><para><computeroutput>true</computeroutput> if this string is greater or equal to the comparand, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1ae0e9a2bf76321136c6dd42e9dde7e12c" name="operator[]" cv="const noexcept"><type>const_reference</type><parameter name="i"><paramtype>size_type</paramtype><description><para>Requested character index </para></description></parameter><description><para>Subscript operator</para><para>


</para></description><requires><para><computeroutput>i &lt; <link linkend="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a47293c97b8f2735433efee82ae71171e">size()</link></computeroutput> </para>
</requires><returns><para>Constant reference to the requested character </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1ae739f0a4a8290b98f2dec599b1c021f5" name="at" cv="const"><type>const_reference</type><parameter name="i"><paramtype>size_type</paramtype><description><para>Requested character index </para></description></parameter><description><para>Checked subscript</para><para>

<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception if index <emphasis>i</emphasis> is out of string boundaries </para></description><returns><para>Constant reference to the requested character</para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a9997c5f9166f76ccff8e5cf312b9587d" name="c_str" cv="const noexcept"><type>const_pointer</type><description><para>
</para></description><returns><para>Pointer to the beginning of the literal </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1aead72bdc28ba080457675a6026e9bb94" name="data" cv="const noexcept"><type>const_pointer</type><description><para>
</para></description><returns><para>Pointer to the beginning of the literal </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a47293c97b8f2735433efee82ae71171e" name="size" cv="const noexcept"><type>size_type</type><description><para>
</para></description><returns><para>Length of the literal </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1ac904ed63c2ae9bd281fc39661d087e1c" name="length" cv="const noexcept"><type>size_type</type><description><para>
</para></description><returns><para>Length of the literal </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1af34f0f34e77bda4a88ebd9b127634992" name="empty" cv="const noexcept"><type>bool</type><description><para>
</para></description><returns><para><computeroutput>true</computeroutput> if the literal is an empty string, <computeroutput>false</computeroutput> otherwise </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a0a794d38955cd03023ce91647c0b4d01" name="begin" cv="const noexcept"><type>const_iterator</type><description><para>
</para></description><returns><para>Iterator that points to the first character of the literal </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a2e258f78385663a2be805d76b8907eba" name="end" cv="const noexcept"><type>const_iterator</type><description><para>
</para></description><returns><para>Iterator that points after the last character of the literal </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1aff2c14a4e54378db02316aa5dacce912" name="rbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para>
</para></description><returns><para>Reverse iterator that points to the last character of the literal </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1ac5bfd48090cb59d7dd635954831415df" name="rend" cv="const noexcept"><type>const_reverse_iterator</type><description><para>
</para></description><returns><para>Reverse iterator that points before the first character of the literal </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1af44434f80c89aaeb92e09cef62c6f651" name="str" cv="const"><type>string_type</type><description><para>
</para></description><returns><para>STL string constructed from the literal </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a96d391a5b8907ff5b9adf72774583f90" name="clear" cv="noexcept"><type>void</type><description><para>The method clears the literal</para><para>
</para></description><postconditions><para><computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1af34f0f34e77bda4a88ebd9b127634992">empty()</link> == true</computeroutput> </para>
</postconditions></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1abd3453975caadda7b45a49a74925ef51" name="swap" cv="noexcept"><type>void</type><parameter name="that"><paramtype><classname>this_type</classname> &amp;</paramtype></parameter><description><para>The method swaps two literals </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a324be6fd4e001310222d66d4b1b11801" name="assign" cv="noexcept"><type><classname>this_type</classname> &amp;</type><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype><description><para>Source literal to copy string from </para></description></parameter><description><para>Assignment from another literal</para><para>

</para></description><postconditions><para><computeroutput>*this == that</computeroutput> </para>
</postconditions></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a986c00ef7e8b64080d25dc9b1473155a" name="assign" cv="noexcept"><type><classname>this_type</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="LenV"><type>size_type</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>T(&amp;)</paramtype><description><para>A zero-terminated constant sequence of characters </para></description></parameter><description><para>Assignment from another literal</para><para>

</para></description><postconditions><para><computeroutput>*this == p</computeroutput> </para>
</postconditions></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1ad80a52952cfff23310acbe0f6d10632c" name="copy" cv="const"><type>size_type</type><parameter name="str"><paramtype>value_type *</paramtype><description><para>Pointer to the external buffer beginning. Must not be NULL. The buffer must have enough capacity to accommodate the requested number of characters. </para></description></parameter><parameter name="n"><paramtype>size_type</paramtype><description><para>Maximum number of characters to copy </para></description></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default><description><para>Starting position to start copying from </para></description></parameter><description><para>The method copies the literal or its portion to an external buffer</para><para>


<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception if <emphasis>pos</emphasis> is out of range. </para></description><requires><para><computeroutput>pos &lt;= <link linkend="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a47293c97b8f2735433efee82ae71171e">size()</link></computeroutput> </para>
</requires><returns><para>Number of characters copied</para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1aeb1919dcc751c90cda39d5e98899fdb5" name="compare" cv="const"><type>int</type><parameter name="pos"><paramtype>size_type</paramtype><description><para>Starting position within this string to perform comparison to </para></description></parameter><parameter name="n"><paramtype>size_type</paramtype><description><para>Length of the substring of this string to perform comparison to </para></description></parameter><parameter name="str"><paramtype>const_pointer</paramtype><description><para>Comparand. Must point to a sequence of characters, must not be NULL. </para></description></parameter><parameter name="len"><paramtype>size_type</paramtype><description><para>Number of characters in the sequence <emphasis>str</emphasis>. </para></description></parameter><description><para>Lexicographically compares the argument string to a part of this string</para><para>


<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception if <emphasis>pos</emphasis> is out of range. </para></description><requires><para><computeroutput>pos &lt;= <link linkend="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a47293c97b8f2735433efee82ae71171e">size()</link></computeroutput> </para>
</requires><returns><para>Zero if the comparand equals this string, a negative value if this string is less than the comparand, a positive value if this string is greater than the comparand.</para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a4895e45b2acd3ad67255a972aea0c175" name="compare" cv="const noexcept"><type>int</type><parameter name="pos"><paramtype>size_type</paramtype><description><para>Starting position within this string to perform comparison to </para></description></parameter><parameter name="n"><paramtype>size_type</paramtype><description><para>Length of the substring of this string to perform comparison to </para></description></parameter><parameter name="str"><paramtype>const_pointer</paramtype><description><para>Comparand. Must point to a zero-terminated sequence of characters, must not be NULL. </para></description></parameter><description><para>Lexicographically compares the argument string to a part of this string</para><para>


<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception if <emphasis>pos</emphasis> is out of range. </para></description><requires><para><computeroutput>pos &lt;= <link linkend="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a47293c97b8f2735433efee82ae71171e">size()</link></computeroutput> </para>
</requires><returns><para>Zero if the comparand equals this string, a negative value if this string is less than the comparand, a positive value if this string is greater than the comparand.</para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1adcafed849f778ba87945c6df4d591a59" name="compare" cv="const noexcept"><type>int</type><parameter name="pos"><paramtype>size_type</paramtype><description><para>Starting position within this string to perform comparison to </para></description></parameter><parameter name="n"><paramtype>size_type</paramtype><description><para>Length of the substring of this string to perform comparison to </para></description></parameter><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographically compares the argument string literal to a part of this string</para><para>


<emphasis role="bold">Throws:</emphasis> An <computeroutput>std::exception</computeroutput>-based exception if <emphasis>pos</emphasis> is out of range. </para></description><requires><para><computeroutput>pos &lt;= <link linkend="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a47293c97b8f2735433efee82ae71171e">size()</link></computeroutput> </para>
</requires><returns><para>Zero if the comparand equals this string, a negative value if this string is less than the comparand, a positive value if this string is greater than the comparand.</para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1af4d73d6fa306de76653c87e25df7fb01" name="compare" cv="const noexcept"><type>int</type><parameter name="str"><paramtype>const_pointer</paramtype><description><para>Comparand. Must point to a sequence of characters, must not be NULL. </para></description></parameter><parameter name="len"><paramtype>size_type</paramtype><description><para>Number of characters in the sequence <emphasis>str</emphasis>. </para></description></parameter><description><para>Lexicographically compares the argument string to this string</para><para>

</para></description><returns><para>Zero if the comparand equals this string, a negative value if this string is less than the comparand, a positive value if this string is greater than the comparand. </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a75d9dd2b14e17ad3698d096f02cda90d" name="compare" cv="const noexcept"><type>int</type><parameter name="str"><paramtype>const_pointer</paramtype><description><para>Comparand. Must point to a zero-terminated sequence of characters, must not be NULL. </para></description></parameter><description><para>Lexicographically compares the argument string to this string</para><para>

</para></description><returns><para>Zero if the comparand equals this string, a negative value if this string is less than the comparand, a positive value if this string is greater than the comparand. </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1basic__string__literal_1a68dada7b305b386c1892738ea01bb0bc" name="compare" cv="const noexcept"><type>int</type><parameter name="that"><paramtype><classname>this_type</classname> const &amp;</paramtype><description><para>Comparand </para></description></parameter><description><para>Lexicographically compares the argument string to this string</para><para>

</para></description><returns><para>Zero if the comparand equals this string, a negative value if this string is less than the comparand, a positive value if this string is greater than the comparand. </para>
</returns></method>
</method-group>
</class><typedef id="doxygen.utilities.string__literal__fwd_8hpp_1a4b916f24dcb8f5337eb8cb9a77aad35d" name="string_literal"><purpose>String literal type for narrow characters. </purpose><type><classname>basic_string_literal</classname>&lt; char &gt;</type></typedef>
<typedef id="doxygen.utilities.string__literal__fwd_8hpp_1a64e1eb718a37cb9f06694ea3d87cd813" name="wstring_literal"><purpose>String literal type for wide characters. </purpose><type><classname>basic_string_literal</classname>&lt; wchar_t &gt;</type></typedef>



















































































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.date__time__types_8hpp" name="boost/log/utility/type_dispatch/date_time_types.hpp">
<para><para>Andrey Semashev </para>

<para>13.03.2008</para>

The header contains definition of date and time-related types supported by the library by default. </para><namespace name="boost">
<namespace name="log">
<typedef id="doxygen.utilities.date__time__types_8hpp_1a56a18fd787f05fdb7741d665ad95e35e" name="native_date_time_types"><description><para>An MPL-sequence of natively supported date and time types of attributes </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef id="doxygen.utilities.date__time__types_8hpp_1ab5898143025a31f1721b5b40ec838716" name="boost_date_time_types"><description><para>An MPL-sequence of Boost date and time types of attributes </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef id="doxygen.utilities.date__time__types_8hpp_1a745597e12748d27eeb5857a876e3d4bf" name="date_time_types"><description><para>An MPL-sequence with the complete list of the supported date and time types </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef id="doxygen.utilities.date__time__types_8hpp_1a28224fc66ee0d3279ed12da72cd82fd8" name="native_date_types"><description><para>An MPL-sequence of natively supported date types of attributes </para></description><type>native_date_time_types</type></typedef>
<typedef id="doxygen.utilities.date__time__types_8hpp_1aa195a11792f41f754fc67460f398b174" name="boost_date_types"><description><para>An MPL-sequence of Boost date types of attributes </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef id="doxygen.utilities.date__time__types_8hpp_1a059c4283b6e45e5c1120f4e0f2701725" name="date_types"><description><para>An MPL-sequence with the complete list of the supported date types </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef id="doxygen.utilities.date__time__types_8hpp_1a955dbf95553429ab8376ae19bf607dd3" name="native_time_types"><description><para>An MPL-sequence of natively supported time types </para></description><type>native_date_time_types</type></typedef>
<typedef id="doxygen.utilities.date__time__types_8hpp_1a1679815fac241d61ec8cf1baf6a7f64f" name="boost_time_types"><purpose>An MPL-sequence of Boost time types. </purpose><type>boost_date_time_types</type></typedef>
<typedef id="doxygen.utilities.date__time__types_8hpp_1a0000bf0391ea6c63001df1adbeecc7de" name="time_types"><description><para>An MPL-sequence with the complete list of the supported time types </para></description><type>date_time_types</type></typedef>
<typedef id="doxygen.utilities.date__time__types_8hpp_1a4b043ddf3723a98d1dafd4967617652d" name="native_time_duration_types"><description><para>An MPL-sequence of natively supported time duration types of attributes </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef id="doxygen.utilities.date__time__types_8hpp_1aae1fcc14a29afe6bc9dacff0a35b62df" name="boost_time_duration_types"><description><para>An MPL-sequence of Boost time duration types of attributes </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef id="doxygen.utilities.date__time__types_8hpp_1a9839c130731eb2f372976b1c9b0e9cb6" name="time_duration_types"><description><para>An MPL-sequence with the complete list of the supported time duration types </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef id="doxygen.utilities.date__time__types_8hpp_1a7ebf7f73d2682359f95d9332eb82dc41" name="boost_time_period_types"><description><para>An MPL-sequence of Boost time duration types of attributes </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef id="doxygen.utilities.date__time__types_8hpp_1a9d35a244d81f084a458d1141575d283e" name="time_period_types"><description><para>An MPL-sequence with the complete list of the supported time period types </para></description><type>boost_time_period_types</type></typedef>



















































































































</namespace>
</namespace>
<macro id="doxygen.utilities.date__time__types_8hpp_1a0daabba09c69863bb8446c3986a441ab" name="BOOST_LOG_NATIVE_DATE_TIME_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of the standard C date/time types. </purpose></macro>
<macro id="doxygen.utilities.date__time__types_8hpp_1a6e441d874a3b050bd0a457c4e3cc5a1e" name="BOOST_LOG_NATIVE_DATE_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of the standard C date types. </purpose></macro>
<macro id="doxygen.utilities.date__time__types_8hpp_1af282d61a3256d686009507fc45f9b821" name="BOOST_LOG_BOOST_DATE_TIME_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of the Boost date/time types. </purpose></macro>
<macro id="doxygen.utilities.date__time__types_8hpp_1abbcb6737ff2a56e9790d459bd4341f53" name="BOOST_LOG_DATE_TIME_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of date/time types. </purpose></macro>
<macro id="doxygen.utilities.date__time__types_8hpp_1ad8a8d1c9aa25a9a981ef82373932a7d4" name="BOOST_LOG_BOOST_DATE_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of the Boost date types. </purpose></macro>
<macro id="doxygen.utilities.date__time__types_8hpp_1a47a95caae49cbd76ca426af6142658d7" name="BOOST_LOG_DATE_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of date types. </purpose></macro>
<macro id="doxygen.utilities.date__time__types_8hpp_1a855f57837c4adb583b61be5f80857b5f" name="BOOST_LOG_NATIVE_TIME_DURATION_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of the standard time duration types. </purpose></macro>
<macro id="doxygen.utilities.date__time__types_8hpp_1a4a6d84ceb4e862bb34a3d7ef649d83f0" name="BOOST_LOG_BOOST_TIME_DURATION_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of the Boost time duration types. </purpose></macro>
<macro id="doxygen.utilities.date__time__types_8hpp_1a6b7b7e9e3adf5e2ea2c6accba0cb4732" name="BOOST_LOG_TIME_DURATION_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of time duration types. </purpose></macro>
<macro id="doxygen.utilities.date__time__types_8hpp_1a15b792327247fbb32350d6a63c87dbf4" name="BOOST_LOG_BOOST_TIME_PERIOD_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of the Boost time period types. </purpose></macro>
<macro id="doxygen.utilities.date__time__types_8hpp_1add89b9e40461c6a1ebbc620df6821f4c" name="BOOST_LOG_TIME_PERIOD_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of time period types. </purpose></macro>
</header>
<header id="doxygen.utilities.dynamic__type__dispatcher_8hpp" name="boost/log/utility/type_dispatch/dynamic_type_dispatcher.hpp">
<para><para>Andrey Semashev </para>

<para>15.04.2007</para>

The header contains implementation of the run-time type dispatcher. </para><namespace name="boost">
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1dynamic__type__dispatcher" name="dynamic_type_dispatcher"><inherit access="public">type_dispatcher</inherit><purpose>A dynamic type dispatcher. </purpose><description><para>The type dispatcher can be used to pass objects of arbitrary types from one component to another. With regard to the library, the type dispatcher can be used to extract attribute values.</para><para>The dynamic type dispatcher can be initialized in run time and, therefore, can support different types, depending on runtime conditions. Each supported type is associated with a functional object that will be called when an object of the type is dispatched. </para></description><method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1dynamic__type__dispatcher_1ac2bc9ffedc3ad9d717bda87abaa65ead"><description><para>Default constructor </para></description></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1dynamic__type__dispatcher_1a3fa61a718c65bb872d46d3d94507c9e6"><parameter name="that"><paramtype><classname>dynamic_type_dispatcher</classname> const &amp;</paramtype></parameter><description><para>Copy constructor </para></description></constructor>
<copy-assignment id="doxygen.utilities.classboost_1_1log_1_1dynamic__type__dispatcher_1a0b492f8b940d81b52e6dfd72402069ca"><type><classname>dynamic_type_dispatcher</classname> &amp;</type><parameter name="that"><paramtype><classname>dynamic_type_dispatcher</classname> const &amp;</paramtype></parameter><description><para>Copy assignment </para></description></copy-assignment>
<method id="doxygen.utilities.classboost_1_1log_1_1dynamic__type__dispatcher_1a82edc8028dffa4fad2218e7dcb6c27df" name="register_type"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VisitorT"/>
        </template><parameter name="visitor"><paramtype>VisitorT const &amp;</paramtype><description><para>Function object that will be associated with the type <computeroutput>T</computeroutput> </para></description></parameter><description><para>The method registers a new type</para><para>
</para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1dynamic__type__dispatcher_1ad7a6885e838060da0060adef09ac4985" name="registered_types_count" cv="const"><type>dispatching_map::size_type</type><description><para>The method returns the number of registered types </para></description></method>
</method-group>
</class>


















































































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.standard__types_8hpp" name="boost/log/utility/type_dispatch/standard_types.hpp">
<para><para>Andrey Semashev </para>

<para>19.05.2007</para>

The header contains definition of standard types supported by the library by default. </para><namespace name="boost">
<namespace name="log">
<typedef id="doxygen.utilities.standard__types_8hpp_1aa5b646912a836bafb7cf4acfcc768057" name="integral_types"><description><para>An MPL-sequence of integral types of attributes, supported by default </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef id="doxygen.utilities.standard__types_8hpp_1add1fae917d9935433b220b200e6f50b3" name="floating_point_types"><description><para>An MPL-sequence of FP types of attributes, supported by default </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef id="doxygen.utilities.standard__types_8hpp_1ae69a91cda37911d0706944888c11bbec" name="arithmetic_types"><description><para>An MPL-sequence of all numeric types of attributes, supported by default </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef id="doxygen.utilities.standard__types_8hpp_1a55120ae4038c279dcd0daae761692fac" name="numeric_types"><purpose>Deprecated alias. </purpose><type>arithmetic_types</type></typedef>
<typedef id="doxygen.utilities.standard__types_8hpp_1a19eacd400be81811d05f6ecea775ceae" name="string_types"><description><para>An MPL-sequence of string types of attributes, supported by default </para></description><type>mpl::vector&lt;&gt;</type></typedef>
<typedef id="doxygen.utilities.standard__types_8hpp_1a433ee384c8b20680ff63e6c0a00041a1" name="default_attribute_types"><purpose>Deprecated alias. </purpose><type>default_attribute_value_types</type></typedef>

































































<function id="doxygen.utilities.standard__types_8hpp_1a8a9e8bee437425853d24237790e690d0" name="BOOST_PP_CAT"><type>typedef</type><parameter name=""><paramtype>mpl::vector</paramtype></parameter><parameter name=""><paramtype>BOOST_PP_SEQ_SIZE((bool)(signed char)(unsigned char)(short)(unsigned short)(int)(unsigned int)(long)(unsigned long)(char)(wchar_t)(char16_t)(char32_t)(float)(double)(long double)(std::string)(boost::log::string_literal)(std::wstring)(boost::log::wstring_literal))</paramtype></parameter><description><para>An MPL-sequence of all attribute value types that are supported by the library by default. </para></description></function>

















































</namespace>
</namespace>
<macro id="doxygen.utilities.standard__types_8hpp_1a371bb5db6f526bf0028d5143892feadd" name="BOOST_LOG_AUX_STANDARD_TYPE_WCHAR_T" kind="functionlike"><macro-parameter name=""/></macro>
<macro id="doxygen.utilities.standard__types_8hpp_1adeca3b0b23b58a321a97a2e26c122162" name="BOOST_LOG_AUX_STANDARD_TYPE_CHAR16_T" kind="functionlike"><macro-parameter name=""/></macro>
<macro id="doxygen.utilities.standard__types_8hpp_1abf45b76e3b4e433eabb5c03a5cea9fd4" name="BOOST_LOG_AUX_STANDARD_TYPE_CHAR32_T" kind="functionlike"><macro-parameter name=""/></macro>
<macro id="doxygen.utilities.standard__types_8hpp_1aae31999a8ca740ac39e66d21b3226603" name="BOOST_LOG_STANDARD_CHAR_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of character types. </purpose></macro>
<macro id="doxygen.utilities.standard__types_8hpp_1a5573be69eca419c2c880dfc4a7445b17" name="BOOST_LOG_AUX_STANDARD_LONG_LONG_TYPES" kind="functionlike"><macro-parameter name=""/></macro>
<macro id="doxygen.utilities.standard__types_8hpp_1aef92406011e1ad6380efb964fc17355b" name="BOOST_LOG_STANDARD_INTEGRAL_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of integral types. </purpose></macro>
<macro id="doxygen.utilities.standard__types_8hpp_1ab3a4ed68a3a5da2fd0c68ab46af87401" name="BOOST_LOG_STANDARD_FLOATING_POINT_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of floating point types. </purpose></macro>
<macro id="doxygen.utilities.standard__types_8hpp_1a77a16f7ff62bf7daa127b942665a71bc" name="BOOST_LOG_STANDARD_ARITHMETIC_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of arithmetic types. </purpose></macro>
<macro id="doxygen.utilities.standard__types_8hpp_1a5f314912964fc561f87934f6f2a36484" name="BOOST_LOG_AUX_STANDARD_STRING_TYPES" kind="functionlike"><macro-parameter name=""/></macro>
<macro id="doxygen.utilities.standard__types_8hpp_1a1c6c92c9ca84f635dd68441364911798" name="BOOST_LOG_AUX_STANDARD_WSTRING_TYPES" kind="functionlike"><macro-parameter name=""/></macro>
<macro id="doxygen.utilities.standard__types_8hpp_1ab3928cc97e73433b903a7dc940c9fbf6" name="BOOST_LOG_STANDARD_STRING_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of string types. </purpose></macro>
<macro id="doxygen.utilities.standard__types_8hpp_1a095583ac0853db1cba9c7559942b2848" name="BOOST_LOG_DEFAULT_ATTRIBUTE_VALUE_TYPES" kind="functionlike"><macro-parameter name=""/><purpose>Boost.Preprocessor sequence of the default attribute value types supported by the library. </purpose></macro>
</header>
<header id="doxygen.utilities.static__type__dispatcher_8hpp" name="boost/log/utility/type_dispatch/static_type_dispatcher.hpp">
<para><para>Andrey Semashev </para>

<para>15.04.2007</para>

The header contains implementation of a compile-time type dispatcher. </para><namespace name="boost">
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1static__type__dispatcher" name="static_type_dispatcher"><template>
      <template-type-parameter name="T"/>
    </template><purpose>A static type dispatcher class. </purpose><description><para>The type dispatcher can be used to pass objects of arbitrary types from one component to another. With regard to the library, the type dispatcher can be used to extract attribute values.</para><para>Static type dispatchers allow to specify one or several supported types at compile time. </para></description><method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1static__type__dispatcher_1a569e9644d3799accead02a9929245beb" specifiers="explicit"><template>
          <template-type-parameter name="ReceiverT"/>
        </template><parameter name="receiver"><paramtype>ReceiverT &amp;</paramtype><description><para>Unary function object that will be called on a dispatched value. The receiver must be callable with an argument of any of the supported types of the dispatcher. </para></description></parameter><description><para>Constructor. Initializes the dispatcher internals.</para><para>The <emphasis>receiver</emphasis> object is not copied inside the dispatcher, but references to it may be kept by the dispatcher after construction. The receiver object must remain valid until the dispatcher is destroyed.</para><para>
</para></description></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1static__type__dispatcher_1aec09d9cf7ab6987050bfe279df2c5252" cv="= delete"><parameter name=""><paramtype><classname>static_type_dispatcher</classname> const &amp;</paramtype></parameter></constructor>
<copy-assignment id="doxygen.utilities.classboost_1_1log_1_1static__type__dispatcher_1a25779ce26a4fe331bbbcd61d312d9cc0" cv="= delete"><type><classname>static_type_dispatcher</classname> &amp;</type><parameter name=""><paramtype><classname>static_type_dispatcher</classname> const &amp;</paramtype></parameter></copy-assignment>
</method-group>
</class>


















































































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.type__dispatcher_8hpp" name="boost/log/utility/type_dispatch/type_dispatcher.hpp">
<para><para>Andrey Semashev </para>

<para>15.04.2007</para>

The header contains definition of generic type dispatcher interfaces. </para><namespace name="boost">
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1type__dispatcher" name="type_dispatcher"><purpose>A type dispatcher interface. </purpose><description><para>All type dispatchers support this interface. It is used to acquire the visitor interface for the requested type. </para></description><class id="doxygen.utilities.classboost_1_1log_1_1type__dispatcher_1_1callback" name="callback"><template>
      <template-type-parameter name="T"/>
    </template><description><para>This interface is used by type dispatchers to consume the dispatched value. </para></description><method-group name="public member functions">
<method id="doxygen.utilities.classboost_1_1log_1_1type__dispatcher_1_1callback_1a570fac1da40ec0a52a45c279a4b6543e" name="operator()" cv="const"><type>void</type><parameter name="value"><paramtype>T const &amp;</paramtype><description><para>The dispatched value </para></description></parameter><description><para>The operator invokes the visitor-specific logic with the given value</para><para>
</para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1type__dispatcher_1_1callback_1a420e60e9788bfa3b52aa3aab72ea3a5e" name="conversion-operator" cv="const noexcept" specifiers="explicit"><type>bool</type><description><para>The operator checks if the visitor is attached to a receiver </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1type__dispatcher_1_1callback_1aa781ac6ac5a122ef2e89325c84d51f5a" name="operator!" cv="const noexcept"><type>bool</type><description><para>The operator checks if the visitor is not attached to a receiver </para></description></method>
</method-group>
</class><method-group name="protected member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1type__dispatcher_1abe865574e9df12d4090123e5b925de96" specifiers="explicit" cv="noexcept"><parameter name="get_callback_impl"><paramtype>get_callback_impl_type</paramtype></parameter><description><para>Initializing constructor </para></description></constructor>
<destructor id="doxygen.utilities.classboost_1_1log_1_1type__dispatcher_1abb9a41a9b95d5d7759494b6d3c97ac38" cv="= default"/>
<constructor id="doxygen.utilities.classboost_1_1log_1_1type__dispatcher_1a817fbec9e49548d0e3bb42e21ec4ff1a" cv="= default"><parameter name="that"><paramtype><classname>type_dispatcher</classname> const &amp;</paramtype></parameter></constructor>
<copy-assignment id="doxygen.utilities.classboost_1_1log_1_1type__dispatcher_1a5e79aa81c27f1041d07ce018a84c1d1d" cv="= default"><type><classname>type_dispatcher</classname> &amp;</type><parameter name="that"><paramtype><classname>type_dispatcher</classname> const &amp;</paramtype></parameter></copy-assignment>
</method-group>
<method-group name="public member functions">
<method id="doxygen.utilities.classboost_1_1log_1_1type__dispatcher_1a9f115542d70131068467a7a8c8779166" name="get_callback"><type><classname>callback</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><description><para>The method requests a callback for the value of type <computeroutput>T</computeroutput> </para><para>
</para></description><returns><para>The type-specific callback or an empty value, if the type is not supported </para>
</returns></method>
</method-group>
</class>


















































































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.unique__identifier__name_8hpp" name="boost/log/utility/unique_identifier_name.hpp">
<para><para>Andrey Semashev </para>

<para>30.04.2008</para>

The header contains <computeroutput>BOOST_LOG_UNIQUE_IDENTIFIER_NAME</computeroutput> macro definition. </para><macro id="doxygen.utilities.unique__identifier__name_8hpp_1abf8715d9fac02271a18fb22d65d3313f" name="BOOST_LOG_UNIQUE_IDENTIFIER_NAME" kind="functionlike"><macro-parameter name="prefix"/><description><para>Constructs a unique (in the current file scope) token that can be used as a variable name. The name will contain a prefix passed in the <emphasis>prefix</emphasis> argument. This allows to use the macro multiple times on a single line. </para></description></macro>
</header>
<header id="doxygen.utilities.unused__variable_8hpp" name="boost/log/utility/unused_variable.hpp">
<para><para>Andrey Semashev </para>

<para>10.05.2008</para>

The header contains definition of a macro to suppress compiler warnings about unused variables. </para><namespace name="boost">
<namespace name="log">



















































































































</namespace>
</namespace>
<macro id="doxygen.utilities.unused__variable_8hpp_1a15b10c2c75cc8c516f02d4ac9ed0c363" name="BOOST_LOG_UNUSED_VARIABLE" kind="functionlike"><macro-parameter name="type"/><macro-parameter name="var"/><macro-parameter name="initializer"/><purpose>The macro suppresses compiler warnings for <computeroutput>var</computeroutput> being unused. </purpose></macro>
</header>
<header id="doxygen.utilities.use__std__allocator_8hpp" name="boost/log/utility/use_std_allocator.hpp">
<para><para>Andrey Semashev </para>

<para>04.03.2021</para>

The header defines <computeroutput>use_std_allocator</computeroutput> tag type. </para><namespace name="boost">
<namespace name="log">
<struct id="doxygen.utilities.structboost_1_1log_1_1use__std__allocator" name="use_std_allocator"><purpose>Tag type that indicates that a specialization of <computeroutput>std::allocator</computeroutput> should be used for allocating memory. </purpose><description><para>This tag type can be used in template parameters in various components of Boost.Log. The type itself is not an allocator type. </para></description></struct>


















































































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.value__ref_8hpp" name="boost/log/utility/value_ref.hpp">
<para><para>Andrey Semashev </para>

<para>27.07.2012</para>

The header contains implementation of a value reference wrapper. </para><namespace name="boost">
<namespace name="log">
<function id="doxygen.utilities.value__ref_8hpp_1aabb6f8a4a71b8749eb1779407783e81e" name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; &amp;</paramtype></parameter><purpose>Free swap function. </purpose></function>
<function id="doxygen.utilities.value__ref_8hpp_1aedd2e85e252981b024c72349f0c684e6" name="operator&lt;&lt;"><type>std::basic_ostream&lt; CharT, TraitsT &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TraitsT"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="strm"><paramtype>std::basic_ostream&lt; CharT, TraitsT &gt; &amp;</paramtype></parameter><parameter name="val"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter><purpose>Stream output operator. </purpose></function>
<function id="doxygen.utilities.value__ref_8hpp_1a66917a7fd72f6c337bf64a5e15dabffa" name="operator&lt;&lt;"><type><classname>basic_formatting_ostream</classname>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="TraitsT"/>
          <template-type-parameter name="AllocatorT"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="strm"><paramtype><classname>basic_formatting_ostream</classname>&lt; CharT, TraitsT, AllocatorT &gt; &amp;</paramtype></parameter><parameter name="val"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter><purpose>Log formatting operator. </purpose></function>
<function id="doxygen.utilities.value__ref_8hpp_1a7d145aea3e101df2f687c8d52414781b" name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.value__ref_8hpp_1aa99ca972b601fd36588e91090d33910f" name="operator=="><type>bool</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="left"><paramtype>U const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.value__ref_8hpp_1a9e42f62bfc71d92651e309589e9869dc" name="operator=="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="TagT1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="TagT2"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T1, TagT1 &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T2, TagT2 &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.value__ref_8hpp_1a98c41ef684f9a5b49be019474cce06f3" name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.value__ref_8hpp_1a77db1964b3ed57652abd7d9d5b3b8fdb" name="operator!="><type>bool</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="left"><paramtype>U const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.value__ref_8hpp_1ac7c3663aa8d483d75fa880eb8772d9b6" name="operator!="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="TagT1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="TagT2"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T1, TagT1 &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T2, TagT2 &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.value__ref_8hpp_1acc898fc85a08b3747cb5da40c9e25c99" name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.value__ref_8hpp_1a979a471b514f1eb77b7d7d2196d7ffa9" name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="left"><paramtype>U const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.value__ref_8hpp_1a802a3f6a9860ce7a8f5c113815ed936b" name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="TagT1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="TagT2"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T1, TagT1 &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T2, TagT2 &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.value__ref_8hpp_1a86ca12125abebd787d37ab919af5c8b7" name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.value__ref_8hpp_1aadad845ecbe350fd660b120788566efa" name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="left"><paramtype>U const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.value__ref_8hpp_1ac353c1df665fef9be3dccd278005d04a" name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="TagT1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="TagT2"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T1, TagT1 &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T2, TagT2 &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.value__ref_8hpp_1adfcc68be40f7733031517e018a3afbe0" name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.value__ref_8hpp_1a4e35bf0ee9e87e718406c093b9b1797b" name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="left"><paramtype>U const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.value__ref_8hpp_1ad234500be76db530a4d3c7171ff885a3" name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="TagT1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="TagT2"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T1, TagT1 &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T2, TagT2 &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.value__ref_8hpp_1af9cb076ee9e8f5d35360bf3a0d3a4865" name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
          <template-type-parameter name="U"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>U const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.value__ref_8hpp_1aef2e7cd03e053319f4a3e03be83c6335" name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TagT"/>
        </template><parameter name="left"><paramtype>U const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T, TagT &gt; const &amp;</paramtype></parameter></function>
<function id="doxygen.utilities.value__ref_8hpp_1a01f3b9f3811f225e8acbbd77dcfd36a3" name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="TagT1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="TagT2"/>
        </template><parameter name="left"><paramtype><classname>value_ref</classname>&lt; T1, TagT1 &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype><classname>value_ref</classname>&lt; T2, TagT2 &gt; const &amp;</paramtype></parameter></function>






























































































</namespace>
</namespace>
</header>
<header id="doxygen.utilities.value__ref__fwd_8hpp" name="boost/log/utility/value_ref_fwd.hpp">
<para><para>Andrey Semashev </para>

<para>27.07.2012</para>

The header contains forward declaration of a value reference wrapper. </para><namespace name="boost">
<namespace name="log">
<class id="doxygen.utilities.classboost_1_1log_1_1value__ref" name="value_ref"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="TagT"/>
    </template><inherit access="public">type</inherit><purpose>Reference wrapper for a stored attribute value. </purpose><description><para>The <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1value__ref">value_ref</link></computeroutput> class template provides access to the stored attribute value. It is not a traditional reference wrapper since it may be empty (i.e. refer to no value at all) and it can also refer to values of different types. Therefore its interface and behavior combines features of Boost.Ref, Boost.Optional and Boost.Variant, depending on the use case.</para><para>The template parameter <computeroutput>T</computeroutput> can be a single type or an MPL sequence of possible types being referred. The reference wrapper will act as either an optional reference or an optional variant of references to the specified types. In any case, the referred values will not be modifiable (i.e. <computeroutput><link linkend="doxygen.utilities.classboost_1_1log_1_1value__ref">value_ref</link></computeroutput> always models a const reference).</para><para>Template parameter <computeroutput>TagT</computeroutput> is optional. It can be used for customizing the operations on this reference wrapper, such as putting the referred value to log. </para></description><method-group name="public member functions">
<constructor id="doxygen.utilities.classboost_1_1log_1_1value__ref_1a2b644fe3d58f1cdc6b55b03911fe3832" cv="= default"><description><para>Default constructor. Creates a reference wrapper that does not refer to a value. </para></description></constructor>
<constructor id="doxygen.utilities.classboost_1_1log_1_1value__ref_1a2b669d41ac103c1617fe5b103fe6c7b1" specifiers="explicit" cv="noexcept"><template>
          <template-type-parameter name="U"/>
        </template><parameter name="val"><paramtype>U const &amp;</paramtype></parameter><description><para>Initializing constructor. Creates a reference wrapper that refers to the specified value. </para></description></constructor>
<method id="doxygen.utilities.classboost_1_1log_1_1value__ref_1a420e60e9788bfa3b52aa3aab72ea3a5e" name="conversion-operator" cv="const noexcept" specifiers="explicit"><type>bool</type><description><para>The operator verifies if the wrapper refers to a value. </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1value__ref_1aa781ac6ac5a122ef2e89325c84d51f5a" name="operator!" cv="const noexcept"><type>bool</type><description><para>The operator verifies if the wrapper does not refer to a value. </para></description></method>
<method id="doxygen.utilities.classboost_1_1log_1_1value__ref_1a3f6fc5de06a318920d84f3c3742db07f" name="empty" cv="const noexcept"><type>bool</type><description><para>
</para></description><returns><para><computeroutput>true</computeroutput> if the wrapper does not refer to a value. </para>
</returns></method>
<method id="doxygen.utilities.classboost_1_1log_1_1value__ref_1a3ea09257f8e8490fc6ab9d60dc5248fd" name="swap" cv="noexcept"><type>void</type><parameter name="that"><paramtype><classname>value_ref</classname> &amp;</paramtype></parameter><description><para>Swaps two reference wrappers </para></description></method>
</method-group>
</class>


















































































































</namespace>
</namespace>
</header>
</library-reference>