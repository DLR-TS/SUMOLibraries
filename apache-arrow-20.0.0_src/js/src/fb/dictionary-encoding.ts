// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';

import { DictionaryKind } from './dictionary-kind.js';
import { Int } from './int.js';


export class DictionaryEncoding {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):DictionaryEncoding {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsDictionaryEncoding(bb:flatbuffers.ByteBuffer, obj?:DictionaryEncoding):DictionaryEncoding {
  return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsDictionaryEncoding(bb:flatbuffers.ByteBuffer, obj?:DictionaryEncoding):DictionaryEncoding {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

/**
 * The known dictionary id in the application where this data is used. In
 * the file or streaming formats, the dictionary ids are found in the
 * DictionaryBatch messages
 */
id():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt64(this.bb_pos + offset) : BigInt('0');
}

/**
 * The dictionary indices are constrained to be non-negative integers. If
 * this field is null, the indices must be signed int32. To maximize
 * cross-language compatibility and performance, implementations are
 * recommended to prefer signed integer types over unsigned integer types
 * and to avoid uint64 indices unless they are required by an application.
 */
indexType(obj?:Int):Int|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new Int()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

/**
 * By default, dictionaries are not ordered, or the order does not have
 * semantic meaning. In some statistical, applications, dictionary-encoding
 * is used to represent ordered categorical data, and we provide a way to
 * preserve that metadata here
 */
isOrdered():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

dictionaryKind():DictionaryKind {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readInt16(this.bb_pos + offset) : DictionaryKind.DenseArray;
}

static startDictionaryEncoding(builder:flatbuffers.Builder) {
  builder.startObject(4);
}

static addId(builder:flatbuffers.Builder, id:bigint) {
  builder.addFieldInt64(0, id, BigInt('0'));
}

static addIndexType(builder:flatbuffers.Builder, indexTypeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, indexTypeOffset, 0);
}

static addIsOrdered(builder:flatbuffers.Builder, isOrdered:boolean) {
  builder.addFieldInt8(2, +isOrdered, +false);
}

static addDictionaryKind(builder:flatbuffers.Builder, dictionaryKind:DictionaryKind) {
  builder.addFieldInt16(3, dictionaryKind, DictionaryKind.DenseArray);
}

static endDictionaryEncoding(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

}
